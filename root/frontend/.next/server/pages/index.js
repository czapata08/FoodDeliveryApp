module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = require('../ssr-module-cache.js');
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete installedModules[moduleId];
/******/ 		}
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./pages/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../next-server/lib/router-context":
/*!**************************************************************!*\
  !*** external "next/dist/next-server/lib/router-context.js" ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"next/dist/next-server/lib/router-context.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJuZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci1jb250ZXh0LmpzXCI/NDEyNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyLWNvbnRleHQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci1jb250ZXh0LmpzXCIpOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../next-server/lib/router-context\n");

/***/ }),

/***/ "./components/cart.js":
/*!****************************!*\
  !*** ./components/cart.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var styled_jsx_style__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! styled-jsx/style */ \"styled-jsx/style\");\n/* harmony import */ var styled_jsx_style__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(styled_jsx_style__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/router */ \"next/router\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var reactstrap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! reactstrap */ \"./node_modules/reactstrap/dist/reactstrap.cjs\");\n/* harmony import */ var reactstrap__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(reactstrap__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./context */ \"./components/context.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/link */ \"./node_modules/next/link.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_5__);\nvar _jsxFileName = \"/Users/carloszapata/Desktop/CAPSTONE/main/root/frontend/components/cart.js\";\n\nvar __jsx = react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement;\n\n\n\n\n\n// we can pass cart data in via props method \n// the alternative is using useContext as below\nfunction Cart() {\n  let isAuthenticated = true;\n  let {\n    cart,\n    addItem,\n    removeItem\n  } = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useContext\"])(_context__WEBPACK_IMPORTED_MODULE_4__[\"default\"]);\n  //const [cartA, setCartA] = useState({cart})\n  //cart = value.cart;\n  //console.log('props:'+ JSON.stringify(value));\n  console.log(`in CART: ${JSON.stringify(cart)}`);\n\n  //   problem is that cart may not be set\n  const router = Object(next_router__WEBPACK_IMPORTED_MODULE_2__[\"useRouter\"])();\n  console.log(`Router Path: ${JSON.stringify(router)}`);\n  const renderItems = () => {\n    let {\n      items\n    } = cart;\n    console.log(`items: ${JSON.stringify(items)}`);\n    if (items && items.length) {\n      var itemList = cart.items.map(item => {\n        if (item.quantity > 0) {\n          return __jsx(\"div\", {\n            className: \"items-one\",\n            style: {\n              marginBottom: 15\n            },\n            key: item.id,\n            __self: this,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 26,\n              columnNumber: 15\n            }\n          }, __jsx(\"div\", {\n            __self: this,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 31,\n              columnNumber: 17\n            }\n          }, __jsx(\"span\", {\n            id: \"item-price\",\n            __self: this,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 32,\n              columnNumber: 19\n            }\n          }, \"\\xA0 $\", item.price), __jsx(\"span\", {\n            id: \"item-name\",\n            __self: this,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 33,\n              columnNumber: 19\n            }\n          }, \"\\xA0 \", item.name)), __jsx(\"div\", {\n            __self: this,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 35,\n              columnNumber: 17\n            }\n          }, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_3__[\"Button\"], {\n            style: {\n              height: 25,\n              padding: 0,\n              width: 15,\n              marginRight: 5,\n              marginLeft: 10\n            },\n            onClick: () => addItem(item),\n            color: \"link\",\n            __self: this,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 36,\n              columnNumber: 19\n            }\n          }, \"+\"), __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_3__[\"Button\"], {\n            style: {\n              height: 25,\n              padding: 0,\n              width: 15,\n              marginRight: 10\n            },\n            onClick: () => removeItem(item),\n            color: \"link\",\n            __self: this,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 49,\n              columnNumber: 19\n            }\n          }, \"-\"), __jsx(\"span\", {\n            style: {\n              marginLeft: 5\n            },\n            id: \"item-quantity\",\n            __self: this,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 61,\n              columnNumber: 19\n            }\n          }, item.quantity, \"x\")));\n        }\n      });\n      return itemList;\n    } else {\n      return __jsx(\"div\", {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 72,\n          columnNumber: 17\n        }\n      });\n    }\n  };\n  const checkoutItems = () => {\n    return __jsx(\"div\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 77,\n        columnNumber: 5\n      }\n    }, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_3__[\"Badge\"], {\n      style: {\n        width: 200,\n        padding: 10\n      },\n      color: \"light\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 78,\n        columnNumber: 7\n      }\n    }, __jsx(\"h5\", {\n      style: {\n        fontWeight: 100,\n        color: \"gray\"\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 79,\n        columnNumber: 9\n      }\n    }, \"Total:\"), __jsx(\"h3\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 80,\n        columnNumber: 9\n      }\n    }, \"$\", cart.total)), __jsx(next_link__WEBPACK_IMPORTED_MODULE_5___default.a, {\n      href: \"/checkout/\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 82,\n        columnNumber: 11\n      }\n    }, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_3__[\"Button\"], {\n      style: {\n        width: \"60%\"\n      },\n      color: \"primary\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 83,\n        columnNumber: 13\n      }\n    }, __jsx(\"a\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 84,\n        columnNumber: 15\n      }\n    }, \"Order\"))));\n  };\n\n  // return Cart\n  return __jsx(\"div\", {\n    className: \"jsx-3161218026\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 92,\n      columnNumber: 5\n    }\n  }, __jsx(\"h1\", {\n    className: \"jsx-3161218026\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 93,\n      columnNumber: 7\n    }\n  }, \" Cart\"), __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_3__[\"Card\"], {\n    style: {\n      padding: \"10px 5px\"\n    },\n    className: \"cart\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 94,\n      columnNumber: 7\n    }\n  }, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_3__[\"CardTitle\"], {\n    style: {\n      margin: 10\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 95,\n      columnNumber: 9\n    }\n  }, \"Your Order:\"), __jsx(\"hr\", {\n    className: \"jsx-3161218026\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 96,\n      columnNumber: 9\n    }\n  }), __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_3__[\"CardBody\"], {\n    style: {\n      padding: 10\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 97,\n      columnNumber: 9\n    }\n  }, __jsx(\"div\", {\n    style: {\n      marginBottom: 6\n    },\n    className: \"jsx-3161218026\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 98,\n      columnNumber: 11\n    }\n  }, __jsx(\"small\", {\n    className: \"jsx-3161218026\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 99,\n      columnNumber: 13\n    }\n  }, \"Items:\")), __jsx(\"div\", {\n    className: \"jsx-3161218026\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 101,\n      columnNumber: 11\n    }\n  }, renderItems()), __jsx(\"div\", {\n    className: \"jsx-3161218026\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 104,\n      columnNumber: 11\n    }\n  }, checkoutItems()), console.log(`Router Path: ${router.asPath}`))), __jsx(styled_jsx_style__WEBPACK_IMPORTED_MODULE_0___default.a, {\n    id: \"3161218026\",\n    __self: this\n  }, \"#item-price.jsx-3161218026{font-size:1.3em;color:rgba(97,97,97,1);}#item-quantity.jsx-3161218026{font-size:0.95em;padding-bottom:4px;color:rgba(158,158,158,1);}#item-name.jsx-3161218026{font-size:1.3em;color:rgba(97,97,97,1);}\\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9jYXJsb3N6YXBhdGEvRGVza3RvcC9DQVBTVE9ORS9tYWluL3Jvb3QvZnJvbnRlbmQvY29tcG9uZW50cy9jYXJ0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQThHa0IsQUFHMkIsQUFJQyxBQUtELGdCQVJVLEFBU0EsQ0FMUCxtQkFDVSxHQUovQixBQVNBLHVCQUpBIiwiZmlsZSI6Ii9Vc2Vycy9jYXJsb3N6YXBhdGEvRGVza3RvcC9DQVBTVE9ORS9tYWluL3Jvb3QvZnJvbnRlbmQvY29tcG9uZW50cy9jYXJ0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gXCJuZXh0L3JvdXRlclwiO1xuaW1wb3J0IHsgQnV0dG9uLCBDYXJkLCBDYXJkQm9keSwgQ2FyZFRpdGxlLCBCYWRnZSB9IGZyb20gXCJyZWFjdHN0cmFwXCI7XG5pbXBvcnQgQXBwQ29udGV4dCBmcm9tIFwiLi9jb250ZXh0XCJcbmltcG9ydCBMaW5rIGZyb20gXCJuZXh0L2xpbmtcIlxuLy8gd2UgY2FuIHBhc3MgY2FydCBkYXRhIGluIHZpYSBwcm9wcyBtZXRob2QgXG4vLyB0aGUgYWx0ZXJuYXRpdmUgaXMgdXNpbmcgdXNlQ29udGV4dCBhcyBiZWxvd1xuZnVuY3Rpb24gQ2FydCgpIHtcbiAgbGV0IGlzQXV0aGVudGljYXRlZCA9IHRydWU7XG4gIGxldCB7Y2FydCxhZGRJdGVtLHJlbW92ZUl0ZW19ID0gdXNlQ29udGV4dChBcHBDb250ZXh0KTtcbiAgLy9jb25zdCBbY2FydEEsIHNldENhcnRBXSA9IHVzZVN0YXRlKHtjYXJ0fSlcbiAgLy9jYXJ0ID0gdmFsdWUuY2FydDtcbiAgLy9jb25zb2xlLmxvZygncHJvcHM6JysgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgY29uc29sZS5sb2coYGluIENBUlQ6ICR7SlNPTi5zdHJpbmdpZnkoY2FydCl9YClcbiAgXG4gIC8vICAgcHJvYmxlbSBpcyB0aGF0IGNhcnQgbWF5IG5vdCBiZSBzZXRcbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XG4gIGNvbnNvbGUubG9nKGBSb3V0ZXIgUGF0aDogJHtKU09OLnN0cmluZ2lmeShyb3V0ZXIpfWApXG4gIGNvbnN0IHJlbmRlckl0ZW1zID0gKCk9PntcbiAgbGV0IHtpdGVtc30gPSBjYXJ0O1xuICAgY29uc29sZS5sb2coYGl0ZW1zOiAke0pTT04uc3RyaW5naWZ5KGl0ZW1zKX1gKVxuICAgIGlmKGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCl7XG4gICAgICB2YXIgaXRlbUxpc3QgPSBjYXJ0Lml0ZW1zLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgIGlmIChpdGVtLnF1YW50aXR5ID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIml0ZW1zLW9uZVwiXG4gICAgICAgICAgICAgICAgc3R5bGU9e3sgbWFyZ2luQm90dG9tOiAxNSB9fVxuICAgICAgICAgICAgICAgIGtleT17aXRlbS5pZH1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICA8c3BhbiBpZD1cIml0ZW0tcHJpY2VcIj4mbmJzcDsgJHtpdGVtLnByaWNlfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPVwiaXRlbS1uYW1lXCI+Jm5ic3A7IHtpdGVtLm5hbWV9PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAyNSxcbiAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNSxcbiAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5SaWdodDogNSxcbiAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiAxMCxcbiAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gYWRkSXRlbShpdGVtKX1cbiAgICAgICAgICAgICAgICAgICAgY29sb3I9XCJsaW5rXCJcbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgK1xuICAgICAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAyNSxcbiAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNSxcbiAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5SaWdodDogMTAsXG4gICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHJlbW92ZUl0ZW0oaXRlbSl9XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yPVwibGlua1wiXG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIC1cbiAgICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gc3R5bGU9e3sgbWFyZ2luTGVmdDogNSB9fSBpZD1cIml0ZW0tcXVhbnRpdHlcIj5cbiAgICAgICAgICAgICAgICAgICAge2l0ZW0ucXVhbnRpdHl9eFxuICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gaXRlbUxpc3Q7XG4gICAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAoPGRpdj48L2Rpdj4pXG4gICAgfVxuICB9XG5jb25zdCBjaGVja291dEl0ZW1zID0gKCk9PntcbiAgcmV0dXJuIChcbiAgICA8ZGl2PlxuICAgICAgPEJhZGdlIHN0eWxlPXt7IHdpZHRoOiAyMDAsIHBhZGRpbmc6IDEwIH19IGNvbG9yPVwibGlnaHRcIj5cbiAgICAgICAgPGg1IHN0eWxlPXt7IGZvbnRXZWlnaHQ6IDEwMCwgY29sb3I6IFwiZ3JheVwiIH19PlRvdGFsOjwvaDU+XG4gICAgICAgIDxoMz4ke2NhcnQudG90YWx9PC9oMz5cbiAgICAgIDwvQmFkZ2U+XG4gICAgICAgICAgPExpbmsgaHJlZj1cIi9jaGVja291dC9cIj5cbiAgICAgICAgICAgIDxCdXR0b24gc3R5bGU9e3sgd2lkdGg6IFwiNjAlXCIgfX0gY29sb3I9XCJwcmltYXJ5XCI+XG4gICAgICAgICAgICAgIDxhPk9yZGVyPC9hPlxuICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgPC9MaW5rPlxuICAgIDwvZGl2PlxuICApfVxuXG4vLyByZXR1cm4gQ2FydFxuICByZXR1cm4gKFxuICAgIDxkaXY+XG4gICAgICA8aDE+IENhcnQ8L2gxPlxuICAgICAgPENhcmQgc3R5bGU9e3sgcGFkZGluZzogXCIxMHB4IDVweFwiIH19IGNsYXNzTmFtZT1cImNhcnRcIj5cbiAgICAgICAgPENhcmRUaXRsZSBzdHlsZT17eyBtYXJnaW46IDEwIH19PllvdXIgT3JkZXI6PC9DYXJkVGl0bGU+XG4gICAgICAgIDxociAvPlxuICAgICAgICA8Q2FyZEJvZHkgc3R5bGU9e3sgcGFkZGluZzogMTAgfX0+XG4gICAgICAgICAgPGRpdiBzdHlsZT17eyBtYXJnaW5Cb3R0b206IDYgfX0+XG4gICAgICAgICAgICA8c21hbGw+SXRlbXM6PC9zbWFsbD5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAge3JlbmRlckl0ZW1zKCl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgIHtjaGVja291dEl0ZW1zKCl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgXG4gICAgICAgICAge2NvbnNvbGUubG9nKGBSb3V0ZXIgUGF0aDogJHtyb3V0ZXIuYXNQYXRofWApfVxuICAgICAgICA8L0NhcmRCb2R5PlxuICAgICAgPC9DYXJkPlxuICAgICAgPHN0eWxlIGpzeD57YFxuICAgICAgICAjaXRlbS1wcmljZSB7XG4gICAgICAgICAgZm9udC1zaXplOiAxLjNlbTtcbiAgICAgICAgICBjb2xvcjogcmdiYSg5NywgOTcsIDk3LCAxKTtcbiAgICAgICAgfVxuICAgICAgICAjaXRlbS1xdWFudGl0eSB7XG4gICAgICAgICAgZm9udC1zaXplOiAwLjk1ZW07XG4gICAgICAgICAgcGFkZGluZy1ib3R0b206IDRweDtcbiAgICAgICAgICBjb2xvcjogcmdiYSgxNTgsIDE1OCwgMTU4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICAjaXRlbS1uYW1lIHtcbiAgICAgICAgICBmb250LXNpemU6IDEuM2VtO1xuICAgICAgICAgIGNvbG9yOiByZ2JhKDk3LCA5NywgOTcsIDEpO1xuICAgICAgICB9XG4gICAgICBgfTwvc3R5bGU+XG4gICAgPC9kaXY+XG4gICk7XG59XG5leHBvcnQgZGVmYXVsdCBDYXJ0O1xuIl19 */\\n/*@ sourceURL=/Users/carloszapata/Desktop/CAPSTONE/main/root/frontend/components/cart.js */\"));\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (Cart);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NhcnQuanM/N2Y1MyJdLCJuYW1lcyI6WyJDYXJ0IiwiaXNBdXRoZW50aWNhdGVkIiwiY2FydCIsImFkZEl0ZW0iLCJyZW1vdmVJdGVtIiwidXNlQ29udGV4dCIsIkFwcENvbnRleHQiLCJjb25zb2xlIiwibG9nIiwiSlNPTiIsInN0cmluZ2lmeSIsInJvdXRlciIsInVzZVJvdXRlciIsInJlbmRlckl0ZW1zIiwiaXRlbXMiLCJsZW5ndGgiLCJpdGVtTGlzdCIsIm1hcCIsIml0ZW0iLCJxdWFudGl0eSIsIm1hcmdpbkJvdHRvbSIsImlkIiwicHJpY2UiLCJuYW1lIiwiaGVpZ2h0IiwicGFkZGluZyIsIndpZHRoIiwibWFyZ2luUmlnaHQiLCJtYXJnaW5MZWZ0IiwiY2hlY2tvdXRJdGVtcyIsImZvbnRXZWlnaHQiLCJjb2xvciIsInRvdGFsIiwibWFyZ2luIiwiYXNQYXRoIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBMEM7QUFDRjtBQUM4QjtBQUNwQztBQUNOO0FBQzVCO0FBQ0E7QUFDQSxTQUFTQSxJQUFJLEdBQUc7RUFDZCxJQUFJQyxlQUFlLEdBQUcsSUFBSTtFQUMxQixJQUFJO0lBQUNDLElBQUk7SUFBQ0MsT0FBTztJQUFDQztFQUFVLENBQUMsR0FBR0Msd0RBQVUsQ0FBQ0MsZ0RBQVUsQ0FBQztFQUN0RDtFQUNBO0VBQ0E7RUFDQUMsT0FBTyxDQUFDQyxHQUFHLENBQUUsWUFBV0MsSUFBSSxDQUFDQyxTQUFTLENBQUNSLElBQUksQ0FBRSxFQUFDLENBQUM7O0VBRS9DO0VBQ0EsTUFBTVMsTUFBTSxHQUFHQyw2REFBUyxFQUFFO0VBQzFCTCxPQUFPLENBQUNDLEdBQUcsQ0FBRSxnQkFBZUMsSUFBSSxDQUFDQyxTQUFTLENBQUNDLE1BQU0sQ0FBRSxFQUFDLENBQUM7RUFDckQsTUFBTUUsV0FBVyxHQUFHLE1BQUk7SUFDeEIsSUFBSTtNQUFDQztJQUFLLENBQUMsR0FBR1osSUFBSTtJQUNqQkss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O0lBQUE7RUFBQSxHQUNHZ0IsYUFBYSxFQUFFLENBQ1osRUFFTHRCLE9BQU8sQ0FBQ0MsR0FBRyxDQUFFLGdCQUFlRyxNQUFNLENBQUN1QixNQUFPLEVBQUMsQ0FBQyxDQUNwQyxDQUNOO0lBQUE7SUFBQTtFQUFBLHU0TEFnQkg7QUFFVjtBQUNlbEMsbUVBQUkiLCJmaWxlIjoiLi9jb21wb25lbnRzL2NhcnQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlQ29udGV4dCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSBcIm5leHQvcm91dGVyXCI7XG5pbXBvcnQgeyBCdXR0b24sIENhcmQsIENhcmRCb2R5LCBDYXJkVGl0bGUsIEJhZGdlIH0gZnJvbSBcInJlYWN0c3RyYXBcIjtcbmltcG9ydCBBcHBDb250ZXh0IGZyb20gXCIuL2NvbnRleHRcIlxuaW1wb3J0IExpbmsgZnJvbSBcIm5leHQvbGlua1wiXG4vLyB3ZSBjYW4gcGFzcyBjYXJ0IGRhdGEgaW4gdmlhIHByb3BzIG1ldGhvZCBcbi8vIHRoZSBhbHRlcm5hdGl2ZSBpcyB1c2luZyB1c2VDb250ZXh0IGFzIGJlbG93XG5mdW5jdGlvbiBDYXJ0KCkge1xuICBsZXQgaXNBdXRoZW50aWNhdGVkID0gdHJ1ZTtcbiAgbGV0IHtjYXJ0LGFkZEl0ZW0scmVtb3ZlSXRlbX0gPSB1c2VDb250ZXh0KEFwcENvbnRleHQpO1xuICAvL2NvbnN0IFtjYXJ0QSwgc2V0Q2FydEFdID0gdXNlU3RhdGUoe2NhcnR9KVxuICAvL2NhcnQgPSB2YWx1ZS5jYXJ0O1xuICAvL2NvbnNvbGUubG9nKCdwcm9wczonKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICBjb25zb2xlLmxvZyhgaW4gQ0FSVDogJHtKU09OLnN0cmluZ2lmeShjYXJ0KX1gKVxuICBcbiAgLy8gICBwcm9ibGVtIGlzIHRoYXQgY2FydCBtYXkgbm90IGJlIHNldFxuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKTtcbiAgY29uc29sZS5sb2coYFJvdXRlciBQYXRoOiAke0pTT04uc3RyaW5naWZ5KHJvdXRlcil9YClcbiAgY29uc3QgcmVuZGVySXRlbXMgPSAoKT0+e1xuICBsZXQge2l0ZW1zfSA9IGNhcnQ7XG4gICBjb25zb2xlLmxvZyhgaXRlbXM6ICR7SlNPTi5zdHJpbmdpZnkoaXRlbXMpfWApXG4gICAgaWYoaXRlbXMgJiYgaXRlbXMubGVuZ3RoKXtcbiAgICAgIHZhciBpdGVtTGlzdCA9IGNhcnQuaXRlbXMubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgaWYgKGl0ZW0ucXVhbnRpdHkgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiaXRlbXMtb25lXCJcbiAgICAgICAgICAgICAgICBzdHlsZT17eyBtYXJnaW5Cb3R0b206IDE1IH19XG4gICAgICAgICAgICAgICAga2V5PXtpdGVtLmlkfVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGlkPVwiaXRlbS1wcmljZVwiPiZuYnNwOyAke2l0ZW0ucHJpY2V9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gaWQ9XCJpdGVtLW5hbWVcIj4mbmJzcDsge2l0ZW0ubmFtZX08L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDI1LFxuICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1LFxuICAgICAgICAgICAgICAgICAgICAgIG1hcmdpblJpZ2h0OiA1LFxuICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbkxlZnQ6IDEwLFxuICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBhZGRJdGVtKGl0ZW0pfVxuICAgICAgICAgICAgICAgICAgICBjb2xvcj1cImxpbmtcIlxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICArXG4gICAgICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDI1LFxuICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDE1LFxuICAgICAgICAgICAgICAgICAgICAgIG1hcmdpblJpZ2h0OiAxMCxcbiAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gcmVtb3ZlSXRlbShpdGVtKX1cbiAgICAgICAgICAgICAgICAgICAgY29sb3I9XCJsaW5rXCJcbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgLVxuICAgICAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICAgICAgICA8c3BhbiBzdHlsZT17eyBtYXJnaW5MZWZ0OiA1IH19IGlkPVwiaXRlbS1xdWFudGl0eVwiPlxuICAgICAgICAgICAgICAgICAgICB7aXRlbS5xdWFudGl0eX14XG4gICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBpdGVtTGlzdDtcbiAgICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICg8ZGl2PjwvZGl2PilcbiAgICB9XG4gIH1cbmNvbnN0IGNoZWNrb3V0SXRlbXMgPSAoKT0+e1xuICByZXR1cm4gKFxuICAgIDxkaXY+XG4gICAgICA8QmFkZ2Ugc3R5bGU9e3sgd2lkdGg6IDIwMCwgcGFkZGluZzogMTAgfX0gY29sb3I9XCJsaWdodFwiPlxuICAgICAgICA8aDUgc3R5bGU9e3sgZm9udFdlaWdodDogMTAwLCBjb2xvcjogXCJncmF5XCIgfX0+VG90YWw6PC9oNT5cbiAgICAgICAgPGgzPiR7Y2FydC50b3RhbH08L2gzPlxuICAgICAgPC9CYWRnZT5cbiAgICAgICAgICA8TGluayBocmVmPVwiL2NoZWNrb3V0L1wiPlxuICAgICAgICAgICAgPEJ1dHRvbiBzdHlsZT17eyB3aWR0aDogXCI2MCVcIiB9fSBjb2xvcj1cInByaW1hcnlcIj5cbiAgICAgICAgICAgICAgPGE+T3JkZXI8L2E+XG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICA8L0xpbms+XG4gICAgPC9kaXY+XG4gICl9XG5cbi8vIHJldHVybiBDYXJ0XG4gIHJldHVybiAoXG4gICAgPGRpdj5cbiAgICAgIDxoMT4gQ2FydDwvaDE+XG4gICAgICA8Q2FyZCBzdHlsZT17eyBwYWRkaW5nOiBcIjEwcHggNXB4XCIgfX0gY2xhc3NOYW1lPVwiY2FydFwiPlxuICAgICAgICA8Q2FyZFRpdGxlIHN0eWxlPXt7IG1hcmdpbjogMTAgfX0+WW91ciBPcmRlcjo8L0NhcmRUaXRsZT5cbiAgICAgICAgPGhyIC8+XG4gICAgICAgIDxDYXJkQm9keSBzdHlsZT17eyBwYWRkaW5nOiAxMCB9fT5cbiAgICAgICAgICA8ZGl2IHN0eWxlPXt7IG1hcmdpbkJvdHRvbTogNiB9fT5cbiAgICAgICAgICAgIDxzbWFsbD5JdGVtczo8L3NtYWxsPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICB7cmVuZGVySXRlbXMoKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAge2NoZWNrb3V0SXRlbXMoKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICBcbiAgICAgICAgICB7Y29uc29sZS5sb2coYFJvdXRlciBQYXRoOiAke3JvdXRlci5hc1BhdGh9YCl9XG4gICAgICAgIDwvQ2FyZEJvZHk+XG4gICAgICA8L0NhcmQ+XG4gICAgICA8c3R5bGUganN4PntgXG4gICAgICAgICNpdGVtLXByaWNlIHtcbiAgICAgICAgICBmb250LXNpemU6IDEuM2VtO1xuICAgICAgICAgIGNvbG9yOiByZ2JhKDk3LCA5NywgOTcsIDEpO1xuICAgICAgICB9XG4gICAgICAgICNpdGVtLXF1YW50aXR5IHtcbiAgICAgICAgICBmb250LXNpemU6IDAuOTVlbTtcbiAgICAgICAgICBwYWRkaW5nLWJvdHRvbTogNHB4O1xuICAgICAgICAgIGNvbG9yOiByZ2JhKDE1OCwgMTU4LCAxNTgsIDEpO1xuICAgICAgICB9XG4gICAgICAgICNpdGVtLW5hbWUge1xuICAgICAgICAgIGZvbnQtc2l6ZTogMS4zZW07XG4gICAgICAgICAgY29sb3I6IHJnYmEoOTcsIDk3LCA5NywgMSk7XG4gICAgICAgIH1cbiAgICAgIGB9PC9zdHlsZT5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cbmV4cG9ydCBkZWZhdWx0IENhcnQ7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/cart.js\n");

/***/ }),

/***/ "./components/context.js":
/*!*******************************!*\
  !*** ./components/context.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* /context/AppContext.js */\n\n\n// create auth context with default value\n\n// set backup default for isAuthenticated if none is provided in Provider\nconst AppContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createContext({\n  cart: {\n    items: [],\n    total: 0\n  },\n  user: null,\n  isAuthenticated: false\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (AppContext);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2NvbnRleHQuanM/MjQzOSJdLCJuYW1lcyI6WyJBcHBDb250ZXh0IiwiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwiY2FydCIsIml0ZW1zIiwidG90YWwiLCJ1c2VyIiwiaXNBdXRoZW50aWNhdGVkIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFFMEI7QUFDMUI7O0FBRUE7QUFDQSxNQUFNQSxVQUFVLGdCQUFHQyw0Q0FBSyxDQUFDQyxhQUFhLENBQUM7RUFDckNDLElBQUksRUFBRTtJQUFFQyxLQUFLLEVBQUUsRUFBRTtJQUFFQyxLQUFLLEVBQUU7RUFBRSxDQUFDO0VBQzdCQyxJQUFJLEVBQUUsSUFBSTtFQUNWQyxlQUFlLEVBQUU7QUFDbkIsQ0FBQyxDQUFDO0FBQ2FQLHlFQUFVIiwiZmlsZSI6Ii4vY29tcG9uZW50cy9jb250ZXh0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogL2NvbnRleHQvQXBwQ29udGV4dC5qcyAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG4vLyBjcmVhdGUgYXV0aCBjb250ZXh0IHdpdGggZGVmYXVsdCB2YWx1ZVxuXG4vLyBzZXQgYmFja3VwIGRlZmF1bHQgZm9yIGlzQXV0aGVudGljYXRlZCBpZiBub25lIGlzIHByb3ZpZGVkIGluIFByb3ZpZGVyXG5jb25zdCBBcHBDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gIGNhcnQ6IHsgaXRlbXM6IFtdLCB0b3RhbDogMCB9LFxuICB1c2VyOiBudWxsLFxuICBpc0F1dGhlbnRpY2F0ZWQ6IGZhbHNlLFxufSk7XG5leHBvcnQgZGVmYXVsdCBBcHBDb250ZXh0O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/context.js\n");

/***/ }),

/***/ "./components/dishes.js":
/*!******************************!*\
  !*** ./components/dishes.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/router */ \"next/router\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @apollo/client */ \"./node_modules/@apollo/client/main.cjs\");\n/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_apollo_client__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./context */ \"./components/context.js\");\n/* harmony import */ var reactstrap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! reactstrap */ \"./node_modules/reactstrap/dist/reactstrap.cjs\");\n/* harmony import */ var reactstrap__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(reactstrap__WEBPACK_IMPORTED_MODULE_4__);\nvar _jsxFileName = \"/Users/carloszapata/Desktop/CAPSTONE/main/root/frontend/components/dishes.js\";\n\nvar __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;\n\n\n\n\n\nfunction Dishes(props) {\n  const {\n    0: restaurantID,\n    1: setRestaurantID\n  } = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])();\n  const {\n    addItem\n  } = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(_context__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\n  const {\n    restId,\n    search\n  } = props;\n  const GET_RESTAURANT_DISHES = _apollo_client__WEBPACK_IMPORTED_MODULE_2__[\"gql\"]`\n    query ($id: ID!) {\n      restaurant(id: $id) {\n        id\n        name\n        dishes {\n          id\n          name\n          description\n          price\n          image {\n            url\n          }\n        }\n      }\n    }\n  `;\n  const {\n    loading,\n    error,\n    data\n  } = Object(_apollo_client__WEBPACK_IMPORTED_MODULE_2__[\"useQuery\"])(GET_RESTAURANT_DISHES, {\n    variables: {\n      id: restId\n    }\n  });\n  if (loading) return __jsx(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 42,\n      columnNumber: 23\n    }\n  }, \"Loading...\");\n  if (error) return __jsx(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 43,\n      columnNumber: 21\n    }\n  }, \"ERROR here\");\n  if (!data) return __jsx(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 44,\n      columnNumber: 21\n    }\n  }, \"Not found\");\n  let restaurant = data.restaurant;\n  let searchQuery = restaurant.dishes.filter(res => {\n    return res.name.toLowerCase().includes(search);\n  });\n  if (searchQuery.length > 0) {\n    return __jsx(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, searchQuery.map(res => __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__[\"Col\"], {\n      xs: \"6\",\n      sm: \"4\",\n      style: {\n        padding: 0\n      },\n      key: res.id,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 56,\n        columnNumber: 11\n      }\n    }, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__[\"Card\"], {\n      style: {\n        margin: \"0 10px\"\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 61,\n        columnNumber: 13\n      }\n    }, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__[\"CardImg\"], {\n      top: true,\n      style: {\n        height: 150,\n        width: 150\n      },\n      src: `http://localhost:1337${res.image.url}`,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 62,\n        columnNumber: 15\n      }\n    }), __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__[\"CardBody\"], {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 67,\n        columnNumber: 15\n      }\n    }, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__[\"CardTitle\"], {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 68,\n        columnNumber: 17\n      }\n    }, res.name), __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__[\"CardText\"], {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 69,\n        columnNumber: 17\n      }\n    }, res.description)), __jsx(\"div\", {\n      className: \"card-footer\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 71,\n        columnNumber: 15\n      }\n    }, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__[\"Button\"], {\n      type: \"info\",\n      outline: true,\n      color: \"primary\",\n      onClick: () => addItem(res),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 72,\n        columnNumber: 17\n      }\n    }, \"+ Add To Cart\"))))));\n  } else {\n    return __jsx(\"h1\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 86,\n        columnNumber: 12\n      }\n    }, \"Refine your search \");\n  }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (Dishes);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL2Rpc2hlcy5qcz80MTQzIl0sIm5hbWVzIjpbIkRpc2hlcyIsInByb3BzIiwicmVzdGF1cmFudElEIiwic2V0UmVzdGF1cmFudElEIiwidXNlU3RhdGUiLCJhZGRJdGVtIiwidXNlQ29udGV4dCIsIkFwcENvbnRleHQiLCJyZXN0SWQiLCJzZWFyY2giLCJHRVRfUkVTVEFVUkFOVF9ESVNIRVMiLCJncWwiLCJsb2FkaW5nIiwiZXJyb3IiLCJkYXRhIiwidXNlUXVlcnkiLCJ2YXJpYWJsZXMiLCJpZCIsInJlc3RhdXJhbnQiLCJzZWFyY2hRdWVyeSIsImRpc2hlcyIsImZpbHRlciIsInJlcyIsIm5hbWUiLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwibGVuZ3RoIiwibWFwIiwicGFkZGluZyIsIm1hcmdpbiIsImhlaWdodCIsIndpZHRoIiwiaW1hZ2UiLCJ1cmwiLCJkZXNjcmlwdGlvbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF3QztBQUNPO0FBQ0Y7QUFDVjtBQVVmO0FBQ3BCLFNBQVNBLE1BQU0sQ0FBQ0MsS0FBSyxFQUFFO0VBQ3JCLE1BQU07SUFBQSxHQUFDQyxZQUFZO0lBQUEsR0FBRUM7RUFBZSxJQUFJQyxzREFBUSxFQUFFO0VBQ2xELE1BQU07SUFBRUM7RUFBUSxDQUFDLEdBQUdDLHdEQUFVLENBQUNDLGdEQUFVLENBQUM7RUFDMUMsTUFBTTtJQUFFQyxNQUFNO0lBQUVDO0VBQU8sQ0FBQyxHQUFHUixLQUFLO0VBRWhDLE1BQU1TLHFCQUFxQixHQUFHQyxrREFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0VBRUQsTUFBTTtJQUFFQyxPQUFPO0lBQUVDLEtBQUs7SUFBRUM7RUFBSyxDQUFDLEdBQUdDLCtEQUFRLENBQUNMLHFCQUFxQixFQUFFO0lBQy9ETSxTQUFTLEVBQUU7TUFBRUMsRUFBRSxFQUFFVDtJQUFPO0VBQzFCLENBQUMsQ0FBQztFQUVGLElBQUlJLE9BQU8sRUFBRSxPQUFPO0lBQUE7SUFBQTtNQUFBO01BQUE7TUFBQTtJQUFBO0VBQUEsZ0JBQWlCO0VBQ3JDLElBQUlDLEtBQUssRUFBRSxPQUFPO0lBQUE7SUFBQTtNQUFBO01BQUE7TUFBQTtJQUFBO0VBQUEsZ0JBQWlCO0VBQ25DLElBQUksQ0FBQ0MsSUFBSSxFQUFFLE9BQU87SUFBQTtJQUFBO01BQUE7TUFBQTtNQUFBO0lBQUE7RUFBQSxlQUFnQjtFQUVsQyxJQUFJSSxVQUFVLEdBQUdKLElBQUksQ0FBQ0ksVUFBVTtFQUVoQyxJQUFJQyxXQUFXLEdBQUdELFVBQVUsQ0FBQ0UsTUFBTSxDQUFDQyxNQUFNLENBQUVDLEdBQUcsSUFBSztJQUNsRCxPQUFPQSxHQUFHLENBQUNDLElBQUksQ0FBQ0MsV0FBVyxFQUFFLENBQUNDLFFBQVEsQ0FBQ2hCLE1BQU0sQ0FBQztFQUNoRCxDQUFDLENBQUM7RUFFRixJQUFJVSxXQUFXLENBQUNPLE1BQU0sR0FBRyxDQUFDLEVBQUU7SUFDMUIsT0FDRSxtRUFDR1AsV0FBVyxDQUFDUSxHQUFHLENBQUVMLEdBQUcsSUFDbkIsTUFBQyw4Q0FBRztNQUNGLEVBQUUsRUFBQyxHQUFHO01BQ04sRUFBRSxFQUFDLEdBQUc7TUFDTixLQUFLLEVBQUU7UUFBRU0sT0FBTyxFQUFFO01BQUUsQ0FBRTtNQUN0QixHQUFHLEVBQUVOLEdBQUcsQ0FBQ0wsRUFBRztNQUFBO01BQUE7UUFBQTtRQUFBO1FBQUE7TUFBQTtJQUFBLEdBQ1osTUFBQywrQ0FBSTtNQUFDLEtBQUssRUFBRTtRQUFFWSxNQUFNLEVBQUU7TUFBUyxDQUFFO01BQUE7TUFBQTtRQUFBO1FBQUE7UUFBQTtNQUFBO0lBQUEsR0FDaEMsTUFBQyxrREFBTztNQUNOLEdBQUcsRUFBRSxJQUFLO01BQ1YsS0FBSyxFQUFFO1FBQUVDLE1BQU0sRUFBRSxHQUFHO1FBQUVDLEtBQUssRUFBRTtNQUFJLENBQUU7TUFDbkMsR0FBRyxFQUFHLHdCQUF1QlQsR0FBRyxDQUFDVSxLQUFLLENBQUNDLEdBQUksRUFBRTtNQUFBO01BQUE7UUFBQTtRQUFBO1FBQUE7TUFBQTtJQUFBLEVBQzdDLEVBQ0YsTUFBQyxtREFBUTtNQUFBO01BQUE7UUFBQTtRQUFBO1FBQUE7TUFBQTtJQUFBLEdBQ1AsTUFBQyxvREFBUztNQUFBO01BQUE7UUFBQTtRQUFBO1FBQUE7TUFBQTtJQUFBLEdBQUVYLEdBQUcsQ0FBQ0MsSUFBSSxDQUFhLEVBQ2pDLE1BQUMsbURBQVE7TUFBQTtNQUFBO1FBQUE7UUFBQTtRQUFBO01BQUE7SUFBQSxHQUFFRCxHQUFHLENBQUNZLFdBQVcsQ0FBWSxDQUM3QixFQUNYO01BQUssU0FBUyxFQUFDLGFBQWE7TUFBQTtNQUFBO1FBQUE7UUFBQTtRQUFBO01BQUE7SUFBQSxHQUMxQixNQUFDLGlEQUFNO01BQ0wsSUFBSSxFQUFDLE1BQU07TUFDWCxPQUFPO01BQ1AsS0FBSyxFQUFDLFNBQVM7TUFDZixPQUFPLEVBQUUsTUFBTTdCLE9BQU8sQ0FBQ2lCLEdBQUcsQ0FBRTtNQUFBO01BQUE7UUFBQTtRQUFBO1FBQUE7TUFBQTtJQUFBLG1CQUVyQixDQUNMLENBQ0QsQ0FFVixDQUFDLENBQ0Q7RUFFUCxDQUFDLE1BQU07SUFDTCxPQUFPO01BQUE7TUFBQTtRQUFBO1FBQUE7UUFBQTtNQUFBO0lBQUEseUJBQTRCO0VBQ3JDO0FBQ0Y7QUFDZXRCLHFFQUFNIiwiZmlsZSI6Ii4vY29tcG9uZW50cy9kaXNoZXMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tIFwibmV4dC9yb3V0ZXJcIjtcbmltcG9ydCB7IGdxbCwgdXNlUXVlcnkgfSBmcm9tIFwiQGFwb2xsby9jbGllbnRcIjtcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VDb250ZXh0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgQXBwQ29udGV4dCBmcm9tIFwiLi9jb250ZXh0XCI7XG5pbXBvcnQge1xuICBCdXR0b24sXG4gIENhcmQsXG4gIENhcmRCb2R5LFxuICBDYXJkSW1nLFxuICBDYXJkVGV4dCxcbiAgQ2FyZFRpdGxlLFxuICBSb3csXG4gIENvbCxcbn0gZnJvbSBcInJlYWN0c3RyYXBcIjtcbmZ1bmN0aW9uIERpc2hlcyhwcm9wcykge1xuICBjb25zdCBbcmVzdGF1cmFudElELCBzZXRSZXN0YXVyYW50SURdID0gdXNlU3RhdGUoKTtcbiAgY29uc3QgeyBhZGRJdGVtIH0gPSB1c2VDb250ZXh0KEFwcENvbnRleHQpO1xuICBjb25zdCB7IHJlc3RJZCwgc2VhcmNoIH0gPSBwcm9wcztcblxuICBjb25zdCBHRVRfUkVTVEFVUkFOVF9ESVNIRVMgPSBncWxgXG4gICAgcXVlcnkgKCRpZDogSUQhKSB7XG4gICAgICByZXN0YXVyYW50KGlkOiAkaWQpIHtcbiAgICAgICAgaWRcbiAgICAgICAgbmFtZVxuICAgICAgICBkaXNoZXMge1xuICAgICAgICAgIGlkXG4gICAgICAgICAgbmFtZVxuICAgICAgICAgIGRlc2NyaXB0aW9uXG4gICAgICAgICAgcHJpY2VcbiAgICAgICAgICBpbWFnZSB7XG4gICAgICAgICAgICB1cmxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGA7XG5cbiAgY29uc3QgeyBsb2FkaW5nLCBlcnJvciwgZGF0YSB9ID0gdXNlUXVlcnkoR0VUX1JFU1RBVVJBTlRfRElTSEVTLCB7XG4gICAgdmFyaWFibGVzOiB7IGlkOiByZXN0SWQgfSxcbiAgfSk7XG5cbiAgaWYgKGxvYWRpbmcpIHJldHVybiA8cD5Mb2FkaW5nLi4uPC9wPjtcbiAgaWYgKGVycm9yKSByZXR1cm4gPHA+RVJST1IgaGVyZTwvcD47XG4gIGlmICghZGF0YSkgcmV0dXJuIDxwPk5vdCBmb3VuZDwvcD47XG5cbiAgbGV0IHJlc3RhdXJhbnQgPSBkYXRhLnJlc3RhdXJhbnQ7XG5cbiAgbGV0IHNlYXJjaFF1ZXJ5ID0gcmVzdGF1cmFudC5kaXNoZXMuZmlsdGVyKChyZXMpID0+IHtcbiAgICByZXR1cm4gcmVzLm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2gpO1xuICB9KTtcblxuICBpZiAoc2VhcmNoUXVlcnkubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiAoXG4gICAgICA8PlxuICAgICAgICB7c2VhcmNoUXVlcnkubWFwKChyZXMpID0+IChcbiAgICAgICAgICA8Q29sXG4gICAgICAgICAgICB4cz0nNidcbiAgICAgICAgICAgIHNtPSc0J1xuICAgICAgICAgICAgc3R5bGU9e3sgcGFkZGluZzogMCB9fVxuICAgICAgICAgICAga2V5PXtyZXMuaWR9PlxuICAgICAgICAgICAgPENhcmQgc3R5bGU9e3sgbWFyZ2luOiBcIjAgMTBweFwiIH19PlxuICAgICAgICAgICAgICA8Q2FyZEltZ1xuICAgICAgICAgICAgICAgIHRvcD17dHJ1ZX1cbiAgICAgICAgICAgICAgICBzdHlsZT17eyBoZWlnaHQ6IDE1MCwgd2lkdGg6IDE1MCB9fVxuICAgICAgICAgICAgICAgIHNyYz17YGh0dHA6Ly9sb2NhbGhvc3Q6MTMzNyR7cmVzLmltYWdlLnVybH1gfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8Q2FyZEJvZHk+XG4gICAgICAgICAgICAgICAgPENhcmRUaXRsZT57cmVzLm5hbWV9PC9DYXJkVGl0bGU+XG4gICAgICAgICAgICAgICAgPENhcmRUZXh0PntyZXMuZGVzY3JpcHRpb259PC9DYXJkVGV4dD5cbiAgICAgICAgICAgICAgPC9DYXJkQm9keT5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J2NhcmQtZm9vdGVyJz5cbiAgICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgICB0eXBlPSdpbmZvJ1xuICAgICAgICAgICAgICAgICAgb3V0bGluZVxuICAgICAgICAgICAgICAgICAgY29sb3I9J3ByaW1hcnknXG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBhZGRJdGVtKHJlcyl9PlxuICAgICAgICAgICAgICAgICAgKyBBZGQgVG8gQ2FydFxuICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvQ2FyZD5cbiAgICAgICAgICA8L0NvbD5cbiAgICAgICAgKSl9XG4gICAgICA8Lz5cbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiA8aDE+UmVmaW5lIHlvdXIgc2VhcmNoIDwvaDE+O1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBEaXNoZXM7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/dishes.js\n");

/***/ }),

/***/ "./node_modules/@apollo/client/cache/cache.cjs":
/*!*****************************************************!*\
  !*** ./node_modules/@apollo/client/cache/cache.cjs ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar globals = __webpack_require__(/*! ../utilities/globals */ \"./node_modules/@apollo/client/utilities/globals/globals.cjs\");\nvar tslib = __webpack_require__(/*! tslib */ \"tslib\");\nvar optimism = __webpack_require__(/*! optimism */ \"optimism\");\nvar utilities = __webpack_require__(/*! ../utilities */ \"./node_modules/@apollo/client/utilities/utilities.cjs\");\nvar equality = __webpack_require__(/*! @wry/equality */ \"@wry/equality\");\nvar trie = __webpack_require__(/*! @wry/trie */ \"@wry/trie\");\nvar graphql = __webpack_require__(/*! graphql */ \"graphql\");\nvar context = __webpack_require__(/*! @wry/context */ \"@wry/context\");\n\nvar ApolloCache = (function () {\n    function ApolloCache() {\n        this.getFragmentDoc = optimism.wrap(utilities.getFragmentQueryDocument);\n    }\n    ApolloCache.prototype.batch = function (options) {\n        var _this = this;\n        var optimisticId = typeof options.optimistic === \"string\" ? options.optimistic :\n            options.optimistic === false ? null : void 0;\n        var updateResult;\n        this.performTransaction(function () { return updateResult = options.update(_this); }, optimisticId);\n        return updateResult;\n    };\n    ApolloCache.prototype.recordOptimisticTransaction = function (transaction, optimisticId) {\n        this.performTransaction(transaction, optimisticId);\n    };\n    ApolloCache.prototype.transformDocument = function (document) {\n        return document;\n    };\n    ApolloCache.prototype.transformForLink = function (document) {\n        return document;\n    };\n    ApolloCache.prototype.identify = function (object) {\n        return;\n    };\n    ApolloCache.prototype.gc = function () {\n        return [];\n    };\n    ApolloCache.prototype.modify = function (options) {\n        return false;\n    };\n    ApolloCache.prototype.readQuery = function (options, optimistic) {\n        if (optimistic === void 0) { optimistic = !!options.optimistic; }\n        return this.read(tslib.__assign(tslib.__assign({}, options), { rootId: options.id || 'ROOT_QUERY', optimistic: optimistic }));\n    };\n    ApolloCache.prototype.readFragment = function (options, optimistic) {\n        if (optimistic === void 0) { optimistic = !!options.optimistic; }\n        return this.read(tslib.__assign(tslib.__assign({}, options), { query: this.getFragmentDoc(options.fragment, options.fragmentName), rootId: options.id, optimistic: optimistic }));\n    };\n    ApolloCache.prototype.writeQuery = function (_a) {\n        var id = _a.id, data = _a.data, options = tslib.__rest(_a, [\"id\", \"data\"]);\n        return this.write(Object.assign(options, {\n            dataId: id || 'ROOT_QUERY',\n            result: data,\n        }));\n    };\n    ApolloCache.prototype.writeFragment = function (_a) {\n        var id = _a.id, data = _a.data, fragment = _a.fragment, fragmentName = _a.fragmentName, options = tslib.__rest(_a, [\"id\", \"data\", \"fragment\", \"fragmentName\"]);\n        return this.write(Object.assign(options, {\n            query: this.getFragmentDoc(fragment, fragmentName),\n            dataId: id,\n            result: data,\n        }));\n    };\n    ApolloCache.prototype.updateQuery = function (options, update) {\n        return this.batch({\n            update: function (cache) {\n                var value = cache.readQuery(options);\n                var data = update(value);\n                if (data === void 0 || data === null)\n                    return value;\n                cache.writeQuery(tslib.__assign(tslib.__assign({}, options), { data: data }));\n                return data;\n            },\n        });\n    };\n    ApolloCache.prototype.updateFragment = function (options, update) {\n        return this.batch({\n            update: function (cache) {\n                var value = cache.readFragment(options);\n                var data = update(value);\n                if (data === void 0 || data === null)\n                    return value;\n                cache.writeFragment(tslib.__assign(tslib.__assign({}, options), { data: data }));\n                return data;\n            },\n        });\n    };\n    return ApolloCache;\n}());\n\nexports.Cache = void 0;\n(function (Cache) {\n})(exports.Cache || (exports.Cache = {}));\n\nvar MissingFieldError = (function (_super) {\n    tslib.__extends(MissingFieldError, _super);\n    function MissingFieldError(message, path, query, variables) {\n        var _a;\n        var _this = _super.call(this, message) || this;\n        _this.message = message;\n        _this.path = path;\n        _this.query = query;\n        _this.variables = variables;\n        if (Array.isArray(_this.path)) {\n            _this.missing = _this.message;\n            for (var i = _this.path.length - 1; i >= 0; --i) {\n                _this.missing = (_a = {}, _a[_this.path[i]] = _this.missing, _a);\n            }\n        }\n        else {\n            _this.missing = _this.path;\n        }\n        _this.__proto__ = MissingFieldError.prototype;\n        return _this;\n    }\n    return MissingFieldError;\n}(Error));\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nfunction isNullish(value) {\n    return value === null || value === void 0;\n}\nvar isArray = Array.isArray;\nfunction defaultDataIdFromObject(_a, context) {\n    var __typename = _a.__typename, id = _a.id, _id = _a._id;\n    if (typeof __typename === \"string\") {\n        if (context) {\n            context.keyObject =\n                !isNullish(id) ? { id: id } :\n                    !isNullish(_id) ? { _id: _id } :\n                        void 0;\n        }\n        if (isNullish(id) && !isNullish(_id)) {\n            id = _id;\n        }\n        if (!isNullish(id)) {\n            return \"\".concat(__typename, \":\").concat((typeof id === \"number\" ||\n                typeof id === \"string\") ? id : JSON.stringify(id));\n        }\n    }\n}\nvar defaultConfig = {\n    dataIdFromObject: defaultDataIdFromObject,\n    addTypename: true,\n    resultCaching: true,\n    canonizeResults: false,\n};\nfunction normalizeConfig(config) {\n    return utilities.compact(defaultConfig, config);\n}\nfunction shouldCanonizeResults(config) {\n    var value = config.canonizeResults;\n    return value === void 0 ? defaultConfig.canonizeResults : value;\n}\nfunction getTypenameFromStoreObject(store, objectOrReference) {\n    return utilities.isReference(objectOrReference)\n        ? store.get(objectOrReference.__ref, \"__typename\")\n        : objectOrReference && objectOrReference.__typename;\n}\nvar TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\nfunction fieldNameFromStoreName(storeFieldName) {\n    var match = storeFieldName.match(TypeOrFieldNameRegExp);\n    return match ? match[0] : storeFieldName;\n}\nfunction selectionSetMatchesResult(selectionSet, result, variables) {\n    if (utilities.isNonNullObject(result)) {\n        return isArray(result)\n            ? result.every(function (item) { return selectionSetMatchesResult(selectionSet, item, variables); })\n            : selectionSet.selections.every(function (field) {\n                if (utilities.isField(field) && utilities.shouldInclude(field, variables)) {\n                    var key = utilities.resultKeyNameFromField(field);\n                    return hasOwn.call(result, key) &&\n                        (!field.selectionSet ||\n                            selectionSetMatchesResult(field.selectionSet, result[key], variables));\n                }\n                return true;\n            });\n    }\n    return false;\n}\nfunction storeValueIsStoreObject(value) {\n    return utilities.isNonNullObject(value) &&\n        !utilities.isReference(value) &&\n        !isArray(value);\n}\nfunction makeProcessedFieldsMerger() {\n    return new utilities.DeepMerger;\n}\nfunction extractFragmentContext(document, fragments) {\n    var fragmentMap = utilities.createFragmentMap(utilities.getFragmentDefinitions(document));\n    return {\n        fragmentMap: fragmentMap,\n        lookupFragment: function (name) {\n            var def = fragmentMap[name];\n            if (!def && fragments) {\n                def = fragments.lookup(name);\n            }\n            return def || null;\n        },\n    };\n}\n\nvar DELETE = Object.create(null);\nvar delModifier = function () { return DELETE; };\nvar INVALIDATE = Object.create(null);\nexports.EntityStore = (function () {\n    function EntityStore(policies, group) {\n        var _this = this;\n        this.policies = policies;\n        this.group = group;\n        this.data = Object.create(null);\n        this.rootIds = Object.create(null);\n        this.refs = Object.create(null);\n        this.getFieldValue = function (objectOrReference, storeFieldName) { return utilities.maybeDeepFreeze(utilities.isReference(objectOrReference)\n            ? _this.get(objectOrReference.__ref, storeFieldName)\n            : objectOrReference && objectOrReference[storeFieldName]); };\n        this.canRead = function (objOrRef) {\n            return utilities.isReference(objOrRef)\n                ? _this.has(objOrRef.__ref)\n                : typeof objOrRef === \"object\";\n        };\n        this.toReference = function (objOrIdOrRef, mergeIntoStore) {\n            if (typeof objOrIdOrRef === \"string\") {\n                return utilities.makeReference(objOrIdOrRef);\n            }\n            if (utilities.isReference(objOrIdOrRef)) {\n                return objOrIdOrRef;\n            }\n            var id = _this.policies.identify(objOrIdOrRef)[0];\n            if (id) {\n                var ref = utilities.makeReference(id);\n                if (mergeIntoStore) {\n                    _this.merge(id, objOrIdOrRef);\n                }\n                return ref;\n            }\n        };\n    }\n    EntityStore.prototype.toObject = function () {\n        return tslib.__assign({}, this.data);\n    };\n    EntityStore.prototype.has = function (dataId) {\n        return this.lookup(dataId, true) !== void 0;\n    };\n    EntityStore.prototype.get = function (dataId, fieldName) {\n        this.group.depend(dataId, fieldName);\n        if (hasOwn.call(this.data, dataId)) {\n            var storeObject = this.data[dataId];\n            if (storeObject && hasOwn.call(storeObject, fieldName)) {\n                return storeObject[fieldName];\n            }\n        }\n        if (fieldName === \"__typename\" &&\n            hasOwn.call(this.policies.rootTypenamesById, dataId)) {\n            return this.policies.rootTypenamesById[dataId];\n        }\n        if (this instanceof Layer) {\n            return this.parent.get(dataId, fieldName);\n        }\n    };\n    EntityStore.prototype.lookup = function (dataId, dependOnExistence) {\n        if (dependOnExistence)\n            this.group.depend(dataId, \"__exists\");\n        if (hasOwn.call(this.data, dataId)) {\n            return this.data[dataId];\n        }\n        if (this instanceof Layer) {\n            return this.parent.lookup(dataId, dependOnExistence);\n        }\n        if (this.policies.rootTypenamesById[dataId]) {\n            return Object.create(null);\n        }\n    };\n    EntityStore.prototype.merge = function (older, newer) {\n        var _this = this;\n        var dataId;\n        if (utilities.isReference(older))\n            older = older.__ref;\n        if (utilities.isReference(newer))\n            newer = newer.__ref;\n        var existing = typeof older === \"string\"\n            ? this.lookup(dataId = older)\n            : older;\n        var incoming = typeof newer === \"string\"\n            ? this.lookup(dataId = newer)\n            : newer;\n        if (!incoming)\n            return;\n        __DEV__ ? globals.invariant(typeof dataId === \"string\", \"store.merge expects a string ID\") : globals.invariant(typeof dataId === \"string\", 1);\n        var merged = new utilities.DeepMerger(storeObjectReconciler).merge(existing, incoming);\n        this.data[dataId] = merged;\n        if (merged !== existing) {\n            delete this.refs[dataId];\n            if (this.group.caching) {\n                var fieldsToDirty_1 = Object.create(null);\n                if (!existing)\n                    fieldsToDirty_1.__exists = 1;\n                Object.keys(incoming).forEach(function (storeFieldName) {\n                    if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {\n                        fieldsToDirty_1[storeFieldName] = 1;\n                        var fieldName = fieldNameFromStoreName(storeFieldName);\n                        if (fieldName !== storeFieldName &&\n                            !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {\n                            fieldsToDirty_1[fieldName] = 1;\n                        }\n                        if (merged[storeFieldName] === void 0 && !(_this instanceof Layer)) {\n                            delete merged[storeFieldName];\n                        }\n                    }\n                });\n                if (fieldsToDirty_1.__typename &&\n                    !(existing && existing.__typename) &&\n                    this.policies.rootTypenamesById[dataId] === merged.__typename) {\n                    delete fieldsToDirty_1.__typename;\n                }\n                Object.keys(fieldsToDirty_1).forEach(function (fieldName) { return _this.group.dirty(dataId, fieldName); });\n            }\n        }\n    };\n    EntityStore.prototype.modify = function (dataId, fields) {\n        var _this = this;\n        var storeObject = this.lookup(dataId);\n        if (storeObject) {\n            var changedFields_1 = Object.create(null);\n            var needToMerge_1 = false;\n            var allDeleted_1 = true;\n            var sharedDetails_1 = {\n                DELETE: DELETE,\n                INVALIDATE: INVALIDATE,\n                isReference: utilities.isReference,\n                toReference: this.toReference,\n                canRead: this.canRead,\n                readField: function (fieldNameOrOptions, from) { return _this.policies.readField(typeof fieldNameOrOptions === \"string\" ? {\n                    fieldName: fieldNameOrOptions,\n                    from: from || utilities.makeReference(dataId),\n                } : fieldNameOrOptions, { store: _this }); },\n            };\n            Object.keys(storeObject).forEach(function (storeFieldName) {\n                var fieldName = fieldNameFromStoreName(storeFieldName);\n                var fieldValue = storeObject[storeFieldName];\n                if (fieldValue === void 0)\n                    return;\n                var modify = typeof fields === \"function\"\n                    ? fields\n                    : fields[storeFieldName] || fields[fieldName];\n                if (modify) {\n                    var newValue = modify === delModifier ? DELETE :\n                        modify(utilities.maybeDeepFreeze(fieldValue), tslib.__assign(tslib.__assign({}, sharedDetails_1), { fieldName: fieldName, storeFieldName: storeFieldName, storage: _this.getStorage(dataId, storeFieldName) }));\n                    if (newValue === INVALIDATE) {\n                        _this.group.dirty(dataId, storeFieldName);\n                    }\n                    else {\n                        if (newValue === DELETE)\n                            newValue = void 0;\n                        if (newValue !== fieldValue) {\n                            changedFields_1[storeFieldName] = newValue;\n                            needToMerge_1 = true;\n                            fieldValue = newValue;\n                        }\n                    }\n                }\n                if (fieldValue !== void 0) {\n                    allDeleted_1 = false;\n                }\n            });\n            if (needToMerge_1) {\n                this.merge(dataId, changedFields_1);\n                if (allDeleted_1) {\n                    if (this instanceof Layer) {\n                        this.data[dataId] = void 0;\n                    }\n                    else {\n                        delete this.data[dataId];\n                    }\n                    this.group.dirty(dataId, \"__exists\");\n                }\n                return true;\n            }\n        }\n        return false;\n    };\n    EntityStore.prototype.delete = function (dataId, fieldName, args) {\n        var _a;\n        var storeObject = this.lookup(dataId);\n        if (storeObject) {\n            var typename = this.getFieldValue(storeObject, \"__typename\");\n            var storeFieldName = fieldName && args\n                ? this.policies.getStoreFieldName({ typename: typename, fieldName: fieldName, args: args })\n                : fieldName;\n            return this.modify(dataId, storeFieldName ? (_a = {},\n                _a[storeFieldName] = delModifier,\n                _a) : delModifier);\n        }\n        return false;\n    };\n    EntityStore.prototype.evict = function (options, limit) {\n        var evicted = false;\n        if (options.id) {\n            if (hasOwn.call(this.data, options.id)) {\n                evicted = this.delete(options.id, options.fieldName, options.args);\n            }\n            if (this instanceof Layer && this !== limit) {\n                evicted = this.parent.evict(options, limit) || evicted;\n            }\n            if (options.fieldName || evicted) {\n                this.group.dirty(options.id, options.fieldName || \"__exists\");\n            }\n        }\n        return evicted;\n    };\n    EntityStore.prototype.clear = function () {\n        this.replace(null);\n    };\n    EntityStore.prototype.extract = function () {\n        var _this = this;\n        var obj = this.toObject();\n        var extraRootIds = [];\n        this.getRootIdSet().forEach(function (id) {\n            if (!hasOwn.call(_this.policies.rootTypenamesById, id)) {\n                extraRootIds.push(id);\n            }\n        });\n        if (extraRootIds.length) {\n            obj.__META = { extraRootIds: extraRootIds.sort() };\n        }\n        return obj;\n    };\n    EntityStore.prototype.replace = function (newData) {\n        var _this = this;\n        Object.keys(this.data).forEach(function (dataId) {\n            if (!(newData && hasOwn.call(newData, dataId))) {\n                _this.delete(dataId);\n            }\n        });\n        if (newData) {\n            var __META = newData.__META, rest_1 = tslib.__rest(newData, [\"__META\"]);\n            Object.keys(rest_1).forEach(function (dataId) {\n                _this.merge(dataId, rest_1[dataId]);\n            });\n            if (__META) {\n                __META.extraRootIds.forEach(this.retain, this);\n            }\n        }\n    };\n    EntityStore.prototype.retain = function (rootId) {\n        return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;\n    };\n    EntityStore.prototype.release = function (rootId) {\n        if (this.rootIds[rootId] > 0) {\n            var count = --this.rootIds[rootId];\n            if (!count)\n                delete this.rootIds[rootId];\n            return count;\n        }\n        return 0;\n    };\n    EntityStore.prototype.getRootIdSet = function (ids) {\n        if (ids === void 0) { ids = new Set(); }\n        Object.keys(this.rootIds).forEach(ids.add, ids);\n        if (this instanceof Layer) {\n            this.parent.getRootIdSet(ids);\n        }\n        else {\n            Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);\n        }\n        return ids;\n    };\n    EntityStore.prototype.gc = function () {\n        var _this = this;\n        var ids = this.getRootIdSet();\n        var snapshot = this.toObject();\n        ids.forEach(function (id) {\n            if (hasOwn.call(snapshot, id)) {\n                Object.keys(_this.findChildRefIds(id)).forEach(ids.add, ids);\n                delete snapshot[id];\n            }\n        });\n        var idsToRemove = Object.keys(snapshot);\n        if (idsToRemove.length) {\n            var root_1 = this;\n            while (root_1 instanceof Layer)\n                root_1 = root_1.parent;\n            idsToRemove.forEach(function (id) { return root_1.delete(id); });\n        }\n        return idsToRemove;\n    };\n    EntityStore.prototype.findChildRefIds = function (dataId) {\n        if (!hasOwn.call(this.refs, dataId)) {\n            var found_1 = this.refs[dataId] = Object.create(null);\n            var root = this.data[dataId];\n            if (!root)\n                return found_1;\n            var workSet_1 = new Set([root]);\n            workSet_1.forEach(function (obj) {\n                if (utilities.isReference(obj)) {\n                    found_1[obj.__ref] = true;\n                }\n                if (utilities.isNonNullObject(obj)) {\n                    Object.keys(obj).forEach(function (key) {\n                        var child = obj[key];\n                        if (utilities.isNonNullObject(child)) {\n                            workSet_1.add(child);\n                        }\n                    });\n                }\n            });\n        }\n        return this.refs[dataId];\n    };\n    EntityStore.prototype.makeCacheKey = function () {\n        return this.group.keyMaker.lookupArray(arguments);\n    };\n    return EntityStore;\n}());\nvar CacheGroup = (function () {\n    function CacheGroup(caching, parent) {\n        if (parent === void 0) { parent = null; }\n        this.caching = caching;\n        this.parent = parent;\n        this.d = null;\n        this.resetCaching();\n    }\n    CacheGroup.prototype.resetCaching = function () {\n        this.d = this.caching ? optimism.dep() : null;\n        this.keyMaker = new trie.Trie(utilities.canUseWeakMap);\n    };\n    CacheGroup.prototype.depend = function (dataId, storeFieldName) {\n        if (this.d) {\n            this.d(makeDepKey(dataId, storeFieldName));\n            var fieldName = fieldNameFromStoreName(storeFieldName);\n            if (fieldName !== storeFieldName) {\n                this.d(makeDepKey(dataId, fieldName));\n            }\n            if (this.parent) {\n                this.parent.depend(dataId, storeFieldName);\n            }\n        }\n    };\n    CacheGroup.prototype.dirty = function (dataId, storeFieldName) {\n        if (this.d) {\n            this.d.dirty(makeDepKey(dataId, storeFieldName), storeFieldName === \"__exists\" ? \"forget\" : \"setDirty\");\n        }\n    };\n    return CacheGroup;\n}());\nfunction makeDepKey(dataId, storeFieldName) {\n    return storeFieldName + '#' + dataId;\n}\nfunction maybeDependOnExistenceOfEntity(store, entityId) {\n    if (supportsResultCaching(store)) {\n        store.group.depend(entityId, \"__exists\");\n    }\n}\n(function (EntityStore) {\n    var Root = (function (_super) {\n        tslib.__extends(Root, _super);\n        function Root(_a) {\n            var policies = _a.policies, _b = _a.resultCaching, resultCaching = _b === void 0 ? true : _b, seed = _a.seed;\n            var _this = _super.call(this, policies, new CacheGroup(resultCaching)) || this;\n            _this.stump = new Stump(_this);\n            _this.storageTrie = new trie.Trie(utilities.canUseWeakMap);\n            if (seed)\n                _this.replace(seed);\n            return _this;\n        }\n        Root.prototype.addLayer = function (layerId, replay) {\n            return this.stump.addLayer(layerId, replay);\n        };\n        Root.prototype.removeLayer = function () {\n            return this;\n        };\n        Root.prototype.getStorage = function () {\n            return this.storageTrie.lookupArray(arguments);\n        };\n        return Root;\n    }(EntityStore));\n    EntityStore.Root = Root;\n})(exports.EntityStore || (exports.EntityStore = {}));\nvar Layer = (function (_super) {\n    tslib.__extends(Layer, _super);\n    function Layer(id, parent, replay, group) {\n        var _this = _super.call(this, parent.policies, group) || this;\n        _this.id = id;\n        _this.parent = parent;\n        _this.replay = replay;\n        _this.group = group;\n        replay(_this);\n        return _this;\n    }\n    Layer.prototype.addLayer = function (layerId, replay) {\n        return new Layer(layerId, this, replay, this.group);\n    };\n    Layer.prototype.removeLayer = function (layerId) {\n        var _this = this;\n        var parent = this.parent.removeLayer(layerId);\n        if (layerId === this.id) {\n            if (this.group.caching) {\n                Object.keys(this.data).forEach(function (dataId) {\n                    var ownStoreObject = _this.data[dataId];\n                    var parentStoreObject = parent[\"lookup\"](dataId);\n                    if (!parentStoreObject) {\n                        _this.delete(dataId);\n                    }\n                    else if (!ownStoreObject) {\n                        _this.group.dirty(dataId, \"__exists\");\n                        Object.keys(parentStoreObject).forEach(function (storeFieldName) {\n                            _this.group.dirty(dataId, storeFieldName);\n                        });\n                    }\n                    else if (ownStoreObject !== parentStoreObject) {\n                        Object.keys(ownStoreObject).forEach(function (storeFieldName) {\n                            if (!equality.equal(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {\n                                _this.group.dirty(dataId, storeFieldName);\n                            }\n                        });\n                    }\n                });\n            }\n            return parent;\n        }\n        if (parent === this.parent)\n            return this;\n        return parent.addLayer(this.id, this.replay);\n    };\n    Layer.prototype.toObject = function () {\n        return tslib.__assign(tslib.__assign({}, this.parent.toObject()), this.data);\n    };\n    Layer.prototype.findChildRefIds = function (dataId) {\n        var fromParent = this.parent.findChildRefIds(dataId);\n        return hasOwn.call(this.data, dataId) ? tslib.__assign(tslib.__assign({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;\n    };\n    Layer.prototype.getStorage = function () {\n        var p = this.parent;\n        while (p.parent)\n            p = p.parent;\n        return p.getStorage.apply(p, arguments);\n    };\n    return Layer;\n}(exports.EntityStore));\nvar Stump = (function (_super) {\n    tslib.__extends(Stump, _super);\n    function Stump(root) {\n        return _super.call(this, \"EntityStore.Stump\", root, function () { }, new CacheGroup(root.group.caching, root.group)) || this;\n    }\n    Stump.prototype.removeLayer = function () {\n        return this;\n    };\n    Stump.prototype.merge = function () {\n        return this.parent.merge.apply(this.parent, arguments);\n    };\n    return Stump;\n}(Layer));\nfunction storeObjectReconciler(existingObject, incomingObject, property) {\n    var existingValue = existingObject[property];\n    var incomingValue = incomingObject[property];\n    return equality.equal(existingValue, incomingValue) ? existingValue : incomingValue;\n}\nfunction supportsResultCaching(store) {\n    return !!(store instanceof exports.EntityStore && store.group.caching);\n}\n\nfunction shallowCopy(value) {\n    if (utilities.isNonNullObject(value)) {\n        return isArray(value)\n            ? value.slice(0)\n            : tslib.__assign({ __proto__: Object.getPrototypeOf(value) }, value);\n    }\n    return value;\n}\nvar ObjectCanon = (function () {\n    function ObjectCanon() {\n        this.known = new (utilities.canUseWeakSet ? WeakSet : Set)();\n        this.pool = new trie.Trie(utilities.canUseWeakMap);\n        this.passes = new WeakMap();\n        this.keysByJSON = new Map();\n        this.empty = this.admit({});\n    }\n    ObjectCanon.prototype.isKnown = function (value) {\n        return utilities.isNonNullObject(value) && this.known.has(value);\n    };\n    ObjectCanon.prototype.pass = function (value) {\n        if (utilities.isNonNullObject(value)) {\n            var copy = shallowCopy(value);\n            this.passes.set(copy, value);\n            return copy;\n        }\n        return value;\n    };\n    ObjectCanon.prototype.admit = function (value) {\n        var _this = this;\n        if (utilities.isNonNullObject(value)) {\n            var original = this.passes.get(value);\n            if (original)\n                return original;\n            var proto = Object.getPrototypeOf(value);\n            switch (proto) {\n                case Array.prototype: {\n                    if (this.known.has(value))\n                        return value;\n                    var array = value.map(this.admit, this);\n                    var node = this.pool.lookupArray(array);\n                    if (!node.array) {\n                        this.known.add(node.array = array);\n                        if (__DEV__) {\n                            Object.freeze(array);\n                        }\n                    }\n                    return node.array;\n                }\n                case null:\n                case Object.prototype: {\n                    if (this.known.has(value))\n                        return value;\n                    var proto_1 = Object.getPrototypeOf(value);\n                    var array_1 = [proto_1];\n                    var keys = this.sortedKeys(value);\n                    array_1.push(keys.json);\n                    var firstValueIndex_1 = array_1.length;\n                    keys.sorted.forEach(function (key) {\n                        array_1.push(_this.admit(value[key]));\n                    });\n                    var node = this.pool.lookupArray(array_1);\n                    if (!node.object) {\n                        var obj_1 = node.object = Object.create(proto_1);\n                        this.known.add(obj_1);\n                        keys.sorted.forEach(function (key, i) {\n                            obj_1[key] = array_1[firstValueIndex_1 + i];\n                        });\n                        if (__DEV__) {\n                            Object.freeze(obj_1);\n                        }\n                    }\n                    return node.object;\n                }\n            }\n        }\n        return value;\n    };\n    ObjectCanon.prototype.sortedKeys = function (obj) {\n        var keys = Object.keys(obj);\n        var node = this.pool.lookupArray(keys);\n        if (!node.keys) {\n            keys.sort();\n            var json = JSON.stringify(keys);\n            if (!(node.keys = this.keysByJSON.get(json))) {\n                this.keysByJSON.set(json, node.keys = { sorted: keys, json: json });\n            }\n        }\n        return node.keys;\n    };\n    return ObjectCanon;\n}());\nvar canonicalStringify = Object.assign(function (value) {\n    if (utilities.isNonNullObject(value)) {\n        if (stringifyCanon === void 0) {\n            resetCanonicalStringify();\n        }\n        var canonical = stringifyCanon.admit(value);\n        var json = stringifyCache.get(canonical);\n        if (json === void 0) {\n            stringifyCache.set(canonical, json = JSON.stringify(canonical));\n        }\n        return json;\n    }\n    return JSON.stringify(value);\n}, {\n    reset: resetCanonicalStringify,\n});\nvar stringifyCanon;\nvar stringifyCache;\nfunction resetCanonicalStringify() {\n    stringifyCanon = new ObjectCanon;\n    stringifyCache = new (utilities.canUseWeakMap ? WeakMap : Map)();\n}\n\nfunction execSelectionSetKeyArgs(options) {\n    return [\n        options.selectionSet,\n        options.objectOrReference,\n        options.context,\n        options.context.canonizeResults,\n    ];\n}\nvar StoreReader = (function () {\n    function StoreReader(config) {\n        var _this = this;\n        this.knownResults = new (utilities.canUseWeakMap ? WeakMap : Map)();\n        this.config = utilities.compact(config, {\n            addTypename: config.addTypename !== false,\n            canonizeResults: shouldCanonizeResults(config),\n        });\n        this.canon = config.canon || new ObjectCanon;\n        this.executeSelectionSet = optimism.wrap(function (options) {\n            var _a;\n            var canonizeResults = options.context.canonizeResults;\n            var peekArgs = execSelectionSetKeyArgs(options);\n            peekArgs[3] = !canonizeResults;\n            var other = (_a = _this.executeSelectionSet).peek.apply(_a, peekArgs);\n            if (other) {\n                if (canonizeResults) {\n                    return tslib.__assign(tslib.__assign({}, other), { result: _this.canon.admit(other.result) });\n                }\n                return other;\n            }\n            maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\n            return _this.execSelectionSetImpl(options);\n        }, {\n            max: this.config.resultCacheMaxSize,\n            keyArgs: execSelectionSetKeyArgs,\n            makeCacheKey: function (selectionSet, parent, context, canonizeResults) {\n                if (supportsResultCaching(context.store)) {\n                    return context.store.makeCacheKey(selectionSet, utilities.isReference(parent) ? parent.__ref : parent, context.varString, canonizeResults);\n                }\n            }\n        });\n        this.executeSubSelectedArray = optimism.wrap(function (options) {\n            maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);\n            return _this.execSubSelectedArrayImpl(options);\n        }, {\n            max: this.config.resultCacheMaxSize,\n            makeCacheKey: function (_a) {\n                var field = _a.field, array = _a.array, context = _a.context;\n                if (supportsResultCaching(context.store)) {\n                    return context.store.makeCacheKey(field, array, context.varString);\n                }\n            }\n        });\n    }\n    StoreReader.prototype.resetCanon = function () {\n        this.canon = new ObjectCanon;\n    };\n    StoreReader.prototype.diffQueryAgainstStore = function (_a) {\n        var store = _a.store, query = _a.query, _b = _a.rootId, rootId = _b === void 0 ? 'ROOT_QUERY' : _b, variables = _a.variables, _c = _a.returnPartialData, returnPartialData = _c === void 0 ? true : _c, _d = _a.canonizeResults, canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;\n        var policies = this.config.cache.policies;\n        variables = tslib.__assign(tslib.__assign({}, utilities.getDefaultValues(utilities.getQueryDefinition(query))), variables);\n        var rootRef = utilities.makeReference(rootId);\n        var execResult = this.executeSelectionSet({\n            selectionSet: utilities.getMainDefinition(query).selectionSet,\n            objectOrReference: rootRef,\n            enclosingRef: rootRef,\n            context: tslib.__assign({ store: store, query: query, policies: policies, variables: variables, varString: canonicalStringify(variables), canonizeResults: canonizeResults }, extractFragmentContext(query, this.config.fragments)),\n        });\n        var missing;\n        if (execResult.missing) {\n            missing = [new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables)];\n            if (!returnPartialData) {\n                throw missing[0];\n            }\n        }\n        return {\n            result: execResult.result,\n            complete: !missing,\n            missing: missing,\n        };\n    };\n    StoreReader.prototype.isFresh = function (result, parent, selectionSet, context) {\n        if (supportsResultCaching(context.store) &&\n            this.knownResults.get(result) === selectionSet) {\n            var latest = this.executeSelectionSet.peek(selectionSet, parent, context, this.canon.isKnown(result));\n            if (latest && result === latest.result) {\n                return true;\n            }\n        }\n        return false;\n    };\n    StoreReader.prototype.execSelectionSetImpl = function (_a) {\n        var _this = this;\n        var selectionSet = _a.selectionSet, objectOrReference = _a.objectOrReference, enclosingRef = _a.enclosingRef, context = _a.context;\n        if (utilities.isReference(objectOrReference) &&\n            !context.policies.rootTypenamesById[objectOrReference.__ref] &&\n            !context.store.has(objectOrReference.__ref)) {\n            return {\n                result: this.canon.empty,\n                missing: \"Dangling reference to missing \".concat(objectOrReference.__ref, \" object\"),\n            };\n        }\n        var variables = context.variables, policies = context.policies, store = context.store;\n        var typename = store.getFieldValue(objectOrReference, \"__typename\");\n        var objectsToMerge = [];\n        var missing;\n        var missingMerger = new utilities.DeepMerger();\n        if (this.config.addTypename &&\n            typeof typename === \"string\" &&\n            !policies.rootIdsByTypename[typename]) {\n            objectsToMerge.push({ __typename: typename });\n        }\n        function handleMissing(result, resultName) {\n            var _a;\n            if (result.missing) {\n                missing = missingMerger.merge(missing, (_a = {}, _a[resultName] = result.missing, _a));\n            }\n            return result.result;\n        }\n        var workSet = new Set(selectionSet.selections);\n        workSet.forEach(function (selection) {\n            var _a, _b;\n            if (!utilities.shouldInclude(selection, variables))\n                return;\n            if (utilities.isField(selection)) {\n                var fieldValue = policies.readField({\n                    fieldName: selection.name.value,\n                    field: selection,\n                    variables: context.variables,\n                    from: objectOrReference,\n                }, context);\n                var resultName = utilities.resultKeyNameFromField(selection);\n                if (fieldValue === void 0) {\n                    if (!utilities.addTypenameToDocument.added(selection)) {\n                        missing = missingMerger.merge(missing, (_a = {},\n                            _a[resultName] = \"Can't find field '\".concat(selection.name.value, \"' on \").concat(utilities.isReference(objectOrReference)\n                                ? objectOrReference.__ref + \" object\"\n                                : \"object \" + JSON.stringify(objectOrReference, null, 2)),\n                            _a));\n                    }\n                }\n                else if (isArray(fieldValue)) {\n                    fieldValue = handleMissing(_this.executeSubSelectedArray({\n                        field: selection,\n                        array: fieldValue,\n                        enclosingRef: enclosingRef,\n                        context: context,\n                    }), resultName);\n                }\n                else if (!selection.selectionSet) {\n                    if (context.canonizeResults) {\n                        fieldValue = _this.canon.pass(fieldValue);\n                    }\n                }\n                else if (fieldValue != null) {\n                    fieldValue = handleMissing(_this.executeSelectionSet({\n                        selectionSet: selection.selectionSet,\n                        objectOrReference: fieldValue,\n                        enclosingRef: utilities.isReference(fieldValue) ? fieldValue : enclosingRef,\n                        context: context,\n                    }), resultName);\n                }\n                if (fieldValue !== void 0) {\n                    objectsToMerge.push((_b = {}, _b[resultName] = fieldValue, _b));\n                }\n            }\n            else {\n                var fragment = utilities.getFragmentFromSelection(selection, context.lookupFragment);\n                if (!fragment && selection.kind === graphql.Kind.FRAGMENT_SPREAD) {\n                    throw __DEV__ ? new globals.InvariantError(\"No fragment named \".concat(selection.name.value)) : new globals.InvariantError(5);\n                }\n                if (fragment && policies.fragmentMatches(fragment, typename)) {\n                    fragment.selectionSet.selections.forEach(workSet.add, workSet);\n                }\n            }\n        });\n        var result = utilities.mergeDeepArray(objectsToMerge);\n        var finalResult = { result: result, missing: missing };\n        var frozen = context.canonizeResults\n            ? this.canon.admit(finalResult)\n            : utilities.maybeDeepFreeze(finalResult);\n        if (frozen.result) {\n            this.knownResults.set(frozen.result, selectionSet);\n        }\n        return frozen;\n    };\n    StoreReader.prototype.execSubSelectedArrayImpl = function (_a) {\n        var _this = this;\n        var field = _a.field, array = _a.array, enclosingRef = _a.enclosingRef, context = _a.context;\n        var missing;\n        var missingMerger = new utilities.DeepMerger();\n        function handleMissing(childResult, i) {\n            var _a;\n            if (childResult.missing) {\n                missing = missingMerger.merge(missing, (_a = {}, _a[i] = childResult.missing, _a));\n            }\n            return childResult.result;\n        }\n        if (field.selectionSet) {\n            array = array.filter(context.store.canRead);\n        }\n        array = array.map(function (item, i) {\n            if (item === null) {\n                return null;\n            }\n            if (isArray(item)) {\n                return handleMissing(_this.executeSubSelectedArray({\n                    field: field,\n                    array: item,\n                    enclosingRef: enclosingRef,\n                    context: context,\n                }), i);\n            }\n            if (field.selectionSet) {\n                return handleMissing(_this.executeSelectionSet({\n                    selectionSet: field.selectionSet,\n                    objectOrReference: item,\n                    enclosingRef: utilities.isReference(item) ? item : enclosingRef,\n                    context: context,\n                }), i);\n            }\n            if (__DEV__) {\n                assertSelectionSetForIdValue(context.store, field, item);\n            }\n            return item;\n        });\n        return {\n            result: context.canonizeResults ? this.canon.admit(array) : array,\n            missing: missing,\n        };\n    };\n    return StoreReader;\n}());\nfunction firstMissing(tree) {\n    try {\n        JSON.stringify(tree, function (_, value) {\n            if (typeof value === \"string\")\n                throw value;\n            return value;\n        });\n    }\n    catch (result) {\n        return result;\n    }\n}\nfunction assertSelectionSetForIdValue(store, field, fieldValue) {\n    if (!field.selectionSet) {\n        var workSet_1 = new Set([fieldValue]);\n        workSet_1.forEach(function (value) {\n            if (utilities.isNonNullObject(value)) {\n                __DEV__ ? globals.invariant(!utilities.isReference(value), \"Missing selection set for object of type \".concat(getTypenameFromStoreObject(store, value), \" returned for query field \").concat(field.name.value)) : globals.invariant(!utilities.isReference(value), 6);\n                Object.values(value).forEach(workSet_1.add, workSet_1);\n            }\n        });\n    }\n}\n\nvar cacheSlot = new context.Slot();\nvar cacheInfoMap = new WeakMap();\nfunction getCacheInfo(cache) {\n    var info = cacheInfoMap.get(cache);\n    if (!info) {\n        cacheInfoMap.set(cache, info = {\n            vars: new Set,\n            dep: optimism.dep(),\n        });\n    }\n    return info;\n}\nfunction forgetCache(cache) {\n    getCacheInfo(cache).vars.forEach(function (rv) { return rv.forgetCache(cache); });\n}\nfunction recallCache(cache) {\n    getCacheInfo(cache).vars.forEach(function (rv) { return rv.attachCache(cache); });\n}\nfunction makeVar(value) {\n    var caches = new Set();\n    var listeners = new Set();\n    var rv = function (newValue) {\n        if (arguments.length > 0) {\n            if (value !== newValue) {\n                value = newValue;\n                caches.forEach(function (cache) {\n                    getCacheInfo(cache).dep.dirty(rv);\n                    broadcast(cache);\n                });\n                var oldListeners = Array.from(listeners);\n                listeners.clear();\n                oldListeners.forEach(function (listener) { return listener(value); });\n            }\n        }\n        else {\n            var cache = cacheSlot.getValue();\n            if (cache) {\n                attach(cache);\n                getCacheInfo(cache).dep(rv);\n            }\n        }\n        return value;\n    };\n    rv.onNextChange = function (listener) {\n        listeners.add(listener);\n        return function () {\n            listeners.delete(listener);\n        };\n    };\n    var attach = rv.attachCache = function (cache) {\n        caches.add(cache);\n        getCacheInfo(cache).vars.add(rv);\n        return rv;\n    };\n    rv.forgetCache = function (cache) { return caches.delete(cache); };\n    return rv;\n}\nfunction broadcast(cache) {\n    if (cache.broadcastWatches) {\n        cache.broadcastWatches();\n    }\n}\n\nvar specifierInfoCache = Object.create(null);\nfunction lookupSpecifierInfo(spec) {\n    var cacheKey = JSON.stringify(spec);\n    return specifierInfoCache[cacheKey] ||\n        (specifierInfoCache[cacheKey] = Object.create(null));\n}\nfunction keyFieldsFnFromSpecifier(specifier) {\n    var info = lookupSpecifierInfo(specifier);\n    return info.keyFieldsFn || (info.keyFieldsFn = function (object, context) {\n        var extract = function (from, key) { return context.readField(key, from); };\n        var keyObject = context.keyObject = collectSpecifierPaths(specifier, function (schemaKeyPath) {\n            var extracted = extractKeyPath(context.storeObject, schemaKeyPath, extract);\n            if (extracted === void 0 &&\n                object !== context.storeObject &&\n                hasOwn.call(object, schemaKeyPath[0])) {\n                extracted = extractKeyPath(object, schemaKeyPath, extractKey);\n            }\n            __DEV__ ? globals.invariant(extracted !== void 0, \"Missing field '\".concat(schemaKeyPath.join('.'), \"' while extracting keyFields from \").concat(JSON.stringify(object))) : globals.invariant(extracted !== void 0, 2);\n            return extracted;\n        });\n        return \"\".concat(context.typename, \":\").concat(JSON.stringify(keyObject));\n    });\n}\nfunction keyArgsFnFromSpecifier(specifier) {\n    var info = lookupSpecifierInfo(specifier);\n    return info.keyArgsFn || (info.keyArgsFn = function (args, _a) {\n        var field = _a.field, variables = _a.variables, fieldName = _a.fieldName;\n        var collected = collectSpecifierPaths(specifier, function (keyPath) {\n            var firstKey = keyPath[0];\n            var firstChar = firstKey.charAt(0);\n            if (firstChar === \"@\") {\n                if (field && utilities.isNonEmptyArray(field.directives)) {\n                    var directiveName_1 = firstKey.slice(1);\n                    var d = field.directives.find(function (d) { return d.name.value === directiveName_1; });\n                    var directiveArgs = d && utilities.argumentsObjectFromField(d, variables);\n                    return directiveArgs && extractKeyPath(directiveArgs, keyPath.slice(1));\n                }\n                return;\n            }\n            if (firstChar === \"$\") {\n                var variableName = firstKey.slice(1);\n                if (variables && hasOwn.call(variables, variableName)) {\n                    var varKeyPath = keyPath.slice(0);\n                    varKeyPath[0] = variableName;\n                    return extractKeyPath(variables, varKeyPath);\n                }\n                return;\n            }\n            if (args) {\n                return extractKeyPath(args, keyPath);\n            }\n        });\n        var suffix = JSON.stringify(collected);\n        if (args || suffix !== \"{}\") {\n            fieldName += \":\" + suffix;\n        }\n        return fieldName;\n    });\n}\nfunction collectSpecifierPaths(specifier, extractor) {\n    var merger = new utilities.DeepMerger;\n    return getSpecifierPaths(specifier).reduce(function (collected, path) {\n        var _a;\n        var toMerge = extractor(path);\n        if (toMerge !== void 0) {\n            for (var i = path.length - 1; i >= 0; --i) {\n                toMerge = (_a = {}, _a[path[i]] = toMerge, _a);\n            }\n            collected = merger.merge(collected, toMerge);\n        }\n        return collected;\n    }, Object.create(null));\n}\nfunction getSpecifierPaths(spec) {\n    var info = lookupSpecifierInfo(spec);\n    if (!info.paths) {\n        var paths_1 = info.paths = [];\n        var currentPath_1 = [];\n        spec.forEach(function (s, i) {\n            if (isArray(s)) {\n                getSpecifierPaths(s).forEach(function (p) { return paths_1.push(currentPath_1.concat(p)); });\n                currentPath_1.length = 0;\n            }\n            else {\n                currentPath_1.push(s);\n                if (!isArray(spec[i + 1])) {\n                    paths_1.push(currentPath_1.slice(0));\n                    currentPath_1.length = 0;\n                }\n            }\n        });\n    }\n    return info.paths;\n}\nfunction extractKey(object, key) {\n    return object[key];\n}\nfunction extractKeyPath(object, path, extract) {\n    extract = extract || extractKey;\n    return normalize(path.reduce(function reducer(obj, key) {\n        return isArray(obj)\n            ? obj.map(function (child) { return reducer(child, key); })\n            : obj && extract(obj, key);\n    }, object));\n}\nfunction normalize(value) {\n    if (utilities.isNonNullObject(value)) {\n        if (isArray(value)) {\n            return value.map(normalize);\n        }\n        return collectSpecifierPaths(Object.keys(value).sort(), function (path) { return extractKeyPath(value, path); });\n    }\n    return value;\n}\n\nutilities.getStoreKeyName.setStringify(canonicalStringify);\nfunction argsFromFieldSpecifier(spec) {\n    return spec.args !== void 0 ? spec.args :\n        spec.field ? utilities.argumentsObjectFromField(spec.field, spec.variables) : null;\n}\nvar nullKeyFieldsFn = function () { return void 0; };\nvar simpleKeyArgsFn = function (_args, context) { return context.fieldName; };\nvar mergeTrueFn = function (existing, incoming, _a) {\n    var mergeObjects = _a.mergeObjects;\n    return mergeObjects(existing, incoming);\n};\nvar mergeFalseFn = function (_, incoming) { return incoming; };\nvar Policies = (function () {\n    function Policies(config) {\n        this.config = config;\n        this.typePolicies = Object.create(null);\n        this.toBeAdded = Object.create(null);\n        this.supertypeMap = new Map();\n        this.fuzzySubtypes = new Map();\n        this.rootIdsByTypename = Object.create(null);\n        this.rootTypenamesById = Object.create(null);\n        this.usingPossibleTypes = false;\n        this.config = tslib.__assign({ dataIdFromObject: defaultDataIdFromObject }, config);\n        this.cache = this.config.cache;\n        this.setRootTypename(\"Query\");\n        this.setRootTypename(\"Mutation\");\n        this.setRootTypename(\"Subscription\");\n        if (config.possibleTypes) {\n            this.addPossibleTypes(config.possibleTypes);\n        }\n        if (config.typePolicies) {\n            this.addTypePolicies(config.typePolicies);\n        }\n    }\n    Policies.prototype.identify = function (object, partialContext) {\n        var _a;\n        var policies = this;\n        var typename = partialContext && (partialContext.typename ||\n            ((_a = partialContext.storeObject) === null || _a === void 0 ? void 0 : _a.__typename)) || object.__typename;\n        if (typename === this.rootTypenamesById.ROOT_QUERY) {\n            return [\"ROOT_QUERY\"];\n        }\n        var storeObject = partialContext && partialContext.storeObject || object;\n        var context = tslib.__assign(tslib.__assign({}, partialContext), { typename: typename, storeObject: storeObject, readField: partialContext && partialContext.readField || function () {\n                var options = normalizeReadFieldOptions(arguments, storeObject);\n                return policies.readField(options, {\n                    store: policies.cache[\"data\"],\n                    variables: options.variables,\n                });\n            } });\n        var id;\n        var policy = typename && this.getTypePolicy(typename);\n        var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;\n        while (keyFn) {\n            var specifierOrId = keyFn(object, context);\n            if (isArray(specifierOrId)) {\n                keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n            }\n            else {\n                id = specifierOrId;\n                break;\n            }\n        }\n        id = id ? String(id) : void 0;\n        return context.keyObject ? [id, context.keyObject] : [id];\n    };\n    Policies.prototype.addTypePolicies = function (typePolicies) {\n        var _this = this;\n        Object.keys(typePolicies).forEach(function (typename) {\n            var _a = typePolicies[typename], queryType = _a.queryType, mutationType = _a.mutationType, subscriptionType = _a.subscriptionType, incoming = tslib.__rest(_a, [\"queryType\", \"mutationType\", \"subscriptionType\"]);\n            if (queryType)\n                _this.setRootTypename(\"Query\", typename);\n            if (mutationType)\n                _this.setRootTypename(\"Mutation\", typename);\n            if (subscriptionType)\n                _this.setRootTypename(\"Subscription\", typename);\n            if (hasOwn.call(_this.toBeAdded, typename)) {\n                _this.toBeAdded[typename].push(incoming);\n            }\n            else {\n                _this.toBeAdded[typename] = [incoming];\n            }\n        });\n    };\n    Policies.prototype.updateTypePolicy = function (typename, incoming) {\n        var _this = this;\n        var existing = this.getTypePolicy(typename);\n        var keyFields = incoming.keyFields, fields = incoming.fields;\n        function setMerge(existing, merge) {\n            existing.merge =\n                typeof merge === \"function\" ? merge :\n                    merge === true ? mergeTrueFn :\n                        merge === false ? mergeFalseFn :\n                            existing.merge;\n        }\n        setMerge(existing, incoming.merge);\n        existing.keyFn =\n            keyFields === false ? nullKeyFieldsFn :\n                isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) :\n                    typeof keyFields === \"function\" ? keyFields :\n                        existing.keyFn;\n        if (fields) {\n            Object.keys(fields).forEach(function (fieldName) {\n                var existing = _this.getFieldPolicy(typename, fieldName, true);\n                var incoming = fields[fieldName];\n                if (typeof incoming === \"function\") {\n                    existing.read = incoming;\n                }\n                else {\n                    var keyArgs = incoming.keyArgs, read = incoming.read, merge = incoming.merge;\n                    existing.keyFn =\n                        keyArgs === false ? simpleKeyArgsFn :\n                            isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) :\n                                typeof keyArgs === \"function\" ? keyArgs :\n                                    existing.keyFn;\n                    if (typeof read === \"function\") {\n                        existing.read = read;\n                    }\n                    setMerge(existing, merge);\n                }\n                if (existing.read && existing.merge) {\n                    existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n                }\n            });\n        }\n    };\n    Policies.prototype.setRootTypename = function (which, typename) {\n        if (typename === void 0) { typename = which; }\n        var rootId = \"ROOT_\" + which.toUpperCase();\n        var old = this.rootTypenamesById[rootId];\n        if (typename !== old) {\n            __DEV__ ? globals.invariant(!old || old === which, \"Cannot change root \".concat(which, \" __typename more than once\")) : globals.invariant(!old || old === which, 3);\n            if (old)\n                delete this.rootIdsByTypename[old];\n            this.rootIdsByTypename[typename] = rootId;\n            this.rootTypenamesById[rootId] = typename;\n        }\n    };\n    Policies.prototype.addPossibleTypes = function (possibleTypes) {\n        var _this = this;\n        this.usingPossibleTypes = true;\n        Object.keys(possibleTypes).forEach(function (supertype) {\n            _this.getSupertypeSet(supertype, true);\n            possibleTypes[supertype].forEach(function (subtype) {\n                _this.getSupertypeSet(subtype, true).add(supertype);\n                var match = subtype.match(TypeOrFieldNameRegExp);\n                if (!match || match[0] !== subtype) {\n                    _this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n                }\n            });\n        });\n    };\n    Policies.prototype.getTypePolicy = function (typename) {\n        var _this = this;\n        if (!hasOwn.call(this.typePolicies, typename)) {\n            var policy_1 = this.typePolicies[typename] = Object.create(null);\n            policy_1.fields = Object.create(null);\n            var supertypes = this.supertypeMap.get(typename);\n            if (supertypes && supertypes.size) {\n                supertypes.forEach(function (supertype) {\n                    var _a = _this.getTypePolicy(supertype), fields = _a.fields, rest = tslib.__rest(_a, [\"fields\"]);\n                    Object.assign(policy_1, rest);\n                    Object.assign(policy_1.fields, fields);\n                });\n            }\n        }\n        var inbox = this.toBeAdded[typename];\n        if (inbox && inbox.length) {\n            inbox.splice(0).forEach(function (policy) {\n                _this.updateTypePolicy(typename, policy);\n            });\n        }\n        return this.typePolicies[typename];\n    };\n    Policies.prototype.getFieldPolicy = function (typename, fieldName, createIfMissing) {\n        if (typename) {\n            var fieldPolicies = this.getTypePolicy(typename).fields;\n            return fieldPolicies[fieldName] || (createIfMissing && (fieldPolicies[fieldName] = Object.create(null)));\n        }\n    };\n    Policies.prototype.getSupertypeSet = function (subtype, createIfMissing) {\n        var supertypeSet = this.supertypeMap.get(subtype);\n        if (!supertypeSet && createIfMissing) {\n            this.supertypeMap.set(subtype, supertypeSet = new Set());\n        }\n        return supertypeSet;\n    };\n    Policies.prototype.fragmentMatches = function (fragment, typename, result, variables) {\n        var _this = this;\n        if (!fragment.typeCondition)\n            return true;\n        if (!typename)\n            return false;\n        var supertype = fragment.typeCondition.name.value;\n        if (typename === supertype)\n            return true;\n        if (this.usingPossibleTypes &&\n            this.supertypeMap.has(supertype)) {\n            var typenameSupertypeSet = this.getSupertypeSet(typename, true);\n            var workQueue_1 = [typenameSupertypeSet];\n            var maybeEnqueue_1 = function (subtype) {\n                var supertypeSet = _this.getSupertypeSet(subtype, false);\n                if (supertypeSet &&\n                    supertypeSet.size &&\n                    workQueue_1.indexOf(supertypeSet) < 0) {\n                    workQueue_1.push(supertypeSet);\n                }\n            };\n            var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n            var checkingFuzzySubtypes = false;\n            for (var i = 0; i < workQueue_1.length; ++i) {\n                var supertypeSet = workQueue_1[i];\n                if (supertypeSet.has(supertype)) {\n                    if (!typenameSupertypeSet.has(supertype)) {\n                        if (checkingFuzzySubtypes) {\n                            __DEV__ && globals.invariant.warn(\"Inferring subtype \".concat(typename, \" of supertype \").concat(supertype));\n                        }\n                        typenameSupertypeSet.add(supertype);\n                    }\n                    return true;\n                }\n                supertypeSet.forEach(maybeEnqueue_1);\n                if (needToCheckFuzzySubtypes &&\n                    i === workQueue_1.length - 1 &&\n                    selectionSetMatchesResult(fragment.selectionSet, result, variables)) {\n                    needToCheckFuzzySubtypes = false;\n                    checkingFuzzySubtypes = true;\n                    this.fuzzySubtypes.forEach(function (regExp, fuzzyString) {\n                        var match = typename.match(regExp);\n                        if (match && match[0] === typename) {\n                            maybeEnqueue_1(fuzzyString);\n                        }\n                    });\n                }\n            }\n        }\n        return false;\n    };\n    Policies.prototype.hasKeyArgs = function (typename, fieldName) {\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        return !!(policy && policy.keyFn);\n    };\n    Policies.prototype.getStoreFieldName = function (fieldSpec) {\n        var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        var storeFieldName;\n        var keyFn = policy && policy.keyFn;\n        if (keyFn && typename) {\n            var context = {\n                typename: typename,\n                fieldName: fieldName,\n                field: fieldSpec.field || null,\n                variables: fieldSpec.variables,\n            };\n            var args = argsFromFieldSpecifier(fieldSpec);\n            while (keyFn) {\n                var specifierOrString = keyFn(args, context);\n                if (isArray(specifierOrString)) {\n                    keyFn = keyArgsFnFromSpecifier(specifierOrString);\n                }\n                else {\n                    storeFieldName = specifierOrString || fieldName;\n                    break;\n                }\n            }\n        }\n        if (storeFieldName === void 0) {\n            storeFieldName = fieldSpec.field\n                ? utilities.storeKeyNameFromField(fieldSpec.field, fieldSpec.variables)\n                : utilities.getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n        }\n        if (storeFieldName === false) {\n            return fieldName;\n        }\n        return fieldName === fieldNameFromStoreName(storeFieldName)\n            ? storeFieldName\n            : fieldName + \":\" + storeFieldName;\n    };\n    Policies.prototype.readField = function (options, context) {\n        var objectOrReference = options.from;\n        if (!objectOrReference)\n            return;\n        var nameOrField = options.field || options.fieldName;\n        if (!nameOrField)\n            return;\n        if (options.typename === void 0) {\n            var typename = context.store.getFieldValue(objectOrReference, \"__typename\");\n            if (typename)\n                options.typename = typename;\n        }\n        var storeFieldName = this.getStoreFieldName(options);\n        var fieldName = fieldNameFromStoreName(storeFieldName);\n        var existing = context.store.getFieldValue(objectOrReference, storeFieldName);\n        var policy = this.getFieldPolicy(options.typename, fieldName, false);\n        var read = policy && policy.read;\n        if (read) {\n            var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(utilities.isReference(objectOrReference)\n                ? objectOrReference.__ref\n                : objectOrReference, storeFieldName));\n            return cacheSlot.withValue(this.cache, read, [existing, readOptions]);\n        }\n        return existing;\n    };\n    Policies.prototype.getReadFunction = function (typename, fieldName) {\n        var policy = this.getFieldPolicy(typename, fieldName, false);\n        return policy && policy.read;\n    };\n    Policies.prototype.getMergeFunction = function (parentTypename, fieldName, childTypename) {\n        var policy = this.getFieldPolicy(parentTypename, fieldName, false);\n        var merge = policy && policy.merge;\n        if (!merge && childTypename) {\n            policy = this.getTypePolicy(childTypename);\n            merge = policy && policy.merge;\n        }\n        return merge;\n    };\n    Policies.prototype.runMergeFunction = function (existing, incoming, _a, context, storage) {\n        var field = _a.field, typename = _a.typename, merge = _a.merge;\n        if (merge === mergeTrueFn) {\n            return makeMergeObjectsFunction(context.store)(existing, incoming);\n        }\n        if (merge === mergeFalseFn) {\n            return incoming;\n        }\n        if (context.overwrite) {\n            existing = void 0;\n        }\n        return merge(existing, incoming, makeFieldFunctionOptions(this, void 0, { typename: typename, fieldName: field.name.value, field: field, variables: context.variables }, context, storage || Object.create(null)));\n    };\n    return Policies;\n}());\nfunction makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {\n    var storeFieldName = policies.getStoreFieldName(fieldSpec);\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var variables = fieldSpec.variables || context.variables;\n    var _a = context.store, toReference = _a.toReference, canRead = _a.canRead;\n    return {\n        args: argsFromFieldSpecifier(fieldSpec),\n        field: fieldSpec.field || null,\n        fieldName: fieldName,\n        storeFieldName: storeFieldName,\n        variables: variables,\n        isReference: utilities.isReference,\n        toReference: toReference,\n        storage: storage,\n        cache: policies.cache,\n        canRead: canRead,\n        readField: function () {\n            return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, variables), context);\n        },\n        mergeObjects: makeMergeObjectsFunction(context.store),\n    };\n}\nfunction normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {\n    var fieldNameOrOptions = readFieldArgs[0], from = readFieldArgs[1], argc = readFieldArgs.length;\n    var options;\n    if (typeof fieldNameOrOptions === \"string\") {\n        options = {\n            fieldName: fieldNameOrOptions,\n            from: argc > 1 ? from : objectOrReference,\n        };\n    }\n    else {\n        options = tslib.__assign({}, fieldNameOrOptions);\n        if (!hasOwn.call(options, \"from\")) {\n            options.from = objectOrReference;\n        }\n    }\n    if (__DEV__ && options.from === void 0) {\n        __DEV__ && globals.invariant.warn(\"Undefined 'from' passed to readField with arguments \".concat(utilities.stringifyForDisplay(Array.from(readFieldArgs))));\n    }\n    if (void 0 === options.variables) {\n        options.variables = variables;\n    }\n    return options;\n}\nfunction makeMergeObjectsFunction(store) {\n    return function mergeObjects(existing, incoming) {\n        if (isArray(existing) || isArray(incoming)) {\n            throw __DEV__ ? new globals.InvariantError(\"Cannot automatically merge arrays\") : new globals.InvariantError(4);\n        }\n        if (utilities.isNonNullObject(existing) &&\n            utilities.isNonNullObject(incoming)) {\n            var eType = store.getFieldValue(existing, \"__typename\");\n            var iType = store.getFieldValue(incoming, \"__typename\");\n            var typesDiffer = eType && iType && eType !== iType;\n            if (typesDiffer) {\n                return incoming;\n            }\n            if (utilities.isReference(existing) &&\n                storeValueIsStoreObject(incoming)) {\n                store.merge(existing.__ref, incoming);\n                return existing;\n            }\n            if (storeValueIsStoreObject(existing) &&\n                utilities.isReference(incoming)) {\n                store.merge(existing, incoming.__ref);\n                return incoming;\n            }\n            if (storeValueIsStoreObject(existing) &&\n                storeValueIsStoreObject(incoming)) {\n                return tslib.__assign(tslib.__assign({}, existing), incoming);\n            }\n        }\n        return incoming;\n    };\n}\n\nfunction getContextFlavor(context, clientOnly, deferred) {\n    var key = \"\".concat(clientOnly).concat(deferred);\n    var flavored = context.flavors.get(key);\n    if (!flavored) {\n        context.flavors.set(key, flavored = (context.clientOnly === clientOnly &&\n            context.deferred === deferred) ? context : tslib.__assign(tslib.__assign({}, context), { clientOnly: clientOnly, deferred: deferred }));\n    }\n    return flavored;\n}\nvar StoreWriter = (function () {\n    function StoreWriter(cache, reader, fragments) {\n        this.cache = cache;\n        this.reader = reader;\n        this.fragments = fragments;\n    }\n    StoreWriter.prototype.writeToStore = function (store, _a) {\n        var _this = this;\n        var query = _a.query, result = _a.result, dataId = _a.dataId, variables = _a.variables, overwrite = _a.overwrite;\n        var operationDefinition = utilities.getOperationDefinition(query);\n        var merger = makeProcessedFieldsMerger();\n        variables = tslib.__assign(tslib.__assign({}, utilities.getDefaultValues(operationDefinition)), variables);\n        var context = tslib.__assign(tslib.__assign({ store: store, written: Object.create(null), merge: function (existing, incoming) {\n                return merger.merge(existing, incoming);\n            }, variables: variables, varString: canonicalStringify(variables) }, extractFragmentContext(query, this.fragments)), { overwrite: !!overwrite, incomingById: new Map, clientOnly: false, deferred: false, flavors: new Map });\n        var ref = this.processSelectionSet({\n            result: result || Object.create(null),\n            dataId: dataId,\n            selectionSet: operationDefinition.selectionSet,\n            mergeTree: { map: new Map },\n            context: context,\n        });\n        if (!utilities.isReference(ref)) {\n            throw __DEV__ ? new globals.InvariantError(\"Could not identify object \".concat(JSON.stringify(result))) : new globals.InvariantError(7);\n        }\n        context.incomingById.forEach(function (_a, dataId) {\n            var storeObject = _a.storeObject, mergeTree = _a.mergeTree, fieldNodeSet = _a.fieldNodeSet;\n            var entityRef = utilities.makeReference(dataId);\n            if (mergeTree && mergeTree.map.size) {\n                var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);\n                if (utilities.isReference(applied)) {\n                    return;\n                }\n                storeObject = applied;\n            }\n            if (__DEV__ && !context.overwrite) {\n                var fieldsWithSelectionSets_1 = Object.create(null);\n                fieldNodeSet.forEach(function (field) {\n                    if (field.selectionSet) {\n                        fieldsWithSelectionSets_1[field.name.value] = true;\n                    }\n                });\n                var hasSelectionSet_1 = function (storeFieldName) {\n                    return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] === true;\n                };\n                var hasMergeFunction_1 = function (storeFieldName) {\n                    var childTree = mergeTree && mergeTree.map.get(storeFieldName);\n                    return Boolean(childTree && childTree.info && childTree.info.merge);\n                };\n                Object.keys(storeObject).forEach(function (storeFieldName) {\n                    if (hasSelectionSet_1(storeFieldName) &&\n                        !hasMergeFunction_1(storeFieldName)) {\n                        warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);\n                    }\n                });\n            }\n            store.merge(dataId, storeObject);\n        });\n        store.retain(ref.__ref);\n        return ref;\n    };\n    StoreWriter.prototype.processSelectionSet = function (_a) {\n        var _this = this;\n        var dataId = _a.dataId, result = _a.result, selectionSet = _a.selectionSet, context = _a.context, mergeTree = _a.mergeTree;\n        var policies = this.cache.policies;\n        var incoming = Object.create(null);\n        var typename = (dataId && policies.rootTypenamesById[dataId]) ||\n            utilities.getTypenameFromResult(result, selectionSet, context.fragmentMap) ||\n            (dataId && context.store.get(dataId, \"__typename\"));\n        if (\"string\" === typeof typename) {\n            incoming.__typename = typename;\n        }\n        var readField = function () {\n            var options = normalizeReadFieldOptions(arguments, incoming, context.variables);\n            if (utilities.isReference(options.from)) {\n                var info = context.incomingById.get(options.from.__ref);\n                if (info) {\n                    var result_1 = policies.readField(tslib.__assign(tslib.__assign({}, options), { from: info.storeObject }), context);\n                    if (result_1 !== void 0) {\n                        return result_1;\n                    }\n                }\n            }\n            return policies.readField(options, context);\n        };\n        var fieldNodeSet = new Set();\n        this.flattenFields(selectionSet, result, context, typename).forEach(function (context, field) {\n            var _a;\n            var resultFieldKey = utilities.resultKeyNameFromField(field);\n            var value = result[resultFieldKey];\n            fieldNodeSet.add(field);\n            if (value !== void 0) {\n                var storeFieldName = policies.getStoreFieldName({\n                    typename: typename,\n                    fieldName: field.name.value,\n                    field: field,\n                    variables: context.variables,\n                });\n                var childTree = getChildMergeTree(mergeTree, storeFieldName);\n                var incomingValue = _this.processFieldValue(value, field, field.selectionSet\n                    ? getContextFlavor(context, false, false)\n                    : context, childTree);\n                var childTypename = void 0;\n                if (field.selectionSet &&\n                    (utilities.isReference(incomingValue) ||\n                        storeValueIsStoreObject(incomingValue))) {\n                    childTypename = readField(\"__typename\", incomingValue);\n                }\n                var merge = policies.getMergeFunction(typename, field.name.value, childTypename);\n                if (merge) {\n                    childTree.info = {\n                        field: field,\n                        typename: typename,\n                        merge: merge,\n                    };\n                }\n                else {\n                    maybeRecycleChildMergeTree(mergeTree, storeFieldName);\n                }\n                incoming = context.merge(incoming, (_a = {},\n                    _a[storeFieldName] = incomingValue,\n                    _a));\n            }\n            else if (__DEV__ &&\n                !context.clientOnly &&\n                !context.deferred &&\n                !utilities.addTypenameToDocument.added(field) &&\n                !policies.getReadFunction(typename, field.name.value)) {\n                __DEV__ && globals.invariant.error(\"Missing field '\".concat(utilities.resultKeyNameFromField(field), \"' while writing result \").concat(JSON.stringify(result, null, 2)).substring(0, 1000));\n            }\n        });\n        try {\n            var _b = policies.identify(result, {\n                typename: typename,\n                selectionSet: selectionSet,\n                fragmentMap: context.fragmentMap,\n                storeObject: incoming,\n                readField: readField,\n            }), id = _b[0], keyObject = _b[1];\n            dataId = dataId || id;\n            if (keyObject) {\n                incoming = context.merge(incoming, keyObject);\n            }\n        }\n        catch (e) {\n            if (!dataId)\n                throw e;\n        }\n        if (\"string\" === typeof dataId) {\n            var dataRef = utilities.makeReference(dataId);\n            var sets = context.written[dataId] || (context.written[dataId] = []);\n            if (sets.indexOf(selectionSet) >= 0)\n                return dataRef;\n            sets.push(selectionSet);\n            if (this.reader && this.reader.isFresh(result, dataRef, selectionSet, context)) {\n                return dataRef;\n            }\n            var previous_1 = context.incomingById.get(dataId);\n            if (previous_1) {\n                previous_1.storeObject = context.merge(previous_1.storeObject, incoming);\n                previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);\n                fieldNodeSet.forEach(function (field) { return previous_1.fieldNodeSet.add(field); });\n            }\n            else {\n                context.incomingById.set(dataId, {\n                    storeObject: incoming,\n                    mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,\n                    fieldNodeSet: fieldNodeSet,\n                });\n            }\n            return dataRef;\n        }\n        return incoming;\n    };\n    StoreWriter.prototype.processFieldValue = function (value, field, context, mergeTree) {\n        var _this = this;\n        if (!field.selectionSet || value === null) {\n            return __DEV__ ? utilities.cloneDeep(value) : value;\n        }\n        if (isArray(value)) {\n            return value.map(function (item, i) {\n                var value = _this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i));\n                maybeRecycleChildMergeTree(mergeTree, i);\n                return value;\n            });\n        }\n        return this.processSelectionSet({\n            result: value,\n            selectionSet: field.selectionSet,\n            context: context,\n            mergeTree: mergeTree,\n        });\n    };\n    StoreWriter.prototype.flattenFields = function (selectionSet, result, context, typename) {\n        if (typename === void 0) { typename = utilities.getTypenameFromResult(result, selectionSet, context.fragmentMap); }\n        var fieldMap = new Map();\n        var policies = this.cache.policies;\n        var limitingTrie = new trie.Trie(false);\n        (function flatten(selectionSet, inheritedContext) {\n            var visitedNode = limitingTrie.lookup(selectionSet, inheritedContext.clientOnly, inheritedContext.deferred);\n            if (visitedNode.visited)\n                return;\n            visitedNode.visited = true;\n            selectionSet.selections.forEach(function (selection) {\n                if (!utilities.shouldInclude(selection, context.variables))\n                    return;\n                var clientOnly = inheritedContext.clientOnly, deferred = inheritedContext.deferred;\n                if (!(clientOnly && deferred) &&\n                    utilities.isNonEmptyArray(selection.directives)) {\n                    selection.directives.forEach(function (dir) {\n                        var name = dir.name.value;\n                        if (name === \"client\")\n                            clientOnly = true;\n                        if (name === \"defer\") {\n                            var args = utilities.argumentsObjectFromField(dir, context.variables);\n                            if (!args || args.if !== false) {\n                                deferred = true;\n                            }\n                        }\n                    });\n                }\n                if (utilities.isField(selection)) {\n                    var existing = fieldMap.get(selection);\n                    if (existing) {\n                        clientOnly = clientOnly && existing.clientOnly;\n                        deferred = deferred && existing.deferred;\n                    }\n                    fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));\n                }\n                else {\n                    var fragment = utilities.getFragmentFromSelection(selection, context.lookupFragment);\n                    if (!fragment && selection.kind === graphql.Kind.FRAGMENT_SPREAD) {\n                        throw __DEV__ ? new globals.InvariantError(\"No fragment named \".concat(selection.name.value)) : new globals.InvariantError(8);\n                    }\n                    if (fragment &&\n                        policies.fragmentMatches(fragment, typename, result, context.variables)) {\n                        flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));\n                    }\n                }\n            });\n        })(selectionSet, context);\n        return fieldMap;\n    };\n    StoreWriter.prototype.applyMerges = function (mergeTree, existing, incoming, context, getStorageArgs) {\n        var _a;\n        var _this = this;\n        if (mergeTree.map.size && !utilities.isReference(incoming)) {\n            var e_1 = (!isArray(incoming) &&\n                (utilities.isReference(existing) || storeValueIsStoreObject(existing))) ? existing : void 0;\n            var i_1 = incoming;\n            if (e_1 && !getStorageArgs) {\n                getStorageArgs = [utilities.isReference(e_1) ? e_1.__ref : e_1];\n            }\n            var changedFields_1;\n            var getValue_1 = function (from, name) {\n                return isArray(from)\n                    ? (typeof name === \"number\" ? from[name] : void 0)\n                    : context.store.getFieldValue(from, String(name));\n            };\n            mergeTree.map.forEach(function (childTree, storeFieldName) {\n                var eVal = getValue_1(e_1, storeFieldName);\n                var iVal = getValue_1(i_1, storeFieldName);\n                if (void 0 === iVal)\n                    return;\n                if (getStorageArgs) {\n                    getStorageArgs.push(storeFieldName);\n                }\n                var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);\n                if (aVal !== iVal) {\n                    changedFields_1 = changedFields_1 || new Map;\n                    changedFields_1.set(storeFieldName, aVal);\n                }\n                if (getStorageArgs) {\n                    globals.invariant(getStorageArgs.pop() === storeFieldName);\n                }\n            });\n            if (changedFields_1) {\n                incoming = (isArray(i_1) ? i_1.slice(0) : tslib.__assign({}, i_1));\n                changedFields_1.forEach(function (value, name) {\n                    incoming[name] = value;\n                });\n            }\n        }\n        if (mergeTree.info) {\n            return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a = context.store).getStorage.apply(_a, getStorageArgs));\n        }\n        return incoming;\n    };\n    return StoreWriter;\n}());\nvar emptyMergeTreePool = [];\nfunction getChildMergeTree(_a, name) {\n    var map = _a.map;\n    if (!map.has(name)) {\n        map.set(name, emptyMergeTreePool.pop() || { map: new Map });\n    }\n    return map.get(name);\n}\nfunction mergeMergeTrees(left, right) {\n    if (left === right || !right || mergeTreeIsEmpty(right))\n        return left;\n    if (!left || mergeTreeIsEmpty(left))\n        return right;\n    var info = left.info && right.info ? tslib.__assign(tslib.__assign({}, left.info), right.info) : left.info || right.info;\n    var needToMergeMaps = left.map.size && right.map.size;\n    var map = needToMergeMaps ? new Map :\n        left.map.size ? left.map : right.map;\n    var merged = { info: info, map: map };\n    if (needToMergeMaps) {\n        var remainingRightKeys_1 = new Set(right.map.keys());\n        left.map.forEach(function (leftTree, key) {\n            merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));\n            remainingRightKeys_1.delete(key);\n        });\n        remainingRightKeys_1.forEach(function (key) {\n            merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));\n        });\n    }\n    return merged;\n}\nfunction mergeTreeIsEmpty(tree) {\n    return !tree || !(tree.info || tree.map.size);\n}\nfunction maybeRecycleChildMergeTree(_a, name) {\n    var map = _a.map;\n    var childTree = map.get(name);\n    if (childTree && mergeTreeIsEmpty(childTree)) {\n        emptyMergeTreePool.push(childTree);\n        map.delete(name);\n    }\n}\nvar warnings = new Set();\nfunction warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {\n    var getChild = function (objOrRef) {\n        var child = store.getFieldValue(objOrRef, storeFieldName);\n        return typeof child === \"object\" && child;\n    };\n    var existing = getChild(existingRef);\n    if (!existing)\n        return;\n    var incoming = getChild(incomingObj);\n    if (!incoming)\n        return;\n    if (utilities.isReference(existing))\n        return;\n    if (equality.equal(existing, incoming))\n        return;\n    if (Object.keys(existing).every(function (key) { return store.getFieldValue(incoming, key) !== void 0; })) {\n        return;\n    }\n    var parentType = store.getFieldValue(existingRef, \"__typename\") ||\n        store.getFieldValue(incomingObj, \"__typename\");\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var typeDotName = \"\".concat(parentType, \".\").concat(fieldName);\n    if (warnings.has(typeDotName))\n        return;\n    warnings.add(typeDotName);\n    var childTypenames = [];\n    if (!isArray(existing) &&\n        !isArray(incoming)) {\n        [existing, incoming].forEach(function (child) {\n            var typename = store.getFieldValue(child, \"__typename\");\n            if (typeof typename === \"string\" &&\n                !childTypenames.includes(typename)) {\n                childTypenames.push(typename);\n            }\n        });\n    }\n    __DEV__ && globals.invariant.warn(\"Cache data may be lost when replacing the \".concat(fieldName, \" field of a \").concat(parentType, \" object.\\n\\nTo address this problem (which is not a bug in Apollo Client), \").concat(childTypenames.length\n        ? \"either ensure all objects of type \" +\n            childTypenames.join(\" and \") + \" have an ID or a custom merge function, or \"\n        : \"\", \"define a custom merge function for the \").concat(typeDotName, \" field, so InMemoryCache can safely merge these objects:\\n\\n  existing: \").concat(JSON.stringify(existing).slice(0, 1000), \"\\n  incoming: \").concat(JSON.stringify(incoming).slice(0, 1000), \"\\n\\nFor more information about these options, please refer to the documentation:\\n\\n  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers\\n  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects\\n\"));\n}\n\nvar InMemoryCache = (function (_super) {\n    tslib.__extends(InMemoryCache, _super);\n    function InMemoryCache(config) {\n        if (config === void 0) { config = {}; }\n        var _this = _super.call(this) || this;\n        _this.watches = new Set();\n        _this.typenameDocumentCache = new Map();\n        _this.makeVar = makeVar;\n        _this.txCount = 0;\n        _this.config = normalizeConfig(config);\n        _this.addTypename = !!_this.config.addTypename;\n        _this.policies = new Policies({\n            cache: _this,\n            dataIdFromObject: _this.config.dataIdFromObject,\n            possibleTypes: _this.config.possibleTypes,\n            typePolicies: _this.config.typePolicies,\n        });\n        _this.init();\n        return _this;\n    }\n    InMemoryCache.prototype.init = function () {\n        var rootStore = this.data = new exports.EntityStore.Root({\n            policies: this.policies,\n            resultCaching: this.config.resultCaching,\n        });\n        this.optimisticData = rootStore.stump;\n        this.resetResultCache();\n    };\n    InMemoryCache.prototype.resetResultCache = function (resetResultIdentities) {\n        var _this = this;\n        var previousReader = this.storeReader;\n        var fragments = this.config.fragments;\n        this.storeWriter = new StoreWriter(this, this.storeReader = new StoreReader({\n            cache: this,\n            addTypename: this.addTypename,\n            resultCacheMaxSize: this.config.resultCacheMaxSize,\n            canonizeResults: shouldCanonizeResults(this.config),\n            canon: resetResultIdentities\n                ? void 0\n                : previousReader && previousReader.canon,\n            fragments: fragments,\n        }), fragments);\n        this.maybeBroadcastWatch = optimism.wrap(function (c, options) {\n            return _this.broadcastWatch(c, options);\n        }, {\n            max: this.config.resultCacheMaxSize,\n            makeCacheKey: function (c) {\n                var store = c.optimistic ? _this.optimisticData : _this.data;\n                if (supportsResultCaching(store)) {\n                    var optimistic = c.optimistic, id = c.id, variables = c.variables;\n                    return store.makeCacheKey(c.query, c.callback, canonicalStringify({ optimistic: optimistic, id: id, variables: variables }));\n                }\n            }\n        });\n        new Set([\n            this.data.group,\n            this.optimisticData.group,\n        ]).forEach(function (group) { return group.resetCaching(); });\n    };\n    InMemoryCache.prototype.restore = function (data) {\n        this.init();\n        if (data)\n            this.data.replace(data);\n        return this;\n    };\n    InMemoryCache.prototype.extract = function (optimistic) {\n        if (optimistic === void 0) { optimistic = false; }\n        return (optimistic ? this.optimisticData : this.data).extract();\n    };\n    InMemoryCache.prototype.read = function (options) {\n        var _a = options.returnPartialData, returnPartialData = _a === void 0 ? false : _a;\n        try {\n            return this.storeReader.diffQueryAgainstStore(tslib.__assign(tslib.__assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, config: this.config, returnPartialData: returnPartialData })).result || null;\n        }\n        catch (e) {\n            if (e instanceof MissingFieldError) {\n                return null;\n            }\n            throw e;\n        }\n    };\n    InMemoryCache.prototype.write = function (options) {\n        try {\n            ++this.txCount;\n            return this.storeWriter.writeToStore(this.data, options);\n        }\n        finally {\n            if (!--this.txCount && options.broadcast !== false) {\n                this.broadcastWatches();\n            }\n        }\n    };\n    InMemoryCache.prototype.modify = function (options) {\n        if (hasOwn.call(options, \"id\") && !options.id) {\n            return false;\n        }\n        var store = options.optimistic\n            ? this.optimisticData\n            : this.data;\n        try {\n            ++this.txCount;\n            return store.modify(options.id || \"ROOT_QUERY\", options.fields);\n        }\n        finally {\n            if (!--this.txCount && options.broadcast !== false) {\n                this.broadcastWatches();\n            }\n        }\n    };\n    InMemoryCache.prototype.diff = function (options) {\n        return this.storeReader.diffQueryAgainstStore(tslib.__assign(tslib.__assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, rootId: options.id || \"ROOT_QUERY\", config: this.config }));\n    };\n    InMemoryCache.prototype.watch = function (watch) {\n        var _this = this;\n        if (!this.watches.size) {\n            recallCache(this);\n        }\n        this.watches.add(watch);\n        if (watch.immediate) {\n            this.maybeBroadcastWatch(watch);\n        }\n        return function () {\n            if (_this.watches.delete(watch) && !_this.watches.size) {\n                forgetCache(_this);\n            }\n            _this.maybeBroadcastWatch.forget(watch);\n        };\n    };\n    InMemoryCache.prototype.gc = function (options) {\n        canonicalStringify.reset();\n        var ids = this.optimisticData.gc();\n        if (options && !this.txCount) {\n            if (options.resetResultCache) {\n                this.resetResultCache(options.resetResultIdentities);\n            }\n            else if (options.resetResultIdentities) {\n                this.storeReader.resetCanon();\n            }\n        }\n        return ids;\n    };\n    InMemoryCache.prototype.retain = function (rootId, optimistic) {\n        return (optimistic ? this.optimisticData : this.data).retain(rootId);\n    };\n    InMemoryCache.prototype.release = function (rootId, optimistic) {\n        return (optimistic ? this.optimisticData : this.data).release(rootId);\n    };\n    InMemoryCache.prototype.identify = function (object) {\n        if (utilities.isReference(object))\n            return object.__ref;\n        try {\n            return this.policies.identify(object)[0];\n        }\n        catch (e) {\n            __DEV__ && globals.invariant.warn(e);\n        }\n    };\n    InMemoryCache.prototype.evict = function (options) {\n        if (!options.id) {\n            if (hasOwn.call(options, \"id\")) {\n                return false;\n            }\n            options = tslib.__assign(tslib.__assign({}, options), { id: \"ROOT_QUERY\" });\n        }\n        try {\n            ++this.txCount;\n            return this.optimisticData.evict(options, this.data);\n        }\n        finally {\n            if (!--this.txCount && options.broadcast !== false) {\n                this.broadcastWatches();\n            }\n        }\n    };\n    InMemoryCache.prototype.reset = function (options) {\n        var _this = this;\n        this.init();\n        canonicalStringify.reset();\n        if (options && options.discardWatches) {\n            this.watches.forEach(function (watch) { return _this.maybeBroadcastWatch.forget(watch); });\n            this.watches.clear();\n            forgetCache(this);\n        }\n        else {\n            this.broadcastWatches();\n        }\n        return Promise.resolve();\n    };\n    InMemoryCache.prototype.removeOptimistic = function (idToRemove) {\n        var newOptimisticData = this.optimisticData.removeLayer(idToRemove);\n        if (newOptimisticData !== this.optimisticData) {\n            this.optimisticData = newOptimisticData;\n            this.broadcastWatches();\n        }\n    };\n    InMemoryCache.prototype.batch = function (options) {\n        var _this = this;\n        var update = options.update, _a = options.optimistic, optimistic = _a === void 0 ? true : _a, removeOptimistic = options.removeOptimistic, onWatchUpdated = options.onWatchUpdated;\n        var updateResult;\n        var perform = function (layer) {\n            var _a = _this, data = _a.data, optimisticData = _a.optimisticData;\n            ++_this.txCount;\n            if (layer) {\n                _this.data = _this.optimisticData = layer;\n            }\n            try {\n                return updateResult = update(_this);\n            }\n            finally {\n                --_this.txCount;\n                _this.data = data;\n                _this.optimisticData = optimisticData;\n            }\n        };\n        var alreadyDirty = new Set();\n        if (onWatchUpdated && !this.txCount) {\n            this.broadcastWatches(tslib.__assign(tslib.__assign({}, options), { onWatchUpdated: function (watch) {\n                    alreadyDirty.add(watch);\n                    return false;\n                } }));\n        }\n        if (typeof optimistic === 'string') {\n            this.optimisticData = this.optimisticData.addLayer(optimistic, perform);\n        }\n        else if (optimistic === false) {\n            perform(this.data);\n        }\n        else {\n            perform();\n        }\n        if (typeof removeOptimistic === \"string\") {\n            this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);\n        }\n        if (onWatchUpdated && alreadyDirty.size) {\n            this.broadcastWatches(tslib.__assign(tslib.__assign({}, options), { onWatchUpdated: function (watch, diff) {\n                    var result = onWatchUpdated.call(this, watch, diff);\n                    if (result !== false) {\n                        alreadyDirty.delete(watch);\n                    }\n                    return result;\n                } }));\n            if (alreadyDirty.size) {\n                alreadyDirty.forEach(function (watch) { return _this.maybeBroadcastWatch.dirty(watch); });\n            }\n        }\n        else {\n            this.broadcastWatches(options);\n        }\n        return updateResult;\n    };\n    InMemoryCache.prototype.performTransaction = function (update, optimisticId) {\n        return this.batch({\n            update: update,\n            optimistic: optimisticId || (optimisticId !== null),\n        });\n    };\n    InMemoryCache.prototype.transformDocument = function (document) {\n        if (this.addTypename) {\n            var result = this.typenameDocumentCache.get(document);\n            if (!result) {\n                result = utilities.addTypenameToDocument(document);\n                this.typenameDocumentCache.set(document, result);\n                this.typenameDocumentCache.set(result, result);\n            }\n            return result;\n        }\n        return document;\n    };\n    InMemoryCache.prototype.transformForLink = function (document) {\n        var fragments = this.config.fragments;\n        return fragments\n            ? fragments.transform(document)\n            : document;\n    };\n    InMemoryCache.prototype.broadcastWatches = function (options) {\n        var _this = this;\n        if (!this.txCount) {\n            this.watches.forEach(function (c) { return _this.maybeBroadcastWatch(c, options); });\n        }\n    };\n    InMemoryCache.prototype.broadcastWatch = function (c, options) {\n        var lastDiff = c.lastDiff;\n        var diff = this.diff(c);\n        if (options) {\n            if (c.optimistic &&\n                typeof options.optimistic === \"string\") {\n                diff.fromOptimisticTransaction = true;\n            }\n            if (options.onWatchUpdated &&\n                options.onWatchUpdated.call(this, c, diff, lastDiff) === false) {\n                return;\n            }\n        }\n        if (!lastDiff || !equality.equal(lastDiff.result, diff.result)) {\n            c.callback(c.lastDiff = diff, lastDiff);\n        }\n    };\n    return InMemoryCache;\n}(ApolloCache));\n\nfunction createFragmentRegistry() {\n    var fragments = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        fragments[_i] = arguments[_i];\n    }\n    return new (FragmentRegistry.bind.apply(FragmentRegistry, tslib.__spreadArray([void 0], fragments, false)))();\n}\nvar arrayLikeForEach = Array.prototype.forEach;\nvar FragmentRegistry = (function () {\n    function FragmentRegistry() {\n        var fragments = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            fragments[_i] = arguments[_i];\n        }\n        this.registry = Object.create(null);\n        this.resetCaches();\n        if (fragments.length) {\n            this.register.apply(this, fragments);\n        }\n    }\n    FragmentRegistry.prototype.register = function () {\n        var _this = this;\n        var definitions = new Map();\n        arrayLikeForEach.call(arguments, function (doc) {\n            utilities.getFragmentDefinitions(doc).forEach(function (node) {\n                definitions.set(node.name.value, node);\n            });\n        });\n        definitions.forEach(function (node, name) {\n            if (node !== _this.registry[name]) {\n                _this.registry[name] = node;\n                _this.invalidate(name);\n            }\n        });\n        return this;\n    };\n    FragmentRegistry.prototype.invalidate = function (name) { };\n    FragmentRegistry.prototype.resetCaches = function () {\n        this.invalidate = (this.lookup = this.cacheUnaryMethod(\"lookup\")).dirty;\n        this.transform = this.cacheUnaryMethod(\"transform\");\n        this.findFragmentSpreads = this.cacheUnaryMethod(\"findFragmentSpreads\");\n    };\n    FragmentRegistry.prototype.cacheUnaryMethod = function (name) {\n        var registry = this;\n        var originalMethod = FragmentRegistry.prototype[name];\n        return optimism.wrap(function () {\n            return originalMethod.apply(registry, arguments);\n        }, {\n            makeCacheKey: function (arg) { return arg; },\n        });\n    };\n    FragmentRegistry.prototype.lookup = function (fragmentName) {\n        return this.registry[fragmentName] || null;\n    };\n    FragmentRegistry.prototype.transform = function (document) {\n        var _this = this;\n        var defined = new Map();\n        utilities.getFragmentDefinitions(document).forEach(function (def) {\n            defined.set(def.name.value, def);\n        });\n        var unbound = new Set();\n        var enqueue = function (spreadName) {\n            if (!defined.has(spreadName)) {\n                unbound.add(spreadName);\n            }\n        };\n        var enqueueChildSpreads = function (node) { return Object.keys(_this.findFragmentSpreads(node)).forEach(enqueue); };\n        enqueueChildSpreads(document);\n        var missing = [];\n        var map = Object.create(null);\n        unbound.forEach(function (fragmentName) {\n            var knownFragmentDef = defined.get(fragmentName);\n            if (knownFragmentDef) {\n                enqueueChildSpreads(map[fragmentName] = knownFragmentDef);\n            }\n            else {\n                missing.push(fragmentName);\n                var def = _this.lookup(fragmentName);\n                if (def) {\n                    enqueueChildSpreads(map[fragmentName] = def);\n                }\n            }\n        });\n        if (missing.length) {\n            var defsToAppend_1 = [];\n            missing.forEach(function (name) {\n                var def = map[name];\n                if (def) {\n                    defsToAppend_1.push(def);\n                }\n            });\n            if (defsToAppend_1.length) {\n                document = tslib.__assign(tslib.__assign({}, document), { definitions: document.definitions.concat(defsToAppend_1) });\n            }\n        }\n        return document;\n    };\n    FragmentRegistry.prototype.findFragmentSpreads = function (root) {\n        var spreads = Object.create(null);\n        graphql.visit(root, {\n            FragmentSpread: function (node) {\n                spreads[node.name.value] = node;\n            },\n        });\n        return spreads;\n    };\n    return FragmentRegistry;\n}());\n\nexports.isReference = utilities.isReference;\nexports.makeReference = utilities.makeReference;\nexports.ApolloCache = ApolloCache;\nexports.InMemoryCache = InMemoryCache;\nexports.MissingFieldError = MissingFieldError;\nexports.Policies = Policies;\nexports.cacheSlot = cacheSlot;\nexports.canonicalStringify = canonicalStringify;\nexports.createFragmentRegistry = createFragmentRegistry;\nexports.defaultDataIdFromObject = defaultDataIdFromObject;\nexports.fieldNameFromStoreName = fieldNameFromStoreName;\nexports.makeVar = makeVar;\n//# sourceMappingURL=cache.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvY2FjaGUvY2FjaGUuY2pzP2VkMzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQThDLGNBQWM7O0FBRTVELGNBQWMsbUJBQU8sQ0FBQyx5RkFBc0I7QUFDNUMsWUFBWSxtQkFBTyxDQUFDLG9CQUFPO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQywwQkFBVTtBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQywyRUFBYztBQUN0QyxlQUFlLG1CQUFPLENBQUMsb0NBQWU7QUFDdEMsV0FBVyxtQkFBTyxDQUFDLDRCQUFXO0FBQzlCLGNBQWMsbUJBQU8sQ0FBQyx3QkFBUztBQUMvQixjQUFjLG1CQUFPLENBQUMsa0NBQWM7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw2Q0FBNkMsRUFBRTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbUNBQW1DO0FBQ3ZFLHlEQUF5RCxhQUFhLDZEQUE2RDtBQUNuSTtBQUNBO0FBQ0Esb0NBQW9DLG1DQUFtQztBQUN2RSx5REFBeUQsYUFBYSxpSEFBaUg7QUFDdkw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsYUFBYSxhQUFhO0FBQzNGO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGFBQWEsYUFBYTtBQUM5RjtBQUNBLGFBQWE7QUFDYixTQUFT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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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ImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9jYWNoZS9jYWNoZS5janMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBnbG9iYWxzID0gcmVxdWlyZSgnLi4vdXRpbGl0aWVzL2dsb2JhbHMnKTtcbnZhciB0c2xpYiA9IHJlcXVpcmUoJ3RzbGliJyk7XG52YXIgb3B0aW1pc20gPSByZXF1aXJlKCdvcHRpbWlzbScpO1xudmFyIHV0aWxpdGllcyA9IHJlcXVpcmUoJy4uL3V0aWxpdGllcycpO1xudmFyIGVxdWFsaXR5ID0gcmVxdWlyZSgnQHdyeS9lcXVhbGl0eScpO1xudmFyIHRyaWUgPSByZXF1aXJlKCdAd3J5L3RyaWUnKTtcbnZhciBncmFwaHFsID0gcmVxdWlyZSgnZ3JhcGhxbCcpO1xudmFyIGNvbnRleHQgPSByZXF1aXJlKCdAd3J5L2NvbnRleHQnKTtcblxudmFyIEFwb2xsb0NhY2hlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBcG9sbG9DYWNoZSgpIHtcbiAgICAgICAgdGhpcy5nZXRGcmFnbWVudERvYyA9IG9wdGltaXNtLndyYXAodXRpbGl0aWVzLmdldEZyYWdtZW50UXVlcnlEb2N1bWVudCk7XG4gICAgfVxuICAgIEFwb2xsb0NhY2hlLnByb3RvdHlwZS5iYXRjaCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBvcHRpbWlzdGljSWQgPSB0eXBlb2Ygb3B0aW9ucy5vcHRpbWlzdGljID09PSBcInN0cmluZ1wiID8gb3B0aW9ucy5vcHRpbWlzdGljIDpcbiAgICAgICAgICAgIG9wdGlvbnMub3B0aW1pc3RpYyA9PT0gZmFsc2UgPyBudWxsIDogdm9pZCAwO1xuICAgICAgICB2YXIgdXBkYXRlUmVzdWx0O1xuICAgICAgICB0aGlzLnBlcmZvcm1UcmFuc2FjdGlvbihmdW5jdGlvbiAoKSB7IHJldHVybiB1cGRhdGVSZXN1bHQgPSBvcHRpb25zLnVwZGF0ZShfdGhpcyk7IH0sIG9wdGltaXN0aWNJZCk7XG4gICAgICAgIHJldHVybiB1cGRhdGVSZXN1bHQ7XG4gICAgfTtcbiAgICBBcG9sbG9DYWNoZS5wcm90b3R5cGUucmVjb3JkT3B0aW1pc3RpY1RyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBvcHRpbWlzdGljSWQpIHtcbiAgICAgICAgdGhpcy5wZXJmb3JtVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIG9wdGltaXN0aWNJZCk7XG4gICAgfTtcbiAgICBBcG9sbG9DYWNoZS5wcm90b3R5cGUudHJhbnNmb3JtRG9jdW1lbnQgPSBmdW5jdGlvbiAoZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH07XG4gICAgQXBvbGxvQ2FjaGUucHJvdG90eXBlLnRyYW5zZm9ybUZvckxpbmsgPSBmdW5jdGlvbiAoZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH07XG4gICAgQXBvbGxvQ2FjaGUucHJvdG90eXBlLmlkZW50aWZ5ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbiAgICBBcG9sbG9DYWNoZS5wcm90b3R5cGUuZ2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIEFwb2xsb0NhY2hlLnByb3RvdHlwZS5tb2RpZnkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBBcG9sbG9DYWNoZS5wcm90b3R5cGUucmVhZFF1ZXJ5ID0gZnVuY3Rpb24gKG9wdGlvbnMsIG9wdGltaXN0aWMpIHtcbiAgICAgICAgaWYgKG9wdGltaXN0aWMgPT09IHZvaWQgMCkgeyBvcHRpbWlzdGljID0gISFvcHRpb25zLm9wdGltaXN0aWM7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZCh0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgcm9vdElkOiBvcHRpb25zLmlkIHx8ICdST09UX1FVRVJZJywgb3B0aW1pc3RpYzogb3B0aW1pc3RpYyB9KSk7XG4gICAgfTtcbiAgICBBcG9sbG9DYWNoZS5wcm90b3R5cGUucmVhZEZyYWdtZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMsIG9wdGltaXN0aWMpIHtcbiAgICAgICAgaWYgKG9wdGltaXN0aWMgPT09IHZvaWQgMCkgeyBvcHRpbWlzdGljID0gISFvcHRpb25zLm9wdGltaXN0aWM7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZCh0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgcXVlcnk6IHRoaXMuZ2V0RnJhZ21lbnREb2Mob3B0aW9ucy5mcmFnbWVudCwgb3B0aW9ucy5mcmFnbWVudE5hbWUpLCByb290SWQ6IG9wdGlvbnMuaWQsIG9wdGltaXN0aWM6IG9wdGltaXN0aWMgfSkpO1xuICAgIH07XG4gICAgQXBvbGxvQ2FjaGUucHJvdG90eXBlLndyaXRlUXVlcnkgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGlkID0gX2EuaWQsIGRhdGEgPSBfYS5kYXRhLCBvcHRpb25zID0gdHNsaWIuX19yZXN0KF9hLCBbXCJpZFwiLCBcImRhdGFcIl0pO1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZShPYmplY3QuYXNzaWduKG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGRhdGFJZDogaWQgfHwgJ1JPT1RfUVVFUlknLFxuICAgICAgICAgICAgcmVzdWx0OiBkYXRhLFxuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBBcG9sbG9DYWNoZS5wcm90b3R5cGUud3JpdGVGcmFnbWVudCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgaWQgPSBfYS5pZCwgZGF0YSA9IF9hLmRhdGEsIGZyYWdtZW50ID0gX2EuZnJhZ21lbnQsIGZyYWdtZW50TmFtZSA9IF9hLmZyYWdtZW50TmFtZSwgb3B0aW9ucyA9IHRzbGliLl9fcmVzdChfYSwgW1wiaWRcIiwgXCJkYXRhXCIsIFwiZnJhZ21lbnRcIiwgXCJmcmFnbWVudE5hbWVcIl0pO1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZShPYmplY3QuYXNzaWduKG9wdGlvbnMsIHtcbiAgICAgICAgICAgIHF1ZXJ5OiB0aGlzLmdldEZyYWdtZW50RG9jKGZyYWdtZW50LCBmcmFnbWVudE5hbWUpLFxuICAgICAgICAgICAgZGF0YUlkOiBpZCxcbiAgICAgICAgICAgIHJlc3VsdDogZGF0YSxcbiAgICAgICAgfSkpO1xuICAgIH07XG4gICAgQXBvbGxvQ2FjaGUucHJvdG90eXBlLnVwZGF0ZVF1ZXJ5ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHVwZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXRjaCh7XG4gICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uIChjYWNoZSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNhY2hlLnJlYWRRdWVyeShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEgPT09IHZvaWQgMCB8fCBkYXRhID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgY2FjaGUud3JpdGVRdWVyeSh0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgZGF0YTogZGF0YSB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFwb2xsb0NhY2hlLnByb3RvdHlwZS51cGRhdGVGcmFnbWVudCA9IGZ1bmN0aW9uIChvcHRpb25zLCB1cGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmF0Y2goe1xuICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoY2FjaGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjYWNoZS5yZWFkRnJhZ21lbnQob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB1cGRhdGUodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhID09PSB2b2lkIDAgfHwgZGF0YSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIGNhY2hlLndyaXRlRnJhZ21lbnQodHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGRhdGE6IGRhdGEgfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQXBvbGxvQ2FjaGU7XG59KCkpO1xuXG5leHBvcnRzLkNhY2hlID0gdm9pZCAwO1xuKGZ1bmN0aW9uIChDYWNoZSkge1xufSkoZXhwb3J0cy5DYWNoZSB8fCAoZXhwb3J0cy5DYWNoZSA9IHt9KSk7XG5cbnZhciBNaXNzaW5nRmllbGRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKE1pc3NpbmdGaWVsZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1pc3NpbmdGaWVsZEVycm9yKG1lc3NhZ2UsIHBhdGgsIHF1ZXJ5LCB2YXJpYWJsZXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgX3RoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIF90aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIF90aGlzLnZhcmlhYmxlcyA9IHZhcmlhYmxlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoX3RoaXMucGF0aCkpIHtcbiAgICAgICAgICAgIF90aGlzLm1pc3NpbmcgPSBfdGhpcy5tZXNzYWdlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IF90aGlzLnBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5taXNzaW5nID0gKF9hID0ge30sIF9hW190aGlzLnBhdGhbaV1dID0gX3RoaXMubWlzc2luZywgX2EpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMubWlzc2luZyA9IF90aGlzLnBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuX19wcm90b19fID0gTWlzc2luZ0ZpZWxkRXJyb3IucHJvdG90eXBlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBNaXNzaW5nRmllbGRFcnJvcjtcbn0oRXJyb3IpKTtcblxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBpc051bGxpc2godmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMDtcbn1cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmZ1bmN0aW9uIGRlZmF1bHREYXRhSWRGcm9tT2JqZWN0KF9hLCBjb250ZXh0KSB7XG4gICAgdmFyIF9fdHlwZW5hbWUgPSBfYS5fX3R5cGVuYW1lLCBpZCA9IF9hLmlkLCBfaWQgPSBfYS5faWQ7XG4gICAgaWYgKHR5cGVvZiBfX3R5cGVuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICBjb250ZXh0LmtleU9iamVjdCA9XG4gICAgICAgICAgICAgICAgIWlzTnVsbGlzaChpZCkgPyB7IGlkOiBpZCB9IDpcbiAgICAgICAgICAgICAgICAgICAgIWlzTnVsbGlzaChfaWQpID8geyBfaWQ6IF9pZCB9IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOdWxsaXNoKGlkKSAmJiAhaXNOdWxsaXNoKF9pZCkpIHtcbiAgICAgICAgICAgIGlkID0gX2lkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNOdWxsaXNoKGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KF9fdHlwZW5hbWUsIFwiOlwiKS5jb25jYXQoKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIiB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiBpZCA9PT0gXCJzdHJpbmdcIikgPyBpZCA6IEpTT04uc3RyaW5naWZ5KGlkKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG52YXIgZGVmYXVsdENvbmZpZyA9IHtcbiAgICBkYXRhSWRGcm9tT2JqZWN0OiBkZWZhdWx0RGF0YUlkRnJvbU9iamVjdCxcbiAgICBhZGRUeXBlbmFtZTogdHJ1ZSxcbiAgICByZXN1bHRDYWNoaW5nOiB0cnVlLFxuICAgIGNhbm9uaXplUmVzdWx0czogZmFsc2UsXG59O1xuZnVuY3Rpb24gbm9ybWFsaXplQ29uZmlnKGNvbmZpZykge1xuICAgIHJldHVybiB1dGlsaXRpZXMuY29tcGFjdChkZWZhdWx0Q29uZmlnLCBjb25maWcpO1xufVxuZnVuY3Rpb24gc2hvdWxkQ2Fub25pemVSZXN1bHRzKGNvbmZpZykge1xuICAgIHZhciB2YWx1ZSA9IGNvbmZpZy5jYW5vbml6ZVJlc3VsdHM7XG4gICAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyBkZWZhdWx0Q29uZmlnLmNhbm9uaXplUmVzdWx0cyA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0VHlwZW5hbWVGcm9tU3RvcmVPYmplY3Qoc3RvcmUsIG9iamVjdE9yUmVmZXJlbmNlKSB7XG4gICAgcmV0dXJuIHV0aWxpdGllcy5pc1JlZmVyZW5jZShvYmplY3RPclJlZmVyZW5jZSlcbiAgICAgICAgPyBzdG9yZS5nZXQob2JqZWN0T3JSZWZlcmVuY2UuX19yZWYsIFwiX190eXBlbmFtZVwiKVxuICAgICAgICA6IG9iamVjdE9yUmVmZXJlbmNlICYmIG9iamVjdE9yUmVmZXJlbmNlLl9fdHlwZW5hbWU7XG59XG52YXIgVHlwZU9yRmllbGROYW1lUmVnRXhwID0gL15bX2Etel1bXzAtOWEtel0qL2k7XG5mdW5jdGlvbiBmaWVsZE5hbWVGcm9tU3RvcmVOYW1lKHN0b3JlRmllbGROYW1lKSB7XG4gICAgdmFyIG1hdGNoID0gc3RvcmVGaWVsZE5hbWUubWF0Y2goVHlwZU9yRmllbGROYW1lUmVnRXhwKTtcbiAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFswXSA6IHN0b3JlRmllbGROYW1lO1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uU2V0TWF0Y2hlc1Jlc3VsdChzZWxlY3Rpb25TZXQsIHJlc3VsdCwgdmFyaWFibGVzKSB7XG4gICAgaWYgKHV0aWxpdGllcy5pc05vbk51bGxPYmplY3QocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gaXNBcnJheShyZXN1bHQpXG4gICAgICAgICAgICA/IHJlc3VsdC5ldmVyeShmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gc2VsZWN0aW9uU2V0TWF0Y2hlc1Jlc3VsdChzZWxlY3Rpb25TZXQsIGl0ZW0sIHZhcmlhYmxlcyk7IH0pXG4gICAgICAgICAgICA6IHNlbGVjdGlvblNldC5zZWxlY3Rpb25zLmV2ZXJ5KGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgICAgIGlmICh1dGlsaXRpZXMuaXNGaWVsZChmaWVsZCkgJiYgdXRpbGl0aWVzLnNob3VsZEluY2x1ZGUoZmllbGQsIHZhcmlhYmxlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IHV0aWxpdGllcy5yZXN1bHRLZXlOYW1lRnJvbUZpZWxkKGZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc093bi5jYWxsKHJlc3VsdCwga2V5KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCFmaWVsZC5zZWxlY3Rpb25TZXQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25TZXRNYXRjaGVzUmVzdWx0KGZpZWxkLnNlbGVjdGlvblNldCwgcmVzdWx0W2tleV0sIHZhcmlhYmxlcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzdG9yZVZhbHVlSXNTdG9yZU9iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsaXRpZXMuaXNOb25OdWxsT2JqZWN0KHZhbHVlKSAmJlxuICAgICAgICAhdXRpbGl0aWVzLmlzUmVmZXJlbmNlKHZhbHVlKSAmJlxuICAgICAgICAhaXNBcnJheSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBtYWtlUHJvY2Vzc2VkRmllbGRzTWVyZ2VyKCkge1xuICAgIHJldHVybiBuZXcgdXRpbGl0aWVzLkRlZXBNZXJnZXI7XG59XG5mdW5jdGlvbiBleHRyYWN0RnJhZ21lbnRDb250ZXh0KGRvY3VtZW50LCBmcmFnbWVudHMpIHtcbiAgICB2YXIgZnJhZ21lbnRNYXAgPSB1dGlsaXRpZXMuY3JlYXRlRnJhZ21lbnRNYXAodXRpbGl0aWVzLmdldEZyYWdtZW50RGVmaW5pdGlvbnMoZG9jdW1lbnQpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmcmFnbWVudE1hcDogZnJhZ21lbnRNYXAsXG4gICAgICAgIGxvb2t1cEZyYWdtZW50OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIGRlZiA9IGZyYWdtZW50TWFwW25hbWVdO1xuICAgICAgICAgICAgaWYgKCFkZWYgJiYgZnJhZ21lbnRzKSB7XG4gICAgICAgICAgICAgICAgZGVmID0gZnJhZ21lbnRzLmxvb2t1cChuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWYgfHwgbnVsbDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG52YXIgREVMRVRFID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbnZhciBkZWxNb2RpZmllciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIERFTEVURTsgfTtcbnZhciBJTlZBTElEQVRFID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmV4cG9ydHMuRW50aXR5U3RvcmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVudGl0eVN0b3JlKHBvbGljaWVzLCBncm91cCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnBvbGljaWVzID0gcG9saWNpZXM7XG4gICAgICAgIHRoaXMuZ3JvdXAgPSBncm91cDtcbiAgICAgICAgdGhpcy5kYXRhID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5yb290SWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5yZWZzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5nZXRGaWVsZFZhbHVlID0gZnVuY3Rpb24gKG9iamVjdE9yUmVmZXJlbmNlLCBzdG9yZUZpZWxkTmFtZSkgeyByZXR1cm4gdXRpbGl0aWVzLm1heWJlRGVlcEZyZWV6ZSh1dGlsaXRpZXMuaXNSZWZlcmVuY2Uob2JqZWN0T3JSZWZlcmVuY2UpXG4gICAgICAgICAgICA/IF90aGlzLmdldChvYmplY3RPclJlZmVyZW5jZS5fX3JlZiwgc3RvcmVGaWVsZE5hbWUpXG4gICAgICAgICAgICA6IG9iamVjdE9yUmVmZXJlbmNlICYmIG9iamVjdE9yUmVmZXJlbmNlW3N0b3JlRmllbGROYW1lXSk7IH07XG4gICAgICAgIHRoaXMuY2FuUmVhZCA9IGZ1bmN0aW9uIChvYmpPclJlZikge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxpdGllcy5pc1JlZmVyZW5jZShvYmpPclJlZilcbiAgICAgICAgICAgICAgICA/IF90aGlzLmhhcyhvYmpPclJlZi5fX3JlZilcbiAgICAgICAgICAgICAgICA6IHR5cGVvZiBvYmpPclJlZiA9PT0gXCJvYmplY3RcIjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50b1JlZmVyZW5jZSA9IGZ1bmN0aW9uIChvYmpPcklkT3JSZWYsIG1lcmdlSW50b1N0b3JlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iak9ySWRPclJlZiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsaXRpZXMubWFrZVJlZmVyZW5jZShvYmpPcklkT3JSZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHV0aWxpdGllcy5pc1JlZmVyZW5jZShvYmpPcklkT3JSZWYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iak9ySWRPclJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpZCA9IF90aGlzLnBvbGljaWVzLmlkZW50aWZ5KG9iak9ySWRPclJlZilbMF07XG4gICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVmID0gdXRpbGl0aWVzLm1ha2VSZWZlcmVuY2UoaWQpO1xuICAgICAgICAgICAgICAgIGlmIChtZXJnZUludG9TdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tZXJnZShpZCwgb2JqT3JJZE9yUmVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgRW50aXR5U3RvcmUucHJvdG90eXBlLnRvT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24oe30sIHRoaXMuZGF0YSk7XG4gICAgfTtcbiAgICBFbnRpdHlTdG9yZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb29rdXAoZGF0YUlkLCB0cnVlKSAhPT0gdm9pZCAwO1xuICAgIH07XG4gICAgRW50aXR5U3RvcmUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChkYXRhSWQsIGZpZWxkTmFtZSkge1xuICAgICAgICB0aGlzLmdyb3VwLmRlcGVuZChkYXRhSWQsIGZpZWxkTmFtZSk7XG4gICAgICAgIGlmIChoYXNPd24uY2FsbCh0aGlzLmRhdGEsIGRhdGFJZCkpIHtcbiAgICAgICAgICAgIHZhciBzdG9yZU9iamVjdCA9IHRoaXMuZGF0YVtkYXRhSWRdO1xuICAgICAgICAgICAgaWYgKHN0b3JlT2JqZWN0ICYmIGhhc093bi5jYWxsKHN0b3JlT2JqZWN0LCBmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlT2JqZWN0W2ZpZWxkTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkTmFtZSA9PT0gXCJfX3R5cGVuYW1lXCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMucG9saWNpZXMucm9vdFR5cGVuYW1lc0J5SWQsIGRhdGFJZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvbGljaWVzLnJvb3RUeXBlbmFtZXNCeUlkW2RhdGFJZF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBMYXllcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldChkYXRhSWQsIGZpZWxkTmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVudGl0eVN0b3JlLnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbiAoZGF0YUlkLCBkZXBlbmRPbkV4aXN0ZW5jZSkge1xuICAgICAgICBpZiAoZGVwZW5kT25FeGlzdGVuY2UpXG4gICAgICAgICAgICB0aGlzLmdyb3VwLmRlcGVuZChkYXRhSWQsIFwiX19leGlzdHNcIik7XG4gICAgICAgIGlmIChoYXNPd24uY2FsbCh0aGlzLmRhdGEsIGRhdGFJZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFbZGF0YUlkXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIExheWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQubG9va3VwKGRhdGFJZCwgZGVwZW5kT25FeGlzdGVuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBvbGljaWVzLnJvb3RUeXBlbmFtZXNCeUlkW2RhdGFJZF0pIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbnRpdHlTdG9yZS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAob2xkZXIsIG5ld2VyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkYXRhSWQ7XG4gICAgICAgIGlmICh1dGlsaXRpZXMuaXNSZWZlcmVuY2Uob2xkZXIpKVxuICAgICAgICAgICAgb2xkZXIgPSBvbGRlci5fX3JlZjtcbiAgICAgICAgaWYgKHV0aWxpdGllcy5pc1JlZmVyZW5jZShuZXdlcikpXG4gICAgICAgICAgICBuZXdlciA9IG5ld2VyLl9fcmVmO1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSB0eXBlb2Ygb2xkZXIgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8gdGhpcy5sb29rdXAoZGF0YUlkID0gb2xkZXIpXG4gICAgICAgICAgICA6IG9sZGVyO1xuICAgICAgICB2YXIgaW5jb21pbmcgPSB0eXBlb2YgbmV3ZXIgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8gdGhpcy5sb29rdXAoZGF0YUlkID0gbmV3ZXIpXG4gICAgICAgICAgICA6IG5ld2VyO1xuICAgICAgICBpZiAoIWluY29taW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBfX0RFVl9fID8gZ2xvYmFscy5pbnZhcmlhbnQodHlwZW9mIGRhdGFJZCA9PT0gXCJzdHJpbmdcIiwgXCJzdG9yZS5tZXJnZSBleHBlY3RzIGEgc3RyaW5nIElEXCIpIDogZ2xvYmFscy5pbnZhcmlhbnQodHlwZW9mIGRhdGFJZCA9PT0gXCJzdHJpbmdcIiwgMSk7XG4gICAgICAgIHZhciBtZXJnZWQgPSBuZXcgdXRpbGl0aWVzLkRlZXBNZXJnZXIoc3RvcmVPYmplY3RSZWNvbmNpbGVyKS5tZXJnZShleGlzdGluZywgaW5jb21pbmcpO1xuICAgICAgICB0aGlzLmRhdGFbZGF0YUlkXSA9IG1lcmdlZDtcbiAgICAgICAgaWYgKG1lcmdlZCAhPT0gZXhpc3RpbmcpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlZnNbZGF0YUlkXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmdyb3VwLmNhY2hpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRzVG9EaXJ0eV8xID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nKVxuICAgICAgICAgICAgICAgICAgICBmaWVsZHNUb0RpcnR5XzEuX19leGlzdHMgPSAxO1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGluY29taW5nKS5mb3JFYWNoKGZ1bmN0aW9uIChzdG9yZUZpZWxkTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nIHx8IGV4aXN0aW5nW3N0b3JlRmllbGROYW1lXSAhPT0gbWVyZ2VkW3N0b3JlRmllbGROYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzVG9EaXJ0eV8xW3N0b3JlRmllbGROYW1lXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGROYW1lID0gZmllbGROYW1lRnJvbVN0b3JlTmFtZShzdG9yZUZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGROYW1lICE9PSBzdG9yZUZpZWxkTmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFfdGhpcy5wb2xpY2llcy5oYXNLZXlBcmdzKG1lcmdlZC5fX3R5cGVuYW1lLCBmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzVG9EaXJ0eV8xW2ZpZWxkTmFtZV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lcmdlZFtzdG9yZUZpZWxkTmFtZV0gPT09IHZvaWQgMCAmJiAhKF90aGlzIGluc3RhbmNlb2YgTGF5ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG1lcmdlZFtzdG9yZUZpZWxkTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGRzVG9EaXJ0eV8xLl9fdHlwZW5hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgIShleGlzdGluZyAmJiBleGlzdGluZy5fX3R5cGVuYW1lKSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvbGljaWVzLnJvb3RUeXBlbmFtZXNCeUlkW2RhdGFJZF0gPT09IG1lcmdlZC5fX3R5cGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBmaWVsZHNUb0RpcnR5XzEuX190eXBlbmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZmllbGRzVG9EaXJ0eV8xKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZE5hbWUpIHsgcmV0dXJuIF90aGlzLmdyb3VwLmRpcnR5KGRhdGFJZCwgZmllbGROYW1lKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVudGl0eVN0b3JlLnByb3RvdHlwZS5tb2RpZnkgPSBmdW5jdGlvbiAoZGF0YUlkLCBmaWVsZHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHN0b3JlT2JqZWN0ID0gdGhpcy5sb29rdXAoZGF0YUlkKTtcbiAgICAgICAgaWYgKHN0b3JlT2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlZEZpZWxkc18xID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIHZhciBuZWVkVG9NZXJnZV8xID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgYWxsRGVsZXRlZF8xID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBzaGFyZWREZXRhaWxzXzEgPSB7XG4gICAgICAgICAgICAgICAgREVMRVRFOiBERUxFVEUsXG4gICAgICAgICAgICAgICAgSU5WQUxJREFURTogSU5WQUxJREFURSxcbiAgICAgICAgICAgICAgICBpc1JlZmVyZW5jZTogdXRpbGl0aWVzLmlzUmVmZXJlbmNlLFxuICAgICAgICAgICAgICAgIHRvUmVmZXJlbmNlOiB0aGlzLnRvUmVmZXJlbmNlLFxuICAgICAgICAgICAgICAgIGNhblJlYWQ6IHRoaXMuY2FuUmVhZCxcbiAgICAgICAgICAgICAgICByZWFkRmllbGQ6IGZ1bmN0aW9uIChmaWVsZE5hbWVPck9wdGlvbnMsIGZyb20pIHsgcmV0dXJuIF90aGlzLnBvbGljaWVzLnJlYWRGaWVsZCh0eXBlb2YgZmllbGROYW1lT3JPcHRpb25zID09PSBcInN0cmluZ1wiID8ge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZE5hbWU6IGZpZWxkTmFtZU9yT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogZnJvbSB8fCB1dGlsaXRpZXMubWFrZVJlZmVyZW5jZShkYXRhSWQpLFxuICAgICAgICAgICAgICAgIH0gOiBmaWVsZE5hbWVPck9wdGlvbnMsIHsgc3RvcmU6IF90aGlzIH0pOyB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHN0b3JlT2JqZWN0KS5mb3JFYWNoKGZ1bmN0aW9uIChzdG9yZUZpZWxkTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZE5hbWUgPSBmaWVsZE5hbWVGcm9tU3RvcmVOYW1lKHN0b3JlRmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRWYWx1ZSA9IHN0b3JlT2JqZWN0W3N0b3JlRmllbGROYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIG1vZGlmeSA9IHR5cGVvZiBmaWVsZHMgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICA/IGZpZWxkc1xuICAgICAgICAgICAgICAgICAgICA6IGZpZWxkc1tzdG9yZUZpZWxkTmFtZV0gfHwgZmllbGRzW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKG1vZGlmeSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBtb2RpZnkgPT09IGRlbE1vZGlmaWVyID8gREVMRVRFIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmeSh1dGlsaXRpZXMubWF5YmVEZWVwRnJlZXplKGZpZWxkVmFsdWUpLCB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgc2hhcmVkRGV0YWlsc18xKSwgeyBmaWVsZE5hbWU6IGZpZWxkTmFtZSwgc3RvcmVGaWVsZE5hbWU6IHN0b3JlRmllbGROYW1lLCBzdG9yYWdlOiBfdGhpcy5nZXRTdG9yYWdlKGRhdGFJZCwgc3RvcmVGaWVsZE5hbWUpIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSBJTlZBTElEQVRFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5ncm91cC5kaXJ0eShkYXRhSWQsIHN0b3JlRmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gREVMRVRFKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBmaWVsZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZEZpZWxkc18xW3N0b3JlRmllbGROYW1lXSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRUb01lcmdlXzEgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkVmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmllbGRWYWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbERlbGV0ZWRfMSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG5lZWRUb01lcmdlXzEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lcmdlKGRhdGFJZCwgY2hhbmdlZEZpZWxkc18xKTtcbiAgICAgICAgICAgICAgICBpZiAoYWxsRGVsZXRlZF8xKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtkYXRhSWRdID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZGF0YVtkYXRhSWRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAuZGlydHkoZGF0YUlkLCBcIl9fZXhpc3RzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBFbnRpdHlTdG9yZS5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGRhdGFJZCwgZmllbGROYW1lLCBhcmdzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIHN0b3JlT2JqZWN0ID0gdGhpcy5sb29rdXAoZGF0YUlkKTtcbiAgICAgICAgaWYgKHN0b3JlT2JqZWN0KSB7XG4gICAgICAgICAgICB2YXIgdHlwZW5hbWUgPSB0aGlzLmdldEZpZWxkVmFsdWUoc3RvcmVPYmplY3QsIFwiX190eXBlbmFtZVwiKTtcbiAgICAgICAgICAgIHZhciBzdG9yZUZpZWxkTmFtZSA9IGZpZWxkTmFtZSAmJiBhcmdzXG4gICAgICAgICAgICAgICAgPyB0aGlzLnBvbGljaWVzLmdldFN0b3JlRmllbGROYW1lKHsgdHlwZW5hbWU6IHR5cGVuYW1lLCBmaWVsZE5hbWU6IGZpZWxkTmFtZSwgYXJnczogYXJncyB9KVxuICAgICAgICAgICAgICAgIDogZmllbGROYW1lO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kaWZ5KGRhdGFJZCwgc3RvcmVGaWVsZE5hbWUgPyAoX2EgPSB7fSxcbiAgICAgICAgICAgICAgICBfYVtzdG9yZUZpZWxkTmFtZV0gPSBkZWxNb2RpZmllcixcbiAgICAgICAgICAgICAgICBfYSkgOiBkZWxNb2RpZmllcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgRW50aXR5U3RvcmUucHJvdG90eXBlLmV2aWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIGxpbWl0KSB7XG4gICAgICAgIHZhciBldmljdGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChvcHRpb25zLmlkKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwodGhpcy5kYXRhLCBvcHRpb25zLmlkKSkge1xuICAgICAgICAgICAgICAgIGV2aWN0ZWQgPSB0aGlzLmRlbGV0ZShvcHRpb25zLmlkLCBvcHRpb25zLmZpZWxkTmFtZSwgb3B0aW9ucy5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgTGF5ZXIgJiYgdGhpcyAhPT0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICBldmljdGVkID0gdGhpcy5wYXJlbnQuZXZpY3Qob3B0aW9ucywgbGltaXQpIHx8IGV2aWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5maWVsZE5hbWUgfHwgZXZpY3RlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAuZGlydHkob3B0aW9ucy5pZCwgb3B0aW9ucy5maWVsZE5hbWUgfHwgXCJfX2V4aXN0c1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZpY3RlZDtcbiAgICB9O1xuICAgIEVudGl0eVN0b3JlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZXBsYWNlKG51bGwpO1xuICAgIH07XG4gICAgRW50aXR5U3RvcmUucHJvdG90eXBlLmV4dHJhY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBvYmogPSB0aGlzLnRvT2JqZWN0KCk7XG4gICAgICAgIHZhciBleHRyYVJvb3RJZHMgPSBbXTtcbiAgICAgICAgdGhpcy5nZXRSb290SWRTZXQoKS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd24uY2FsbChfdGhpcy5wb2xpY2llcy5yb290VHlwZW5hbWVzQnlJZCwgaWQpKSB7XG4gICAgICAgICAgICAgICAgZXh0cmFSb290SWRzLnB1c2goaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGV4dHJhUm9vdElkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9iai5fX01FVEEgPSB7IGV4dHJhUm9vdElkczogZXh0cmFSb290SWRzLnNvcnQoKSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgICBFbnRpdHlTdG9yZS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgICAgICBpZiAoIShuZXdEYXRhICYmIGhhc093bi5jYWxsKG5ld0RhdGEsIGRhdGFJZCkpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGVsZXRlKGRhdGFJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobmV3RGF0YSkge1xuICAgICAgICAgICAgdmFyIF9fTUVUQSA9IG5ld0RhdGEuX19NRVRBLCByZXN0XzEgPSB0c2xpYi5fX3Jlc3QobmV3RGF0YSwgW1wiX19NRVRBXCJdKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHJlc3RfMSkuZm9yRWFjaChmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubWVyZ2UoZGF0YUlkLCByZXN0XzFbZGF0YUlkXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChfX01FVEEpIHtcbiAgICAgICAgICAgICAgICBfX01FVEEuZXh0cmFSb290SWRzLmZvckVhY2godGhpcy5yZXRhaW4sIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBFbnRpdHlTdG9yZS5wcm90b3R5cGUucmV0YWluID0gZnVuY3Rpb24gKHJvb3RJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290SWRzW3Jvb3RJZF0gPSAodGhpcy5yb290SWRzW3Jvb3RJZF0gfHwgMCkgKyAxO1xuICAgIH07XG4gICAgRW50aXR5U3RvcmUucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbiAocm9vdElkKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb3RJZHNbcm9vdElkXSA+IDApIHtcbiAgICAgICAgICAgIHZhciBjb3VudCA9IC0tdGhpcy5yb290SWRzW3Jvb3RJZF07XG4gICAgICAgICAgICBpZiAoIWNvdW50KVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJvb3RJZHNbcm9vdElkXTtcbiAgICAgICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIEVudGl0eVN0b3JlLnByb3RvdHlwZS5nZXRSb290SWRTZXQgPSBmdW5jdGlvbiAoaWRzKSB7XG4gICAgICAgIGlmIChpZHMgPT09IHZvaWQgMCkgeyBpZHMgPSBuZXcgU2V0KCk7IH1cbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5yb290SWRzKS5mb3JFYWNoKGlkcy5hZGQsIGlkcyk7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgTGF5ZXIpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmdldFJvb3RJZFNldChpZHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5wb2xpY2llcy5yb290VHlwZW5hbWVzQnlJZCkuZm9yRWFjaChpZHMuYWRkLCBpZHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZHM7XG4gICAgfTtcbiAgICBFbnRpdHlTdG9yZS5wcm90b3R5cGUuZ2MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBpZHMgPSB0aGlzLmdldFJvb3RJZFNldCgpO1xuICAgICAgICB2YXIgc25hcHNob3QgPSB0aGlzLnRvT2JqZWN0KCk7XG4gICAgICAgIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKHNuYXBzaG90LCBpZCkpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhfdGhpcy5maW5kQ2hpbGRSZWZJZHMoaWQpKS5mb3JFYWNoKGlkcy5hZGQsIGlkcyk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNuYXBzaG90W2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpZHNUb1JlbW92ZSA9IE9iamVjdC5rZXlzKHNuYXBzaG90KTtcbiAgICAgICAgaWYgKGlkc1RvUmVtb3ZlLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHJvb3RfMSA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAocm9vdF8xIGluc3RhbmNlb2YgTGF5ZXIpXG4gICAgICAgICAgICAgICAgcm9vdF8xID0gcm9vdF8xLnBhcmVudDtcbiAgICAgICAgICAgIGlkc1RvUmVtb3ZlLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7IHJldHVybiByb290XzEuZGVsZXRlKGlkKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkc1RvUmVtb3ZlO1xuICAgIH07XG4gICAgRW50aXR5U3RvcmUucHJvdG90eXBlLmZpbmRDaGlsZFJlZklkcyA9IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgaWYgKCFoYXNPd24uY2FsbCh0aGlzLnJlZnMsIGRhdGFJZCkpIHtcbiAgICAgICAgICAgIHZhciBmb3VuZF8xID0gdGhpcy5yZWZzW2RhdGFJZF0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLmRhdGFbZGF0YUlkXTtcbiAgICAgICAgICAgIGlmICghcm9vdClcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmRfMTtcbiAgICAgICAgICAgIHZhciB3b3JrU2V0XzEgPSBuZXcgU2V0KFtyb290XSk7XG4gICAgICAgICAgICB3b3JrU2V0XzEuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHV0aWxpdGllcy5pc1JlZmVyZW5jZShvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kXzFbb2JqLl9fcmVmXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1dGlsaXRpZXMuaXNOb25OdWxsT2JqZWN0KG9iaikpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHV0aWxpdGllcy5pc05vbk51bGxPYmplY3QoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya1NldF8xLmFkZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlZnNbZGF0YUlkXTtcbiAgICB9O1xuICAgIEVudGl0eVN0b3JlLnByb3RvdHlwZS5tYWtlQ2FjaGVLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyb3VwLmtleU1ha2VyLmxvb2t1cEFycmF5KGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICByZXR1cm4gRW50aXR5U3RvcmU7XG59KCkpO1xudmFyIENhY2hlR3JvdXAgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhY2hlR3JvdXAoY2FjaGluZywgcGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IHZvaWQgMCkgeyBwYXJlbnQgPSBudWxsOyB9XG4gICAgICAgIHRoaXMuY2FjaGluZyA9IGNhY2hpbmc7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmQgPSBudWxsO1xuICAgICAgICB0aGlzLnJlc2V0Q2FjaGluZygpO1xuICAgIH1cbiAgICBDYWNoZUdyb3VwLnByb3RvdHlwZS5yZXNldENhY2hpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZCA9IHRoaXMuY2FjaGluZyA/IG9wdGltaXNtLmRlcCgpIDogbnVsbDtcbiAgICAgICAgdGhpcy5rZXlNYWtlciA9IG5ldyB0cmllLlRyaWUodXRpbGl0aWVzLmNhblVzZVdlYWtNYXApO1xuICAgIH07XG4gICAgQ2FjaGVHcm91cC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gKGRhdGFJZCwgc3RvcmVGaWVsZE5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZCkge1xuICAgICAgICAgICAgdGhpcy5kKG1ha2VEZXBLZXkoZGF0YUlkLCBzdG9yZUZpZWxkTmFtZSkpO1xuICAgICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IGZpZWxkTmFtZUZyb21TdG9yZU5hbWUoc3RvcmVGaWVsZE5hbWUpO1xuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSAhPT0gc3RvcmVGaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmQobWFrZURlcEtleShkYXRhSWQsIGZpZWxkTmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuZGVwZW5kKGRhdGFJZCwgc3RvcmVGaWVsZE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDYWNoZUdyb3VwLnByb3RvdHlwZS5kaXJ0eSA9IGZ1bmN0aW9uIChkYXRhSWQsIHN0b3JlRmllbGROYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmQpIHtcbiAgICAgICAgICAgIHRoaXMuZC5kaXJ0eShtYWtlRGVwS2V5KGRhdGFJZCwgc3RvcmVGaWVsZE5hbWUpLCBzdG9yZUZpZWxkTmFtZSA9PT0gXCJfX2V4aXN0c1wiID8gXCJmb3JnZXRcIiA6IFwic2V0RGlydHlcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDYWNoZUdyb3VwO1xufSgpKTtcbmZ1bmN0aW9uIG1ha2VEZXBLZXkoZGF0YUlkLCBzdG9yZUZpZWxkTmFtZSkge1xuICAgIHJldHVybiBzdG9yZUZpZWxkTmFtZSArICcjJyArIGRhdGFJZDtcbn1cbmZ1bmN0aW9uIG1heWJlRGVwZW5kT25FeGlzdGVuY2VPZkVudGl0eShzdG9yZSwgZW50aXR5SWQpIHtcbiAgICBpZiAoc3VwcG9ydHNSZXN1bHRDYWNoaW5nKHN0b3JlKSkge1xuICAgICAgICBzdG9yZS5ncm91cC5kZXBlbmQoZW50aXR5SWQsIFwiX19leGlzdHNcIik7XG4gICAgfVxufVxuKGZ1bmN0aW9uIChFbnRpdHlTdG9yZSkge1xuICAgIHZhciBSb290ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgdHNsaWIuX19leHRlbmRzKFJvb3QsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIFJvb3QoX2EpIHtcbiAgICAgICAgICAgIHZhciBwb2xpY2llcyA9IF9hLnBvbGljaWVzLCBfYiA9IF9hLnJlc3VsdENhY2hpbmcsIHJlc3VsdENhY2hpbmcgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iLCBzZWVkID0gX2Euc2VlZDtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHBvbGljaWVzLCBuZXcgQ2FjaGVHcm91cChyZXN1bHRDYWNoaW5nKSkgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLnN0dW1wID0gbmV3IFN0dW1wKF90aGlzKTtcbiAgICAgICAgICAgIF90aGlzLnN0b3JhZ2VUcmllID0gbmV3IHRyaWUuVHJpZSh1dGlsaXRpZXMuY2FuVXNlV2Vha01hcCk7XG4gICAgICAgICAgICBpZiAoc2VlZClcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXBsYWNlKHNlZWQpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIFJvb3QucHJvdG90eXBlLmFkZExheWVyID0gZnVuY3Rpb24gKGxheWVySWQsIHJlcGxheSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3R1bXAuYWRkTGF5ZXIobGF5ZXJJZCwgcmVwbGF5KTtcbiAgICAgICAgfTtcbiAgICAgICAgUm9vdC5wcm90b3R5cGUucmVtb3ZlTGF5ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgUm9vdC5wcm90b3R5cGUuZ2V0U3RvcmFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2VUcmllLmxvb2t1cEFycmF5KGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSb290O1xuICAgIH0oRW50aXR5U3RvcmUpKTtcbiAgICBFbnRpdHlTdG9yZS5Sb290ID0gUm9vdDtcbn0pKGV4cG9ydHMuRW50aXR5U3RvcmUgfHwgKGV4cG9ydHMuRW50aXR5U3RvcmUgPSB7fSkpO1xudmFyIExheWVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoTGF5ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGF5ZXIoaWQsIHBhcmVudCwgcmVwbGF5LCBncm91cCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXJlbnQucG9saWNpZXMsIGdyb3VwKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pZCA9IGlkO1xuICAgICAgICBfdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIF90aGlzLnJlcGxheSA9IHJlcGxheTtcbiAgICAgICAgX3RoaXMuZ3JvdXAgPSBncm91cDtcbiAgICAgICAgcmVwbGF5KF90aGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBMYXllci5wcm90b3R5cGUuYWRkTGF5ZXIgPSBmdW5jdGlvbiAobGF5ZXJJZCwgcmVwbGF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgTGF5ZXIobGF5ZXJJZCwgdGhpcywgcmVwbGF5LCB0aGlzLmdyb3VwKTtcbiAgICB9O1xuICAgIExheWVyLnByb3RvdHlwZS5yZW1vdmVMYXllciA9IGZ1bmN0aW9uIChsYXllcklkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudC5yZW1vdmVMYXllcihsYXllcklkKTtcbiAgICAgICAgaWYgKGxheWVySWQgPT09IHRoaXMuaWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdyb3VwLmNhY2hpbmcpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmRhdGEpLmZvckVhY2goZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3duU3RvcmVPYmplY3QgPSBfdGhpcy5kYXRhW2RhdGFJZF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRTdG9yZU9iamVjdCA9IHBhcmVudFtcImxvb2t1cFwiXShkYXRhSWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFN0b3JlT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kZWxldGUoZGF0YUlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghb3duU3RvcmVPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmdyb3VwLmRpcnR5KGRhdGFJZCwgXCJfX2V4aXN0c1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcmVudFN0b3JlT2JqZWN0KS5mb3JFYWNoKGZ1bmN0aW9uIChzdG9yZUZpZWxkTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmdyb3VwLmRpcnR5KGRhdGFJZCwgc3RvcmVGaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob3duU3RvcmVPYmplY3QgIT09IHBhcmVudFN0b3JlT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhvd25TdG9yZU9iamVjdCkuZm9yRWFjaChmdW5jdGlvbiAoc3RvcmVGaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVxdWFsaXR5LmVxdWFsKG93blN0b3JlT2JqZWN0W3N0b3JlRmllbGROYW1lXSwgcGFyZW50U3RvcmVPYmplY3Rbc3RvcmVGaWVsZE5hbWVdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5ncm91cC5kaXJ0eShkYXRhSWQsIHN0b3JlRmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50ID09PSB0aGlzLnBhcmVudClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gcGFyZW50LmFkZExheWVyKHRoaXMuaWQsIHRoaXMucmVwbGF5KTtcbiAgICB9O1xuICAgIExheWVyLnByb3RvdHlwZS50b09iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCB0aGlzLnBhcmVudC50b09iamVjdCgpKSwgdGhpcy5kYXRhKTtcbiAgICB9O1xuICAgIExheWVyLnByb3RvdHlwZS5maW5kQ2hpbGRSZWZJZHMgPSBmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgIHZhciBmcm9tUGFyZW50ID0gdGhpcy5wYXJlbnQuZmluZENoaWxkUmVmSWRzKGRhdGFJZCk7XG4gICAgICAgIHJldHVybiBoYXNPd24uY2FsbCh0aGlzLmRhdGEsIGRhdGFJZCkgPyB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgZnJvbVBhcmVudCksIF9zdXBlci5wcm90b3R5cGUuZmluZENoaWxkUmVmSWRzLmNhbGwodGhpcywgZGF0YUlkKSkgOiBmcm9tUGFyZW50O1xuICAgIH07XG4gICAgTGF5ZXIucHJvdG90eXBlLmdldFN0b3JhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIHdoaWxlIChwLnBhcmVudClcbiAgICAgICAgICAgIHAgPSBwLnBhcmVudDtcbiAgICAgICAgcmV0dXJuIHAuZ2V0U3RvcmFnZS5hcHBseShwLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgcmV0dXJuIExheWVyO1xufShleHBvcnRzLkVudGl0eVN0b3JlKSk7XG52YXIgU3R1bXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhTdHVtcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdHVtcChyb290KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBcIkVudGl0eVN0b3JlLlN0dW1wXCIsIHJvb3QsIGZ1bmN0aW9uICgpIHsgfSwgbmV3IENhY2hlR3JvdXAocm9vdC5ncm91cC5jYWNoaW5nLCByb290Lmdyb3VwKSkgfHwgdGhpcztcbiAgICB9XG4gICAgU3R1bXAucHJvdG90eXBlLnJlbW92ZUxheWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFN0dW1wLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm1lcmdlLmFwcGx5KHRoaXMucGFyZW50LCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgcmV0dXJuIFN0dW1wO1xufShMYXllcikpO1xuZnVuY3Rpb24gc3RvcmVPYmplY3RSZWNvbmNpbGVyKGV4aXN0aW5nT2JqZWN0LCBpbmNvbWluZ09iamVjdCwgcHJvcGVydHkpIHtcbiAgICB2YXIgZXhpc3RpbmdWYWx1ZSA9IGV4aXN0aW5nT2JqZWN0W3Byb3BlcnR5XTtcbiAgICB2YXIgaW5jb21pbmdWYWx1ZSA9IGluY29taW5nT2JqZWN0W3Byb3BlcnR5XTtcbiAgICByZXR1cm4gZXF1YWxpdHkuZXF1YWwoZXhpc3RpbmdWYWx1ZSwgaW5jb21pbmdWYWx1ZSkgPyBleGlzdGluZ1ZhbHVlIDogaW5jb21pbmdWYWx1ZTtcbn1cbmZ1bmN0aW9uIHN1cHBvcnRzUmVzdWx0Q2FjaGluZyhzdG9yZSkge1xuICAgIHJldHVybiAhIShzdG9yZSBpbnN0YW5jZW9mIGV4cG9ydHMuRW50aXR5U3RvcmUgJiYgc3RvcmUuZ3JvdXAuY2FjaGluZyk7XG59XG5cbmZ1bmN0aW9uIHNoYWxsb3dDb3B5KHZhbHVlKSB7XG4gICAgaWYgKHV0aWxpdGllcy5pc05vbk51bGxPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgICAgICAgPyB2YWx1ZS5zbGljZSgwKVxuICAgICAgICAgICAgOiB0c2xpYi5fX2Fzc2lnbih7IF9fcHJvdG9fXzogT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSB9LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbnZhciBPYmplY3RDYW5vbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2JqZWN0Q2Fub24oKSB7XG4gICAgICAgIHRoaXMua25vd24gPSBuZXcgKHV0aWxpdGllcy5jYW5Vc2VXZWFrU2V0ID8gV2Vha1NldCA6IFNldCkoKTtcbiAgICAgICAgdGhpcy5wb29sID0gbmV3IHRyaWUuVHJpZSh1dGlsaXRpZXMuY2FuVXNlV2Vha01hcCk7XG4gICAgICAgIHRoaXMucGFzc2VzID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdGhpcy5rZXlzQnlKU09OID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmVtcHR5ID0gdGhpcy5hZG1pdCh7fSk7XG4gICAgfVxuICAgIE9iamVjdENhbm9uLnByb3RvdHlwZS5pc0tub3duID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB1dGlsaXRpZXMuaXNOb25OdWxsT2JqZWN0KHZhbHVlKSAmJiB0aGlzLmtub3duLmhhcyh2YWx1ZSk7XG4gICAgfTtcbiAgICBPYmplY3RDYW5vbi5wcm90b3R5cGUucGFzcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodXRpbGl0aWVzLmlzTm9uTnVsbE9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhciBjb3B5ID0gc2hhbGxvd0NvcHkodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5wYXNzZXMuc2V0KGNvcHksIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBjb3B5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIE9iamVjdENhbm9uLnByb3RvdHlwZS5hZG1pdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodXRpbGl0aWVzLmlzTm9uTnVsbE9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IHRoaXMucGFzc2VzLmdldCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgICAgICAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgICAgICAgICAgIHN3aXRjaCAocHJvdG8pIHtcbiAgICAgICAgICAgICAgICBjYXNlIEFycmF5LnByb3RvdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5rbm93bi5oYXModmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXkgPSB2YWx1ZS5tYXAodGhpcy5hZG1pdCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5wb29sLmxvb2t1cEFycmF5KGFycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLmFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtub3duLmFkZChub2RlLmFycmF5ID0gYXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9fREVWX18pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGFycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5hcnJheTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBudWxsOlxuICAgICAgICAgICAgICAgIGNhc2UgT2JqZWN0LnByb3RvdHlwZToge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5rbm93bi5oYXModmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvdG9fMSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJheV8xID0gW3Byb3RvXzFdO1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IHRoaXMuc29ydGVkS2V5cyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5XzEucHVzaChrZXlzLmpzb24pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RWYWx1ZUluZGV4XzEgPSBhcnJheV8xLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5zb3J0ZWQuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheV8xLnB1c2goX3RoaXMuYWRtaXQodmFsdWVba2V5XSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnBvb2wubG9va3VwQXJyYXkoYXJyYXlfMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5vYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmpfMSA9IG5vZGUub2JqZWN0ID0gT2JqZWN0LmNyZWF0ZShwcm90b18xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua25vd24uYWRkKG9ial8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXMuc29ydGVkLmZvckVhY2goZnVuY3Rpb24gKGtleSwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ial8xW2tleV0gPSBhcnJheV8xW2ZpcnN0VmFsdWVJbmRleF8xICsgaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShvYmpfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUub2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBPYmplY3RDYW5vbi5wcm90b3R5cGUuc29ydGVkS2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMucG9vbC5sb29rdXBBcnJheShrZXlzKTtcbiAgICAgICAgaWYgKCFub2RlLmtleXMpIHtcbiAgICAgICAgICAgIGtleXMuc29ydCgpO1xuICAgICAgICAgICAgdmFyIGpzb24gPSBKU09OLnN0cmluZ2lmeShrZXlzKTtcbiAgICAgICAgICAgIGlmICghKG5vZGUua2V5cyA9IHRoaXMua2V5c0J5SlNPTi5nZXQoanNvbikpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlzQnlKU09OLnNldChqc29uLCBub2RlLmtleXMgPSB7IHNvcnRlZDoga2V5cywganNvbjoganNvbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS5rZXlzO1xuICAgIH07XG4gICAgcmV0dXJuIE9iamVjdENhbm9uO1xufSgpKTtcbnZhciBjYW5vbmljYWxTdHJpbmdpZnkgPSBPYmplY3QuYXNzaWduKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh1dGlsaXRpZXMuaXNOb25OdWxsT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBpZiAoc3RyaW5naWZ5Q2Fub24gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmVzZXRDYW5vbmljYWxTdHJpbmdpZnkoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2Fub25pY2FsID0gc3RyaW5naWZ5Q2Fub24uYWRtaXQodmFsdWUpO1xuICAgICAgICB2YXIganNvbiA9IHN0cmluZ2lmeUNhY2hlLmdldChjYW5vbmljYWwpO1xuICAgICAgICBpZiAoanNvbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBzdHJpbmdpZnlDYWNoZS5zZXQoY2Fub25pY2FsLCBqc29uID0gSlNPTi5zdHJpbmdpZnkoY2Fub25pY2FsKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG59LCB7XG4gICAgcmVzZXQ6IHJlc2V0Q2Fub25pY2FsU3RyaW5naWZ5LFxufSk7XG52YXIgc3RyaW5naWZ5Q2Fub247XG52YXIgc3RyaW5naWZ5Q2FjaGU7XG5mdW5jdGlvbiByZXNldENhbm9uaWNhbFN0cmluZ2lmeSgpIHtcbiAgICBzdHJpbmdpZnlDYW5vbiA9IG5ldyBPYmplY3RDYW5vbjtcbiAgICBzdHJpbmdpZnlDYWNoZSA9IG5ldyAodXRpbGl0aWVzLmNhblVzZVdlYWtNYXAgPyBXZWFrTWFwIDogTWFwKSgpO1xufVxuXG5mdW5jdGlvbiBleGVjU2VsZWN0aW9uU2V0S2V5QXJncyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgb3B0aW9ucy5zZWxlY3Rpb25TZXQsXG4gICAgICAgIG9wdGlvbnMub2JqZWN0T3JSZWZlcmVuY2UsXG4gICAgICAgIG9wdGlvbnMuY29udGV4dCxcbiAgICAgICAgb3B0aW9ucy5jb250ZXh0LmNhbm9uaXplUmVzdWx0cyxcbiAgICBdO1xufVxudmFyIFN0b3JlUmVhZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdG9yZVJlYWRlcihjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5rbm93blJlc3VsdHMgPSBuZXcgKHV0aWxpdGllcy5jYW5Vc2VXZWFrTWFwID8gV2Vha01hcCA6IE1hcCkoKTtcbiAgICAgICAgdGhpcy5jb25maWcgPSB1dGlsaXRpZXMuY29tcGFjdChjb25maWcsIHtcbiAgICAgICAgICAgIGFkZFR5cGVuYW1lOiBjb25maWcuYWRkVHlwZW5hbWUgIT09IGZhbHNlLFxuICAgICAgICAgICAgY2Fub25pemVSZXN1bHRzOiBzaG91bGRDYW5vbml6ZVJlc3VsdHMoY29uZmlnKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2Fub24gPSBjb25maWcuY2Fub24gfHwgbmV3IE9iamVjdENhbm9uO1xuICAgICAgICB0aGlzLmV4ZWN1dGVTZWxlY3Rpb25TZXQgPSBvcHRpbWlzbS53cmFwKGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgY2Fub25pemVSZXN1bHRzID0gb3B0aW9ucy5jb250ZXh0LmNhbm9uaXplUmVzdWx0cztcbiAgICAgICAgICAgIHZhciBwZWVrQXJncyA9IGV4ZWNTZWxlY3Rpb25TZXRLZXlBcmdzKG9wdGlvbnMpO1xuICAgICAgICAgICAgcGVla0FyZ3NbM10gPSAhY2Fub25pemVSZXN1bHRzO1xuICAgICAgICAgICAgdmFyIG90aGVyID0gKF9hID0gX3RoaXMuZXhlY3V0ZVNlbGVjdGlvblNldCkucGVlay5hcHBseShfYSwgcGVla0FyZ3MpO1xuICAgICAgICAgICAgaWYgKG90aGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbm9uaXplUmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIG90aGVyKSwgeyByZXN1bHQ6IF90aGlzLmNhbm9uLmFkbWl0KG90aGVyLnJlc3VsdCkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1heWJlRGVwZW5kT25FeGlzdGVuY2VPZkVudGl0eShvcHRpb25zLmNvbnRleHQuc3RvcmUsIG9wdGlvbnMuZW5jbG9zaW5nUmVmLl9fcmVmKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5leGVjU2VsZWN0aW9uU2V0SW1wbChvcHRpb25zKTtcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbWF4OiB0aGlzLmNvbmZpZy5yZXN1bHRDYWNoZU1heFNpemUsXG4gICAgICAgICAgICBrZXlBcmdzOiBleGVjU2VsZWN0aW9uU2V0S2V5QXJncyxcbiAgICAgICAgICAgIG1ha2VDYWNoZUtleTogZnVuY3Rpb24gKHNlbGVjdGlvblNldCwgcGFyZW50LCBjb250ZXh0LCBjYW5vbml6ZVJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydHNSZXN1bHRDYWNoaW5nKGNvbnRleHQuc3RvcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LnN0b3JlLm1ha2VDYWNoZUtleShzZWxlY3Rpb25TZXQsIHV0aWxpdGllcy5pc1JlZmVyZW5jZShwYXJlbnQpID8gcGFyZW50Ll9fcmVmIDogcGFyZW50LCBjb250ZXh0LnZhclN0cmluZywgY2Fub25pemVSZXN1bHRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV4ZWN1dGVTdWJTZWxlY3RlZEFycmF5ID0gb3B0aW1pc20ud3JhcChmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgbWF5YmVEZXBlbmRPbkV4aXN0ZW5jZU9mRW50aXR5KG9wdGlvbnMuY29udGV4dC5zdG9yZSwgb3B0aW9ucy5lbmNsb3NpbmdSZWYuX19yZWYpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmV4ZWNTdWJTZWxlY3RlZEFycmF5SW1wbChvcHRpb25zKTtcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbWF4OiB0aGlzLmNvbmZpZy5yZXN1bHRDYWNoZU1heFNpemUsXG4gICAgICAgICAgICBtYWtlQ2FjaGVLZXk6IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IF9hLmZpZWxkLCBhcnJheSA9IF9hLmFycmF5LCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydHNSZXN1bHRDYWNoaW5nKGNvbnRleHQuc3RvcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0LnN0b3JlLm1ha2VDYWNoZUtleShmaWVsZCwgYXJyYXksIGNvbnRleHQudmFyU3RyaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBTdG9yZVJlYWRlci5wcm90b3R5cGUucmVzZXRDYW5vbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jYW5vbiA9IG5ldyBPYmplY3RDYW5vbjtcbiAgICB9O1xuICAgIFN0b3JlUmVhZGVyLnByb3RvdHlwZS5kaWZmUXVlcnlBZ2FpbnN0U3RvcmUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIHN0b3JlID0gX2Euc3RvcmUsIHF1ZXJ5ID0gX2EucXVlcnksIF9iID0gX2Eucm9vdElkLCByb290SWQgPSBfYiA9PT0gdm9pZCAwID8gJ1JPT1RfUVVFUlknIDogX2IsIHZhcmlhYmxlcyA9IF9hLnZhcmlhYmxlcywgX2MgPSBfYS5yZXR1cm5QYXJ0aWFsRGF0YSwgcmV0dXJuUGFydGlhbERhdGEgPSBfYyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9jLCBfZCA9IF9hLmNhbm9uaXplUmVzdWx0cywgY2Fub25pemVSZXN1bHRzID0gX2QgPT09IHZvaWQgMCA/IHRoaXMuY29uZmlnLmNhbm9uaXplUmVzdWx0cyA6IF9kO1xuICAgICAgICB2YXIgcG9saWNpZXMgPSB0aGlzLmNvbmZpZy5jYWNoZS5wb2xpY2llcztcbiAgICAgICAgdmFyaWFibGVzID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIHV0aWxpdGllcy5nZXREZWZhdWx0VmFsdWVzKHV0aWxpdGllcy5nZXRRdWVyeURlZmluaXRpb24ocXVlcnkpKSksIHZhcmlhYmxlcyk7XG4gICAgICAgIHZhciByb290UmVmID0gdXRpbGl0aWVzLm1ha2VSZWZlcmVuY2Uocm9vdElkKTtcbiAgICAgICAgdmFyIGV4ZWNSZXN1bHQgPSB0aGlzLmV4ZWN1dGVTZWxlY3Rpb25TZXQoe1xuICAgICAgICAgICAgc2VsZWN0aW9uU2V0OiB1dGlsaXRpZXMuZ2V0TWFpbkRlZmluaXRpb24ocXVlcnkpLnNlbGVjdGlvblNldCxcbiAgICAgICAgICAgIG9iamVjdE9yUmVmZXJlbmNlOiByb290UmVmLFxuICAgICAgICAgICAgZW5jbG9zaW5nUmVmOiByb290UmVmLFxuICAgICAgICAgICAgY29udGV4dDogdHNsaWIuX19hc3NpZ24oeyBzdG9yZTogc3RvcmUsIHF1ZXJ5OiBxdWVyeSwgcG9saWNpZXM6IHBvbGljaWVzLCB2YXJpYWJsZXM6IHZhcmlhYmxlcywgdmFyU3RyaW5nOiBjYW5vbmljYWxTdHJpbmdpZnkodmFyaWFibGVzKSwgY2Fub25pemVSZXN1bHRzOiBjYW5vbml6ZVJlc3VsdHMgfSwgZXh0cmFjdEZyYWdtZW50Q29udGV4dChxdWVyeSwgdGhpcy5jb25maWcuZnJhZ21lbnRzKSksXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbWlzc2luZztcbiAgICAgICAgaWYgKGV4ZWNSZXN1bHQubWlzc2luZykge1xuICAgICAgICAgICAgbWlzc2luZyA9IFtuZXcgTWlzc2luZ0ZpZWxkRXJyb3IoZmlyc3RNaXNzaW5nKGV4ZWNSZXN1bHQubWlzc2luZyksIGV4ZWNSZXN1bHQubWlzc2luZywgcXVlcnksIHZhcmlhYmxlcyldO1xuICAgICAgICAgICAgaWYgKCFyZXR1cm5QYXJ0aWFsRGF0YSkge1xuICAgICAgICAgICAgICAgIHRocm93IG1pc3NpbmdbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3VsdDogZXhlY1Jlc3VsdC5yZXN1bHQsXG4gICAgICAgICAgICBjb21wbGV0ZTogIW1pc3NpbmcsXG4gICAgICAgICAgICBtaXNzaW5nOiBtaXNzaW5nLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgU3RvcmVSZWFkZXIucHJvdG90eXBlLmlzRnJlc2ggPSBmdW5jdGlvbiAocmVzdWx0LCBwYXJlbnQsIHNlbGVjdGlvblNldCwgY29udGV4dCkge1xuICAgICAgICBpZiAoc3VwcG9ydHNSZXN1bHRDYWNoaW5nKGNvbnRleHQuc3RvcmUpICYmXG4gICAgICAgICAgICB0aGlzLmtub3duUmVzdWx0cy5nZXQocmVzdWx0KSA9PT0gc2VsZWN0aW9uU2V0KSB7XG4gICAgICAgICAgICB2YXIgbGF0ZXN0ID0gdGhpcy5leGVjdXRlU2VsZWN0aW9uU2V0LnBlZWsoc2VsZWN0aW9uU2V0LCBwYXJlbnQsIGNvbnRleHQsIHRoaXMuY2Fub24uaXNLbm93bihyZXN1bHQpKTtcbiAgICAgICAgICAgIGlmIChsYXRlc3QgJiYgcmVzdWx0ID09PSBsYXRlc3QucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgU3RvcmVSZWFkZXIucHJvdG90eXBlLmV4ZWNTZWxlY3Rpb25TZXRJbXBsID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxlY3Rpb25TZXQgPSBfYS5zZWxlY3Rpb25TZXQsIG9iamVjdE9yUmVmZXJlbmNlID0gX2Eub2JqZWN0T3JSZWZlcmVuY2UsIGVuY2xvc2luZ1JlZiA9IF9hLmVuY2xvc2luZ1JlZiwgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgIGlmICh1dGlsaXRpZXMuaXNSZWZlcmVuY2Uob2JqZWN0T3JSZWZlcmVuY2UpICYmXG4gICAgICAgICAgICAhY29udGV4dC5wb2xpY2llcy5yb290VHlwZW5hbWVzQnlJZFtvYmplY3RPclJlZmVyZW5jZS5fX3JlZl0gJiZcbiAgICAgICAgICAgICFjb250ZXh0LnN0b3JlLmhhcyhvYmplY3RPclJlZmVyZW5jZS5fX3JlZikpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiB0aGlzLmNhbm9uLmVtcHR5LFxuICAgICAgICAgICAgICAgIG1pc3Npbmc6IFwiRGFuZ2xpbmcgcmVmZXJlbmNlIHRvIG1pc3NpbmcgXCIuY29uY2F0KG9iamVjdE9yUmVmZXJlbmNlLl9fcmVmLCBcIiBvYmplY3RcIiksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YXJpYWJsZXMgPSBjb250ZXh0LnZhcmlhYmxlcywgcG9saWNpZXMgPSBjb250ZXh0LnBvbGljaWVzLCBzdG9yZSA9IGNvbnRleHQuc3RvcmU7XG4gICAgICAgIHZhciB0eXBlbmFtZSA9IHN0b3JlLmdldEZpZWxkVmFsdWUob2JqZWN0T3JSZWZlcmVuY2UsIFwiX190eXBlbmFtZVwiKTtcbiAgICAgICAgdmFyIG9iamVjdHNUb01lcmdlID0gW107XG4gICAgICAgIHZhciBtaXNzaW5nO1xuICAgICAgICB2YXIgbWlzc2luZ01lcmdlciA9IG5ldyB1dGlsaXRpZXMuRGVlcE1lcmdlcigpO1xuICAgICAgICBpZiAodGhpcy5jb25maWcuYWRkVHlwZW5hbWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB0eXBlbmFtZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgIXBvbGljaWVzLnJvb3RJZHNCeVR5cGVuYW1lW3R5cGVuYW1lXSkge1xuICAgICAgICAgICAgb2JqZWN0c1RvTWVyZ2UucHVzaCh7IF9fdHlwZW5hbWU6IHR5cGVuYW1lIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZU1pc3NpbmcocmVzdWx0LCByZXN1bHROYW1lKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lm1pc3NpbmcpIHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nID0gbWlzc2luZ01lcmdlci5tZXJnZShtaXNzaW5nLCAoX2EgPSB7fSwgX2FbcmVzdWx0TmFtZV0gPSByZXN1bHQubWlzc2luZywgX2EpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHZhciB3b3JrU2V0ID0gbmV3IFNldChzZWxlY3Rpb25TZXQuc2VsZWN0aW9ucyk7XG4gICAgICAgIHdvcmtTZXQuZm9yRWFjaChmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKCF1dGlsaXRpZXMuc2hvdWxkSW5jbHVkZShzZWxlY3Rpb24sIHZhcmlhYmxlcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHV0aWxpdGllcy5pc0ZpZWxkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRWYWx1ZSA9IHBvbGljaWVzLnJlYWRGaWVsZCh7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZTogc2VsZWN0aW9uLm5hbWUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBzZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogY29udGV4dC52YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgIGZyb206IG9iamVjdE9yUmVmZXJlbmNlLFxuICAgICAgICAgICAgICAgIH0sIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHROYW1lID0gdXRpbGl0aWVzLnJlc3VsdEtleU5hbWVGcm9tRmllbGQoc2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdXRpbGl0aWVzLmFkZFR5cGVuYW1lVG9Eb2N1bWVudC5hZGRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaXNzaW5nID0gbWlzc2luZ01lcmdlci5tZXJnZShtaXNzaW5nLCAoX2EgPSB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYVtyZXN1bHROYW1lXSA9IFwiQ2FuJ3QgZmluZCBmaWVsZCAnXCIuY29uY2F0KHNlbGVjdGlvbi5uYW1lLnZhbHVlLCBcIicgb24gXCIpLmNvbmNhdCh1dGlsaXRpZXMuaXNSZWZlcmVuY2Uob2JqZWN0T3JSZWZlcmVuY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gb2JqZWN0T3JSZWZlcmVuY2UuX19yZWYgKyBcIiBvYmplY3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwib2JqZWN0IFwiICsgSlNPTi5zdHJpbmdpZnkob2JqZWN0T3JSZWZlcmVuY2UsIG51bGwsIDIpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXkoZmllbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRWYWx1ZSA9IGhhbmRsZU1pc3NpbmcoX3RoaXMuZXhlY3V0ZVN1YlNlbGVjdGVkQXJyYXkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5OiBmaWVsZFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5jbG9zaW5nUmVmOiBlbmNsb3NpbmdSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICB9KSwgcmVzdWx0TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzZWxlY3Rpb24uc2VsZWN0aW9uU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LmNhbm9uaXplUmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRWYWx1ZSA9IF90aGlzLmNhbm9uLnBhc3MoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmllbGRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkVmFsdWUgPSBoYW5kbGVNaXNzaW5nKF90aGlzLmV4ZWN1dGVTZWxlY3Rpb25TZXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uU2V0OiBzZWxlY3Rpb24uc2VsZWN0aW9uU2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0T3JSZWZlcmVuY2U6IGZpZWxkVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNsb3NpbmdSZWY6IHV0aWxpdGllcy5pc1JlZmVyZW5jZShmaWVsZFZhbHVlKSA/IGZpZWxkVmFsdWUgOiBlbmNsb3NpbmdSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICB9KSwgcmVzdWx0TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmaWVsZFZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0c1RvTWVyZ2UucHVzaCgoX2IgPSB7fSwgX2JbcmVzdWx0TmFtZV0gPSBmaWVsZFZhbHVlLCBfYikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IHV0aWxpdGllcy5nZXRGcmFnbWVudEZyb21TZWxlY3Rpb24oc2VsZWN0aW9uLCBjb250ZXh0Lmxvb2t1cEZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoIWZyYWdtZW50ICYmIHNlbGVjdGlvbi5raW5kID09PSBncmFwaHFsLktpbmQuRlJBR01FTlRfU1BSRUFEKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IF9fREVWX18gPyBuZXcgZ2xvYmFscy5JbnZhcmlhbnRFcnJvcihcIk5vIGZyYWdtZW50IG5hbWVkIFwiLmNvbmNhdChzZWxlY3Rpb24ubmFtZS52YWx1ZSkpIDogbmV3IGdsb2JhbHMuSW52YXJpYW50RXJyb3IoNSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmcmFnbWVudCAmJiBwb2xpY2llcy5mcmFnbWVudE1hdGNoZXMoZnJhZ21lbnQsIHR5cGVuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC5zZWxlY3Rpb25TZXQuc2VsZWN0aW9ucy5mb3JFYWNoKHdvcmtTZXQuYWRkLCB3b3JrU2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdXRpbGl0aWVzLm1lcmdlRGVlcEFycmF5KG9iamVjdHNUb01lcmdlKTtcbiAgICAgICAgdmFyIGZpbmFsUmVzdWx0ID0geyByZXN1bHQ6IHJlc3VsdCwgbWlzc2luZzogbWlzc2luZyB9O1xuICAgICAgICB2YXIgZnJvemVuID0gY29udGV4dC5jYW5vbml6ZVJlc3VsdHNcbiAgICAgICAgICAgID8gdGhpcy5jYW5vbi5hZG1pdChmaW5hbFJlc3VsdClcbiAgICAgICAgICAgIDogdXRpbGl0aWVzLm1heWJlRGVlcEZyZWV6ZShmaW5hbFJlc3VsdCk7XG4gICAgICAgIGlmIChmcm96ZW4ucmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmtub3duUmVzdWx0cy5zZXQoZnJvemVuLnJlc3VsdCwgc2VsZWN0aW9uU2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJvemVuO1xuICAgIH07XG4gICAgU3RvcmVSZWFkZXIucHJvdG90eXBlLmV4ZWNTdWJTZWxlY3RlZEFycmF5SW1wbCA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZmllbGQgPSBfYS5maWVsZCwgYXJyYXkgPSBfYS5hcnJheSwgZW5jbG9zaW5nUmVmID0gX2EuZW5jbG9zaW5nUmVmLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIG1pc3Npbmc7XG4gICAgICAgIHZhciBtaXNzaW5nTWVyZ2VyID0gbmV3IHV0aWxpdGllcy5EZWVwTWVyZ2VyKCk7XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZU1pc3NpbmcoY2hpbGRSZXN1bHQsIGkpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmIChjaGlsZFJlc3VsdC5taXNzaW5nKSB7XG4gICAgICAgICAgICAgICAgbWlzc2luZyA9IG1pc3NpbmdNZXJnZXIubWVyZ2UobWlzc2luZywgKF9hID0ge30sIF9hW2ldID0gY2hpbGRSZXN1bHQubWlzc2luZywgX2EpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaGlsZFJlc3VsdC5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkLnNlbGVjdGlvblNldCkge1xuICAgICAgICAgICAgYXJyYXkgPSBhcnJheS5maWx0ZXIoY29udGV4dC5zdG9yZS5jYW5SZWFkKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheSA9IGFycmF5Lm1hcChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZU1pc3NpbmcoX3RoaXMuZXhlY3V0ZVN1YlNlbGVjdGVkQXJyYXkoe1xuICAgICAgICAgICAgICAgICAgICBmaWVsZDogZmllbGQsXG4gICAgICAgICAgICAgICAgICAgIGFycmF5OiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICBlbmNsb3NpbmdSZWY6IGVuY2xvc2luZ1JlZixcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICB9KSwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmllbGQuc2VsZWN0aW9uU2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZU1pc3NpbmcoX3RoaXMuZXhlY3V0ZVNlbGVjdGlvblNldCh7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblNldDogZmllbGQuc2VsZWN0aW9uU2V0LFxuICAgICAgICAgICAgICAgICAgICBvYmplY3RPclJlZmVyZW5jZTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgZW5jbG9zaW5nUmVmOiB1dGlsaXRpZXMuaXNSZWZlcmVuY2UoaXRlbSkgPyBpdGVtIDogZW5jbG9zaW5nUmVmLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgIH0pLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0U2VsZWN0aW9uU2V0Rm9ySWRWYWx1ZShjb250ZXh0LnN0b3JlLCBmaWVsZCwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN1bHQ6IGNvbnRleHQuY2Fub25pemVSZXN1bHRzID8gdGhpcy5jYW5vbi5hZG1pdChhcnJheSkgOiBhcnJheSxcbiAgICAgICAgICAgIG1pc3Npbmc6IG1pc3NpbmcsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gU3RvcmVSZWFkZXI7XG59KCkpO1xuZnVuY3Rpb24gZmlyc3RNaXNzaW5nKHRyZWUpIHtcbiAgICB0cnkge1xuICAgICAgICBKU09OLnN0cmluZ2lmeSh0cmVlLCBmdW5jdGlvbiAoXywgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0U2VsZWN0aW9uU2V0Rm9ySWRWYWx1ZShzdG9yZSwgZmllbGQsIGZpZWxkVmFsdWUpIHtcbiAgICBpZiAoIWZpZWxkLnNlbGVjdGlvblNldCkge1xuICAgICAgICB2YXIgd29ya1NldF8xID0gbmV3IFNldChbZmllbGRWYWx1ZV0pO1xuICAgICAgICB3b3JrU2V0XzEuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh1dGlsaXRpZXMuaXNOb25OdWxsT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIF9fREVWX18gPyBnbG9iYWxzLmludmFyaWFudCghdXRpbGl0aWVzLmlzUmVmZXJlbmNlKHZhbHVlKSwgXCJNaXNzaW5nIHNlbGVjdGlvbiBzZXQgZm9yIG9iamVjdCBvZiB0eXBlIFwiLmNvbmNhdChnZXRUeXBlbmFtZUZyb21TdG9yZU9iamVjdChzdG9yZSwgdmFsdWUpLCBcIiByZXR1cm5lZCBmb3IgcXVlcnkgZmllbGQgXCIpLmNvbmNhdChmaWVsZC5uYW1lLnZhbHVlKSkgOiBnbG9iYWxzLmludmFyaWFudCghdXRpbGl0aWVzLmlzUmVmZXJlbmNlKHZhbHVlKSwgNik7XG4gICAgICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyh2YWx1ZSkuZm9yRWFjaCh3b3JrU2V0XzEuYWRkLCB3b3JrU2V0XzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbnZhciBjYWNoZVNsb3QgPSBuZXcgY29udGV4dC5TbG90KCk7XG52YXIgY2FjaGVJbmZvTWFwID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGdldENhY2hlSW5mbyhjYWNoZSkge1xuICAgIHZhciBpbmZvID0gY2FjaGVJbmZvTWFwLmdldChjYWNoZSk7XG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICAgIGNhY2hlSW5mb01hcC5zZXQoY2FjaGUsIGluZm8gPSB7XG4gICAgICAgICAgICB2YXJzOiBuZXcgU2V0LFxuICAgICAgICAgICAgZGVwOiBvcHRpbWlzbS5kZXAoKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBpbmZvO1xufVxuZnVuY3Rpb24gZm9yZ2V0Q2FjaGUoY2FjaGUpIHtcbiAgICBnZXRDYWNoZUluZm8oY2FjaGUpLnZhcnMuZm9yRWFjaChmdW5jdGlvbiAocnYpIHsgcmV0dXJuIHJ2LmZvcmdldENhY2hlKGNhY2hlKTsgfSk7XG59XG5mdW5jdGlvbiByZWNhbGxDYWNoZShjYWNoZSkge1xuICAgIGdldENhY2hlSW5mbyhjYWNoZSkudmFycy5mb3JFYWNoKGZ1bmN0aW9uIChydikgeyByZXR1cm4gcnYuYXR0YWNoQ2FjaGUoY2FjaGUpOyB9KTtcbn1cbmZ1bmN0aW9uIG1ha2VWYXIodmFsdWUpIHtcbiAgICB2YXIgY2FjaGVzID0gbmV3IFNldCgpO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIHJ2ID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgY2FjaGVzLmZvckVhY2goZnVuY3Rpb24gKGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldENhY2hlSW5mbyhjYWNoZSkuZGVwLmRpcnR5KHJ2KTtcbiAgICAgICAgICAgICAgICAgICAgYnJvYWRjYXN0KGNhY2hlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkTGlzdGVuZXJzID0gQXJyYXkuZnJvbShsaXN0ZW5lcnMpO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIG9sZExpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gbGlzdGVuZXIodmFsdWUpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IGNhY2hlU2xvdC5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgYXR0YWNoKGNhY2hlKTtcbiAgICAgICAgICAgICAgICBnZXRDYWNoZUluZm8oY2FjaGUpLmRlcChydik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgcnYub25OZXh0Q2hhbmdlID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgYXR0YWNoID0gcnYuYXR0YWNoQ2FjaGUgPSBmdW5jdGlvbiAoY2FjaGUpIHtcbiAgICAgICAgY2FjaGVzLmFkZChjYWNoZSk7XG4gICAgICAgIGdldENhY2hlSW5mbyhjYWNoZSkudmFycy5hZGQocnYpO1xuICAgICAgICByZXR1cm4gcnY7XG4gICAgfTtcbiAgICBydi5mb3JnZXRDYWNoZSA9IGZ1bmN0aW9uIChjYWNoZSkgeyByZXR1cm4gY2FjaGVzLmRlbGV0ZShjYWNoZSk7IH07XG4gICAgcmV0dXJuIHJ2O1xufVxuZnVuY3Rpb24gYnJvYWRjYXN0KGNhY2hlKSB7XG4gICAgaWYgKGNhY2hlLmJyb2FkY2FzdFdhdGNoZXMpIHtcbiAgICAgICAgY2FjaGUuYnJvYWRjYXN0V2F0Y2hlcygpO1xuICAgIH1cbn1cblxudmFyIHNwZWNpZmllckluZm9DYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBsb29rdXBTcGVjaWZpZXJJbmZvKHNwZWMpIHtcbiAgICB2YXIgY2FjaGVLZXkgPSBKU09OLnN0cmluZ2lmeShzcGVjKTtcbiAgICByZXR1cm4gc3BlY2lmaWVySW5mb0NhY2hlW2NhY2hlS2V5XSB8fFxuICAgICAgICAoc3BlY2lmaWVySW5mb0NhY2hlW2NhY2hlS2V5XSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xufVxuZnVuY3Rpb24ga2V5RmllbGRzRm5Gcm9tU3BlY2lmaWVyKHNwZWNpZmllcikge1xuICAgIHZhciBpbmZvID0gbG9va3VwU3BlY2lmaWVySW5mbyhzcGVjaWZpZXIpO1xuICAgIHJldHVybiBpbmZvLmtleUZpZWxkc0ZuIHx8IChpbmZvLmtleUZpZWxkc0ZuID0gZnVuY3Rpb24gKG9iamVjdCwgY29udGV4dCkge1xuICAgICAgICB2YXIgZXh0cmFjdCA9IGZ1bmN0aW9uIChmcm9tLCBrZXkpIHsgcmV0dXJuIGNvbnRleHQucmVhZEZpZWxkKGtleSwgZnJvbSk7IH07XG4gICAgICAgIHZhciBrZXlPYmplY3QgPSBjb250ZXh0LmtleU9iamVjdCA9IGNvbGxlY3RTcGVjaWZpZXJQYXRocyhzcGVjaWZpZXIsIGZ1bmN0aW9uIChzY2hlbWFLZXlQYXRoKSB7XG4gICAgICAgICAgICB2YXIgZXh0cmFjdGVkID0gZXh0cmFjdEtleVBhdGgoY29udGV4dC5zdG9yZU9iamVjdCwgc2NoZW1hS2V5UGF0aCwgZXh0cmFjdCk7XG4gICAgICAgICAgICBpZiAoZXh0cmFjdGVkID09PSB2b2lkIDAgJiZcbiAgICAgICAgICAgICAgICBvYmplY3QgIT09IGNvbnRleHQuc3RvcmVPYmplY3QgJiZcbiAgICAgICAgICAgICAgICBoYXNPd24uY2FsbChvYmplY3QsIHNjaGVtYUtleVBhdGhbMF0pKSB7XG4gICAgICAgICAgICAgICAgZXh0cmFjdGVkID0gZXh0cmFjdEtleVBhdGgob2JqZWN0LCBzY2hlbWFLZXlQYXRoLCBleHRyYWN0S2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fREVWX18gPyBnbG9iYWxzLmludmFyaWFudChleHRyYWN0ZWQgIT09IHZvaWQgMCwgXCJNaXNzaW5nIGZpZWxkICdcIi5jb25jYXQoc2NoZW1hS2V5UGF0aC5qb2luKCcuJyksIFwiJyB3aGlsZSBleHRyYWN0aW5nIGtleUZpZWxkcyBmcm9tIFwiKS5jb25jYXQoSlNPTi5zdHJpbmdpZnkob2JqZWN0KSkpIDogZ2xvYmFscy5pbnZhcmlhbnQoZXh0cmFjdGVkICE9PSB2b2lkIDAsIDIpO1xuICAgICAgICAgICAgcmV0dXJuIGV4dHJhY3RlZDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChjb250ZXh0LnR5cGVuYW1lLCBcIjpcIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KGtleU9iamVjdCkpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24ga2V5QXJnc0ZuRnJvbVNwZWNpZmllcihzcGVjaWZpZXIpIHtcbiAgICB2YXIgaW5mbyA9IGxvb2t1cFNwZWNpZmllckluZm8oc3BlY2lmaWVyKTtcbiAgICByZXR1cm4gaW5mby5rZXlBcmdzRm4gfHwgKGluZm8ua2V5QXJnc0ZuID0gZnVuY3Rpb24gKGFyZ3MsIF9hKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IF9hLmZpZWxkLCB2YXJpYWJsZXMgPSBfYS52YXJpYWJsZXMsIGZpZWxkTmFtZSA9IF9hLmZpZWxkTmFtZTtcbiAgICAgICAgdmFyIGNvbGxlY3RlZCA9IGNvbGxlY3RTcGVjaWZpZXJQYXRocyhzcGVjaWZpZXIsIGZ1bmN0aW9uIChrZXlQYXRoKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RLZXkgPSBrZXlQYXRoWzBdO1xuICAgICAgICAgICAgdmFyIGZpcnN0Q2hhciA9IGZpcnN0S2V5LmNoYXJBdCgwKTtcbiAgICAgICAgICAgIGlmIChmaXJzdENoYXIgPT09IFwiQFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkICYmIHV0aWxpdGllcy5pc05vbkVtcHR5QXJyYXkoZmllbGQuZGlyZWN0aXZlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpcmVjdGl2ZU5hbWVfMSA9IGZpcnN0S2V5LnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IGZpZWxkLmRpcmVjdGl2ZXMuZmluZChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lLnZhbHVlID09PSBkaXJlY3RpdmVOYW1lXzE7IH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aXZlQXJncyA9IGQgJiYgdXRpbGl0aWVzLmFyZ3VtZW50c09iamVjdEZyb21GaWVsZChkLCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aXZlQXJncyAmJiBleHRyYWN0S2V5UGF0aChkaXJlY3RpdmVBcmdzLCBrZXlQYXRoLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0Q2hhciA9PT0gXCIkXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGVOYW1lID0gZmlyc3RLZXkuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlcyAmJiBoYXNPd24uY2FsbCh2YXJpYWJsZXMsIHZhcmlhYmxlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhcktleVBhdGggPSBrZXlQYXRoLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgICB2YXJLZXlQYXRoWzBdID0gdmFyaWFibGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXh0cmFjdEtleVBhdGgodmFyaWFibGVzLCB2YXJLZXlQYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXh0cmFjdEtleVBhdGgoYXJncywga2V5UGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc3VmZml4ID0gSlNPTi5zdHJpbmdpZnkoY29sbGVjdGVkKTtcbiAgICAgICAgaWYgKGFyZ3MgfHwgc3VmZml4ICE9PSBcInt9XCIpIHtcbiAgICAgICAgICAgIGZpZWxkTmFtZSArPSBcIjpcIiArIHN1ZmZpeDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmllbGROYW1lO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY29sbGVjdFNwZWNpZmllclBhdGhzKHNwZWNpZmllciwgZXh0cmFjdG9yKSB7XG4gICAgdmFyIG1lcmdlciA9IG5ldyB1dGlsaXRpZXMuRGVlcE1lcmdlcjtcbiAgICByZXR1cm4gZ2V0U3BlY2lmaWVyUGF0aHMoc3BlY2lmaWVyKS5yZWR1Y2UoZnVuY3Rpb24gKGNvbGxlY3RlZCwgcGF0aCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciB0b01lcmdlID0gZXh0cmFjdG9yKHBhdGgpO1xuICAgICAgICBpZiAodG9NZXJnZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgIHRvTWVyZ2UgPSAoX2EgPSB7fSwgX2FbcGF0aFtpXV0gPSB0b01lcmdlLCBfYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2xsZWN0ZWQgPSBtZXJnZXIubWVyZ2UoY29sbGVjdGVkLCB0b01lcmdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sbGVjdGVkO1xuICAgIH0sIE9iamVjdC5jcmVhdGUobnVsbCkpO1xufVxuZnVuY3Rpb24gZ2V0U3BlY2lmaWVyUGF0aHMoc3BlYykge1xuICAgIHZhciBpbmZvID0gbG9va3VwU3BlY2lmaWVySW5mbyhzcGVjKTtcbiAgICBpZiAoIWluZm8ucGF0aHMpIHtcbiAgICAgICAgdmFyIHBhdGhzXzEgPSBpbmZvLnBhdGhzID0gW107XG4gICAgICAgIHZhciBjdXJyZW50UGF0aF8xID0gW107XG4gICAgICAgIHNwZWMuZm9yRWFjaChmdW5jdGlvbiAocywgaSkge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkocykpIHtcbiAgICAgICAgICAgICAgICBnZXRTcGVjaWZpZXJQYXRocyhzKS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwYXRoc18xLnB1c2goY3VycmVudFBhdGhfMS5jb25jYXQocCkpOyB9KTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UGF0aF8xLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UGF0aF8xLnB1c2gocyk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KHNwZWNbaSArIDFdKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoc18xLnB1c2goY3VycmVudFBhdGhfMS5zbGljZSgwKSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYXRoXzEubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaW5mby5wYXRocztcbn1cbmZ1bmN0aW9uIGV4dHJhY3RLZXkob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0W2tleV07XG59XG5mdW5jdGlvbiBleHRyYWN0S2V5UGF0aChvYmplY3QsIHBhdGgsIGV4dHJhY3QpIHtcbiAgICBleHRyYWN0ID0gZXh0cmFjdCB8fCBleHRyYWN0S2V5O1xuICAgIHJldHVybiBub3JtYWxpemUocGF0aC5yZWR1Y2UoZnVuY3Rpb24gcmVkdWNlcihvYmosIGtleSkge1xuICAgICAgICByZXR1cm4gaXNBcnJheShvYmopXG4gICAgICAgICAgICA/IG9iai5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiByZWR1Y2VyKGNoaWxkLCBrZXkpOyB9KVxuICAgICAgICAgICAgOiBvYmogJiYgZXh0cmFjdChvYmosIGtleSk7XG4gICAgfSwgb2JqZWN0KSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemUodmFsdWUpIHtcbiAgICBpZiAodXRpbGl0aWVzLmlzTm9uTnVsbE9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKG5vcm1hbGl6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbGxlY3RTcGVjaWZpZXJQYXRocyhPYmplY3Qua2V5cyh2YWx1ZSkuc29ydCgpLCBmdW5jdGlvbiAocGF0aCkgeyByZXR1cm4gZXh0cmFjdEtleVBhdGgodmFsdWUsIHBhdGgpOyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG51dGlsaXRpZXMuZ2V0U3RvcmVLZXlOYW1lLnNldFN0cmluZ2lmeShjYW5vbmljYWxTdHJpbmdpZnkpO1xuZnVuY3Rpb24gYXJnc0Zyb21GaWVsZFNwZWNpZmllcihzcGVjKSB7XG4gICAgcmV0dXJuIHNwZWMuYXJncyAhPT0gdm9pZCAwID8gc3BlYy5hcmdzIDpcbiAgICAgICAgc3BlYy5maWVsZCA/IHV0aWxpdGllcy5hcmd1bWVudHNPYmplY3RGcm9tRmllbGQoc3BlYy5maWVsZCwgc3BlYy52YXJpYWJsZXMpIDogbnVsbDtcbn1cbnZhciBudWxsS2V5RmllbGRzRm4gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB2b2lkIDA7IH07XG52YXIgc2ltcGxlS2V5QXJnc0ZuID0gZnVuY3Rpb24gKF9hcmdzLCBjb250ZXh0KSB7IHJldHVybiBjb250ZXh0LmZpZWxkTmFtZTsgfTtcbnZhciBtZXJnZVRydWVGbiA9IGZ1bmN0aW9uIChleGlzdGluZywgaW5jb21pbmcsIF9hKSB7XG4gICAgdmFyIG1lcmdlT2JqZWN0cyA9IF9hLm1lcmdlT2JqZWN0cztcbiAgICByZXR1cm4gbWVyZ2VPYmplY3RzKGV4aXN0aW5nLCBpbmNvbWluZyk7XG59O1xudmFyIG1lcmdlRmFsc2VGbiA9IGZ1bmN0aW9uIChfLCBpbmNvbWluZykgeyByZXR1cm4gaW5jb21pbmc7IH07XG52YXIgUG9saWNpZXMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBvbGljaWVzKGNvbmZpZykge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy50eXBlUG9saWNpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLnRvQmVBZGRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuc3VwZXJ0eXBlTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmZ1enp5U3VidHlwZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucm9vdElkc0J5VHlwZW5hbWUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLnJvb3RUeXBlbmFtZXNCeUlkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy51c2luZ1Bvc3NpYmxlVHlwZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb25maWcgPSB0c2xpYi5fX2Fzc2lnbih7IGRhdGFJZEZyb21PYmplY3Q6IGRlZmF1bHREYXRhSWRGcm9tT2JqZWN0IH0sIGNvbmZpZyk7XG4gICAgICAgIHRoaXMuY2FjaGUgPSB0aGlzLmNvbmZpZy5jYWNoZTtcbiAgICAgICAgdGhpcy5zZXRSb290VHlwZW5hbWUoXCJRdWVyeVwiKTtcbiAgICAgICAgdGhpcy5zZXRSb290VHlwZW5hbWUoXCJNdXRhdGlvblwiKTtcbiAgICAgICAgdGhpcy5zZXRSb290VHlwZW5hbWUoXCJTdWJzY3JpcHRpb25cIik7XG4gICAgICAgIGlmIChjb25maWcucG9zc2libGVUeXBlcykge1xuICAgICAgICAgICAgdGhpcy5hZGRQb3NzaWJsZVR5cGVzKGNvbmZpZy5wb3NzaWJsZVR5cGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLnR5cGVQb2xpY2llcykge1xuICAgICAgICAgICAgdGhpcy5hZGRUeXBlUG9saWNpZXMoY29uZmlnLnR5cGVQb2xpY2llcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUG9saWNpZXMucHJvdG90eXBlLmlkZW50aWZ5ID0gZnVuY3Rpb24gKG9iamVjdCwgcGFydGlhbENvbnRleHQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgcG9saWNpZXMgPSB0aGlzO1xuICAgICAgICB2YXIgdHlwZW5hbWUgPSBwYXJ0aWFsQ29udGV4dCAmJiAocGFydGlhbENvbnRleHQudHlwZW5hbWUgfHxcbiAgICAgICAgICAgICgoX2EgPSBwYXJ0aWFsQ29udGV4dC5zdG9yZU9iamVjdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLl9fdHlwZW5hbWUpKSB8fCBvYmplY3QuX190eXBlbmFtZTtcbiAgICAgICAgaWYgKHR5cGVuYW1lID09PSB0aGlzLnJvb3RUeXBlbmFtZXNCeUlkLlJPT1RfUVVFUlkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXCJST09UX1FVRVJZXCJdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdG9yZU9iamVjdCA9IHBhcnRpYWxDb250ZXh0ICYmIHBhcnRpYWxDb250ZXh0LnN0b3JlT2JqZWN0IHx8IG9iamVjdDtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgcGFydGlhbENvbnRleHQpLCB7IHR5cGVuYW1lOiB0eXBlbmFtZSwgc3RvcmVPYmplY3Q6IHN0b3JlT2JqZWN0LCByZWFkRmllbGQ6IHBhcnRpYWxDb250ZXh0ICYmIHBhcnRpYWxDb250ZXh0LnJlYWRGaWVsZCB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBub3JtYWxpemVSZWFkRmllbGRPcHRpb25zKGFyZ3VtZW50cywgc3RvcmVPYmplY3QpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwb2xpY2llcy5yZWFkRmllbGQob3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZTogcG9saWNpZXMuY2FjaGVbXCJkYXRhXCJdLFxuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IG9wdGlvbnMudmFyaWFibGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgdmFyIGlkO1xuICAgICAgICB2YXIgcG9saWN5ID0gdHlwZW5hbWUgJiYgdGhpcy5nZXRUeXBlUG9saWN5KHR5cGVuYW1lKTtcbiAgICAgICAgdmFyIGtleUZuID0gcG9saWN5ICYmIHBvbGljeS5rZXlGbiB8fCB0aGlzLmNvbmZpZy5kYXRhSWRGcm9tT2JqZWN0O1xuICAgICAgICB3aGlsZSAoa2V5Rm4pIHtcbiAgICAgICAgICAgIHZhciBzcGVjaWZpZXJPcklkID0ga2V5Rm4ob2JqZWN0LCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHNwZWNpZmllck9ySWQpKSB7XG4gICAgICAgICAgICAgICAga2V5Rm4gPSBrZXlGaWVsZHNGbkZyb21TcGVjaWZpZXIoc3BlY2lmaWVyT3JJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZCA9IHNwZWNpZmllck9ySWQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWQgPSBpZCA/IFN0cmluZyhpZCkgOiB2b2lkIDA7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmtleU9iamVjdCA/IFtpZCwgY29udGV4dC5rZXlPYmplY3RdIDogW2lkXTtcbiAgICB9O1xuICAgIFBvbGljaWVzLnByb3RvdHlwZS5hZGRUeXBlUG9saWNpZXMgPSBmdW5jdGlvbiAodHlwZVBvbGljaWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIE9iamVjdC5rZXlzKHR5cGVQb2xpY2llcykuZm9yRWFjaChmdW5jdGlvbiAodHlwZW5hbWUpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHR5cGVQb2xpY2llc1t0eXBlbmFtZV0sIHF1ZXJ5VHlwZSA9IF9hLnF1ZXJ5VHlwZSwgbXV0YXRpb25UeXBlID0gX2EubXV0YXRpb25UeXBlLCBzdWJzY3JpcHRpb25UeXBlID0gX2Euc3Vic2NyaXB0aW9uVHlwZSwgaW5jb21pbmcgPSB0c2xpYi5fX3Jlc3QoX2EsIFtcInF1ZXJ5VHlwZVwiLCBcIm11dGF0aW9uVHlwZVwiLCBcInN1YnNjcmlwdGlvblR5cGVcIl0pO1xuICAgICAgICAgICAgaWYgKHF1ZXJ5VHlwZSlcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRSb290VHlwZW5hbWUoXCJRdWVyeVwiLCB0eXBlbmFtZSk7XG4gICAgICAgICAgICBpZiAobXV0YXRpb25UeXBlKVxuICAgICAgICAgICAgICAgIF90aGlzLnNldFJvb3RUeXBlbmFtZShcIk11dGF0aW9uXCIsIHR5cGVuYW1lKTtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25UeXBlKVxuICAgICAgICAgICAgICAgIF90aGlzLnNldFJvb3RUeXBlbmFtZShcIlN1YnNjcmlwdGlvblwiLCB0eXBlbmFtZSk7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoX3RoaXMudG9CZUFkZGVkLCB0eXBlbmFtZSkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy50b0JlQWRkZWRbdHlwZW5hbWVdLnB1c2goaW5jb21pbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudG9CZUFkZGVkW3R5cGVuYW1lXSA9IFtpbmNvbWluZ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUG9saWNpZXMucHJvdG90eXBlLnVwZGF0ZVR5cGVQb2xpY3kgPSBmdW5jdGlvbiAodHlwZW5hbWUsIGluY29taW5nKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBleGlzdGluZyA9IHRoaXMuZ2V0VHlwZVBvbGljeSh0eXBlbmFtZSk7XG4gICAgICAgIHZhciBrZXlGaWVsZHMgPSBpbmNvbWluZy5rZXlGaWVsZHMsIGZpZWxkcyA9IGluY29taW5nLmZpZWxkcztcbiAgICAgICAgZnVuY3Rpb24gc2V0TWVyZ2UoZXhpc3RpbmcsIG1lcmdlKSB7XG4gICAgICAgICAgICBleGlzdGluZy5tZXJnZSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIG1lcmdlID09PSBcImZ1bmN0aW9uXCIgPyBtZXJnZSA6XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlID09PSB0cnVlID8gbWVyZ2VUcnVlRm4gOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2UgPT09IGZhbHNlID8gbWVyZ2VGYWxzZUZuIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5tZXJnZTtcbiAgICAgICAgfVxuICAgICAgICBzZXRNZXJnZShleGlzdGluZywgaW5jb21pbmcubWVyZ2UpO1xuICAgICAgICBleGlzdGluZy5rZXlGbiA9XG4gICAgICAgICAgICBrZXlGaWVsZHMgPT09IGZhbHNlID8gbnVsbEtleUZpZWxkc0ZuIDpcbiAgICAgICAgICAgICAgICBpc0FycmF5KGtleUZpZWxkcykgPyBrZXlGaWVsZHNGbkZyb21TcGVjaWZpZXIoa2V5RmllbGRzKSA6XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBrZXlGaWVsZHMgPT09IFwiZnVuY3Rpb25cIiA/IGtleUZpZWxkcyA6XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5rZXlGbjtcbiAgICAgICAgaWYgKGZpZWxkcykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZmllbGRzKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmcgPSBfdGhpcy5nZXRGaWVsZFBvbGljeSh0eXBlbmFtZSwgZmllbGROYW1lLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5jb21pbmcgPSBmaWVsZHNbZmllbGROYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGluY29taW5nID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcucmVhZCA9IGluY29taW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleUFyZ3MgPSBpbmNvbWluZy5rZXlBcmdzLCByZWFkID0gaW5jb21pbmcucmVhZCwgbWVyZ2UgPSBpbmNvbWluZy5tZXJnZTtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3Rpbmcua2V5Rm4gPVxuICAgICAgICAgICAgICAgICAgICAgICAga2V5QXJncyA9PT0gZmFsc2UgPyBzaW1wbGVLZXlBcmdzRm4gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQXJyYXkoa2V5QXJncykgPyBrZXlBcmdzRm5Gcm9tU3BlY2lmaWVyKGtleUFyZ3MpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGtleUFyZ3MgPT09IFwiZnVuY3Rpb25cIiA/IGtleUFyZ3MgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3Rpbmcua2V5Rm47XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVhZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5yZWFkID0gcmVhZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRNZXJnZShleGlzdGluZywgbWVyZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmcucmVhZCAmJiBleGlzdGluZy5tZXJnZSkge1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5rZXlGbiA9IGV4aXN0aW5nLmtleUZuIHx8IHNpbXBsZUtleUFyZ3NGbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUG9saWNpZXMucHJvdG90eXBlLnNldFJvb3RUeXBlbmFtZSA9IGZ1bmN0aW9uICh3aGljaCwgdHlwZW5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVuYW1lID09PSB2b2lkIDApIHsgdHlwZW5hbWUgPSB3aGljaDsgfVxuICAgICAgICB2YXIgcm9vdElkID0gXCJST09UX1wiICsgd2hpY2gudG9VcHBlckNhc2UoKTtcbiAgICAgICAgdmFyIG9sZCA9IHRoaXMucm9vdFR5cGVuYW1lc0J5SWRbcm9vdElkXTtcbiAgICAgICAgaWYgKHR5cGVuYW1lICE9PSBvbGQpIHtcbiAgICAgICAgICAgIF9fREVWX18gPyBnbG9iYWxzLmludmFyaWFudCghb2xkIHx8IG9sZCA9PT0gd2hpY2gsIFwiQ2Fubm90IGNoYW5nZSByb290IFwiLmNvbmNhdCh3aGljaCwgXCIgX190eXBlbmFtZSBtb3JlIHRoYW4gb25jZVwiKSkgOiBnbG9iYWxzLmludmFyaWFudCghb2xkIHx8IG9sZCA9PT0gd2hpY2gsIDMpO1xuICAgICAgICAgICAgaWYgKG9sZClcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5yb290SWRzQnlUeXBlbmFtZVtvbGRdO1xuICAgICAgICAgICAgdGhpcy5yb290SWRzQnlUeXBlbmFtZVt0eXBlbmFtZV0gPSByb290SWQ7XG4gICAgICAgICAgICB0aGlzLnJvb3RUeXBlbmFtZXNCeUlkW3Jvb3RJZF0gPSB0eXBlbmFtZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUG9saWNpZXMucHJvdG90eXBlLmFkZFBvc3NpYmxlVHlwZXMgPSBmdW5jdGlvbiAocG9zc2libGVUeXBlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnVzaW5nUG9zc2libGVUeXBlcyA9IHRydWU7XG4gICAgICAgIE9iamVjdC5rZXlzKHBvc3NpYmxlVHlwZXMpLmZvckVhY2goZnVuY3Rpb24gKHN1cGVydHlwZSkge1xuICAgICAgICAgICAgX3RoaXMuZ2V0U3VwZXJ0eXBlU2V0KHN1cGVydHlwZSwgdHJ1ZSk7XG4gICAgICAgICAgICBwb3NzaWJsZVR5cGVzW3N1cGVydHlwZV0uZm9yRWFjaChmdW5jdGlvbiAoc3VidHlwZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmdldFN1cGVydHlwZVNldChzdWJ0eXBlLCB0cnVlKS5hZGQoc3VwZXJ0eXBlKTtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBzdWJ0eXBlLm1hdGNoKFR5cGVPckZpZWxkTmFtZVJlZ0V4cCk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaCB8fCBtYXRjaFswXSAhPT0gc3VidHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5mdXp6eVN1YnR5cGVzLnNldChzdWJ0eXBlLCBuZXcgUmVnRXhwKHN1YnR5cGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQb2xpY2llcy5wcm90b3R5cGUuZ2V0VHlwZVBvbGljeSA9IGZ1bmN0aW9uICh0eXBlbmFtZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIWhhc093bi5jYWxsKHRoaXMudHlwZVBvbGljaWVzLCB0eXBlbmFtZSkpIHtcbiAgICAgICAgICAgIHZhciBwb2xpY3lfMSA9IHRoaXMudHlwZVBvbGljaWVzW3R5cGVuYW1lXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBwb2xpY3lfMS5maWVsZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgdmFyIHN1cGVydHlwZXMgPSB0aGlzLnN1cGVydHlwZU1hcC5nZXQodHlwZW5hbWUpO1xuICAgICAgICAgICAgaWYgKHN1cGVydHlwZXMgJiYgc3VwZXJ0eXBlcy5zaXplKSB7XG4gICAgICAgICAgICAgICAgc3VwZXJ0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdXBlcnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMuZ2V0VHlwZVBvbGljeShzdXBlcnR5cGUpLCBmaWVsZHMgPSBfYS5maWVsZHMsIHJlc3QgPSB0c2xpYi5fX3Jlc3QoX2EsIFtcImZpZWxkc1wiXSk7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocG9saWN5XzEsIHJlc3QpO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHBvbGljeV8xLmZpZWxkcywgZmllbGRzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5ib3ggPSB0aGlzLnRvQmVBZGRlZFt0eXBlbmFtZV07XG4gICAgICAgIGlmIChpbmJveCAmJiBpbmJveC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGluYm94LnNwbGljZSgwKS5mb3JFYWNoKGZ1bmN0aW9uIChwb2xpY3kpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVUeXBlUG9saWN5KHR5cGVuYW1lLCBwb2xpY3kpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZVBvbGljaWVzW3R5cGVuYW1lXTtcbiAgICB9O1xuICAgIFBvbGljaWVzLnByb3RvdHlwZS5nZXRGaWVsZFBvbGljeSA9IGZ1bmN0aW9uICh0eXBlbmFtZSwgZmllbGROYW1lLCBjcmVhdGVJZk1pc3NpbmcpIHtcbiAgICAgICAgaWYgKHR5cGVuYW1lKSB7XG4gICAgICAgICAgICB2YXIgZmllbGRQb2xpY2llcyA9IHRoaXMuZ2V0VHlwZVBvbGljeSh0eXBlbmFtZSkuZmllbGRzO1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkUG9saWNpZXNbZmllbGROYW1lXSB8fCAoY3JlYXRlSWZNaXNzaW5nICYmIChmaWVsZFBvbGljaWVzW2ZpZWxkTmFtZV0gPSBPYmplY3QuY3JlYXRlKG51bGwpKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBvbGljaWVzLnByb3RvdHlwZS5nZXRTdXBlcnR5cGVTZXQgPSBmdW5jdGlvbiAoc3VidHlwZSwgY3JlYXRlSWZNaXNzaW5nKSB7XG4gICAgICAgIHZhciBzdXBlcnR5cGVTZXQgPSB0aGlzLnN1cGVydHlwZU1hcC5nZXQoc3VidHlwZSk7XG4gICAgICAgIGlmICghc3VwZXJ0eXBlU2V0ICYmIGNyZWF0ZUlmTWlzc2luZykge1xuICAgICAgICAgICAgdGhpcy5zdXBlcnR5cGVNYXAuc2V0KHN1YnR5cGUsIHN1cGVydHlwZVNldCA9IG5ldyBTZXQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVydHlwZVNldDtcbiAgICB9O1xuICAgIFBvbGljaWVzLnByb3RvdHlwZS5mcmFnbWVudE1hdGNoZXMgPSBmdW5jdGlvbiAoZnJhZ21lbnQsIHR5cGVuYW1lLCByZXN1bHQsIHZhcmlhYmxlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIWZyYWdtZW50LnR5cGVDb25kaXRpb24pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCF0eXBlbmFtZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIHN1cGVydHlwZSA9IGZyYWdtZW50LnR5cGVDb25kaXRpb24ubmFtZS52YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVuYW1lID09PSBzdXBlcnR5cGUpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMudXNpbmdQb3NzaWJsZVR5cGVzICYmXG4gICAgICAgICAgICB0aGlzLnN1cGVydHlwZU1hcC5oYXMoc3VwZXJ0eXBlKSkge1xuICAgICAgICAgICAgdmFyIHR5cGVuYW1lU3VwZXJ0eXBlU2V0ID0gdGhpcy5nZXRTdXBlcnR5cGVTZXQodHlwZW5hbWUsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHdvcmtRdWV1ZV8xID0gW3R5cGVuYW1lU3VwZXJ0eXBlU2V0XTtcbiAgICAgICAgICAgIHZhciBtYXliZUVucXVldWVfMSA9IGZ1bmN0aW9uIChzdWJ0eXBlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1cGVydHlwZVNldCA9IF90aGlzLmdldFN1cGVydHlwZVNldChzdWJ0eXBlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN1cGVydHlwZVNldCAmJlxuICAgICAgICAgICAgICAgICAgICBzdXBlcnR5cGVTZXQuc2l6ZSAmJlxuICAgICAgICAgICAgICAgICAgICB3b3JrUXVldWVfMS5pbmRleE9mKHN1cGVydHlwZVNldCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtRdWV1ZV8xLnB1c2goc3VwZXJ0eXBlU2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG5lZWRUb0NoZWNrRnV6enlTdWJ0eXBlcyA9ICEhKHJlc3VsdCAmJiB0aGlzLmZ1enp5U3VidHlwZXMuc2l6ZSk7XG4gICAgICAgICAgICB2YXIgY2hlY2tpbmdGdXp6eVN1YnR5cGVzID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmtRdWV1ZV8xLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1cGVydHlwZVNldCA9IHdvcmtRdWV1ZV8xW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzdXBlcnR5cGVTZXQuaGFzKHN1cGVydHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0eXBlbmFtZVN1cGVydHlwZVNldC5oYXMoc3VwZXJ0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNraW5nRnV6enlTdWJ0eXBlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fREVWX18gJiYgZ2xvYmFscy5pbnZhcmlhbnQud2FybihcIkluZmVycmluZyBzdWJ0eXBlIFwiLmNvbmNhdCh0eXBlbmFtZSwgXCIgb2Ygc3VwZXJ0eXBlIFwiKS5jb25jYXQoc3VwZXJ0eXBlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlbmFtZVN1cGVydHlwZVNldC5hZGQoc3VwZXJ0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3VwZXJ0eXBlU2V0LmZvckVhY2gobWF5YmVFbnF1ZXVlXzEpO1xuICAgICAgICAgICAgICAgIGlmIChuZWVkVG9DaGVja0Z1enp5U3VidHlwZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgaSA9PT0gd29ya1F1ZXVlXzEubGVuZ3RoIC0gMSAmJlxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25TZXRNYXRjaGVzUmVzdWx0KGZyYWdtZW50LnNlbGVjdGlvblNldCwgcmVzdWx0LCB2YXJpYWJsZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5lZWRUb0NoZWNrRnV6enlTdWJ0eXBlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjaGVja2luZ0Z1enp5U3VidHlwZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZ1enp5U3VidHlwZXMuZm9yRWFjaChmdW5jdGlvbiAocmVnRXhwLCBmdXp6eVN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gdHlwZW5hbWUubWF0Y2gocmVnRXhwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaFswXSA9PT0gdHlwZW5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXliZUVucXVldWVfMShmdXp6eVN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBQb2xpY2llcy5wcm90b3R5cGUuaGFzS2V5QXJncyA9IGZ1bmN0aW9uICh0eXBlbmFtZSwgZmllbGROYW1lKSB7XG4gICAgICAgIHZhciBwb2xpY3kgPSB0aGlzLmdldEZpZWxkUG9saWN5KHR5cGVuYW1lLCBmaWVsZE5hbWUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuICEhKHBvbGljeSAmJiBwb2xpY3kua2V5Rm4pO1xuICAgIH07XG4gICAgUG9saWNpZXMucHJvdG90eXBlLmdldFN0b3JlRmllbGROYW1lID0gZnVuY3Rpb24gKGZpZWxkU3BlYykge1xuICAgICAgICB2YXIgdHlwZW5hbWUgPSBmaWVsZFNwZWMudHlwZW5hbWUsIGZpZWxkTmFtZSA9IGZpZWxkU3BlYy5maWVsZE5hbWU7XG4gICAgICAgIHZhciBwb2xpY3kgPSB0aGlzLmdldEZpZWxkUG9saWN5KHR5cGVuYW1lLCBmaWVsZE5hbWUsIGZhbHNlKTtcbiAgICAgICAgdmFyIHN0b3JlRmllbGROYW1lO1xuICAgICAgICB2YXIga2V5Rm4gPSBwb2xpY3kgJiYgcG9saWN5LmtleUZuO1xuICAgICAgICBpZiAoa2V5Rm4gJiYgdHlwZW5hbWUpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIHR5cGVuYW1lOiB0eXBlbmFtZSxcbiAgICAgICAgICAgICAgICBmaWVsZE5hbWU6IGZpZWxkTmFtZSxcbiAgICAgICAgICAgICAgICBmaWVsZDogZmllbGRTcGVjLmZpZWxkIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgdmFyaWFibGVzOiBmaWVsZFNwZWMudmFyaWFibGVzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBhcmdzID0gYXJnc0Zyb21GaWVsZFNwZWNpZmllcihmaWVsZFNwZWMpO1xuICAgICAgICAgICAgd2hpbGUgKGtleUZuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNwZWNpZmllck9yU3RyaW5nID0ga2V5Rm4oYXJncywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoc3BlY2lmaWVyT3JTdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleUZuID0ga2V5QXJnc0ZuRnJvbVNwZWNpZmllcihzcGVjaWZpZXJPclN0cmluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZUZpZWxkTmFtZSA9IHNwZWNpZmllck9yU3RyaW5nIHx8IGZpZWxkTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdG9yZUZpZWxkTmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBzdG9yZUZpZWxkTmFtZSA9IGZpZWxkU3BlYy5maWVsZFxuICAgICAgICAgICAgICAgID8gdXRpbGl0aWVzLnN0b3JlS2V5TmFtZUZyb21GaWVsZChmaWVsZFNwZWMuZmllbGQsIGZpZWxkU3BlYy52YXJpYWJsZXMpXG4gICAgICAgICAgICAgICAgOiB1dGlsaXRpZXMuZ2V0U3RvcmVLZXlOYW1lKGZpZWxkTmFtZSwgYXJnc0Zyb21GaWVsZFNwZWNpZmllcihmaWVsZFNwZWMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RvcmVGaWVsZE5hbWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGROYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWVsZE5hbWUgPT09IGZpZWxkTmFtZUZyb21TdG9yZU5hbWUoc3RvcmVGaWVsZE5hbWUpXG4gICAgICAgICAgICA/IHN0b3JlRmllbGROYW1lXG4gICAgICAgICAgICA6IGZpZWxkTmFtZSArIFwiOlwiICsgc3RvcmVGaWVsZE5hbWU7XG4gICAgfTtcbiAgICBQb2xpY2llcy5wcm90b3R5cGUucmVhZEZpZWxkID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIG9iamVjdE9yUmVmZXJlbmNlID0gb3B0aW9ucy5mcm9tO1xuICAgICAgICBpZiAoIW9iamVjdE9yUmVmZXJlbmNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgbmFtZU9yRmllbGQgPSBvcHRpb25zLmZpZWxkIHx8IG9wdGlvbnMuZmllbGROYW1lO1xuICAgICAgICBpZiAoIW5hbWVPckZpZWxkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAob3B0aW9ucy50eXBlbmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB2YXIgdHlwZW5hbWUgPSBjb250ZXh0LnN0b3JlLmdldEZpZWxkVmFsdWUob2JqZWN0T3JSZWZlcmVuY2UsIFwiX190eXBlbmFtZVwiKTtcbiAgICAgICAgICAgIGlmICh0eXBlbmFtZSlcbiAgICAgICAgICAgICAgICBvcHRpb25zLnR5cGVuYW1lID0gdHlwZW5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0b3JlRmllbGROYW1lID0gdGhpcy5nZXRTdG9yZUZpZWxkTmFtZShvcHRpb25zKTtcbiAgICAgICAgdmFyIGZpZWxkTmFtZSA9IGZpZWxkTmFtZUZyb21TdG9yZU5hbWUoc3RvcmVGaWVsZE5hbWUpO1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBjb250ZXh0LnN0b3JlLmdldEZpZWxkVmFsdWUob2JqZWN0T3JSZWZlcmVuY2UsIHN0b3JlRmllbGROYW1lKTtcbiAgICAgICAgdmFyIHBvbGljeSA9IHRoaXMuZ2V0RmllbGRQb2xpY3kob3B0aW9ucy50eXBlbmFtZSwgZmllbGROYW1lLCBmYWxzZSk7XG4gICAgICAgIHZhciByZWFkID0gcG9saWN5ICYmIHBvbGljeS5yZWFkO1xuICAgICAgICBpZiAocmVhZCkge1xuICAgICAgICAgICAgdmFyIHJlYWRPcHRpb25zID0gbWFrZUZpZWxkRnVuY3Rpb25PcHRpb25zKHRoaXMsIG9iamVjdE9yUmVmZXJlbmNlLCBvcHRpb25zLCBjb250ZXh0LCBjb250ZXh0LnN0b3JlLmdldFN0b3JhZ2UodXRpbGl0aWVzLmlzUmVmZXJlbmNlKG9iamVjdE9yUmVmZXJlbmNlKVxuICAgICAgICAgICAgICAgID8gb2JqZWN0T3JSZWZlcmVuY2UuX19yZWZcbiAgICAgICAgICAgICAgICA6IG9iamVjdE9yUmVmZXJlbmNlLCBzdG9yZUZpZWxkTmFtZSkpO1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlU2xvdC53aXRoVmFsdWUodGhpcy5jYWNoZSwgcmVhZCwgW2V4aXN0aW5nLCByZWFkT3B0aW9uc10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9O1xuICAgIFBvbGljaWVzLnByb3RvdHlwZS5nZXRSZWFkRnVuY3Rpb24gPSBmdW5jdGlvbiAodHlwZW5hbWUsIGZpZWxkTmFtZSkge1xuICAgICAgICB2YXIgcG9saWN5ID0gdGhpcy5nZXRGaWVsZFBvbGljeSh0eXBlbmFtZSwgZmllbGROYW1lLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBwb2xpY3kgJiYgcG9saWN5LnJlYWQ7XG4gICAgfTtcbiAgICBQb2xpY2llcy5wcm90b3R5cGUuZ2V0TWVyZ2VGdW5jdGlvbiA9IGZ1bmN0aW9uIChwYXJlbnRUeXBlbmFtZSwgZmllbGROYW1lLCBjaGlsZFR5cGVuYW1lKSB7XG4gICAgICAgIHZhciBwb2xpY3kgPSB0aGlzLmdldEZpZWxkUG9saWN5KHBhcmVudFR5cGVuYW1lLCBmaWVsZE5hbWUsIGZhbHNlKTtcbiAgICAgICAgdmFyIG1lcmdlID0gcG9saWN5ICYmIHBvbGljeS5tZXJnZTtcbiAgICAgICAgaWYgKCFtZXJnZSAmJiBjaGlsZFR5cGVuYW1lKSB7XG4gICAgICAgICAgICBwb2xpY3kgPSB0aGlzLmdldFR5cGVQb2xpY3koY2hpbGRUeXBlbmFtZSk7XG4gICAgICAgICAgICBtZXJnZSA9IHBvbGljeSAmJiBwb2xpY3kubWVyZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lcmdlO1xuICAgIH07XG4gICAgUG9saWNpZXMucHJvdG90eXBlLnJ1bk1lcmdlRnVuY3Rpb24gPSBmdW5jdGlvbiAoZXhpc3RpbmcsIGluY29taW5nLCBfYSwgY29udGV4dCwgc3RvcmFnZSkge1xuICAgICAgICB2YXIgZmllbGQgPSBfYS5maWVsZCwgdHlwZW5hbWUgPSBfYS50eXBlbmFtZSwgbWVyZ2UgPSBfYS5tZXJnZTtcbiAgICAgICAgaWYgKG1lcmdlID09PSBtZXJnZVRydWVGbikge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VNZXJnZU9iamVjdHNGdW5jdGlvbihjb250ZXh0LnN0b3JlKShleGlzdGluZywgaW5jb21pbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXJnZSA9PT0gbWVyZ2VGYWxzZUZuKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5jb21pbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHQub3ZlcndyaXRlKSB7XG4gICAgICAgICAgICBleGlzdGluZyA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVyZ2UoZXhpc3RpbmcsIGluY29taW5nLCBtYWtlRmllbGRGdW5jdGlvbk9wdGlvbnModGhpcywgdm9pZCAwLCB7IHR5cGVuYW1lOiB0eXBlbmFtZSwgZmllbGROYW1lOiBmaWVsZC5uYW1lLnZhbHVlLCBmaWVsZDogZmllbGQsIHZhcmlhYmxlczogY29udGV4dC52YXJpYWJsZXMgfSwgY29udGV4dCwgc3RvcmFnZSB8fCBPYmplY3QuY3JlYXRlKG51bGwpKSk7XG4gICAgfTtcbiAgICByZXR1cm4gUG9saWNpZXM7XG59KCkpO1xuZnVuY3Rpb24gbWFrZUZpZWxkRnVuY3Rpb25PcHRpb25zKHBvbGljaWVzLCBvYmplY3RPclJlZmVyZW5jZSwgZmllbGRTcGVjLCBjb250ZXh0LCBzdG9yYWdlKSB7XG4gICAgdmFyIHN0b3JlRmllbGROYW1lID0gcG9saWNpZXMuZ2V0U3RvcmVGaWVsZE5hbWUoZmllbGRTcGVjKTtcbiAgICB2YXIgZmllbGROYW1lID0gZmllbGROYW1lRnJvbVN0b3JlTmFtZShzdG9yZUZpZWxkTmFtZSk7XG4gICAgdmFyIHZhcmlhYmxlcyA9IGZpZWxkU3BlYy52YXJpYWJsZXMgfHwgY29udGV4dC52YXJpYWJsZXM7XG4gICAgdmFyIF9hID0gY29udGV4dC5zdG9yZSwgdG9SZWZlcmVuY2UgPSBfYS50b1JlZmVyZW5jZSwgY2FuUmVhZCA9IF9hLmNhblJlYWQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXJnczogYXJnc0Zyb21GaWVsZFNwZWNpZmllcihmaWVsZFNwZWMpLFxuICAgICAgICBmaWVsZDogZmllbGRTcGVjLmZpZWxkIHx8IG51bGwsXG4gICAgICAgIGZpZWxkTmFtZTogZmllbGROYW1lLFxuICAgICAgICBzdG9yZUZpZWxkTmFtZTogc3RvcmVGaWVsZE5hbWUsXG4gICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICBpc1JlZmVyZW5jZTogdXRpbGl0aWVzLmlzUmVmZXJlbmNlLFxuICAgICAgICB0b1JlZmVyZW5jZTogdG9SZWZlcmVuY2UsXG4gICAgICAgIHN0b3JhZ2U6IHN0b3JhZ2UsXG4gICAgICAgIGNhY2hlOiBwb2xpY2llcy5jYWNoZSxcbiAgICAgICAgY2FuUmVhZDogY2FuUmVhZCxcbiAgICAgICAgcmVhZEZpZWxkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcG9saWNpZXMucmVhZEZpZWxkKG5vcm1hbGl6ZVJlYWRGaWVsZE9wdGlvbnMoYXJndW1lbnRzLCBvYmplY3RPclJlZmVyZW5jZSwgdmFyaWFibGVzKSwgY29udGV4dCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmdlT2JqZWN0czogbWFrZU1lcmdlT2JqZWN0c0Z1bmN0aW9uKGNvbnRleHQuc3RvcmUpLFxuICAgIH07XG59XG5mdW5jdGlvbiBub3JtYWxpemVSZWFkRmllbGRPcHRpb25zKHJlYWRGaWVsZEFyZ3MsIG9iamVjdE9yUmVmZXJlbmNlLCB2YXJpYWJsZXMpIHtcbiAgICB2YXIgZmllbGROYW1lT3JPcHRpb25zID0gcmVhZEZpZWxkQXJnc1swXSwgZnJvbSA9IHJlYWRGaWVsZEFyZ3NbMV0sIGFyZ2MgPSByZWFkRmllbGRBcmdzLmxlbmd0aDtcbiAgICB2YXIgb3B0aW9ucztcbiAgICBpZiAodHlwZW9mIGZpZWxkTmFtZU9yT3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgZmllbGROYW1lOiBmaWVsZE5hbWVPck9wdGlvbnMsXG4gICAgICAgICAgICBmcm9tOiBhcmdjID4gMSA/IGZyb20gOiBvYmplY3RPclJlZmVyZW5jZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSB0c2xpYi5fX2Fzc2lnbih7fSwgZmllbGROYW1lT3JPcHRpb25zKTtcbiAgICAgICAgaWYgKCFoYXNPd24uY2FsbChvcHRpb25zLCBcImZyb21cIikpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZnJvbSA9IG9iamVjdE9yUmVmZXJlbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChfX0RFVl9fICYmIG9wdGlvbnMuZnJvbSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIF9fREVWX18gJiYgZ2xvYmFscy5pbnZhcmlhbnQud2FybihcIlVuZGVmaW5lZCAnZnJvbScgcGFzc2VkIHRvIHJlYWRGaWVsZCB3aXRoIGFyZ3VtZW50cyBcIi5jb25jYXQodXRpbGl0aWVzLnN0cmluZ2lmeUZvckRpc3BsYXkoQXJyYXkuZnJvbShyZWFkRmllbGRBcmdzKSkpKTtcbiAgICB9XG4gICAgaWYgKHZvaWQgMCA9PT0gb3B0aW9ucy52YXJpYWJsZXMpIHtcbiAgICAgICAgb3B0aW9ucy52YXJpYWJsZXMgPSB2YXJpYWJsZXM7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gbWFrZU1lcmdlT2JqZWN0c0Z1bmN0aW9uKHN0b3JlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlT2JqZWN0cyhleGlzdGluZywgaW5jb21pbmcpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkoZXhpc3RpbmcpIHx8IGlzQXJyYXkoaW5jb21pbmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBfX0RFVl9fID8gbmV3IGdsb2JhbHMuSW52YXJpYW50RXJyb3IoXCJDYW5ub3QgYXV0b21hdGljYWxseSBtZXJnZSBhcnJheXNcIikgOiBuZXcgZ2xvYmFscy5JbnZhcmlhbnRFcnJvcig0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXRpbGl0aWVzLmlzTm9uTnVsbE9iamVjdChleGlzdGluZykgJiZcbiAgICAgICAgICAgIHV0aWxpdGllcy5pc05vbk51bGxPYmplY3QoaW5jb21pbmcpKSB7XG4gICAgICAgICAgICB2YXIgZVR5cGUgPSBzdG9yZS5nZXRGaWVsZFZhbHVlKGV4aXN0aW5nLCBcIl9fdHlwZW5hbWVcIik7XG4gICAgICAgICAgICB2YXIgaVR5cGUgPSBzdG9yZS5nZXRGaWVsZFZhbHVlKGluY29taW5nLCBcIl9fdHlwZW5hbWVcIik7XG4gICAgICAgICAgICB2YXIgdHlwZXNEaWZmZXIgPSBlVHlwZSAmJiBpVHlwZSAmJiBlVHlwZSAhPT0gaVR5cGU7XG4gICAgICAgICAgICBpZiAodHlwZXNEaWZmZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5jb21pbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXRpbGl0aWVzLmlzUmVmZXJlbmNlKGV4aXN0aW5nKSAmJlxuICAgICAgICAgICAgICAgIHN0b3JlVmFsdWVJc1N0b3JlT2JqZWN0KGluY29taW5nKSkge1xuICAgICAgICAgICAgICAgIHN0b3JlLm1lcmdlKGV4aXN0aW5nLl9fcmVmLCBpbmNvbWluZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0b3JlVmFsdWVJc1N0b3JlT2JqZWN0KGV4aXN0aW5nKSAmJlxuICAgICAgICAgICAgICAgIHV0aWxpdGllcy5pc1JlZmVyZW5jZShpbmNvbWluZykpIHtcbiAgICAgICAgICAgICAgICBzdG9yZS5tZXJnZShleGlzdGluZywgaW5jb21pbmcuX19yZWYpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmNvbWluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdG9yZVZhbHVlSXNTdG9yZU9iamVjdChleGlzdGluZykgJiZcbiAgICAgICAgICAgICAgICBzdG9yZVZhbHVlSXNTdG9yZU9iamVjdChpbmNvbWluZykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGV4aXN0aW5nKSwgaW5jb21pbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmNvbWluZztcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0Rmxhdm9yKGNvbnRleHQsIGNsaWVudE9ubHksIGRlZmVycmVkKSB7XG4gICAgdmFyIGtleSA9IFwiXCIuY29uY2F0KGNsaWVudE9ubHkpLmNvbmNhdChkZWZlcnJlZCk7XG4gICAgdmFyIGZsYXZvcmVkID0gY29udGV4dC5mbGF2b3JzLmdldChrZXkpO1xuICAgIGlmICghZmxhdm9yZWQpIHtcbiAgICAgICAgY29udGV4dC5mbGF2b3JzLnNldChrZXksIGZsYXZvcmVkID0gKGNvbnRleHQuY2xpZW50T25seSA9PT0gY2xpZW50T25seSAmJlxuICAgICAgICAgICAgY29udGV4dC5kZWZlcnJlZCA9PT0gZGVmZXJyZWQpID8gY29udGV4dCA6IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBjb250ZXh0KSwgeyBjbGllbnRPbmx5OiBjbGllbnRPbmx5LCBkZWZlcnJlZDogZGVmZXJyZWQgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gZmxhdm9yZWQ7XG59XG52YXIgU3RvcmVXcml0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0b3JlV3JpdGVyKGNhY2hlLCByZWFkZXIsIGZyYWdtZW50cykge1xuICAgICAgICB0aGlzLmNhY2hlID0gY2FjaGU7XG4gICAgICAgIHRoaXMucmVhZGVyID0gcmVhZGVyO1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICB9XG4gICAgU3RvcmVXcml0ZXIucHJvdG90eXBlLndyaXRlVG9TdG9yZSA9IGZ1bmN0aW9uIChzdG9yZSwgX2EpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHF1ZXJ5ID0gX2EucXVlcnksIHJlc3VsdCA9IF9hLnJlc3VsdCwgZGF0YUlkID0gX2EuZGF0YUlkLCB2YXJpYWJsZXMgPSBfYS52YXJpYWJsZXMsIG92ZXJ3cml0ZSA9IF9hLm92ZXJ3cml0ZTtcbiAgICAgICAgdmFyIG9wZXJhdGlvbkRlZmluaXRpb24gPSB1dGlsaXRpZXMuZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbihxdWVyeSk7XG4gICAgICAgIHZhciBtZXJnZXIgPSBtYWtlUHJvY2Vzc2VkRmllbGRzTWVyZ2VyKCk7XG4gICAgICAgIHZhcmlhYmxlcyA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCB1dGlsaXRpZXMuZ2V0RGVmYXVsdFZhbHVlcyhvcGVyYXRpb25EZWZpbml0aW9uKSksIHZhcmlhYmxlcyk7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oeyBzdG9yZTogc3RvcmUsIHdyaXR0ZW46IE9iamVjdC5jcmVhdGUobnVsbCksIG1lcmdlOiBmdW5jdGlvbiAoZXhpc3RpbmcsIGluY29taW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lcmdlci5tZXJnZShleGlzdGluZywgaW5jb21pbmcpO1xuICAgICAgICAgICAgfSwgdmFyaWFibGVzOiB2YXJpYWJsZXMsIHZhclN0cmluZzogY2Fub25pY2FsU3RyaW5naWZ5KHZhcmlhYmxlcykgfSwgZXh0cmFjdEZyYWdtZW50Q29udGV4dChxdWVyeSwgdGhpcy5mcmFnbWVudHMpKSwgeyBvdmVyd3JpdGU6ICEhb3ZlcndyaXRlLCBpbmNvbWluZ0J5SWQ6IG5ldyBNYXAsIGNsaWVudE9ubHk6IGZhbHNlLCBkZWZlcnJlZDogZmFsc2UsIGZsYXZvcnM6IG5ldyBNYXAgfSk7XG4gICAgICAgIHZhciByZWYgPSB0aGlzLnByb2Nlc3NTZWxlY3Rpb25TZXQoe1xuICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQgfHwgT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgICAgIGRhdGFJZDogZGF0YUlkLFxuICAgICAgICAgICAgc2VsZWN0aW9uU2V0OiBvcGVyYXRpb25EZWZpbml0aW9uLnNlbGVjdGlvblNldCxcbiAgICAgICAgICAgIG1lcmdlVHJlZTogeyBtYXA6IG5ldyBNYXAgfSxcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXV0aWxpdGllcy5pc1JlZmVyZW5jZShyZWYpKSB7XG4gICAgICAgICAgICB0aHJvdyBfX0RFVl9fID8gbmV3IGdsb2JhbHMuSW52YXJpYW50RXJyb3IoXCJDb3VsZCBub3QgaWRlbnRpZnkgb2JqZWN0IFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShyZXN1bHQpKSkgOiBuZXcgZ2xvYmFscy5JbnZhcmlhbnRFcnJvcig3KTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmluY29taW5nQnlJZC5mb3JFYWNoKGZ1bmN0aW9uIChfYSwgZGF0YUlkKSB7XG4gICAgICAgICAgICB2YXIgc3RvcmVPYmplY3QgPSBfYS5zdG9yZU9iamVjdCwgbWVyZ2VUcmVlID0gX2EubWVyZ2VUcmVlLCBmaWVsZE5vZGVTZXQgPSBfYS5maWVsZE5vZGVTZXQ7XG4gICAgICAgICAgICB2YXIgZW50aXR5UmVmID0gdXRpbGl0aWVzLm1ha2VSZWZlcmVuY2UoZGF0YUlkKTtcbiAgICAgICAgICAgIGlmIChtZXJnZVRyZWUgJiYgbWVyZ2VUcmVlLm1hcC5zaXplKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFwcGxpZWQgPSBfdGhpcy5hcHBseU1lcmdlcyhtZXJnZVRyZWUsIGVudGl0eVJlZiwgc3RvcmVPYmplY3QsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGlmICh1dGlsaXRpZXMuaXNSZWZlcmVuY2UoYXBwbGllZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdG9yZU9iamVjdCA9IGFwcGxpZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX19ERVZfXyAmJiAhY29udGV4dC5vdmVyd3JpdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmllbGRzV2l0aFNlbGVjdGlvblNldHNfMSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgICAgZmllbGROb2RlU2V0LmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5zZWxlY3Rpb25TZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkc1dpdGhTZWxlY3Rpb25TZXRzXzFbZmllbGQubmFtZS52YWx1ZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGhhc1NlbGVjdGlvblNldF8xID0gZnVuY3Rpb24gKHN0b3JlRmllbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZHNXaXRoU2VsZWN0aW9uU2V0c18xW2ZpZWxkTmFtZUZyb21TdG9yZU5hbWUoc3RvcmVGaWVsZE5hbWUpXSA9PT0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBoYXNNZXJnZUZ1bmN0aW9uXzEgPSBmdW5jdGlvbiAoc3RvcmVGaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkVHJlZSA9IG1lcmdlVHJlZSAmJiBtZXJnZVRyZWUubWFwLmdldChzdG9yZUZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGNoaWxkVHJlZSAmJiBjaGlsZFRyZWUuaW5mbyAmJiBjaGlsZFRyZWUuaW5mby5tZXJnZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzdG9yZU9iamVjdCkuZm9yRWFjaChmdW5jdGlvbiAoc3RvcmVGaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1NlbGVjdGlvblNldF8xKHN0b3JlRmllbGROYW1lKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWhhc01lcmdlRnVuY3Rpb25fMShzdG9yZUZpZWxkTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5BYm91dERhdGFMb3NzKGVudGl0eVJlZiwgc3RvcmVPYmplY3QsIHN0b3JlRmllbGROYW1lLCBjb250ZXh0LnN0b3JlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmUubWVyZ2UoZGF0YUlkLCBzdG9yZU9iamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdG9yZS5yZXRhaW4ocmVmLl9fcmVmKTtcbiAgICAgICAgcmV0dXJuIHJlZjtcbiAgICB9O1xuICAgIFN0b3JlV3JpdGVyLnByb3RvdHlwZS5wcm9jZXNzU2VsZWN0aW9uU2V0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkYXRhSWQgPSBfYS5kYXRhSWQsIHJlc3VsdCA9IF9hLnJlc3VsdCwgc2VsZWN0aW9uU2V0ID0gX2Euc2VsZWN0aW9uU2V0LCBjb250ZXh0ID0gX2EuY29udGV4dCwgbWVyZ2VUcmVlID0gX2EubWVyZ2VUcmVlO1xuICAgICAgICB2YXIgcG9saWNpZXMgPSB0aGlzLmNhY2hlLnBvbGljaWVzO1xuICAgICAgICB2YXIgaW5jb21pbmcgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB2YXIgdHlwZW5hbWUgPSAoZGF0YUlkICYmIHBvbGljaWVzLnJvb3RUeXBlbmFtZXNCeUlkW2RhdGFJZF0pIHx8XG4gICAgICAgICAgICB1dGlsaXRpZXMuZ2V0VHlwZW5hbWVGcm9tUmVzdWx0KHJlc3VsdCwgc2VsZWN0aW9uU2V0LCBjb250ZXh0LmZyYWdtZW50TWFwKSB8fFxuICAgICAgICAgICAgKGRhdGFJZCAmJiBjb250ZXh0LnN0b3JlLmdldChkYXRhSWQsIFwiX190eXBlbmFtZVwiKSk7XG4gICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZW5hbWUpIHtcbiAgICAgICAgICAgIGluY29taW5nLl9fdHlwZW5hbWUgPSB0eXBlbmFtZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVhZEZpZWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBub3JtYWxpemVSZWFkRmllbGRPcHRpb25zKGFyZ3VtZW50cywgaW5jb21pbmcsIGNvbnRleHQudmFyaWFibGVzKTtcbiAgICAgICAgICAgIGlmICh1dGlsaXRpZXMuaXNSZWZlcmVuY2Uob3B0aW9ucy5mcm9tKSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gY29udGV4dC5pbmNvbWluZ0J5SWQuZ2V0KG9wdGlvbnMuZnJvbS5fX3JlZik7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdF8xID0gcG9saWNpZXMucmVhZEZpZWxkKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBmcm9tOiBpbmZvLnN0b3JlT2JqZWN0IH0pLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdF8xICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRfMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb2xpY2llcy5yZWFkRmllbGQob3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBmaWVsZE5vZGVTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZmxhdHRlbkZpZWxkcyhzZWxlY3Rpb25TZXQsIHJlc3VsdCwgY29udGV4dCwgdHlwZW5hbWUpLmZvckVhY2goZnVuY3Rpb24gKGNvbnRleHQsIGZpZWxkKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgcmVzdWx0RmllbGRLZXkgPSB1dGlsaXRpZXMucmVzdWx0S2V5TmFtZUZyb21GaWVsZChmaWVsZCk7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHRbcmVzdWx0RmllbGRLZXldO1xuICAgICAgICAgICAgZmllbGROb2RlU2V0LmFkZChmaWVsZCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHZhciBzdG9yZUZpZWxkTmFtZSA9IHBvbGljaWVzLmdldFN0b3JlRmllbGROYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZW5hbWU6IHR5cGVuYW1lLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZE5hbWU6IGZpZWxkLm5hbWUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiBjb250ZXh0LnZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRUcmVlID0gZ2V0Q2hpbGRNZXJnZVRyZWUobWVyZ2VUcmVlLCBzdG9yZUZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgdmFyIGluY29taW5nVmFsdWUgPSBfdGhpcy5wcm9jZXNzRmllbGRWYWx1ZSh2YWx1ZSwgZmllbGQsIGZpZWxkLnNlbGVjdGlvblNldFxuICAgICAgICAgICAgICAgICAgICA/IGdldENvbnRleHRGbGF2b3IoY29udGV4dCwgZmFsc2UsIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICA6IGNvbnRleHQsIGNoaWxkVHJlZSk7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkVHlwZW5hbWUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLnNlbGVjdGlvblNldCAmJlxuICAgICAgICAgICAgICAgICAgICAodXRpbGl0aWVzLmlzUmVmZXJlbmNlKGluY29taW5nVmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZVZhbHVlSXNTdG9yZU9iamVjdChpbmNvbWluZ1ZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRUeXBlbmFtZSA9IHJlYWRGaWVsZChcIl9fdHlwZW5hbWVcIiwgaW5jb21pbmdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBtZXJnZSA9IHBvbGljaWVzLmdldE1lcmdlRnVuY3Rpb24odHlwZW5hbWUsIGZpZWxkLm5hbWUudmFsdWUsIGNoaWxkVHlwZW5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChtZXJnZSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFRyZWUuaW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVuYW1lOiB0eXBlbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlOiBtZXJnZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1heWJlUmVjeWNsZUNoaWxkTWVyZ2VUcmVlKG1lcmdlVHJlZSwgc3RvcmVGaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmNvbWluZyA9IGNvbnRleHQubWVyZ2UoaW5jb21pbmcsIChfYSA9IHt9LFxuICAgICAgICAgICAgICAgICAgICBfYVtzdG9yZUZpZWxkTmFtZV0gPSBpbmNvbWluZ1ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBfYSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX19ERVZfXyAmJlxuICAgICAgICAgICAgICAgICFjb250ZXh0LmNsaWVudE9ubHkgJiZcbiAgICAgICAgICAgICAgICAhY29udGV4dC5kZWZlcnJlZCAmJlxuICAgICAgICAgICAgICAgICF1dGlsaXRpZXMuYWRkVHlwZW5hbWVUb0RvY3VtZW50LmFkZGVkKGZpZWxkKSAmJlxuICAgICAgICAgICAgICAgICFwb2xpY2llcy5nZXRSZWFkRnVuY3Rpb24odHlwZW5hbWUsIGZpZWxkLm5hbWUudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgX19ERVZfXyAmJiBnbG9iYWxzLmludmFyaWFudC5lcnJvcihcIk1pc3NpbmcgZmllbGQgJ1wiLmNvbmNhdCh1dGlsaXRpZXMucmVzdWx0S2V5TmFtZUZyb21GaWVsZChmaWVsZCksIFwiJyB3aGlsZSB3cml0aW5nIHJlc3VsdCBcIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KHJlc3VsdCwgbnVsbCwgMikpLnN1YnN0cmluZygwLCAxMDAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIF9iID0gcG9saWNpZXMuaWRlbnRpZnkocmVzdWx0LCB7XG4gICAgICAgICAgICAgICAgdHlwZW5hbWU6IHR5cGVuYW1lLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvblNldDogc2VsZWN0aW9uU2V0LFxuICAgICAgICAgICAgICAgIGZyYWdtZW50TWFwOiBjb250ZXh0LmZyYWdtZW50TWFwLFxuICAgICAgICAgICAgICAgIHN0b3JlT2JqZWN0OiBpbmNvbWluZyxcbiAgICAgICAgICAgICAgICByZWFkRmllbGQ6IHJlYWRGaWVsZCxcbiAgICAgICAgICAgIH0pLCBpZCA9IF9iWzBdLCBrZXlPYmplY3QgPSBfYlsxXTtcbiAgICAgICAgICAgIGRhdGFJZCA9IGRhdGFJZCB8fCBpZDtcbiAgICAgICAgICAgIGlmIChrZXlPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpbmNvbWluZyA9IGNvbnRleHQubWVyZ2UoaW5jb21pbmcsIGtleU9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICghZGF0YUlkKVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBkYXRhSWQpIHtcbiAgICAgICAgICAgIHZhciBkYXRhUmVmID0gdXRpbGl0aWVzLm1ha2VSZWZlcmVuY2UoZGF0YUlkKTtcbiAgICAgICAgICAgIHZhciBzZXRzID0gY29udGV4dC53cml0dGVuW2RhdGFJZF0gfHwgKGNvbnRleHQud3JpdHRlbltkYXRhSWRdID0gW10pO1xuICAgICAgICAgICAgaWYgKHNldHMuaW5kZXhPZihzZWxlY3Rpb25TZXQpID49IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFSZWY7XG4gICAgICAgICAgICBzZXRzLnB1c2goc2VsZWN0aW9uU2V0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWRlciAmJiB0aGlzLnJlYWRlci5pc0ZyZXNoKHJlc3VsdCwgZGF0YVJlZiwgc2VsZWN0aW9uU2V0LCBjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhUmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByZXZpb3VzXzEgPSBjb250ZXh0LmluY29taW5nQnlJZC5nZXQoZGF0YUlkKTtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c18xKSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNfMS5zdG9yZU9iamVjdCA9IGNvbnRleHQubWVyZ2UocHJldmlvdXNfMS5zdG9yZU9iamVjdCwgaW5jb21pbmcpO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzXzEubWVyZ2VUcmVlID0gbWVyZ2VNZXJnZVRyZWVzKHByZXZpb3VzXzEubWVyZ2VUcmVlLCBtZXJnZVRyZWUpO1xuICAgICAgICAgICAgICAgIGZpZWxkTm9kZVNldC5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkgeyByZXR1cm4gcHJldmlvdXNfMS5maWVsZE5vZGVTZXQuYWRkKGZpZWxkKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmluY29taW5nQnlJZC5zZXQoZGF0YUlkLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlT2JqZWN0OiBpbmNvbWluZyxcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VUcmVlOiBtZXJnZVRyZWVJc0VtcHR5KG1lcmdlVHJlZSkgPyB2b2lkIDAgOiBtZXJnZVRyZWUsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkTm9kZVNldDogZmllbGROb2RlU2V0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGFSZWY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluY29taW5nO1xuICAgIH07XG4gICAgU3RvcmVXcml0ZXIucHJvdG90eXBlLnByb2Nlc3NGaWVsZFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBmaWVsZCwgY29udGV4dCwgbWVyZ2VUcmVlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghZmllbGQuc2VsZWN0aW9uU2V0IHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gX19ERVZfXyA/IHV0aWxpdGllcy5jbG9uZURlZXAodmFsdWUpIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gX3RoaXMucHJvY2Vzc0ZpZWxkVmFsdWUoaXRlbSwgZmllbGQsIGNvbnRleHQsIGdldENoaWxkTWVyZ2VUcmVlKG1lcmdlVHJlZSwgaSkpO1xuICAgICAgICAgICAgICAgIG1heWJlUmVjeWNsZUNoaWxkTWVyZ2VUcmVlKG1lcmdlVHJlZSwgaSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1NlbGVjdGlvblNldCh7XG4gICAgICAgICAgICByZXN1bHQ6IHZhbHVlLFxuICAgICAgICAgICAgc2VsZWN0aW9uU2V0OiBmaWVsZC5zZWxlY3Rpb25TZXQsXG4gICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgbWVyZ2VUcmVlOiBtZXJnZVRyZWUsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU3RvcmVXcml0ZXIucHJvdG90eXBlLmZsYXR0ZW5GaWVsZHMgPSBmdW5jdGlvbiAoc2VsZWN0aW9uU2V0LCByZXN1bHQsIGNvbnRleHQsIHR5cGVuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlbmFtZSA9PT0gdm9pZCAwKSB7IHR5cGVuYW1lID0gdXRpbGl0aWVzLmdldFR5cGVuYW1lRnJvbVJlc3VsdChyZXN1bHQsIHNlbGVjdGlvblNldCwgY29udGV4dC5mcmFnbWVudE1hcCk7IH1cbiAgICAgICAgdmFyIGZpZWxkTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgcG9saWNpZXMgPSB0aGlzLmNhY2hlLnBvbGljaWVzO1xuICAgICAgICB2YXIgbGltaXRpbmdUcmllID0gbmV3IHRyaWUuVHJpZShmYWxzZSk7XG4gICAgICAgIChmdW5jdGlvbiBmbGF0dGVuKHNlbGVjdGlvblNldCwgaW5oZXJpdGVkQ29udGV4dCkge1xuICAgICAgICAgICAgdmFyIHZpc2l0ZWROb2RlID0gbGltaXRpbmdUcmllLmxvb2t1cChzZWxlY3Rpb25TZXQsIGluaGVyaXRlZENvbnRleHQuY2xpZW50T25seSwgaW5oZXJpdGVkQ29udGV4dC5kZWZlcnJlZCk7XG4gICAgICAgICAgICBpZiAodmlzaXRlZE5vZGUudmlzaXRlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2aXNpdGVkTm9kZS52aXNpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlbGVjdGlvblNldC5zZWxlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICghdXRpbGl0aWVzLnNob3VsZEluY2x1ZGUoc2VsZWN0aW9uLCBjb250ZXh0LnZhcmlhYmxlcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgY2xpZW50T25seSA9IGluaGVyaXRlZENvbnRleHQuY2xpZW50T25seSwgZGVmZXJyZWQgPSBpbmhlcml0ZWRDb250ZXh0LmRlZmVycmVkO1xuICAgICAgICAgICAgICAgIGlmICghKGNsaWVudE9ubHkgJiYgZGVmZXJyZWQpICYmXG4gICAgICAgICAgICAgICAgICAgIHV0aWxpdGllcy5pc05vbkVtcHR5QXJyYXkoc2VsZWN0aW9uLmRpcmVjdGl2ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5kaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBkaXIubmFtZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSBcImNsaWVudFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudE9ubHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwiZGVmZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gdXRpbGl0aWVzLmFyZ3VtZW50c09iamVjdEZyb21GaWVsZChkaXIsIGNvbnRleHQudmFyaWFibGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFyZ3MgfHwgYXJncy5pZiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1dGlsaXRpZXMuaXNGaWVsZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBleGlzdGluZyA9IGZpZWxkTWFwLmdldChzZWxlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudE9ubHkgPSBjbGllbnRPbmx5ICYmIGV4aXN0aW5nLmNsaWVudE9ubHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZCA9IGRlZmVycmVkICYmIGV4aXN0aW5nLmRlZmVycmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkTWFwLnNldChzZWxlY3Rpb24sIGdldENvbnRleHRGbGF2b3IoY29udGV4dCwgY2xpZW50T25seSwgZGVmZXJyZWQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IHV0aWxpdGllcy5nZXRGcmFnbWVudEZyb21TZWxlY3Rpb24oc2VsZWN0aW9uLCBjb250ZXh0Lmxvb2t1cEZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmcmFnbWVudCAmJiBzZWxlY3Rpb24ua2luZCA9PT0gZ3JhcGhxbC5LaW5kLkZSQUdNRU5UX1NQUkVBRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX19ERVZfXyA/IG5ldyBnbG9iYWxzLkludmFyaWFudEVycm9yKFwiTm8gZnJhZ21lbnQgbmFtZWQgXCIuY29uY2F0KHNlbGVjdGlvbi5uYW1lLnZhbHVlKSkgOiBuZXcgZ2xvYmFscy5JbnZhcmlhbnRFcnJvcig4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZ21lbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbGljaWVzLmZyYWdtZW50TWF0Y2hlcyhmcmFnbWVudCwgdHlwZW5hbWUsIHJlc3VsdCwgY29udGV4dC52YXJpYWJsZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbGF0dGVuKGZyYWdtZW50LnNlbGVjdGlvblNldCwgZ2V0Q29udGV4dEZsYXZvcihjb250ZXh0LCBjbGllbnRPbmx5LCBkZWZlcnJlZCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKHNlbGVjdGlvblNldCwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBmaWVsZE1hcDtcbiAgICB9O1xuICAgIFN0b3JlV3JpdGVyLnByb3RvdHlwZS5hcHBseU1lcmdlcyA9IGZ1bmN0aW9uIChtZXJnZVRyZWUsIGV4aXN0aW5nLCBpbmNvbWluZywgY29udGV4dCwgZ2V0U3RvcmFnZUFyZ3MpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAobWVyZ2VUcmVlLm1hcC5zaXplICYmICF1dGlsaXRpZXMuaXNSZWZlcmVuY2UoaW5jb21pbmcpKSB7XG4gICAgICAgICAgICB2YXIgZV8xID0gKCFpc0FycmF5KGluY29taW5nKSAmJlxuICAgICAgICAgICAgICAgICh1dGlsaXRpZXMuaXNSZWZlcmVuY2UoZXhpc3RpbmcpIHx8IHN0b3JlVmFsdWVJc1N0b3JlT2JqZWN0KGV4aXN0aW5nKSkpID8gZXhpc3RpbmcgOiB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgaV8xID0gaW5jb21pbmc7XG4gICAgICAgICAgICBpZiAoZV8xICYmICFnZXRTdG9yYWdlQXJncykge1xuICAgICAgICAgICAgICAgIGdldFN0b3JhZ2VBcmdzID0gW3V0aWxpdGllcy5pc1JlZmVyZW5jZShlXzEpID8gZV8xLl9fcmVmIDogZV8xXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaGFuZ2VkRmllbGRzXzE7XG4gICAgICAgICAgICB2YXIgZ2V0VmFsdWVfMSA9IGZ1bmN0aW9uIChmcm9tLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkoZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgPyAodHlwZW9mIG5hbWUgPT09IFwibnVtYmVyXCIgPyBmcm9tW25hbWVdIDogdm9pZCAwKVxuICAgICAgICAgICAgICAgICAgICA6IGNvbnRleHQuc3RvcmUuZ2V0RmllbGRWYWx1ZShmcm9tLCBTdHJpbmcobmFtZSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1lcmdlVHJlZS5tYXAuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGRUcmVlLCBzdG9yZUZpZWxkTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBlVmFsID0gZ2V0VmFsdWVfMShlXzEsIHN0b3JlRmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgaVZhbCA9IGdldFZhbHVlXzEoaV8xLCBzdG9yZUZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gaVZhbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChnZXRTdG9yYWdlQXJncykge1xuICAgICAgICAgICAgICAgICAgICBnZXRTdG9yYWdlQXJncy5wdXNoKHN0b3JlRmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGFWYWwgPSBfdGhpcy5hcHBseU1lcmdlcyhjaGlsZFRyZWUsIGVWYWwsIGlWYWwsIGNvbnRleHQsIGdldFN0b3JhZ2VBcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoYVZhbCAhPT0gaVZhbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkRmllbGRzXzEgPSBjaGFuZ2VkRmllbGRzXzEgfHwgbmV3IE1hcDtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZEZpZWxkc18xLnNldChzdG9yZUZpZWxkTmFtZSwgYVZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChnZXRTdG9yYWdlQXJncykge1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWxzLmludmFyaWFudChnZXRTdG9yYWdlQXJncy5wb3AoKSA9PT0gc3RvcmVGaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWRGaWVsZHNfMSkge1xuICAgICAgICAgICAgICAgIGluY29taW5nID0gKGlzQXJyYXkoaV8xKSA/IGlfMS5zbGljZSgwKSA6IHRzbGliLl9fYXNzaWduKHt9LCBpXzEpKTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkRmllbGRzXzEuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jb21pbmdbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWVyZ2VUcmVlLmluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlLnBvbGljaWVzLnJ1bk1lcmdlRnVuY3Rpb24oZXhpc3RpbmcsIGluY29taW5nLCBtZXJnZVRyZWUuaW5mbywgY29udGV4dCwgZ2V0U3RvcmFnZUFyZ3MgJiYgKF9hID0gY29udGV4dC5zdG9yZSkuZ2V0U3RvcmFnZS5hcHBseShfYSwgZ2V0U3RvcmFnZUFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5jb21pbmc7XG4gICAgfTtcbiAgICByZXR1cm4gU3RvcmVXcml0ZXI7XG59KCkpO1xudmFyIGVtcHR5TWVyZ2VUcmVlUG9vbCA9IFtdO1xuZnVuY3Rpb24gZ2V0Q2hpbGRNZXJnZVRyZWUoX2EsIG5hbWUpIHtcbiAgICB2YXIgbWFwID0gX2EubWFwO1xuICAgIGlmICghbWFwLmhhcyhuYW1lKSkge1xuICAgICAgICBtYXAuc2V0KG5hbWUsIGVtcHR5TWVyZ2VUcmVlUG9vbC5wb3AoKSB8fCB7IG1hcDogbmV3IE1hcCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcC5nZXQobmFtZSk7XG59XG5mdW5jdGlvbiBtZXJnZU1lcmdlVHJlZXMobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdCA9PT0gcmlnaHQgfHwgIXJpZ2h0IHx8IG1lcmdlVHJlZUlzRW1wdHkocmlnaHQpKVxuICAgICAgICByZXR1cm4gbGVmdDtcbiAgICBpZiAoIWxlZnQgfHwgbWVyZ2VUcmVlSXNFbXB0eShsZWZ0KSlcbiAgICAgICAgcmV0dXJuIHJpZ2h0O1xuICAgIHZhciBpbmZvID0gbGVmdC5pbmZvICYmIHJpZ2h0LmluZm8gPyB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgbGVmdC5pbmZvKSwgcmlnaHQuaW5mbykgOiBsZWZ0LmluZm8gfHwgcmlnaHQuaW5mbztcbiAgICB2YXIgbmVlZFRvTWVyZ2VNYXBzID0gbGVmdC5tYXAuc2l6ZSAmJiByaWdodC5tYXAuc2l6ZTtcbiAgICB2YXIgbWFwID0gbmVlZFRvTWVyZ2VNYXBzID8gbmV3IE1hcCA6XG4gICAgICAgIGxlZnQubWFwLnNpemUgPyBsZWZ0Lm1hcCA6IHJpZ2h0Lm1hcDtcbiAgICB2YXIgbWVyZ2VkID0geyBpbmZvOiBpbmZvLCBtYXA6IG1hcCB9O1xuICAgIGlmIChuZWVkVG9NZXJnZU1hcHMpIHtcbiAgICAgICAgdmFyIHJlbWFpbmluZ1JpZ2h0S2V5c18xID0gbmV3IFNldChyaWdodC5tYXAua2V5cygpKTtcbiAgICAgICAgbGVmdC5tYXAuZm9yRWFjaChmdW5jdGlvbiAobGVmdFRyZWUsIGtleSkge1xuICAgICAgICAgICAgbWVyZ2VkLm1hcC5zZXQoa2V5LCBtZXJnZU1lcmdlVHJlZXMobGVmdFRyZWUsIHJpZ2h0Lm1hcC5nZXQoa2V5KSkpO1xuICAgICAgICAgICAgcmVtYWluaW5nUmlnaHRLZXlzXzEuZGVsZXRlKGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZW1haW5pbmdSaWdodEtleXNfMS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIG1lcmdlZC5tYXAuc2V0KGtleSwgbWVyZ2VNZXJnZVRyZWVzKHJpZ2h0Lm1hcC5nZXQoa2V5KSwgbGVmdC5tYXAuZ2V0KGtleSkpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWQ7XG59XG5mdW5jdGlvbiBtZXJnZVRyZWVJc0VtcHR5KHRyZWUpIHtcbiAgICByZXR1cm4gIXRyZWUgfHwgISh0cmVlLmluZm8gfHwgdHJlZS5tYXAuc2l6ZSk7XG59XG5mdW5jdGlvbiBtYXliZVJlY3ljbGVDaGlsZE1lcmdlVHJlZShfYSwgbmFtZSkge1xuICAgIHZhciBtYXAgPSBfYS5tYXA7XG4gICAgdmFyIGNoaWxkVHJlZSA9IG1hcC5nZXQobmFtZSk7XG4gICAgaWYgKGNoaWxkVHJlZSAmJiBtZXJnZVRyZWVJc0VtcHR5KGNoaWxkVHJlZSkpIHtcbiAgICAgICAgZW1wdHlNZXJnZVRyZWVQb29sLnB1c2goY2hpbGRUcmVlKTtcbiAgICAgICAgbWFwLmRlbGV0ZShuYW1lKTtcbiAgICB9XG59XG52YXIgd2FybmluZ3MgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiB3YXJuQWJvdXREYXRhTG9zcyhleGlzdGluZ1JlZiwgaW5jb21pbmdPYmosIHN0b3JlRmllbGROYW1lLCBzdG9yZSkge1xuICAgIHZhciBnZXRDaGlsZCA9IGZ1bmN0aW9uIChvYmpPclJlZikge1xuICAgICAgICB2YXIgY2hpbGQgPSBzdG9yZS5nZXRGaWVsZFZhbHVlKG9iak9yUmVmLCBzdG9yZUZpZWxkTmFtZSk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgY2hpbGQgPT09IFwib2JqZWN0XCIgJiYgY2hpbGQ7XG4gICAgfTtcbiAgICB2YXIgZXhpc3RpbmcgPSBnZXRDaGlsZChleGlzdGluZ1JlZik7XG4gICAgaWYgKCFleGlzdGluZylcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciBpbmNvbWluZyA9IGdldENoaWxkKGluY29taW5nT2JqKTtcbiAgICBpZiAoIWluY29taW5nKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHV0aWxpdGllcy5pc1JlZmVyZW5jZShleGlzdGluZykpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoZXF1YWxpdHkuZXF1YWwoZXhpc3RpbmcsIGluY29taW5nKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChPYmplY3Qua2V5cyhleGlzdGluZykuZXZlcnkoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gc3RvcmUuZ2V0RmllbGRWYWx1ZShpbmNvbWluZywga2V5KSAhPT0gdm9pZCAwOyB9KSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwYXJlbnRUeXBlID0gc3RvcmUuZ2V0RmllbGRWYWx1ZShleGlzdGluZ1JlZiwgXCJfX3R5cGVuYW1lXCIpIHx8XG4gICAgICAgIHN0b3JlLmdldEZpZWxkVmFsdWUoaW5jb21pbmdPYmosIFwiX190eXBlbmFtZVwiKTtcbiAgICB2YXIgZmllbGROYW1lID0gZmllbGROYW1lRnJvbVN0b3JlTmFtZShzdG9yZUZpZWxkTmFtZSk7XG4gICAgdmFyIHR5cGVEb3ROYW1lID0gXCJcIi5jb25jYXQocGFyZW50VHlwZSwgXCIuXCIpLmNvbmNhdChmaWVsZE5hbWUpO1xuICAgIGlmICh3YXJuaW5ncy5oYXModHlwZURvdE5hbWUpKVxuICAgICAgICByZXR1cm47XG4gICAgd2FybmluZ3MuYWRkKHR5cGVEb3ROYW1lKTtcbiAgICB2YXIgY2hpbGRUeXBlbmFtZXMgPSBbXTtcbiAgICBpZiAoIWlzQXJyYXkoZXhpc3RpbmcpICYmXG4gICAgICAgICFpc0FycmF5KGluY29taW5nKSkge1xuICAgICAgICBbZXhpc3RpbmcsIGluY29taW5nXS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgdmFyIHR5cGVuYW1lID0gc3RvcmUuZ2V0RmllbGRWYWx1ZShjaGlsZCwgXCJfX3R5cGVuYW1lXCIpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlbmFtZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgICFjaGlsZFR5cGVuYW1lcy5pbmNsdWRlcyh0eXBlbmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFR5cGVuYW1lcy5wdXNoKHR5cGVuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9fREVWX18gJiYgZ2xvYmFscy5pbnZhcmlhbnQud2FybihcIkNhY2hlIGRhdGEgbWF5IGJlIGxvc3Qgd2hlbiByZXBsYWNpbmcgdGhlIFwiLmNvbmNhdChmaWVsZE5hbWUsIFwiIGZpZWxkIG9mIGEgXCIpLmNvbmNhdChwYXJlbnRUeXBlLCBcIiBvYmplY3QuXFxuXFxuVG8gYWRkcmVzcyB0aGlzIHByb2JsZW0gKHdoaWNoIGlzIG5vdCBhIGJ1ZyBpbiBBcG9sbG8gQ2xpZW50KSwgXCIpLmNvbmNhdChjaGlsZFR5cGVuYW1lcy5sZW5ndGhcbiAgICAgICAgPyBcImVpdGhlciBlbnN1cmUgYWxsIG9iamVjdHMgb2YgdHlwZSBcIiArXG4gICAgICAgICAgICBjaGlsZFR5cGVuYW1lcy5qb2luKFwiIGFuZCBcIikgKyBcIiBoYXZlIGFuIElEIG9yIGEgY3VzdG9tIG1lcmdlIGZ1bmN0aW9uLCBvciBcIlxuICAgICAgICA6IFwiXCIsIFwiZGVmaW5lIGEgY3VzdG9tIG1lcmdlIGZ1bmN0aW9uIGZvciB0aGUgXCIpLmNvbmNhdCh0eXBlRG90TmFtZSwgXCIgZmllbGQsIHNvIEluTWVtb3J5Q2FjaGUgY2FuIHNhZmVseSBtZXJnZSB0aGVzZSBvYmplY3RzOlxcblxcbiAgZXhpc3Rpbmc6IFwiKS5jb25jYXQoSlNPTi5zdHJpbmdpZnkoZXhpc3RpbmcpLnNsaWNlKDAsIDEwMDApLCBcIlxcbiAgaW5jb21pbmc6IFwiKS5jb25jYXQoSlNPTi5zdHJpbmdpZnkoaW5jb21pbmcpLnNsaWNlKDAsIDEwMDApLCBcIlxcblxcbkZvciBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZXNlIG9wdGlvbnMsIHBsZWFzZSByZWZlciB0byB0aGUgZG9jdW1lbnRhdGlvbjpcXG5cXG4gICogRW5zdXJpbmcgZW50aXR5IG9iamVjdHMgaGF2ZSBJRHM6IGh0dHBzOi8vZ28uYXBvbGxvLmRldi9jL2dlbmVyYXRpbmctdW5pcXVlLWlkZW50aWZpZXJzXFxuICAqIERlZmluaW5nIGN1c3RvbSBtZXJnZSBmdW5jdGlvbnM6IGh0dHBzOi8vZ28uYXBvbGxvLmRldi9jL21lcmdpbmctbm9uLW5vcm1hbGl6ZWQtb2JqZWN0c1xcblwiKSk7XG59XG5cbnZhciBJbk1lbW9yeUNhY2hlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoSW5NZW1vcnlDYWNoZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbk1lbW9yeUNhY2hlKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0ge307IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMud2F0Y2hlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgX3RoaXMudHlwZW5hbWVEb2N1bWVudENhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICBfdGhpcy5tYWtlVmFyID0gbWFrZVZhcjtcbiAgICAgICAgX3RoaXMudHhDb3VudCA9IDA7XG4gICAgICAgIF90aGlzLmNvbmZpZyA9IG5vcm1hbGl6ZUNvbmZpZyhjb25maWcpO1xuICAgICAgICBfdGhpcy5hZGRUeXBlbmFtZSA9ICEhX3RoaXMuY29uZmlnLmFkZFR5cGVuYW1lO1xuICAgICAgICBfdGhpcy5wb2xpY2llcyA9IG5ldyBQb2xpY2llcyh7XG4gICAgICAgICAgICBjYWNoZTogX3RoaXMsXG4gICAgICAgICAgICBkYXRhSWRGcm9tT2JqZWN0OiBfdGhpcy5jb25maWcuZGF0YUlkRnJvbU9iamVjdCxcbiAgICAgICAgICAgIHBvc3NpYmxlVHlwZXM6IF90aGlzLmNvbmZpZy5wb3NzaWJsZVR5cGVzLFxuICAgICAgICAgICAgdHlwZVBvbGljaWVzOiBfdGhpcy5jb25maWcudHlwZVBvbGljaWVzLFxuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuaW5pdCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb290U3RvcmUgPSB0aGlzLmRhdGEgPSBuZXcgZXhwb3J0cy5FbnRpdHlTdG9yZS5Sb290KHtcbiAgICAgICAgICAgIHBvbGljaWVzOiB0aGlzLnBvbGljaWVzLFxuICAgICAgICAgICAgcmVzdWx0Q2FjaGluZzogdGhpcy5jb25maWcucmVzdWx0Q2FjaGluZyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub3B0aW1pc3RpY0RhdGEgPSByb290U3RvcmUuc3R1bXA7XG4gICAgICAgIHRoaXMucmVzZXRSZXN1bHRDYWNoZSgpO1xuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUucmVzZXRSZXN1bHRDYWNoZSA9IGZ1bmN0aW9uIChyZXNldFJlc3VsdElkZW50aXRpZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHByZXZpb3VzUmVhZGVyID0gdGhpcy5zdG9yZVJlYWRlcjtcbiAgICAgICAgdmFyIGZyYWdtZW50cyA9IHRoaXMuY29uZmlnLmZyYWdtZW50cztcbiAgICAgICAgdGhpcy5zdG9yZVdyaXRlciA9IG5ldyBTdG9yZVdyaXRlcih0aGlzLCB0aGlzLnN0b3JlUmVhZGVyID0gbmV3IFN0b3JlUmVhZGVyKHtcbiAgICAgICAgICAgIGNhY2hlOiB0aGlzLFxuICAgICAgICAgICAgYWRkVHlwZW5hbWU6IHRoaXMuYWRkVHlwZW5hbWUsXG4gICAgICAgICAgICByZXN1bHRDYWNoZU1heFNpemU6IHRoaXMuY29uZmlnLnJlc3VsdENhY2hlTWF4U2l6ZSxcbiAgICAgICAgICAgIGNhbm9uaXplUmVzdWx0czogc2hvdWxkQ2Fub25pemVSZXN1bHRzKHRoaXMuY29uZmlnKSxcbiAgICAgICAgICAgIGNhbm9uOiByZXNldFJlc3VsdElkZW50aXRpZXNcbiAgICAgICAgICAgICAgICA/IHZvaWQgMFxuICAgICAgICAgICAgICAgIDogcHJldmlvdXNSZWFkZXIgJiYgcHJldmlvdXNSZWFkZXIuY2Fub24sXG4gICAgICAgICAgICBmcmFnbWVudHM6IGZyYWdtZW50cyxcbiAgICAgICAgfSksIGZyYWdtZW50cyk7XG4gICAgICAgIHRoaXMubWF5YmVCcm9hZGNhc3RXYXRjaCA9IG9wdGltaXNtLndyYXAoZnVuY3Rpb24gKGMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5icm9hZGNhc3RXYXRjaChjLCBvcHRpb25zKTtcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbWF4OiB0aGlzLmNvbmZpZy5yZXN1bHRDYWNoZU1heFNpemUsXG4gICAgICAgICAgICBtYWtlQ2FjaGVLZXk6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gYy5vcHRpbWlzdGljID8gX3RoaXMub3B0aW1pc3RpY0RhdGEgOiBfdGhpcy5kYXRhO1xuICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0c1Jlc3VsdENhY2hpbmcoc3RvcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpbWlzdGljID0gYy5vcHRpbWlzdGljLCBpZCA9IGMuaWQsIHZhcmlhYmxlcyA9IGMudmFyaWFibGVzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmUubWFrZUNhY2hlS2V5KGMucXVlcnksIGMuY2FsbGJhY2ssIGNhbm9uaWNhbFN0cmluZ2lmeSh7IG9wdGltaXN0aWM6IG9wdGltaXN0aWMsIGlkOiBpZCwgdmFyaWFibGVzOiB2YXJpYWJsZXMgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG5ldyBTZXQoW1xuICAgICAgICAgICAgdGhpcy5kYXRhLmdyb3VwLFxuICAgICAgICAgICAgdGhpcy5vcHRpbWlzdGljRGF0YS5ncm91cCxcbiAgICAgICAgXSkuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXApIHsgcmV0dXJuIGdyb3VwLnJlc2V0Q2FjaGluZygpOyB9KTtcbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLnJlc3RvcmUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgaWYgKGRhdGEpXG4gICAgICAgICAgICB0aGlzLmRhdGEucmVwbGFjZShkYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBJbk1lbW9yeUNhY2hlLnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24gKG9wdGltaXN0aWMpIHtcbiAgICAgICAgaWYgKG9wdGltaXN0aWMgPT09IHZvaWQgMCkgeyBvcHRpbWlzdGljID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIChvcHRpbWlzdGljID8gdGhpcy5vcHRpbWlzdGljRGF0YSA6IHRoaXMuZGF0YSkuZXh0cmFjdCgpO1xuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSA9IG9wdGlvbnMucmV0dXJuUGFydGlhbERhdGEsIHJldHVyblBhcnRpYWxEYXRhID0gX2EgPT09IHZvaWQgMCA/IGZhbHNlIDogX2E7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdG9yZVJlYWRlci5kaWZmUXVlcnlBZ2FpbnN0U3RvcmUodHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHN0b3JlOiBvcHRpb25zLm9wdGltaXN0aWMgPyB0aGlzLm9wdGltaXN0aWNEYXRhIDogdGhpcy5kYXRhLCBjb25maWc6IHRoaXMuY29uZmlnLCByZXR1cm5QYXJ0aWFsRGF0YTogcmV0dXJuUGFydGlhbERhdGEgfSkpLnJlc3VsdCB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIE1pc3NpbmdGaWVsZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbk1lbW9yeUNhY2hlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICArK3RoaXMudHhDb3VudDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0b3JlV3JpdGVyLndyaXRlVG9TdG9yZSh0aGlzLmRhdGEsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKCEtLXRoaXMudHhDb3VudCAmJiBvcHRpb25zLmJyb2FkY2FzdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJyb2FkY2FzdFdhdGNoZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUubW9kaWZ5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGhhc093bi5jYWxsKG9wdGlvbnMsIFwiaWRcIikgJiYgIW9wdGlvbnMuaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RvcmUgPSBvcHRpb25zLm9wdGltaXN0aWNcbiAgICAgICAgICAgID8gdGhpcy5vcHRpbWlzdGljRGF0YVxuICAgICAgICAgICAgOiB0aGlzLmRhdGE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICArK3RoaXMudHhDb3VudDtcbiAgICAgICAgICAgIHJldHVybiBzdG9yZS5tb2RpZnkob3B0aW9ucy5pZCB8fCBcIlJPT1RfUVVFUllcIiwgb3B0aW9ucy5maWVsZHMpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKCEtLXRoaXMudHhDb3VudCAmJiBvcHRpb25zLmJyb2FkY2FzdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJyb2FkY2FzdFdhdGNoZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUuZGlmZiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlUmVhZGVyLmRpZmZRdWVyeUFnYWluc3RTdG9yZSh0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgc3RvcmU6IG9wdGlvbnMub3B0aW1pc3RpYyA/IHRoaXMub3B0aW1pc3RpY0RhdGEgOiB0aGlzLmRhdGEsIHJvb3RJZDogb3B0aW9ucy5pZCB8fCBcIlJPT1RfUVVFUllcIiwgY29uZmlnOiB0aGlzLmNvbmZpZyB9KSk7XG4gICAgfTtcbiAgICBJbk1lbW9yeUNhY2hlLnByb3RvdHlwZS53YXRjaCA9IGZ1bmN0aW9uICh3YXRjaCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMud2F0Y2hlcy5zaXplKSB7XG4gICAgICAgICAgICByZWNhbGxDYWNoZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhdGNoZXMuYWRkKHdhdGNoKTtcbiAgICAgICAgaWYgKHdhdGNoLmltbWVkaWF0ZSkge1xuICAgICAgICAgICAgdGhpcy5tYXliZUJyb2FkY2FzdFdhdGNoKHdhdGNoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLndhdGNoZXMuZGVsZXRlKHdhdGNoKSAmJiAhX3RoaXMud2F0Y2hlcy5zaXplKSB7XG4gICAgICAgICAgICAgICAgZm9yZ2V0Q2FjaGUoX3RoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMubWF5YmVCcm9hZGNhc3RXYXRjaC5mb3JnZXQod2F0Y2gpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUuZ2MgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBjYW5vbmljYWxTdHJpbmdpZnkucmVzZXQoKTtcbiAgICAgICAgdmFyIGlkcyA9IHRoaXMub3B0aW1pc3RpY0RhdGEuZ2MoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgIXRoaXMudHhDb3VudCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVzZXRSZXN1bHRDYWNoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRSZXN1bHRDYWNoZShvcHRpb25zLnJlc2V0UmVzdWx0SWRlbnRpdGllcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLnJlc2V0UmVzdWx0SWRlbnRpdGllcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmVSZWFkZXIucmVzZXRDYW5vbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZHM7XG4gICAgfTtcbiAgICBJbk1lbW9yeUNhY2hlLnByb3RvdHlwZS5yZXRhaW4gPSBmdW5jdGlvbiAocm9vdElkLCBvcHRpbWlzdGljKSB7XG4gICAgICAgIHJldHVybiAob3B0aW1pc3RpYyA/IHRoaXMub3B0aW1pc3RpY0RhdGEgOiB0aGlzLmRhdGEpLnJldGFpbihyb290SWQpO1xuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uIChyb290SWQsIG9wdGltaXN0aWMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpbWlzdGljID8gdGhpcy5vcHRpbWlzdGljRGF0YSA6IHRoaXMuZGF0YSkucmVsZWFzZShyb290SWQpO1xuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUuaWRlbnRpZnkgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICAgIGlmICh1dGlsaXRpZXMuaXNSZWZlcmVuY2Uob2JqZWN0KSlcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QuX19yZWY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb2xpY2llcy5pZGVudGlmeShvYmplY3QpWzBdO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBfX0RFVl9fICYmIGdsb2JhbHMuaW52YXJpYW50Lndhcm4oZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLmV2aWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLmlkKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwob3B0aW9ucywgXCJpZFwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnMgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgaWQ6IFwiUk9PVF9RVUVSWVwiIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICArK3RoaXMudHhDb3VudDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGltaXN0aWNEYXRhLmV2aWN0KG9wdGlvbnMsIHRoaXMuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoIS0tdGhpcy50eENvdW50ICYmIG9wdGlvbnMuYnJvYWRjYXN0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0V2F0Y2hlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBJbk1lbW9yeUNhY2hlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICBjYW5vbmljYWxTdHJpbmdpZnkucmVzZXQoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kaXNjYXJkV2F0Y2hlcykge1xuICAgICAgICAgICAgdGhpcy53YXRjaGVzLmZvckVhY2goZnVuY3Rpb24gKHdhdGNoKSB7IHJldHVybiBfdGhpcy5tYXliZUJyb2FkY2FzdFdhdGNoLmZvcmdldCh3YXRjaCk7IH0pO1xuICAgICAgICAgICAgdGhpcy53YXRjaGVzLmNsZWFyKCk7XG4gICAgICAgICAgICBmb3JnZXRDYWNoZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0V2F0Y2hlcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLnJlbW92ZU9wdGltaXN0aWMgPSBmdW5jdGlvbiAoaWRUb1JlbW92ZSkge1xuICAgICAgICB2YXIgbmV3T3B0aW1pc3RpY0RhdGEgPSB0aGlzLm9wdGltaXN0aWNEYXRhLnJlbW92ZUxheWVyKGlkVG9SZW1vdmUpO1xuICAgICAgICBpZiAobmV3T3B0aW1pc3RpY0RhdGEgIT09IHRoaXMub3B0aW1pc3RpY0RhdGEpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW1pc3RpY0RhdGEgPSBuZXdPcHRpbWlzdGljRGF0YTtcbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0V2F0Y2hlcygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbk1lbW9yeUNhY2hlLnByb3RvdHlwZS5iYXRjaCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB1cGRhdGUgPSBvcHRpb25zLnVwZGF0ZSwgX2EgPSBvcHRpb25zLm9wdGltaXN0aWMsIG9wdGltaXN0aWMgPSBfYSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9hLCByZW1vdmVPcHRpbWlzdGljID0gb3B0aW9ucy5yZW1vdmVPcHRpbWlzdGljLCBvbldhdGNoVXBkYXRlZCA9IG9wdGlvbnMub25XYXRjaFVwZGF0ZWQ7XG4gICAgICAgIHZhciB1cGRhdGVSZXN1bHQ7XG4gICAgICAgIHZhciBwZXJmb3JtID0gZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcywgZGF0YSA9IF9hLmRhdGEsIG9wdGltaXN0aWNEYXRhID0gX2Eub3B0aW1pc3RpY0RhdGE7XG4gICAgICAgICAgICArK190aGlzLnR4Q291bnQ7XG4gICAgICAgICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5kYXRhID0gX3RoaXMub3B0aW1pc3RpY0RhdGEgPSBsYXllcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVJlc3VsdCA9IHVwZGF0ZShfdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAtLV90aGlzLnR4Q291bnQ7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgX3RoaXMub3B0aW1pc3RpY0RhdGEgPSBvcHRpbWlzdGljRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGFscmVhZHlEaXJ0eSA9IG5ldyBTZXQoKTtcbiAgICAgICAgaWYgKG9uV2F0Y2hVcGRhdGVkICYmICF0aGlzLnR4Q291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0V2F0Y2hlcyh0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgb25XYXRjaFVwZGF0ZWQ6IGZ1bmN0aW9uICh3YXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBhbHJlYWR5RGlydHkuYWRkKHdhdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW1pc3RpYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW1pc3RpY0RhdGEgPSB0aGlzLm9wdGltaXN0aWNEYXRhLmFkZExheWVyKG9wdGltaXN0aWMsIHBlcmZvcm0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGltaXN0aWMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBwZXJmb3JtKHRoaXMuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwZXJmb3JtKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByZW1vdmVPcHRpbWlzdGljID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGltaXN0aWNEYXRhID0gdGhpcy5vcHRpbWlzdGljRGF0YS5yZW1vdmVMYXllcihyZW1vdmVPcHRpbWlzdGljKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25XYXRjaFVwZGF0ZWQgJiYgYWxyZWFkeURpcnR5LnNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0V2F0Y2hlcyh0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgb25XYXRjaFVwZGF0ZWQ6IGZ1bmN0aW9uICh3YXRjaCwgZGlmZikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gb25XYXRjaFVwZGF0ZWQuY2FsbCh0aGlzLCB3YXRjaCwgZGlmZik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHJlYWR5RGlydHkuZGVsZXRlKHdhdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0gfSkpO1xuICAgICAgICAgICAgaWYgKGFscmVhZHlEaXJ0eS5zaXplKSB7XG4gICAgICAgICAgICAgICAgYWxyZWFkeURpcnR5LmZvckVhY2goZnVuY3Rpb24gKHdhdGNoKSB7IHJldHVybiBfdGhpcy5tYXliZUJyb2FkY2FzdFdhdGNoLmRpcnR5KHdhdGNoKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdFdhdGNoZXMob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVwZGF0ZVJlc3VsdDtcbiAgICB9O1xuICAgIEluTWVtb3J5Q2FjaGUucHJvdG90eXBlLnBlcmZvcm1UcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh1cGRhdGUsIG9wdGltaXN0aWNJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXRjaCh7XG4gICAgICAgICAgICB1cGRhdGU6IHVwZGF0ZSxcbiAgICAgICAgICAgIG9wdGltaXN0aWM6IG9wdGltaXN0aWNJZCB8fCAob3B0aW1pc3RpY0lkICE9PSBudWxsKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBJbk1lbW9yeUNhY2hlLnByb3RvdHlwZS50cmFuc2Zvcm1Eb2N1bWVudCA9IGZ1bmN0aW9uIChkb2N1bWVudCkge1xuICAgICAgICBpZiAodGhpcy5hZGRUeXBlbmFtZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMudHlwZW5hbWVEb2N1bWVudENhY2hlLmdldChkb2N1bWVudCk7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHV0aWxpdGllcy5hZGRUeXBlbmFtZVRvRG9jdW1lbnQoZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZW5hbWVEb2N1bWVudENhY2hlLnNldChkb2N1bWVudCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGVuYW1lRG9jdW1lbnRDYWNoZS5zZXQocmVzdWx0LCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgfTtcbiAgICBJbk1lbW9yeUNhY2hlLnByb3RvdHlwZS50cmFuc2Zvcm1Gb3JMaW5rID0gZnVuY3Rpb24gKGRvY3VtZW50KSB7XG4gICAgICAgIHZhciBmcmFnbWVudHMgPSB0aGlzLmNvbmZpZy5mcmFnbWVudHM7XG4gICAgICAgIHJldHVybiBmcmFnbWVudHNcbiAgICAgICAgICAgID8gZnJhZ21lbnRzLnRyYW5zZm9ybShkb2N1bWVudClcbiAgICAgICAgICAgIDogZG9jdW1lbnQ7XG4gICAgfTtcbiAgICBJbk1lbW9yeUNhY2hlLnByb3RvdHlwZS5icm9hZGNhc3RXYXRjaGVzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnR4Q291bnQpIHtcbiAgICAgICAgICAgIHRoaXMud2F0Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBfdGhpcy5tYXliZUJyb2FkY2FzdFdhdGNoKGMsIG9wdGlvbnMpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5NZW1vcnlDYWNoZS5wcm90b3R5cGUuYnJvYWRjYXN0V2F0Y2ggPSBmdW5jdGlvbiAoYywgb3B0aW9ucykge1xuICAgICAgICB2YXIgbGFzdERpZmYgPSBjLmxhc3REaWZmO1xuICAgICAgICB2YXIgZGlmZiA9IHRoaXMuZGlmZihjKTtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChjLm9wdGltaXN0aWMgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy5vcHRpbWlzdGljID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgZGlmZi5mcm9tT3B0aW1pc3RpY1RyYW5zYWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uV2F0Y2hVcGRhdGVkICYmXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vbldhdGNoVXBkYXRlZC5jYWxsKHRoaXMsIGMsIGRpZmYsIGxhc3REaWZmKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsYXN0RGlmZiB8fCAhZXF1YWxpdHkuZXF1YWwobGFzdERpZmYucmVzdWx0LCBkaWZmLnJlc3VsdCkpIHtcbiAgICAgICAgICAgIGMuY2FsbGJhY2soYy5sYXN0RGlmZiA9IGRpZmYsIGxhc3REaWZmKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEluTWVtb3J5Q2FjaGU7XG59KEFwb2xsb0NhY2hlKSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50UmVnaXN0cnkoKSB7XG4gICAgdmFyIGZyYWdtZW50cyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGZyYWdtZW50c1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IChGcmFnbWVudFJlZ2lzdHJ5LmJpbmQuYXBwbHkoRnJhZ21lbnRSZWdpc3RyeSwgdHNsaWIuX19zcHJlYWRBcnJheShbdm9pZCAwXSwgZnJhZ21lbnRzLCBmYWxzZSkpKSgpO1xufVxudmFyIGFycmF5TGlrZUZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcbnZhciBGcmFnbWVudFJlZ2lzdHJ5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGcmFnbWVudFJlZ2lzdHJ5KCkge1xuICAgICAgICB2YXIgZnJhZ21lbnRzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBmcmFnbWVudHNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZ2lzdHJ5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5yZXNldENhY2hlcygpO1xuICAgICAgICBpZiAoZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlci5hcHBseSh0aGlzLCBmcmFnbWVudHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEZyYWdtZW50UmVnaXN0cnkucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZGVmaW5pdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGFycmF5TGlrZUZvckVhY2guY2FsbChhcmd1bWVudHMsIGZ1bmN0aW9uIChkb2MpIHtcbiAgICAgICAgICAgIHV0aWxpdGllcy5nZXRGcmFnbWVudERlZmluaXRpb25zKGRvYykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGRlZmluaXRpb25zLnNldChub2RlLm5hbWUudmFsdWUsIG5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWZpbml0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XG4gICAgICAgICAgICBpZiAobm9kZSAhPT0gX3RoaXMucmVnaXN0cnlbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWdpc3RyeVtuYW1lXSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgX3RoaXMuaW52YWxpZGF0ZShuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgRnJhZ21lbnRSZWdpc3RyeS5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uIChuYW1lKSB7IH07XG4gICAgRnJhZ21lbnRSZWdpc3RyeS5wcm90b3R5cGUucmVzZXRDYWNoZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZSA9ICh0aGlzLmxvb2t1cCA9IHRoaXMuY2FjaGVVbmFyeU1ldGhvZChcImxvb2t1cFwiKSkuZGlydHk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gdGhpcy5jYWNoZVVuYXJ5TWV0aG9kKFwidHJhbnNmb3JtXCIpO1xuICAgICAgICB0aGlzLmZpbmRGcmFnbWVudFNwcmVhZHMgPSB0aGlzLmNhY2hlVW5hcnlNZXRob2QoXCJmaW5kRnJhZ21lbnRTcHJlYWRzXCIpO1xuICAgIH07XG4gICAgRnJhZ21lbnRSZWdpc3RyeS5wcm90b3R5cGUuY2FjaGVVbmFyeU1ldGhvZCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciByZWdpc3RyeSA9IHRoaXM7XG4gICAgICAgIHZhciBvcmlnaW5hbE1ldGhvZCA9IEZyYWdtZW50UmVnaXN0cnkucHJvdG90eXBlW25hbWVdO1xuICAgICAgICByZXR1cm4gb3B0aW1pc20ud3JhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxNZXRob2QuYXBwbHkocmVnaXN0cnksIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1ha2VDYWNoZUtleTogZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gYXJnOyB9LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEZyYWdtZW50UmVnaXN0cnkucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uIChmcmFnbWVudE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0cnlbZnJhZ21lbnROYW1lXSB8fCBudWxsO1xuICAgIH07XG4gICAgRnJhZ21lbnRSZWdpc3RyeS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKGRvY3VtZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBkZWZpbmVkID0gbmV3IE1hcCgpO1xuICAgICAgICB1dGlsaXRpZXMuZ2V0RnJhZ21lbnREZWZpbml0aW9ucyhkb2N1bWVudCkuZm9yRWFjaChmdW5jdGlvbiAoZGVmKSB7XG4gICAgICAgICAgICBkZWZpbmVkLnNldChkZWYubmFtZS52YWx1ZSwgZGVmKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB1bmJvdW5kID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgZW5xdWV1ZSA9IGZ1bmN0aW9uIChzcHJlYWROYW1lKSB7XG4gICAgICAgICAgICBpZiAoIWRlZmluZWQuaGFzKHNwcmVhZE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdW5ib3VuZC5hZGQoc3ByZWFkTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBlbnF1ZXVlQ2hpbGRTcHJlYWRzID0gZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIE9iamVjdC5rZXlzKF90aGlzLmZpbmRGcmFnbWVudFNwcmVhZHMobm9kZSkpLmZvckVhY2goZW5xdWV1ZSk7IH07XG4gICAgICAgIGVucXVldWVDaGlsZFNwcmVhZHMoZG9jdW1lbnQpO1xuICAgICAgICB2YXIgbWlzc2luZyA9IFtdO1xuICAgICAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdW5ib3VuZC5mb3JFYWNoKGZ1bmN0aW9uIChmcmFnbWVudE5hbWUpIHtcbiAgICAgICAgICAgIHZhciBrbm93bkZyYWdtZW50RGVmID0gZGVmaW5lZC5nZXQoZnJhZ21lbnROYW1lKTtcbiAgICAgICAgICAgIGlmIChrbm93bkZyYWdtZW50RGVmKSB7XG4gICAgICAgICAgICAgICAgZW5xdWV1ZUNoaWxkU3ByZWFkcyhtYXBbZnJhZ21lbnROYW1lXSA9IGtub3duRnJhZ21lbnREZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWlzc2luZy5wdXNoKGZyYWdtZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgdmFyIGRlZiA9IF90aGlzLmxvb2t1cChmcmFnbWVudE5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChkZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5xdWV1ZUNoaWxkU3ByZWFkcyhtYXBbZnJhZ21lbnROYW1lXSA9IGRlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG1pc3NpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgZGVmc1RvQXBwZW5kXzEgPSBbXTtcbiAgICAgICAgICAgIG1pc3NpbmcuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWYgPSBtYXBbbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGRlZikge1xuICAgICAgICAgICAgICAgICAgICBkZWZzVG9BcHBlbmRfMS5wdXNoKGRlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZGVmc1RvQXBwZW5kXzEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgZG9jdW1lbnQpLCB7IGRlZmluaXRpb25zOiBkb2N1bWVudC5kZWZpbml0aW9ucy5jb25jYXQoZGVmc1RvQXBwZW5kXzEpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICB9O1xuICAgIEZyYWdtZW50UmVnaXN0cnkucHJvdG90eXBlLmZpbmRGcmFnbWVudFNwcmVhZHMgPSBmdW5jdGlvbiAocm9vdCkge1xuICAgICAgICB2YXIgc3ByZWFkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGdyYXBocWwudmlzaXQocm9vdCwge1xuICAgICAgICAgICAgRnJhZ21lbnRTcHJlYWQ6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgc3ByZWFkc1tub2RlLm5hbWUudmFsdWVdID0gbm9kZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3ByZWFkcztcbiAgICB9O1xuICAgIHJldHVybiBGcmFnbWVudFJlZ2lzdHJ5O1xufSgpKTtcblxuZXhwb3J0cy5pc1JlZmVyZW5jZSA9IHV0aWxpdGllcy5pc1JlZmVyZW5jZTtcbmV4cG9ydHMubWFrZVJlZmVyZW5jZSA9IHV0aWxpdGllcy5tYWtlUmVmZXJlbmNlO1xuZXhwb3J0cy5BcG9sbG9DYWNoZSA9IEFwb2xsb0NhY2hlO1xuZXhwb3J0cy5Jbk1lbW9yeUNhY2hlID0gSW5NZW1vcnlDYWNoZTtcbmV4cG9ydHMuTWlzc2luZ0ZpZWxkRXJyb3IgPSBNaXNzaW5nRmllbGRFcnJvcjtcbmV4cG9ydHMuUG9saWNpZXMgPSBQb2xpY2llcztcbmV4cG9ydHMuY2FjaGVTbG90ID0gY2FjaGVTbG90O1xuZXhwb3J0cy5jYW5vbmljYWxTdHJpbmdpZnkgPSBjYW5vbmljYWxTdHJpbmdpZnk7XG5leHBvcnRzLmNyZWF0ZUZyYWdtZW50UmVnaXN0cnkgPSBjcmVhdGVGcmFnbWVudFJlZ2lzdHJ5O1xuZXhwb3J0cy5kZWZhdWx0RGF0YUlkRnJvbU9iamVjdCA9IGRlZmF1bHREYXRhSWRGcm9tT2JqZWN0O1xuZXhwb3J0cy5maWVsZE5hbWVGcm9tU3RvcmVOYW1lID0gZmllbGROYW1lRnJvbVN0b3JlTmFtZTtcbmV4cG9ydHMubWFrZVZhciA9IG1ha2VWYXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWNoZS5janMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@apollo/client/cache/cache.cjs\n");

/***/ }),

/***/ "./node_modules/@apollo/client/core/core.cjs":
/*!***************************************************!*\
  !*** ./node_modules/@apollo/client/core/core.cjs ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar globals = __webpack_require__(/*! ../utilities/globals */ \"./node_modules/@apollo/client/utilities/globals/globals.cjs\");\nvar tslib = __webpack_require__(/*! tslib */ \"tslib\");\nvar core = __webpack_require__(/*! ../link/core */ \"./node_modules/@apollo/client/link/core/core.cjs\");\nvar http = __webpack_require__(/*! ../link/http */ \"./node_modules/@apollo/client/link/http/http.cjs\");\nvar equality = __webpack_require__(/*! @wry/equality */ \"@wry/equality\");\nvar cache = __webpack_require__(/*! ../cache */ \"./node_modules/@apollo/client/cache/cache.cjs\");\nvar utilities = __webpack_require__(/*! ../utilities */ \"./node_modules/@apollo/client/utilities/utilities.cjs\");\nvar errors = __webpack_require__(/*! ../errors */ \"./node_modules/@apollo/client/errors/errors.cjs\");\nvar graphql = __webpack_require__(/*! graphql */ \"graphql\");\nvar utils = __webpack_require__(/*! ../link/utils */ \"./node_modules/@apollo/client/link/utils/utils.cjs\");\nvar tsInvariant = __webpack_require__(/*! ts-invariant */ \"./node_modules/ts-invariant/lib/invariant.cjs\");\nvar graphqlTag = __webpack_require__(/*! graphql-tag */ \"graphql-tag\");\n\nvar version = '3.7.1';\n\nfunction isExecutionPatchIncrementalResult(value) {\n    return !!value.incremental;\n}\n\nexports.NetworkStatus = void 0;\n(function (NetworkStatus) {\n    NetworkStatus[NetworkStatus[\"loading\"] = 1] = \"loading\";\n    NetworkStatus[NetworkStatus[\"setVariables\"] = 2] = \"setVariables\";\n    NetworkStatus[NetworkStatus[\"fetchMore\"] = 3] = \"fetchMore\";\n    NetworkStatus[NetworkStatus[\"refetch\"] = 4] = \"refetch\";\n    NetworkStatus[NetworkStatus[\"poll\"] = 6] = \"poll\";\n    NetworkStatus[NetworkStatus[\"ready\"] = 7] = \"ready\";\n    NetworkStatus[NetworkStatus[\"error\"] = 8] = \"error\";\n})(exports.NetworkStatus || (exports.NetworkStatus = {}));\nfunction isNetworkRequestInFlight(networkStatus) {\n    return networkStatus ? networkStatus < 7 : false;\n}\n\nvar assign = Object.assign, hasOwnProperty$1 = Object.hasOwnProperty;\nvar ObservableQuery = (function (_super) {\n    tslib.__extends(ObservableQuery, _super);\n    function ObservableQuery(_a) {\n        var queryManager = _a.queryManager, queryInfo = _a.queryInfo, options = _a.options;\n        var _this = _super.call(this, function (observer) {\n            try {\n                var subObserver = observer._subscription._observer;\n                if (subObserver && !subObserver.error) {\n                    subObserver.error = defaultSubscriptionObserverErrorCallback;\n                }\n            }\n            catch (_a) { }\n            var first = !_this.observers.size;\n            _this.observers.add(observer);\n            var last = _this.last;\n            if (last && last.error) {\n                observer.error && observer.error(last.error);\n            }\n            else if (last && last.result) {\n                observer.next && observer.next(last.result);\n            }\n            if (first) {\n                _this.reobserve().catch(function () { });\n            }\n            return function () {\n                if (_this.observers.delete(observer) && !_this.observers.size) {\n                    _this.tearDownQuery();\n                }\n            };\n        }) || this;\n        _this.observers = new Set();\n        _this.subscriptions = new Set();\n        _this.queryInfo = queryInfo;\n        _this.queryManager = queryManager;\n        _this.isTornDown = false;\n        var _b = queryManager.defaultOptions.watchQuery, _c = _b === void 0 ? {} : _b, _d = _c.fetchPolicy, defaultFetchPolicy = _d === void 0 ? \"cache-first\" : _d;\n        var _e = options.fetchPolicy, fetchPolicy = _e === void 0 ? defaultFetchPolicy : _e, _f = options.initialFetchPolicy, initialFetchPolicy = _f === void 0 ? (fetchPolicy === \"standby\" ? defaultFetchPolicy : fetchPolicy) : _f;\n        _this.options = tslib.__assign(tslib.__assign({}, options), { initialFetchPolicy: initialFetchPolicy, fetchPolicy: fetchPolicy });\n        _this.queryId = queryInfo.queryId || queryManager.generateQueryId();\n        var opDef = utilities.getOperationDefinition(_this.query);\n        _this.queryName = opDef && opDef.name && opDef.name.value;\n        return _this;\n    }\n    Object.defineProperty(ObservableQuery.prototype, \"query\", {\n        get: function () {\n            return this.queryManager.transform(this.options.query).document;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ObservableQuery.prototype, \"variables\", {\n        get: function () {\n            return this.options.variables;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ObservableQuery.prototype.result = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            var observer = {\n                next: function (result) {\n                    resolve(result);\n                    _this.observers.delete(observer);\n                    if (!_this.observers.size) {\n                        _this.queryManager.removeQuery(_this.queryId);\n                    }\n                    setTimeout(function () {\n                        subscription.unsubscribe();\n                    }, 0);\n                },\n                error: reject,\n            };\n            var subscription = _this.subscribe(observer);\n        });\n    };\n    ObservableQuery.prototype.getCurrentResult = function (saveAsLastResult) {\n        if (saveAsLastResult === void 0) { saveAsLastResult = true; }\n        var lastResult = this.getLastResult(true);\n        var networkStatus = this.queryInfo.networkStatus ||\n            (lastResult && lastResult.networkStatus) ||\n            exports.NetworkStatus.ready;\n        var result = tslib.__assign(tslib.__assign({}, lastResult), { loading: isNetworkRequestInFlight(networkStatus), networkStatus: networkStatus });\n        var _a = this.options.fetchPolicy, fetchPolicy = _a === void 0 ? \"cache-first\" : _a;\n        if (fetchPolicy === 'network-only' ||\n            fetchPolicy === 'no-cache' ||\n            fetchPolicy === 'standby' ||\n            this.queryManager.transform(this.options.query).hasForcedResolvers) ;\n        else {\n            var diff = this.queryInfo.getDiff();\n            if (diff.complete || this.options.returnPartialData) {\n                result.data = diff.result;\n            }\n            if (equality.equal(result.data, {})) {\n                result.data = void 0;\n            }\n            if (diff.complete) {\n                delete result.partial;\n                if (diff.complete &&\n                    result.networkStatus === exports.NetworkStatus.loading &&\n                    (fetchPolicy === 'cache-first' ||\n                        fetchPolicy === 'cache-only')) {\n                    result.networkStatus = exports.NetworkStatus.ready;\n                    result.loading = false;\n                }\n            }\n            else {\n                result.partial = true;\n            }\n            if (__DEV__ &&\n                !diff.complete &&\n                !this.options.partialRefetch &&\n                !result.loading &&\n                !result.data &&\n                !result.error) {\n                logMissingFieldErrors(diff.missing);\n            }\n        }\n        if (saveAsLastResult) {\n            this.updateLastResult(result);\n        }\n        return result;\n    };\n    ObservableQuery.prototype.isDifferentFromLastResult = function (newResult, variables) {\n        return (!this.last ||\n            !equality.equal(this.last.result, newResult) ||\n            (variables && !equality.equal(this.last.variables, variables)));\n    };\n    ObservableQuery.prototype.getLast = function (key, variablesMustMatch) {\n        var last = this.last;\n        if (last &&\n            last[key] &&\n            (!variablesMustMatch || equality.equal(last.variables, this.variables))) {\n            return last[key];\n        }\n    };\n    ObservableQuery.prototype.getLastResult = function (variablesMustMatch) {\n        return this.getLast(\"result\", variablesMustMatch);\n    };\n    ObservableQuery.prototype.getLastError = function (variablesMustMatch) {\n        return this.getLast(\"error\", variablesMustMatch);\n    };\n    ObservableQuery.prototype.resetLastResults = function () {\n        delete this.last;\n        this.isTornDown = false;\n    };\n    ObservableQuery.prototype.resetQueryStoreErrors = function () {\n        this.queryManager.resetErrors(this.queryId);\n    };\n    ObservableQuery.prototype.refetch = function (variables) {\n        var _a;\n        var reobserveOptions = {\n            pollInterval: 0,\n        };\n        var fetchPolicy = this.options.fetchPolicy;\n        if (fetchPolicy === 'cache-and-network') {\n            reobserveOptions.fetchPolicy = fetchPolicy;\n        }\n        else if (fetchPolicy === 'no-cache') {\n            reobserveOptions.fetchPolicy = 'no-cache';\n        }\n        else {\n            reobserveOptions.fetchPolicy = 'network-only';\n        }\n        if (__DEV__ && variables && hasOwnProperty$1.call(variables, \"variables\")) {\n            var queryDef = utilities.getQueryDefinition(this.query);\n            var vars = queryDef.variableDefinitions;\n            if (!vars || !vars.some(function (v) { return v.variable.name.value === \"variables\"; })) {\n                __DEV__ && globals.invariant.warn(\"Called refetch(\".concat(JSON.stringify(variables), \") for query \").concat(((_a = queryDef.name) === null || _a === void 0 ? void 0 : _a.value) || JSON.stringify(queryDef), \", which does not declare a $variables variable.\\nDid you mean to call refetch(variables) instead of refetch({ variables })?\"));\n            }\n        }\n        if (variables && !equality.equal(this.options.variables, variables)) {\n            reobserveOptions.variables = this.options.variables = tslib.__assign(tslib.__assign({}, this.options.variables), variables);\n        }\n        this.queryInfo.resetLastWrite();\n        return this.reobserve(reobserveOptions, exports.NetworkStatus.refetch);\n    };\n    ObservableQuery.prototype.fetchMore = function (fetchMoreOptions) {\n        var _this = this;\n        var combinedOptions = tslib.__assign(tslib.__assign({}, (fetchMoreOptions.query ? fetchMoreOptions : tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign({}, this.options), { query: this.query }), fetchMoreOptions), { variables: tslib.__assign(tslib.__assign({}, this.options.variables), fetchMoreOptions.variables) }))), { fetchPolicy: \"no-cache\" });\n        var qid = this.queryManager.generateQueryId();\n        var queryInfo = this.queryInfo;\n        var originalNetworkStatus = queryInfo.networkStatus;\n        queryInfo.networkStatus = exports.NetworkStatus.fetchMore;\n        if (combinedOptions.notifyOnNetworkStatusChange) {\n            this.observe();\n        }\n        var updatedQuerySet = new Set();\n        return this.queryManager.fetchQuery(qid, combinedOptions, exports.NetworkStatus.fetchMore).then(function (fetchMoreResult) {\n            _this.queryManager.removeQuery(qid);\n            if (queryInfo.networkStatus === exports.NetworkStatus.fetchMore) {\n                queryInfo.networkStatus = originalNetworkStatus;\n            }\n            _this.queryManager.cache.batch({\n                update: function (cache) {\n                    var updateQuery = fetchMoreOptions.updateQuery;\n                    if (updateQuery) {\n                        cache.updateQuery({\n                            query: _this.query,\n                            variables: _this.variables,\n                            returnPartialData: true,\n                            optimistic: false,\n                        }, function (previous) { return updateQuery(previous, {\n                            fetchMoreResult: fetchMoreResult.data,\n                            variables: combinedOptions.variables,\n                        }); });\n                    }\n                    else {\n                        cache.writeQuery({\n                            query: combinedOptions.query,\n                            variables: combinedOptions.variables,\n                            data: fetchMoreResult.data,\n                        });\n                    }\n                },\n                onWatchUpdated: function (watch) {\n                    updatedQuerySet.add(watch.query);\n                },\n            });\n            return fetchMoreResult;\n        }).finally(function () {\n            if (!updatedQuerySet.has(_this.query)) {\n                reobserveCacheFirst(_this);\n            }\n        });\n    };\n    ObservableQuery.prototype.subscribeToMore = function (options) {\n        var _this = this;\n        var subscription = this.queryManager\n            .startGraphQLSubscription({\n            query: options.document,\n            variables: options.variables,\n            context: options.context,\n        })\n            .subscribe({\n            next: function (subscriptionData) {\n                var updateQuery = options.updateQuery;\n                if (updateQuery) {\n                    _this.updateQuery(function (previous, _a) {\n                        var variables = _a.variables;\n                        return updateQuery(previous, {\n                            subscriptionData: subscriptionData,\n                            variables: variables,\n                        });\n                    });\n                }\n            },\n            error: function (err) {\n                if (options.onError) {\n                    options.onError(err);\n                    return;\n                }\n                __DEV__ && globals.invariant.error('Unhandled GraphQL subscription error', err);\n            },\n        });\n        this.subscriptions.add(subscription);\n        return function () {\n            if (_this.subscriptions.delete(subscription)) {\n                subscription.unsubscribe();\n            }\n        };\n    };\n    ObservableQuery.prototype.setOptions = function (newOptions) {\n        return this.reobserve(newOptions);\n    };\n    ObservableQuery.prototype.setVariables = function (variables) {\n        if (equality.equal(this.variables, variables)) {\n            return this.observers.size\n                ? this.result()\n                : Promise.resolve();\n        }\n        this.options.variables = variables;\n        if (!this.observers.size) {\n            return Promise.resolve();\n        }\n        return this.reobserve({\n            fetchPolicy: this.options.initialFetchPolicy,\n            variables: variables,\n        }, exports.NetworkStatus.setVariables);\n    };\n    ObservableQuery.prototype.updateQuery = function (mapFn) {\n        var queryManager = this.queryManager;\n        var result = queryManager.cache.diff({\n            query: this.options.query,\n            variables: this.variables,\n            returnPartialData: true,\n            optimistic: false,\n        }).result;\n        var newResult = mapFn(result, {\n            variables: this.variables,\n        });\n        if (newResult) {\n            queryManager.cache.writeQuery({\n                query: this.options.query,\n                data: newResult,\n                variables: this.variables,\n            });\n            queryManager.broadcastQueries();\n        }\n    };\n    ObservableQuery.prototype.startPolling = function (pollInterval) {\n        this.options.pollInterval = pollInterval;\n        this.updatePolling();\n    };\n    ObservableQuery.prototype.stopPolling = function () {\n        this.options.pollInterval = 0;\n        this.updatePolling();\n    };\n    ObservableQuery.prototype.applyNextFetchPolicy = function (reason, options) {\n        if (options.nextFetchPolicy) {\n            var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? \"cache-first\" : _a, _b = options.initialFetchPolicy, initialFetchPolicy = _b === void 0 ? fetchPolicy : _b;\n            if (fetchPolicy === \"standby\") ;\n            else if (typeof options.nextFetchPolicy === \"function\") {\n                options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {\n                    reason: reason,\n                    options: options,\n                    observable: this,\n                    initialFetchPolicy: initialFetchPolicy,\n                });\n            }\n            else if (reason === \"variables-changed\") {\n                options.fetchPolicy = initialFetchPolicy;\n            }\n            else {\n                options.fetchPolicy = options.nextFetchPolicy;\n            }\n        }\n        return options.fetchPolicy;\n    };\n    ObservableQuery.prototype.fetch = function (options, newNetworkStatus) {\n        this.queryManager.setObservableQuery(this);\n        return this.queryManager.fetchQueryObservable(this.queryId, options, newNetworkStatus);\n    };\n    ObservableQuery.prototype.updatePolling = function () {\n        var _this = this;\n        if (this.queryManager.ssrMode) {\n            return;\n        }\n        var _a = this, pollingInfo = _a.pollingInfo, pollInterval = _a.options.pollInterval;\n        if (!pollInterval) {\n            if (pollingInfo) {\n                clearTimeout(pollingInfo.timeout);\n                delete this.pollingInfo;\n            }\n            return;\n        }\n        if (pollingInfo &&\n            pollingInfo.interval === pollInterval) {\n            return;\n        }\n        __DEV__ ? globals.invariant(pollInterval, 'Attempted to start a polling query without a polling interval.') : globals.invariant(pollInterval, 12);\n        var info = pollingInfo || (this.pollingInfo = {});\n        info.interval = pollInterval;\n        var maybeFetch = function () {\n            if (_this.pollingInfo) {\n                if (!isNetworkRequestInFlight(_this.queryInfo.networkStatus)) {\n                    _this.reobserve({\n                        fetchPolicy: _this.options.initialFetchPolicy === 'no-cache' ? 'no-cache' : 'network-only',\n                    }, exports.NetworkStatus.poll).then(poll, poll);\n                }\n                else {\n                    poll();\n                }\n            }\n        };\n        var poll = function () {\n            var info = _this.pollingInfo;\n            if (info) {\n                clearTimeout(info.timeout);\n                info.timeout = setTimeout(maybeFetch, info.interval);\n            }\n        };\n        poll();\n    };\n    ObservableQuery.prototype.updateLastResult = function (newResult, variables) {\n        if (variables === void 0) { variables = this.variables; }\n        this.last = tslib.__assign(tslib.__assign({}, this.last), { result: this.queryManager.assumeImmutableResults\n                ? newResult\n                : utilities.cloneDeep(newResult), variables: variables });\n        if (!utilities.isNonEmptyArray(newResult.errors)) {\n            delete this.last.error;\n        }\n        return this.last;\n    };\n    ObservableQuery.prototype.reobserve = function (newOptions, newNetworkStatus) {\n        var _this = this;\n        this.isTornDown = false;\n        var useDisposableConcast = newNetworkStatus === exports.NetworkStatus.refetch ||\n            newNetworkStatus === exports.NetworkStatus.fetchMore ||\n            newNetworkStatus === exports.NetworkStatus.poll;\n        var oldVariables = this.options.variables;\n        var oldFetchPolicy = this.options.fetchPolicy;\n        var mergedOptions = utilities.compact(this.options, newOptions || {});\n        var options = useDisposableConcast\n            ? mergedOptions\n            : assign(this.options, mergedOptions);\n        if (!useDisposableConcast) {\n            this.updatePolling();\n            if (newOptions &&\n                newOptions.variables &&\n                !equality.equal(newOptions.variables, oldVariables) &&\n                options.fetchPolicy !== \"standby\" &&\n                options.fetchPolicy === oldFetchPolicy) {\n                this.applyNextFetchPolicy(\"variables-changed\", options);\n                if (newNetworkStatus === void 0) {\n                    newNetworkStatus = exports.NetworkStatus.setVariables;\n                }\n            }\n        }\n        var variables = options.variables && tslib.__assign({}, options.variables);\n        var concast = this.fetch(options, newNetworkStatus);\n        var observer = {\n            next: function (result) {\n                _this.reportResult(result, variables);\n            },\n            error: function (error) {\n                _this.reportError(error, variables);\n            },\n        };\n        if (!useDisposableConcast) {\n            if (this.concast && this.observer) {\n                this.concast.removeObserver(this.observer);\n            }\n            this.concast = concast;\n            this.observer = observer;\n        }\n        concast.addObserver(observer);\n        return concast.promise;\n    };\n    ObservableQuery.prototype.observe = function () {\n        this.reportResult(this.getCurrentResult(false), this.variables);\n    };\n    ObservableQuery.prototype.reportResult = function (result, variables) {\n        var lastError = this.getLastError();\n        if (lastError || this.isDifferentFromLastResult(result, variables)) {\n            if (lastError || !result.partial || this.options.returnPartialData) {\n                this.updateLastResult(result, variables);\n            }\n            utilities.iterateObserversSafely(this.observers, 'next', result);\n        }\n    };\n    ObservableQuery.prototype.reportError = function (error, variables) {\n        var errorResult = tslib.__assign(tslib.__assign({}, this.getLastResult()), { error: error, errors: error.graphQLErrors, networkStatus: exports.NetworkStatus.error, loading: false });\n        this.updateLastResult(errorResult, variables);\n        utilities.iterateObserversSafely(this.observers, 'error', this.last.error = error);\n    };\n    ObservableQuery.prototype.hasObservers = function () {\n        return this.observers.size > 0;\n    };\n    ObservableQuery.prototype.tearDownQuery = function () {\n        if (this.isTornDown)\n            return;\n        if (this.concast && this.observer) {\n            this.concast.removeObserver(this.observer);\n            delete this.concast;\n            delete this.observer;\n        }\n        this.stopPolling();\n        this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });\n        this.subscriptions.clear();\n        this.queryManager.stopQuery(this.queryId);\n        this.observers.clear();\n        this.isTornDown = true;\n    };\n    return ObservableQuery;\n}(utilities.Observable));\nutilities.fixObservableSubclass(ObservableQuery);\nfunction reobserveCacheFirst(obsQuery) {\n    var _a = obsQuery.options, fetchPolicy = _a.fetchPolicy, nextFetchPolicy = _a.nextFetchPolicy;\n    if (fetchPolicy === \"cache-and-network\" ||\n        fetchPolicy === \"network-only\") {\n        return obsQuery.reobserve({\n            fetchPolicy: \"cache-first\",\n            nextFetchPolicy: function () {\n                this.nextFetchPolicy = nextFetchPolicy;\n                if (typeof nextFetchPolicy === \"function\") {\n                    return nextFetchPolicy.apply(this, arguments);\n                }\n                return fetchPolicy;\n            },\n        });\n    }\n    return obsQuery.reobserve();\n}\nfunction defaultSubscriptionObserverErrorCallback(error) {\n    __DEV__ && globals.invariant.error('Unhandled error', error.message, error.stack);\n}\nfunction logMissingFieldErrors(missing) {\n    if (__DEV__ && missing) {\n        __DEV__ && globals.invariant.debug(\"Missing cache result fields: \".concat(JSON.stringify(missing)), missing);\n    }\n}\n\nvar LocalState = (function () {\n    function LocalState(_a) {\n        var cache = _a.cache, client = _a.client, resolvers = _a.resolvers, fragmentMatcher = _a.fragmentMatcher;\n        this.cache = cache;\n        if (client) {\n            this.client = client;\n        }\n        if (resolvers) {\n            this.addResolvers(resolvers);\n        }\n        if (fragmentMatcher) {\n            this.setFragmentMatcher(fragmentMatcher);\n        }\n    }\n    LocalState.prototype.addResolvers = function (resolvers) {\n        var _this = this;\n        this.resolvers = this.resolvers || {};\n        if (Array.isArray(resolvers)) {\n            resolvers.forEach(function (resolverGroup) {\n                _this.resolvers = utilities.mergeDeep(_this.resolvers, resolverGroup);\n            });\n        }\n        else {\n            this.resolvers = utilities.mergeDeep(this.resolvers, resolvers);\n        }\n    };\n    LocalState.prototype.setResolvers = function (resolvers) {\n        this.resolvers = {};\n        this.addResolvers(resolvers);\n    };\n    LocalState.prototype.getResolvers = function () {\n        return this.resolvers || {};\n    };\n    LocalState.prototype.runResolvers = function (_a) {\n        var document = _a.document, remoteResult = _a.remoteResult, context = _a.context, variables = _a.variables, _b = _a.onlyRunForcedResolvers, onlyRunForcedResolvers = _b === void 0 ? false : _b;\n        return tslib.__awaiter(this, void 0, void 0, function () {\n            return tslib.__generator(this, function (_c) {\n                if (document) {\n                    return [2, this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function (localResult) { return (tslib.__assign(tslib.__assign({}, remoteResult), { data: localResult.result })); })];\n                }\n                return [2, remoteResult];\n            });\n        });\n    };\n    LocalState.prototype.setFragmentMatcher = function (fragmentMatcher) {\n        this.fragmentMatcher = fragmentMatcher;\n    };\n    LocalState.prototype.getFragmentMatcher = function () {\n        return this.fragmentMatcher;\n    };\n    LocalState.prototype.clientQuery = function (document) {\n        if (utilities.hasDirectives(['client'], document)) {\n            if (this.resolvers) {\n                return document;\n            }\n        }\n        return null;\n    };\n    LocalState.prototype.serverQuery = function (document) {\n        return utilities.removeClientSetsFromDocument(document);\n    };\n    LocalState.prototype.prepareContext = function (context) {\n        var cache = this.cache;\n        return tslib.__assign(tslib.__assign({}, context), { cache: cache, getCacheKey: function (obj) {\n                return cache.identify(obj);\n            } });\n    };\n    LocalState.prototype.addExportedVariables = function (document, variables, context) {\n        if (variables === void 0) { variables = {}; }\n        if (context === void 0) { context = {}; }\n        return tslib.__awaiter(this, void 0, void 0, function () {\n            return tslib.__generator(this, function (_a) {\n                if (document) {\n                    return [2, this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function (data) { return (tslib.__assign(tslib.__assign({}, variables), data.exportedVariables)); })];\n                }\n                return [2, tslib.__assign({}, variables)];\n            });\n        });\n    };\n    LocalState.prototype.shouldForceResolvers = function (document) {\n        var forceResolvers = false;\n        graphql.visit(document, {\n            Directive: {\n                enter: function (node) {\n                    if (node.name.value === 'client' && node.arguments) {\n                        forceResolvers = node.arguments.some(function (arg) {\n                            return arg.name.value === 'always' &&\n                                arg.value.kind === 'BooleanValue' &&\n                                arg.value.value === true;\n                        });\n                        if (forceResolvers) {\n                            return graphql.BREAK;\n                        }\n                    }\n                },\n            },\n        });\n        return forceResolvers;\n    };\n    LocalState.prototype.buildRootValueFromCache = function (document, variables) {\n        return this.cache.diff({\n            query: utilities.buildQueryFromSelectionSet(document),\n            variables: variables,\n            returnPartialData: true,\n            optimistic: false,\n        }).result;\n    };\n    LocalState.prototype.resolveDocument = function (document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {\n        if (context === void 0) { context = {}; }\n        if (variables === void 0) { variables = {}; }\n        if (fragmentMatcher === void 0) { fragmentMatcher = function () { return true; }; }\n        if (onlyRunForcedResolvers === void 0) { onlyRunForcedResolvers = false; }\n        return tslib.__awaiter(this, void 0, void 0, function () {\n            var mainDefinition, fragments, fragmentMap, definitionOperation, defaultOperationType, _a, cache, client, execContext;\n            return tslib.__generator(this, function (_b) {\n                mainDefinition = utilities.getMainDefinition(document);\n                fragments = utilities.getFragmentDefinitions(document);\n                fragmentMap = utilities.createFragmentMap(fragments);\n                definitionOperation = mainDefinition\n                    .operation;\n                defaultOperationType = definitionOperation\n                    ? definitionOperation.charAt(0).toUpperCase() +\n                        definitionOperation.slice(1)\n                    : 'Query';\n                _a = this, cache = _a.cache, client = _a.client;\n                execContext = {\n                    fragmentMap: fragmentMap,\n                    context: tslib.__assign(tslib.__assign({}, context), { cache: cache, client: client }),\n                    variables: variables,\n                    fragmentMatcher: fragmentMatcher,\n                    defaultOperationType: defaultOperationType,\n                    exportedVariables: {},\n                    onlyRunForcedResolvers: onlyRunForcedResolvers,\n                };\n                return [2, this.resolveSelectionSet(mainDefinition.selectionSet, rootValue, execContext).then(function (result) { return ({\n                        result: result,\n                        exportedVariables: execContext.exportedVariables,\n                    }); })];\n            });\n        });\n    };\n    LocalState.prototype.resolveSelectionSet = function (selectionSet, rootValue, execContext) {\n        return tslib.__awaiter(this, void 0, void 0, function () {\n            var fragmentMap, context, variables, resultsToMerge, execute;\n            var _this = this;\n            return tslib.__generator(this, function (_a) {\n                fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;\n                resultsToMerge = [rootValue];\n                execute = function (selection) { return tslib.__awaiter(_this, void 0, void 0, function () {\n                    var fragment, typeCondition;\n                    return tslib.__generator(this, function (_a) {\n                        if (!utilities.shouldInclude(selection, variables)) {\n                            return [2];\n                        }\n                        if (utilities.isField(selection)) {\n                            return [2, this.resolveField(selection, rootValue, execContext).then(function (fieldResult) {\n                                    var _a;\n                                    if (typeof fieldResult !== 'undefined') {\n                                        resultsToMerge.push((_a = {},\n                                            _a[utilities.resultKeyNameFromField(selection)] = fieldResult,\n                                            _a));\n                                    }\n                                })];\n                        }\n                        if (utilities.isInlineFragment(selection)) {\n                            fragment = selection;\n                        }\n                        else {\n                            fragment = fragmentMap[selection.name.value];\n                            __DEV__ ? globals.invariant(fragment, \"No fragment named \".concat(selection.name.value)) : globals.invariant(fragment, 11);\n                        }\n                        if (fragment && fragment.typeCondition) {\n                            typeCondition = fragment.typeCondition.name.value;\n                            if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n                                return [2, this.resolveSelectionSet(fragment.selectionSet, rootValue, execContext).then(function (fragmentResult) {\n                                        resultsToMerge.push(fragmentResult);\n                                    })];\n                            }\n                        }\n                        return [2];\n                    });\n                }); };\n                return [2, Promise.all(selectionSet.selections.map(execute)).then(function () {\n                        return utilities.mergeDeepArray(resultsToMerge);\n                    })];\n            });\n        });\n    };\n    LocalState.prototype.resolveField = function (field, rootValue, execContext) {\n        return tslib.__awaiter(this, void 0, void 0, function () {\n            var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;\n            var _this = this;\n            return tslib.__generator(this, function (_a) {\n                variables = execContext.variables;\n                fieldName = field.name.value;\n                aliasedFieldName = utilities.resultKeyNameFromField(field);\n                aliasUsed = fieldName !== aliasedFieldName;\n                defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n                resultPromise = Promise.resolve(defaultResult);\n                if (!execContext.onlyRunForcedResolvers ||\n                    this.shouldForceResolvers(field)) {\n                    resolverType = rootValue.__typename || execContext.defaultOperationType;\n                    resolverMap = this.resolvers && this.resolvers[resolverType];\n                    if (resolverMap) {\n                        resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n                        if (resolve) {\n                            resultPromise = Promise.resolve(cache.cacheSlot.withValue(this.cache, resolve, [\n                                rootValue,\n                                utilities.argumentsObjectFromField(field, variables),\n                                execContext.context,\n                                { field: field, fragmentMap: execContext.fragmentMap },\n                            ]));\n                        }\n                    }\n                }\n                return [2, resultPromise.then(function (result) {\n                        if (result === void 0) { result = defaultResult; }\n                        if (field.directives) {\n                            field.directives.forEach(function (directive) {\n                                if (directive.name.value === 'export' && directive.arguments) {\n                                    directive.arguments.forEach(function (arg) {\n                                        if (arg.name.value === 'as' && arg.value.kind === 'StringValue') {\n                                            execContext.exportedVariables[arg.value.value] = result;\n                                        }\n                                    });\n                                }\n                            });\n                        }\n                        if (!field.selectionSet) {\n                            return result;\n                        }\n                        if (result == null) {\n                            return result;\n                        }\n                        if (Array.isArray(result)) {\n                            return _this.resolveSubSelectedArray(field, result, execContext);\n                        }\n                        if (field.selectionSet) {\n                            return _this.resolveSelectionSet(field.selectionSet, result, execContext);\n                        }\n                    })];\n            });\n        });\n    };\n    LocalState.prototype.resolveSubSelectedArray = function (field, result, execContext) {\n        var _this = this;\n        return Promise.all(result.map(function (item) {\n            if (item === null) {\n                return null;\n            }\n            if (Array.isArray(item)) {\n                return _this.resolveSubSelectedArray(field, item, execContext);\n            }\n            if (field.selectionSet) {\n                return _this.resolveSelectionSet(field.selectionSet, item, execContext);\n            }\n        }));\n    };\n    return LocalState;\n}());\n\nvar destructiveMethodCounts = new (utilities.canUseWeakMap ? WeakMap : Map)();\nfunction wrapDestructiveCacheMethod(cache, methodName) {\n    var original = cache[methodName];\n    if (typeof original === \"function\") {\n        cache[methodName] = function () {\n            destructiveMethodCounts.set(cache, (destructiveMethodCounts.get(cache) + 1) % 1e15);\n            return original.apply(this, arguments);\n        };\n    }\n}\nfunction cancelNotifyTimeout(info) {\n    if (info[\"notifyTimeout\"]) {\n        clearTimeout(info[\"notifyTimeout\"]);\n        info[\"notifyTimeout\"] = void 0;\n    }\n}\nvar QueryInfo = (function () {\n    function QueryInfo(queryManager, queryId) {\n        if (queryId === void 0) { queryId = queryManager.generateQueryId(); }\n        this.queryId = queryId;\n        this.listeners = new Set();\n        this.document = null;\n        this.lastRequestId = 1;\n        this.subscriptions = new Set();\n        this.stopped = false;\n        this.dirty = false;\n        this.observableQuery = null;\n        var cache = this.cache = queryManager.cache;\n        if (!destructiveMethodCounts.has(cache)) {\n            destructiveMethodCounts.set(cache, 0);\n            wrapDestructiveCacheMethod(cache, \"evict\");\n            wrapDestructiveCacheMethod(cache, \"modify\");\n            wrapDestructiveCacheMethod(cache, \"reset\");\n        }\n    }\n    QueryInfo.prototype.init = function (query) {\n        var networkStatus = query.networkStatus || exports.NetworkStatus.loading;\n        if (this.variables &&\n            this.networkStatus !== exports.NetworkStatus.loading &&\n            !equality.equal(this.variables, query.variables)) {\n            networkStatus = exports.NetworkStatus.setVariables;\n        }\n        if (!equality.equal(query.variables, this.variables)) {\n            this.lastDiff = void 0;\n        }\n        Object.assign(this, {\n            document: query.document,\n            variables: query.variables,\n            networkError: null,\n            graphQLErrors: this.graphQLErrors || [],\n            networkStatus: networkStatus,\n        });\n        if (query.observableQuery) {\n            this.setObservableQuery(query.observableQuery);\n        }\n        if (query.lastRequestId) {\n            this.lastRequestId = query.lastRequestId;\n        }\n        return this;\n    };\n    QueryInfo.prototype.reset = function () {\n        cancelNotifyTimeout(this);\n        this.dirty = false;\n    };\n    QueryInfo.prototype.getDiff = function (variables) {\n        if (variables === void 0) { variables = this.variables; }\n        var options = this.getDiffOptions(variables);\n        if (this.lastDiff && equality.equal(options, this.lastDiff.options)) {\n            return this.lastDiff.diff;\n        }\n        this.updateWatch(this.variables = variables);\n        var oq = this.observableQuery;\n        if (oq && oq.options.fetchPolicy === \"no-cache\") {\n            return { complete: false };\n        }\n        var diff = this.cache.diff(options);\n        this.updateLastDiff(diff, options);\n        return diff;\n    };\n    QueryInfo.prototype.updateLastDiff = function (diff, options) {\n        this.lastDiff = diff ? {\n            diff: diff,\n            options: options || this.getDiffOptions(),\n        } : void 0;\n    };\n    QueryInfo.prototype.getDiffOptions = function (variables) {\n        var _a;\n        if (variables === void 0) { variables = this.variables; }\n        return {\n            query: this.document,\n            variables: variables,\n            returnPartialData: true,\n            optimistic: true,\n            canonizeResults: (_a = this.observableQuery) === null || _a === void 0 ? void 0 : _a.options.canonizeResults,\n        };\n    };\n    QueryInfo.prototype.setDiff = function (diff) {\n        var _this = this;\n        var oldDiff = this.lastDiff && this.lastDiff.diff;\n        this.updateLastDiff(diff);\n        if (!this.dirty &&\n            !equality.equal(oldDiff && oldDiff.result, diff && diff.result)) {\n            this.dirty = true;\n            if (!this.notifyTimeout) {\n                this.notifyTimeout = setTimeout(function () { return _this.notify(); }, 0);\n            }\n        }\n    };\n    QueryInfo.prototype.setObservableQuery = function (oq) {\n        var _this = this;\n        if (oq === this.observableQuery)\n            return;\n        if (this.oqListener) {\n            this.listeners.delete(this.oqListener);\n        }\n        this.observableQuery = oq;\n        if (oq) {\n            oq[\"queryInfo\"] = this;\n            this.listeners.add(this.oqListener = function () {\n                var diff = _this.getDiff();\n                if (diff.fromOptimisticTransaction) {\n                    oq[\"observe\"]();\n                }\n                else {\n                    reobserveCacheFirst(oq);\n                }\n            });\n        }\n        else {\n            delete this.oqListener;\n        }\n    };\n    QueryInfo.prototype.notify = function () {\n        var _this = this;\n        cancelNotifyTimeout(this);\n        if (this.shouldNotify()) {\n            this.listeners.forEach(function (listener) { return listener(_this); });\n        }\n        this.dirty = false;\n    };\n    QueryInfo.prototype.shouldNotify = function () {\n        if (!this.dirty || !this.listeners.size) {\n            return false;\n        }\n        if (isNetworkRequestInFlight(this.networkStatus) &&\n            this.observableQuery) {\n            var fetchPolicy = this.observableQuery.options.fetchPolicy;\n            if (fetchPolicy !== \"cache-only\" &&\n                fetchPolicy !== \"cache-and-network\") {\n                return false;\n            }\n        }\n        return true;\n    };\n    QueryInfo.prototype.stop = function () {\n        if (!this.stopped) {\n            this.stopped = true;\n            this.reset();\n            this.cancel();\n            this.cancel = QueryInfo.prototype.cancel;\n            this.subscriptions.forEach(function (sub) { return sub.unsubscribe(); });\n            var oq = this.observableQuery;\n            if (oq)\n                oq.stopPolling();\n        }\n    };\n    QueryInfo.prototype.cancel = function () { };\n    QueryInfo.prototype.updateWatch = function (variables) {\n        var _this = this;\n        if (variables === void 0) { variables = this.variables; }\n        var oq = this.observableQuery;\n        if (oq && oq.options.fetchPolicy === \"no-cache\") {\n            return;\n        }\n        var watchOptions = tslib.__assign(tslib.__assign({}, this.getDiffOptions(variables)), { watcher: this, callback: function (diff) { return _this.setDiff(diff); } });\n        if (!this.lastWatch ||\n            !equality.equal(watchOptions, this.lastWatch)) {\n            this.cancel();\n            this.cancel = this.cache.watch(this.lastWatch = watchOptions);\n        }\n    };\n    QueryInfo.prototype.resetLastWrite = function () {\n        this.lastWrite = void 0;\n    };\n    QueryInfo.prototype.shouldWrite = function (result, variables) {\n        var lastWrite = this.lastWrite;\n        return !(lastWrite &&\n            lastWrite.dmCount === destructiveMethodCounts.get(this.cache) &&\n            equality.equal(variables, lastWrite.variables) &&\n            equality.equal(result.data, lastWrite.result.data));\n    };\n    QueryInfo.prototype.markResult = function (result, document, options, cacheWriteBehavior) {\n        var _this = this;\n        var graphQLErrors = utilities.isNonEmptyArray(result.errors)\n            ? result.errors.slice(0)\n            : [];\n        this.reset();\n        if ('incremental' in result && utilities.isNonEmptyArray(result.incremental)) {\n            var mergedData_1 = this.getDiff().result;\n            var merger_1 = new utilities.DeepMerger();\n            result.incremental.forEach(function (_a) {\n                var data = _a.data, path = _a.path, errors = _a.errors;\n                for (var i = path.length - 1; i >= 0; --i) {\n                    var key = path[i];\n                    var isNumericKey = !isNaN(+key);\n                    var parent_1 = isNumericKey ? [] : {};\n                    parent_1[key] = data;\n                    data = parent_1;\n                }\n                if (errors) {\n                    graphQLErrors.push.apply(graphQLErrors, errors);\n                }\n                mergedData_1 = merger_1.merge(mergedData_1, data);\n            });\n            result.data = mergedData_1;\n        }\n        this.graphQLErrors = graphQLErrors;\n        if (options.fetchPolicy === 'no-cache') {\n            this.updateLastDiff({ result: result.data, complete: true }, this.getDiffOptions(options.variables));\n        }\n        else if (cacheWriteBehavior !== 0) {\n            if (shouldWriteResult(result, options.errorPolicy)) {\n                this.cache.performTransaction(function (cache) {\n                    if (_this.shouldWrite(result, options.variables)) {\n                        cache.writeQuery({\n                            query: document,\n                            data: result.data,\n                            variables: options.variables,\n                            overwrite: cacheWriteBehavior === 1,\n                        });\n                        _this.lastWrite = {\n                            result: result,\n                            variables: options.variables,\n                            dmCount: destructiveMethodCounts.get(_this.cache),\n                        };\n                    }\n                    else {\n                        if (_this.lastDiff &&\n                            _this.lastDiff.diff.complete) {\n                            result.data = _this.lastDiff.diff.result;\n                            return;\n                        }\n                    }\n                    var diffOptions = _this.getDiffOptions(options.variables);\n                    var diff = cache.diff(diffOptions);\n                    if (!_this.stopped) {\n                        _this.updateWatch(options.variables);\n                    }\n                    _this.updateLastDiff(diff, diffOptions);\n                    if (diff.complete) {\n                        result.data = diff.result;\n                    }\n                });\n            }\n            else {\n                this.lastWrite = void 0;\n            }\n        }\n    };\n    QueryInfo.prototype.markReady = function () {\n        this.networkError = null;\n        return this.networkStatus = exports.NetworkStatus.ready;\n    };\n    QueryInfo.prototype.markError = function (error) {\n        this.networkStatus = exports.NetworkStatus.error;\n        this.lastWrite = void 0;\n        this.reset();\n        if (error.graphQLErrors) {\n            this.graphQLErrors = error.graphQLErrors;\n        }\n        if (error.networkError) {\n            this.networkError = error.networkError;\n        }\n        return error;\n    };\n    return QueryInfo;\n}());\nfunction shouldWriteResult(result, errorPolicy) {\n    if (errorPolicy === void 0) { errorPolicy = \"none\"; }\n    var ignoreErrors = errorPolicy === \"ignore\" ||\n        errorPolicy === \"all\";\n    var writeWithErrors = !utilities.graphQLResultHasError(result);\n    if (!writeWithErrors && ignoreErrors && result.data) {\n        writeWithErrors = true;\n    }\n    return writeWithErrors;\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar QueryManager = (function () {\n    function QueryManager(_a) {\n        var cache = _a.cache, link = _a.link, defaultOptions = _a.defaultOptions, _b = _a.queryDeduplication, queryDeduplication = _b === void 0 ? false : _b, onBroadcast = _a.onBroadcast, _c = _a.ssrMode, ssrMode = _c === void 0 ? false : _c, _d = _a.clientAwareness, clientAwareness = _d === void 0 ? {} : _d, localState = _a.localState, assumeImmutableResults = _a.assumeImmutableResults;\n        this.clientAwareness = {};\n        this.queries = new Map();\n        this.fetchCancelFns = new Map();\n        this.transformCache = new (utilities.canUseWeakMap ? WeakMap : Map)();\n        this.queryIdCounter = 1;\n        this.requestIdCounter = 1;\n        this.mutationIdCounter = 1;\n        this.inFlightLinkObservables = new Map();\n        this.cache = cache;\n        this.link = link;\n        this.defaultOptions = defaultOptions || Object.create(null);\n        this.queryDeduplication = queryDeduplication;\n        this.clientAwareness = clientAwareness;\n        this.localState = localState || new LocalState({ cache: cache });\n        this.ssrMode = ssrMode;\n        this.assumeImmutableResults = !!assumeImmutableResults;\n        if ((this.onBroadcast = onBroadcast)) {\n            this.mutationStore = Object.create(null);\n        }\n    }\n    QueryManager.prototype.stop = function () {\n        var _this = this;\n        this.queries.forEach(function (_info, queryId) {\n            _this.stopQueryNoBroadcast(queryId);\n        });\n        this.cancelPendingFetches(__DEV__ ? new globals.InvariantError('QueryManager stopped while query was in flight') : new globals.InvariantError(13));\n    };\n    QueryManager.prototype.cancelPendingFetches = function (error) {\n        this.fetchCancelFns.forEach(function (cancel) { return cancel(error); });\n        this.fetchCancelFns.clear();\n    };\n    QueryManager.prototype.mutate = function (_a) {\n        var _b, _c;\n        var mutation = _a.mutation, variables = _a.variables, optimisticResponse = _a.optimisticResponse, updateQueries = _a.updateQueries, _d = _a.refetchQueries, refetchQueries = _d === void 0 ? [] : _d, _e = _a.awaitRefetchQueries, awaitRefetchQueries = _e === void 0 ? false : _e, updateWithProxyFn = _a.update, onQueryUpdated = _a.onQueryUpdated, _f = _a.fetchPolicy, fetchPolicy = _f === void 0 ? ((_b = this.defaultOptions.mutate) === null || _b === void 0 ? void 0 : _b.fetchPolicy) || \"network-only\" : _f, _g = _a.errorPolicy, errorPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.errorPolicy) || \"none\" : _g, keepRootFields = _a.keepRootFields, context = _a.context;\n        return tslib.__awaiter(this, void 0, void 0, function () {\n            var mutationId, _h, document, hasClientExports, mutationStoreValue, self;\n            return tslib.__generator(this, function (_j) {\n                switch (_j.label) {\n                    case 0:\n                        __DEV__ ? globals.invariant(mutation, 'mutation option is required. You must specify your GraphQL document in the mutation option.') : globals.invariant(mutation, 14);\n                        __DEV__ ? globals.invariant(fetchPolicy === 'network-only' ||\n                            fetchPolicy === 'no-cache', \"Mutations support only 'network-only' or 'no-cache' fetchPolicy strings. The default `network-only` behavior automatically writes mutation results to the cache. Passing `no-cache` skips the cache write.\") : globals.invariant(fetchPolicy === 'network-only' ||\n                            fetchPolicy === 'no-cache', 15);\n                        mutationId = this.generateMutationId();\n                        _h = this.transform(mutation), document = _h.document, hasClientExports = _h.hasClientExports;\n                        mutation = this.cache.transformForLink(document);\n                        variables = this.getVariables(mutation, variables);\n                        if (!hasClientExports) return [3, 2];\n                        return [4, this.localState.addExportedVariables(mutation, variables, context)];\n                    case 1:\n                        variables = (_j.sent());\n                        _j.label = 2;\n                    case 2:\n                        mutationStoreValue = this.mutationStore &&\n                            (this.mutationStore[mutationId] = {\n                                mutation: mutation,\n                                variables: variables,\n                                loading: true,\n                                error: null,\n                            });\n                        if (optimisticResponse) {\n                            this.markMutationOptimistic(optimisticResponse, {\n                                mutationId: mutationId,\n                                document: mutation,\n                                variables: variables,\n                                fetchPolicy: fetchPolicy,\n                                errorPolicy: errorPolicy,\n                                context: context,\n                                updateQueries: updateQueries,\n                                update: updateWithProxyFn,\n                                keepRootFields: keepRootFields,\n                            });\n                        }\n                        this.broadcastQueries();\n                        self = this;\n                        return [2, new Promise(function (resolve, reject) {\n                                return utilities.asyncMap(self.getObservableFromLink(mutation, tslib.__assign(tslib.__assign({}, context), { optimisticResponse: optimisticResponse }), variables, false), function (result) {\n                                    if (utilities.graphQLResultHasError(result) && errorPolicy === 'none') {\n                                        throw new errors.ApolloError({\n                                            graphQLErrors: result.errors,\n                                        });\n                                    }\n                                    if (mutationStoreValue) {\n                                        mutationStoreValue.loading = false;\n                                        mutationStoreValue.error = null;\n                                    }\n                                    var storeResult = tslib.__assign({}, result);\n                                    if (typeof refetchQueries === \"function\") {\n                                        refetchQueries = refetchQueries(storeResult);\n                                    }\n                                    if (errorPolicy === 'ignore' &&\n                                        utilities.graphQLResultHasError(storeResult)) {\n                                        delete storeResult.errors;\n                                    }\n                                    return self.markMutationResult({\n                                        mutationId: mutationId,\n                                        result: storeResult,\n                                        document: mutation,\n                                        variables: variables,\n                                        fetchPolicy: fetchPolicy,\n                                        errorPolicy: errorPolicy,\n                                        context: context,\n                                        update: updateWithProxyFn,\n                                        updateQueries: updateQueries,\n                                        awaitRefetchQueries: awaitRefetchQueries,\n                                        refetchQueries: refetchQueries,\n                                        removeOptimistic: optimisticResponse ? mutationId : void 0,\n                                        onQueryUpdated: onQueryUpdated,\n                                        keepRootFields: keepRootFields,\n                                    });\n                                }).subscribe({\n                                    next: function (storeResult) {\n                                        self.broadcastQueries();\n                                        resolve(storeResult);\n                                    },\n                                    error: function (err) {\n                                        if (mutationStoreValue) {\n                                            mutationStoreValue.loading = false;\n                                            mutationStoreValue.error = err;\n                                        }\n                                        if (optimisticResponse) {\n                                            self.cache.removeOptimistic(mutationId);\n                                        }\n                                        self.broadcastQueries();\n                                        reject(err instanceof errors.ApolloError ? err : new errors.ApolloError({\n                                            networkError: err,\n                                        }));\n                                    },\n                                });\n                            })];\n                }\n            });\n        });\n    };\n    QueryManager.prototype.markMutationResult = function (mutation, cache) {\n        var _this = this;\n        if (cache === void 0) { cache = this.cache; }\n        var result = mutation.result;\n        var cacheWrites = [];\n        var skipCache = mutation.fetchPolicy === \"no-cache\";\n        if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {\n            cacheWrites.push({\n                result: result.data,\n                dataId: 'ROOT_MUTATION',\n                query: mutation.document,\n                variables: mutation.variables,\n            });\n            var updateQueries_1 = mutation.updateQueries;\n            if (updateQueries_1) {\n                this.queries.forEach(function (_a, queryId) {\n                    var observableQuery = _a.observableQuery;\n                    var queryName = observableQuery && observableQuery.queryName;\n                    if (!queryName || !hasOwnProperty.call(updateQueries_1, queryName)) {\n                        return;\n                    }\n                    var updater = updateQueries_1[queryName];\n                    var _b = _this.queries.get(queryId), document = _b.document, variables = _b.variables;\n                    var _c = cache.diff({\n                        query: document,\n                        variables: variables,\n                        returnPartialData: true,\n                        optimistic: false,\n                    }), currentQueryResult = _c.result, complete = _c.complete;\n                    if (complete && currentQueryResult) {\n                        var nextQueryResult = updater(currentQueryResult, {\n                            mutationResult: result,\n                            queryName: document && utilities.getOperationName(document) || void 0,\n                            queryVariables: variables,\n                        });\n                        if (nextQueryResult) {\n                            cacheWrites.push({\n                                result: nextQueryResult,\n                                dataId: 'ROOT_QUERY',\n                                query: document,\n                                variables: variables,\n                            });\n                        }\n                    }\n                });\n            }\n        }\n        if (cacheWrites.length > 0 ||\n            mutation.refetchQueries ||\n            mutation.update ||\n            mutation.onQueryUpdated ||\n            mutation.removeOptimistic) {\n            var results_1 = [];\n            this.refetchQueries({\n                updateCache: function (cache) {\n                    if (!skipCache) {\n                        cacheWrites.forEach(function (write) { return cache.write(write); });\n                    }\n                    var update = mutation.update;\n                    if (update) {\n                        if (!skipCache) {\n                            var diff = cache.diff({\n                                id: \"ROOT_MUTATION\",\n                                query: _this.transform(mutation.document).asQuery,\n                                variables: mutation.variables,\n                                optimistic: false,\n                                returnPartialData: true,\n                            });\n                            if (diff.complete && !(isExecutionPatchIncrementalResult(result))) {\n                                result = tslib.__assign(tslib.__assign({}, result), { data: diff.result });\n                            }\n                        }\n                        update(cache, result, {\n                            context: mutation.context,\n                            variables: mutation.variables,\n                        });\n                    }\n                    if (!skipCache && !mutation.keepRootFields) {\n                        cache.modify({\n                            id: 'ROOT_MUTATION',\n                            fields: function (value, _a) {\n                                var fieldName = _a.fieldName, DELETE = _a.DELETE;\n                                return fieldName === \"__typename\" ? value : DELETE;\n                            },\n                        });\n                    }\n                },\n                include: mutation.refetchQueries,\n                optimistic: false,\n                removeOptimistic: mutation.removeOptimistic,\n                onQueryUpdated: mutation.onQueryUpdated || null,\n            }).forEach(function (result) { return results_1.push(result); });\n            if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {\n                return Promise.all(results_1).then(function () { return result; });\n            }\n        }\n        return Promise.resolve(result);\n    };\n    QueryManager.prototype.markMutationOptimistic = function (optimisticResponse, mutation) {\n        var _this = this;\n        var data = typeof optimisticResponse === \"function\"\n            ? optimisticResponse(mutation.variables)\n            : optimisticResponse;\n        return this.cache.recordOptimisticTransaction(function (cache) {\n            try {\n                _this.markMutationResult(tslib.__assign(tslib.__assign({}, mutation), { result: { data: data } }), cache);\n            }\n            catch (error) {\n                __DEV__ && globals.invariant.error(error);\n            }\n        }, mutation.mutationId);\n    };\n    QueryManager.prototype.fetchQuery = function (queryId, options, networkStatus) {\n        return this.fetchQueryObservable(queryId, options, networkStatus).promise;\n    };\n    QueryManager.prototype.getQueryStore = function () {\n        var store = Object.create(null);\n        this.queries.forEach(function (info, queryId) {\n            store[queryId] = {\n                variables: info.variables,\n                networkStatus: info.networkStatus,\n                networkError: info.networkError,\n                graphQLErrors: info.graphQLErrors,\n            };\n        });\n        return store;\n    };\n    QueryManager.prototype.resetErrors = function (queryId) {\n        var queryInfo = this.queries.get(queryId);\n        if (queryInfo) {\n            queryInfo.networkError = undefined;\n            queryInfo.graphQLErrors = [];\n        }\n    };\n    QueryManager.prototype.transform = function (document) {\n        var transformCache = this.transformCache;\n        if (!transformCache.has(document)) {\n            var transformed = this.cache.transformDocument(document);\n            var noConnection = utilities.removeConnectionDirectiveFromDocument(transformed);\n            var clientQuery = this.localState.clientQuery(transformed);\n            var serverQuery = noConnection && this.localState.serverQuery(noConnection);\n            var cacheEntry_1 = {\n                document: transformed,\n                hasClientExports: utilities.hasClientExports(transformed),\n                hasForcedResolvers: this.localState.shouldForceResolvers(transformed),\n                clientQuery: clientQuery,\n                serverQuery: serverQuery,\n                defaultVars: utilities.getDefaultValues(utilities.getOperationDefinition(transformed)),\n                asQuery: tslib.__assign(tslib.__assign({}, transformed), { definitions: transformed.definitions.map(function (def) {\n                        if (def.kind === \"OperationDefinition\" &&\n                            def.operation !== \"query\") {\n                            return tslib.__assign(tslib.__assign({}, def), { operation: \"query\" });\n                        }\n                        return def;\n                    }) })\n            };\n            var add = function (doc) {\n                if (doc && !transformCache.has(doc)) {\n                    transformCache.set(doc, cacheEntry_1);\n                }\n            };\n            add(document);\n            add(transformed);\n            add(clientQuery);\n            add(serverQuery);\n        }\n        return transformCache.get(document);\n    };\n    QueryManager.prototype.getVariables = function (document, variables) {\n        return tslib.__assign(tslib.__assign({}, this.transform(document).defaultVars), variables);\n    };\n    QueryManager.prototype.watchQuery = function (options) {\n        options = tslib.__assign(tslib.__assign({}, options), { variables: this.getVariables(options.query, options.variables) });\n        if (typeof options.notifyOnNetworkStatusChange === 'undefined') {\n            options.notifyOnNetworkStatusChange = false;\n        }\n        var queryInfo = new QueryInfo(this);\n        var observable = new ObservableQuery({\n            queryManager: this,\n            queryInfo: queryInfo,\n            options: options,\n        });\n        this.queries.set(observable.queryId, queryInfo);\n        queryInfo.init({\n            document: observable.query,\n            observableQuery: observable,\n            variables: observable.variables,\n        });\n        return observable;\n    };\n    QueryManager.prototype.query = function (options, queryId) {\n        var _this = this;\n        if (queryId === void 0) { queryId = this.generateQueryId(); }\n        __DEV__ ? globals.invariant(options.query, 'query option is required. You must specify your GraphQL document ' +\n            'in the query option.') : globals.invariant(options.query, 16);\n        __DEV__ ? globals.invariant(options.query.kind === 'Document', 'You must wrap the query string in a \"gql\" tag.') : globals.invariant(options.query.kind === 'Document', 17);\n        __DEV__ ? globals.invariant(!options.returnPartialData, 'returnPartialData option only supported on watchQuery.') : globals.invariant(!options.returnPartialData, 18);\n        __DEV__ ? globals.invariant(!options.pollInterval, 'pollInterval option only supported on watchQuery.') : globals.invariant(!options.pollInterval, 19);\n        return this.fetchQuery(queryId, options).finally(function () { return _this.stopQuery(queryId); });\n    };\n    QueryManager.prototype.generateQueryId = function () {\n        return String(this.queryIdCounter++);\n    };\n    QueryManager.prototype.generateRequestId = function () {\n        return this.requestIdCounter++;\n    };\n    QueryManager.prototype.generateMutationId = function () {\n        return String(this.mutationIdCounter++);\n    };\n    QueryManager.prototype.stopQueryInStore = function (queryId) {\n        this.stopQueryInStoreNoBroadcast(queryId);\n        this.broadcastQueries();\n    };\n    QueryManager.prototype.stopQueryInStoreNoBroadcast = function (queryId) {\n        var queryInfo = this.queries.get(queryId);\n        if (queryInfo)\n            queryInfo.stop();\n    };\n    QueryManager.prototype.clearStore = function (options) {\n        if (options === void 0) { options = {\n            discardWatches: true,\n        }; }\n        this.cancelPendingFetches(__DEV__ ? new globals.InvariantError('Store reset while query was in flight (not completed in link chain)') : new globals.InvariantError(20));\n        this.queries.forEach(function (queryInfo) {\n            if (queryInfo.observableQuery) {\n                queryInfo.networkStatus = exports.NetworkStatus.loading;\n            }\n            else {\n                queryInfo.stop();\n            }\n        });\n        if (this.mutationStore) {\n            this.mutationStore = Object.create(null);\n        }\n        return this.cache.reset(options);\n    };\n    QueryManager.prototype.getObservableQueries = function (include) {\n        var _this = this;\n        if (include === void 0) { include = \"active\"; }\n        var queries = new Map();\n        var queryNamesAndDocs = new Map();\n        var legacyQueryOptions = new Set();\n        if (Array.isArray(include)) {\n            include.forEach(function (desc) {\n                if (typeof desc === \"string\") {\n                    queryNamesAndDocs.set(desc, false);\n                }\n                else if (utilities.isDocumentNode(desc)) {\n                    queryNamesAndDocs.set(_this.transform(desc).document, false);\n                }\n                else if (utilities.isNonNullObject(desc) && desc.query) {\n                    legacyQueryOptions.add(desc);\n                }\n            });\n        }\n        this.queries.forEach(function (_a, queryId) {\n            var oq = _a.observableQuery, document = _a.document;\n            if (oq) {\n                if (include === \"all\") {\n                    queries.set(queryId, oq);\n                    return;\n                }\n                var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;\n                if (fetchPolicy === \"standby\" ||\n                    (include === \"active\" && !oq.hasObservers())) {\n                    return;\n                }\n                if (include === \"active\" ||\n                    (queryName && queryNamesAndDocs.has(queryName)) ||\n                    (document && queryNamesAndDocs.has(document))) {\n                    queries.set(queryId, oq);\n                    if (queryName)\n                        queryNamesAndDocs.set(queryName, true);\n                    if (document)\n                        queryNamesAndDocs.set(document, true);\n                }\n            }\n        });\n        if (legacyQueryOptions.size) {\n            legacyQueryOptions.forEach(function (options) {\n                var queryId = utilities.makeUniqueId(\"legacyOneTimeQuery\");\n                var queryInfo = _this.getQuery(queryId).init({\n                    document: options.query,\n                    variables: options.variables,\n                });\n                var oq = new ObservableQuery({\n                    queryManager: _this,\n                    queryInfo: queryInfo,\n                    options: tslib.__assign(tslib.__assign({}, options), { fetchPolicy: \"network-only\" }),\n                });\n                globals.invariant(oq.queryId === queryId);\n                queryInfo.setObservableQuery(oq);\n                queries.set(queryId, oq);\n            });\n        }\n        if (__DEV__ && queryNamesAndDocs.size) {\n            queryNamesAndDocs.forEach(function (included, nameOrDoc) {\n                if (!included) {\n                    __DEV__ && globals.invariant.warn(\"Unknown query \".concat(typeof nameOrDoc === \"string\" ? \"named \" : \"\").concat(JSON.stringify(nameOrDoc, null, 2), \" requested in refetchQueries options.include array\"));\n                }\n            });\n        }\n        return queries;\n    };\n    QueryManager.prototype.reFetchObservableQueries = function (includeStandby) {\n        var _this = this;\n        if (includeStandby === void 0) { includeStandby = false; }\n        var observableQueryPromises = [];\n        this.getObservableQueries(includeStandby ? \"all\" : \"active\").forEach(function (observableQuery, queryId) {\n            var fetchPolicy = observableQuery.options.fetchPolicy;\n            observableQuery.resetLastResults();\n            if (includeStandby ||\n                (fetchPolicy !== \"standby\" &&\n                    fetchPolicy !== \"cache-only\")) {\n                observableQueryPromises.push(observableQuery.refetch());\n            }\n            _this.getQuery(queryId).setDiff(null);\n        });\n        this.broadcastQueries();\n        return Promise.all(observableQueryPromises);\n    };\n    QueryManager.prototype.setObservableQuery = function (observableQuery) {\n        this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);\n    };\n    QueryManager.prototype.startGraphQLSubscription = function (_a) {\n        var _this = this;\n        var query = _a.query, fetchPolicy = _a.fetchPolicy, errorPolicy = _a.errorPolicy, variables = _a.variables, _b = _a.context, context = _b === void 0 ? {} : _b;\n        query = this.transform(query).document;\n        variables = this.getVariables(query, variables);\n        var makeObservable = function (variables) {\n            return _this.getObservableFromLink(query, context, variables).map(function (result) {\n                if (fetchPolicy !== 'no-cache') {\n                    if (shouldWriteResult(result, errorPolicy)) {\n                        _this.cache.write({\n                            query: query,\n                            result: result.data,\n                            dataId: 'ROOT_SUBSCRIPTION',\n                            variables: variables,\n                        });\n                    }\n                    _this.broadcastQueries();\n                }\n                if (utilities.graphQLResultHasError(result)) {\n                    throw new errors.ApolloError({\n                        graphQLErrors: result.errors,\n                    });\n                }\n                return result;\n            });\n        };\n        if (this.transform(query).hasClientExports) {\n            var observablePromise_1 = this.localState.addExportedVariables(query, variables, context).then(makeObservable);\n            return new utilities.Observable(function (observer) {\n                var sub = null;\n                observablePromise_1.then(function (observable) { return sub = observable.subscribe(observer); }, observer.error);\n                return function () { return sub && sub.unsubscribe(); };\n            });\n        }\n        return makeObservable(variables);\n    };\n    QueryManager.prototype.stopQuery = function (queryId) {\n        this.stopQueryNoBroadcast(queryId);\n        this.broadcastQueries();\n    };\n    QueryManager.prototype.stopQueryNoBroadcast = function (queryId) {\n        this.stopQueryInStoreNoBroadcast(queryId);\n        this.removeQuery(queryId);\n    };\n    QueryManager.prototype.removeQuery = function (queryId) {\n        this.fetchCancelFns.delete(queryId);\n        if (this.queries.has(queryId)) {\n            this.getQuery(queryId).stop();\n            this.queries.delete(queryId);\n        }\n    };\n    QueryManager.prototype.broadcastQueries = function () {\n        if (this.onBroadcast)\n            this.onBroadcast();\n        this.queries.forEach(function (info) { return info.notify(); });\n    };\n    QueryManager.prototype.getLocalState = function () {\n        return this.localState;\n    };\n    QueryManager.prototype.getObservableFromLink = function (query, context, variables, deduplication) {\n        var _this = this;\n        var _a;\n        if (deduplication === void 0) { deduplication = (_a = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a !== void 0 ? _a : this.queryDeduplication; }\n        var observable;\n        var serverQuery = this.transform(query).serverQuery;\n        if (serverQuery) {\n            var _b = this, inFlightLinkObservables_1 = _b.inFlightLinkObservables, link = _b.link;\n            var operation = {\n                query: serverQuery,\n                variables: variables,\n                operationName: utilities.getOperationName(serverQuery) || void 0,\n                context: this.prepareContext(tslib.__assign(tslib.__assign({}, context), { forceFetch: !deduplication })),\n            };\n            context = operation.context;\n            if (deduplication) {\n                var byVariables_1 = inFlightLinkObservables_1.get(serverQuery) || new Map();\n                inFlightLinkObservables_1.set(serverQuery, byVariables_1);\n                var varJson_1 = cache.canonicalStringify(variables);\n                observable = byVariables_1.get(varJson_1);\n                if (!observable) {\n                    var concast = new utilities.Concast([\n                        core.execute(link, operation)\n                    ]);\n                    byVariables_1.set(varJson_1, observable = concast);\n                    concast.beforeNext(function () {\n                        if (byVariables_1.delete(varJson_1) &&\n                            byVariables_1.size < 1) {\n                            inFlightLinkObservables_1.delete(serverQuery);\n                        }\n                    });\n                }\n            }\n            else {\n                observable = new utilities.Concast([\n                    core.execute(link, operation)\n                ]);\n            }\n        }\n        else {\n            observable = new utilities.Concast([\n                utilities.Observable.of({ data: {} })\n            ]);\n            context = this.prepareContext(context);\n        }\n        var clientQuery = this.transform(query).clientQuery;\n        if (clientQuery) {\n            observable = utilities.asyncMap(observable, function (result) {\n                return _this.localState.runResolvers({\n                    document: clientQuery,\n                    remoteResult: result,\n                    context: context,\n                    variables: variables,\n                });\n            });\n        }\n        return observable;\n    };\n    QueryManager.prototype.getResultsFromLink = function (queryInfo, cacheWriteBehavior, options) {\n        var requestId = queryInfo.lastRequestId = this.generateRequestId();\n        options = utilities.cloneDeep(options);\n        var linkDocument = this.cache.transformForLink(this.transform(queryInfo.document).document);\n        return utilities.asyncMap(this.getObservableFromLink(linkDocument, options.context, options.variables), function (result) {\n            var graphQLErrors = utilities.isNonEmptyArray(result.errors)\n                ? result.errors.slice(0)\n                : [];\n            if ('incremental' in result && utilities.isNonEmptyArray(result.incremental)) {\n                result.incremental.forEach(function (incrementalResult) {\n                    if (incrementalResult.errors) {\n                        graphQLErrors.push.apply(graphQLErrors, incrementalResult.errors);\n                    }\n                });\n            }\n            var hasErrors = utilities.isNonEmptyArray(graphQLErrors);\n            if (requestId >= queryInfo.lastRequestId) {\n                if (hasErrors && options.errorPolicy === \"none\") {\n                    throw queryInfo.markError(new errors.ApolloError({\n                        graphQLErrors: graphQLErrors,\n                    }));\n                }\n                queryInfo.markResult(result, linkDocument, options, cacheWriteBehavior);\n                queryInfo.markReady();\n            }\n            var aqr = {\n                data: result.data,\n                loading: false,\n                networkStatus: exports.NetworkStatus.ready,\n            };\n            if (hasErrors && options.errorPolicy !== \"ignore\") {\n                aqr.errors = graphQLErrors;\n                aqr.networkStatus = exports.NetworkStatus.error;\n            }\n            return aqr;\n        }, function (networkError) {\n            var error = errors.isApolloError(networkError)\n                ? networkError\n                : new errors.ApolloError({ networkError: networkError });\n            if (requestId >= queryInfo.lastRequestId) {\n                queryInfo.markError(error);\n            }\n            throw error;\n        });\n    };\n    QueryManager.prototype.fetchQueryObservable = function (queryId, options, networkStatus) {\n        var _this = this;\n        if (networkStatus === void 0) { networkStatus = exports.NetworkStatus.loading; }\n        var query = this.transform(options.query).document;\n        var variables = this.getVariables(query, options.variables);\n        var queryInfo = this.getQuery(queryId);\n        var defaults = this.defaultOptions.watchQuery;\n        var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? defaults && defaults.fetchPolicy || \"cache-first\" : _a, _b = options.errorPolicy, errorPolicy = _b === void 0 ? defaults && defaults.errorPolicy || \"none\" : _b, _c = options.returnPartialData, returnPartialData = _c === void 0 ? false : _c, _d = options.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e = options.context, context = _e === void 0 ? {} : _e;\n        var normalized = Object.assign({}, options, {\n            query: query,\n            variables: variables,\n            fetchPolicy: fetchPolicy,\n            errorPolicy: errorPolicy,\n            returnPartialData: returnPartialData,\n            notifyOnNetworkStatusChange: notifyOnNetworkStatusChange,\n            context: context,\n        });\n        var fromVariables = function (variables) {\n            normalized.variables = variables;\n            var concastSources = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);\n            if (normalized.fetchPolicy !== \"standby\" &&\n                concastSources.length > 0 &&\n                queryInfo.observableQuery) {\n                queryInfo.observableQuery[\"applyNextFetchPolicy\"](\"after-fetch\", options);\n            }\n            return concastSources;\n        };\n        var cleanupCancelFn = function () { return _this.fetchCancelFns.delete(queryId); };\n        this.fetchCancelFns.set(queryId, function (reason) {\n            cleanupCancelFn();\n            setTimeout(function () { return concast.cancel(reason); });\n        });\n        var concast = new utilities.Concast(this.transform(normalized.query).hasClientExports\n            ? this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables)\n            : fromVariables(normalized.variables));\n        concast.promise.then(cleanupCancelFn, cleanupCancelFn);\n        return concast;\n    };\n    QueryManager.prototype.refetchQueries = function (_a) {\n        var _this = this;\n        var updateCache = _a.updateCache, include = _a.include, _b = _a.optimistic, optimistic = _b === void 0 ? false : _b, _c = _a.removeOptimistic, removeOptimistic = _c === void 0 ? optimistic ? utilities.makeUniqueId(\"refetchQueries\") : void 0 : _c, onQueryUpdated = _a.onQueryUpdated;\n        var includedQueriesById = new Map();\n        if (include) {\n            this.getObservableQueries(include).forEach(function (oq, queryId) {\n                includedQueriesById.set(queryId, {\n                    oq: oq,\n                    lastDiff: _this.getQuery(queryId).getDiff(),\n                });\n            });\n        }\n        var results = new Map;\n        if (updateCache) {\n            this.cache.batch({\n                update: updateCache,\n                optimistic: optimistic && removeOptimistic || false,\n                removeOptimistic: removeOptimistic,\n                onWatchUpdated: function (watch, diff, lastDiff) {\n                    var oq = watch.watcher instanceof QueryInfo &&\n                        watch.watcher.observableQuery;\n                    if (oq) {\n                        if (onQueryUpdated) {\n                            includedQueriesById.delete(oq.queryId);\n                            var result = onQueryUpdated(oq, diff, lastDiff);\n                            if (result === true) {\n                                result = oq.refetch();\n                            }\n                            if (result !== false) {\n                                results.set(oq, result);\n                            }\n                            return result;\n                        }\n                        if (onQueryUpdated !== null) {\n                            includedQueriesById.set(oq.queryId, { oq: oq, lastDiff: lastDiff, diff: diff });\n                        }\n                    }\n                },\n            });\n        }\n        if (includedQueriesById.size) {\n            includedQueriesById.forEach(function (_a, queryId) {\n                var oq = _a.oq, lastDiff = _a.lastDiff, diff = _a.diff;\n                var result;\n                if (onQueryUpdated) {\n                    if (!diff) {\n                        var info = oq[\"queryInfo\"];\n                        info.reset();\n                        diff = info.getDiff();\n                    }\n                    result = onQueryUpdated(oq, diff, lastDiff);\n                }\n                if (!onQueryUpdated || result === true) {\n                    result = oq.refetch();\n                }\n                if (result !== false) {\n                    results.set(oq, result);\n                }\n                if (queryId.indexOf(\"legacyOneTimeQuery\") >= 0) {\n                    _this.stopQueryNoBroadcast(queryId);\n                }\n            });\n        }\n        if (removeOptimistic) {\n            this.cache.removeOptimistic(removeOptimistic);\n        }\n        return results;\n    };\n    QueryManager.prototype.fetchQueryByPolicy = function (queryInfo, _a, networkStatus) {\n        var _this = this;\n        var query = _a.query, variables = _a.variables, fetchPolicy = _a.fetchPolicy, refetchWritePolicy = _a.refetchWritePolicy, errorPolicy = _a.errorPolicy, returnPartialData = _a.returnPartialData, context = _a.context, notifyOnNetworkStatusChange = _a.notifyOnNetworkStatusChange;\n        var oldNetworkStatus = queryInfo.networkStatus;\n        queryInfo.init({\n            document: this.transform(query).document,\n            variables: variables,\n            networkStatus: networkStatus,\n        });\n        var readCache = function () { return queryInfo.getDiff(variables); };\n        var resultsFromCache = function (diff, networkStatus) {\n            if (networkStatus === void 0) { networkStatus = queryInfo.networkStatus || exports.NetworkStatus.loading; }\n            var data = diff.result;\n            if (__DEV__ &&\n                !returnPartialData &&\n                !equality.equal(data, {})) {\n                logMissingFieldErrors(diff.missing);\n            }\n            var fromData = function (data) { return utilities.Observable.of(tslib.__assign({ data: data, loading: isNetworkRequestInFlight(networkStatus), networkStatus: networkStatus }, (diff.complete ? null : { partial: true }))); };\n            if (data && _this.transform(query).hasForcedResolvers) {\n                return _this.localState.runResolvers({\n                    document: query,\n                    remoteResult: { data: data },\n                    context: context,\n                    variables: variables,\n                    onlyRunForcedResolvers: true,\n                }).then(function (resolved) { return fromData(resolved.data || void 0); });\n            }\n            return fromData(data);\n        };\n        var cacheWriteBehavior = fetchPolicy === \"no-cache\" ? 0 :\n            (networkStatus === exports.NetworkStatus.refetch &&\n                refetchWritePolicy !== \"merge\") ? 1\n                : 2;\n        var resultsFromLink = function () { return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {\n            variables: variables,\n            context: context,\n            fetchPolicy: fetchPolicy,\n            errorPolicy: errorPolicy,\n        }); };\n        var shouldNotify = notifyOnNetworkStatusChange &&\n            typeof oldNetworkStatus === \"number\" &&\n            oldNetworkStatus !== networkStatus &&\n            isNetworkRequestInFlight(networkStatus);\n        switch (fetchPolicy) {\n            default:\n            case \"cache-first\": {\n                var diff = readCache();\n                if (diff.complete) {\n                    return [\n                        resultsFromCache(diff, queryInfo.markReady()),\n                    ];\n                }\n                if (returnPartialData || shouldNotify) {\n                    return [\n                        resultsFromCache(diff),\n                        resultsFromLink(),\n                    ];\n                }\n                return [\n                    resultsFromLink(),\n                ];\n            }\n            case \"cache-and-network\": {\n                var diff = readCache();\n                if (diff.complete || returnPartialData || shouldNotify) {\n                    return [\n                        resultsFromCache(diff),\n                        resultsFromLink(),\n                    ];\n                }\n                return [\n                    resultsFromLink(),\n                ];\n            }\n            case \"cache-only\":\n                return [\n                    resultsFromCache(readCache(), queryInfo.markReady()),\n                ];\n            case \"network-only\":\n                if (shouldNotify) {\n                    return [\n                        resultsFromCache(readCache()),\n                        resultsFromLink(),\n                    ];\n                }\n                return [resultsFromLink()];\n            case \"no-cache\":\n                if (shouldNotify) {\n                    return [\n                        resultsFromCache(queryInfo.getDiff()),\n                        resultsFromLink(),\n                    ];\n                }\n                return [resultsFromLink()];\n            case \"standby\":\n                return [];\n        }\n    };\n    QueryManager.prototype.getQuery = function (queryId) {\n        if (queryId && !this.queries.has(queryId)) {\n            this.queries.set(queryId, new QueryInfo(this, queryId));\n        }\n        return this.queries.get(queryId);\n    };\n    QueryManager.prototype.prepareContext = function (context) {\n        if (context === void 0) { context = {}; }\n        var newContext = this.localState.prepareContext(context);\n        return tslib.__assign(tslib.__assign({}, newContext), { clientAwareness: this.clientAwareness });\n    };\n    return QueryManager;\n}());\n\nvar hasSuggestedDevtools = false;\nvar ApolloClient = (function () {\n    function ApolloClient(options) {\n        var _this = this;\n        this.resetStoreCallbacks = [];\n        this.clearStoreCallbacks = [];\n        var uri = options.uri, credentials = options.credentials, headers = options.headers, cache = options.cache, _a = options.ssrMode, ssrMode = _a === void 0 ? false : _a, _b = options.ssrForceFetchDelay, ssrForceFetchDelay = _b === void 0 ? 0 : _b, _c = options.connectToDevTools, connectToDevTools = _c === void 0 ? typeof window === 'object' &&\n            !window.__APOLLO_CLIENT__ &&\n            __DEV__ : _c, _d = options.queryDeduplication, queryDeduplication = _d === void 0 ? true : _d, defaultOptions = options.defaultOptions, _e = options.assumeImmutableResults, assumeImmutableResults = _e === void 0 ? false : _e, resolvers = options.resolvers, typeDefs = options.typeDefs, fragmentMatcher = options.fragmentMatcher, clientAwarenessName = options.name, clientAwarenessVersion = options.version;\n        var link = options.link;\n        if (!link) {\n            link = uri\n                ? new http.HttpLink({ uri: uri, credentials: credentials, headers: headers })\n                : core.ApolloLink.empty();\n        }\n        if (!cache) {\n            throw __DEV__ ? new globals.InvariantError(\"To initialize Apollo Client, you must specify a 'cache' property \" +\n                \"in the options object. \\n\" +\n                \"For more information, please visit: https://go.apollo.dev/c/docs\") : new globals.InvariantError(9);\n        }\n        this.link = link;\n        this.cache = cache;\n        this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n        this.queryDeduplication = queryDeduplication;\n        this.defaultOptions = defaultOptions || Object.create(null);\n        this.typeDefs = typeDefs;\n        if (ssrForceFetchDelay) {\n            setTimeout(function () { return (_this.disableNetworkFetches = false); }, ssrForceFetchDelay);\n        }\n        this.watchQuery = this.watchQuery.bind(this);\n        this.query = this.query.bind(this);\n        this.mutate = this.mutate.bind(this);\n        this.resetStore = this.resetStore.bind(this);\n        this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n        if (connectToDevTools && typeof window === 'object') {\n            window.__APOLLO_CLIENT__ = this;\n        }\n        if (!hasSuggestedDevtools && __DEV__) {\n            hasSuggestedDevtools = true;\n            if (typeof window !== 'undefined' &&\n                window.document &&\n                window.top === window.self &&\n                !window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {\n                var nav = window.navigator;\n                var ua = nav && nav.userAgent;\n                var url = void 0;\n                if (typeof ua === \"string\") {\n                    if (ua.indexOf(\"Chrome/\") > -1) {\n                        url = \"https://chrome.google.com/webstore/detail/\" +\n                            \"apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\";\n                    }\n                    else if (ua.indexOf(\"Firefox/\") > -1) {\n                        url = \"https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/\";\n                    }\n                }\n                if (url) {\n                    __DEV__ && globals.invariant.log(\"Download the Apollo DevTools for a better development \" +\n                        \"experience: \" + url);\n                }\n            }\n        }\n        this.version = version;\n        this.localState = new LocalState({\n            cache: cache,\n            client: this,\n            resolvers: resolvers,\n            fragmentMatcher: fragmentMatcher,\n        });\n        this.queryManager = new QueryManager({\n            cache: this.cache,\n            link: this.link,\n            defaultOptions: this.defaultOptions,\n            queryDeduplication: queryDeduplication,\n            ssrMode: ssrMode,\n            clientAwareness: {\n                name: clientAwarenessName,\n                version: clientAwarenessVersion,\n            },\n            localState: this.localState,\n            assumeImmutableResults: assumeImmutableResults,\n            onBroadcast: connectToDevTools ? function () {\n                if (_this.devToolsHookCb) {\n                    _this.devToolsHookCb({\n                        action: {},\n                        state: {\n                            queries: _this.queryManager.getQueryStore(),\n                            mutations: _this.queryManager.mutationStore || {},\n                        },\n                        dataWithOptimisticResults: _this.cache.extract(true),\n                    });\n                }\n            } : void 0,\n        });\n    }\n    ApolloClient.prototype.stop = function () {\n        this.queryManager.stop();\n    };\n    ApolloClient.prototype.watchQuery = function (options) {\n        if (this.defaultOptions.watchQuery) {\n            options = utilities.mergeOptions(this.defaultOptions.watchQuery, options);\n        }\n        if (this.disableNetworkFetches &&\n            (options.fetchPolicy === 'network-only' ||\n                options.fetchPolicy === 'cache-and-network')) {\n            options = tslib.__assign(tslib.__assign({}, options), { fetchPolicy: 'cache-first' });\n        }\n        return this.queryManager.watchQuery(options);\n    };\n    ApolloClient.prototype.query = function (options) {\n        if (this.defaultOptions.query) {\n            options = utilities.mergeOptions(this.defaultOptions.query, options);\n        }\n        __DEV__ ? globals.invariant(options.fetchPolicy !== 'cache-and-network', 'The cache-and-network fetchPolicy does not work with client.query, because ' +\n            'client.query can only return a single result. Please use client.watchQuery ' +\n            'to receive multiple results from the cache and the network, or consider ' +\n            'using a different fetchPolicy, such as cache-first or network-only.') : globals.invariant(options.fetchPolicy !== 'cache-and-network', 10);\n        if (this.disableNetworkFetches && options.fetchPolicy === 'network-only') {\n            options = tslib.__assign(tslib.__assign({}, options), { fetchPolicy: 'cache-first' });\n        }\n        return this.queryManager.query(options);\n    };\n    ApolloClient.prototype.mutate = function (options) {\n        if (this.defaultOptions.mutate) {\n            options = utilities.mergeOptions(this.defaultOptions.mutate, options);\n        }\n        return this.queryManager.mutate(options);\n    };\n    ApolloClient.prototype.subscribe = function (options) {\n        return this.queryManager.startGraphQLSubscription(options);\n    };\n    ApolloClient.prototype.readQuery = function (options, optimistic) {\n        if (optimistic === void 0) { optimistic = false; }\n        return this.cache.readQuery(options, optimistic);\n    };\n    ApolloClient.prototype.readFragment = function (options, optimistic) {\n        if (optimistic === void 0) { optimistic = false; }\n        return this.cache.readFragment(options, optimistic);\n    };\n    ApolloClient.prototype.writeQuery = function (options) {\n        this.cache.writeQuery(options);\n        this.queryManager.broadcastQueries();\n    };\n    ApolloClient.prototype.writeFragment = function (options) {\n        this.cache.writeFragment(options);\n        this.queryManager.broadcastQueries();\n    };\n    ApolloClient.prototype.__actionHookForDevTools = function (cb) {\n        this.devToolsHookCb = cb;\n    };\n    ApolloClient.prototype.__requestRaw = function (payload) {\n        return core.execute(this.link, payload);\n    };\n    ApolloClient.prototype.resetStore = function () {\n        var _this = this;\n        return Promise.resolve()\n            .then(function () { return _this.queryManager.clearStore({\n            discardWatches: false,\n        }); })\n            .then(function () { return Promise.all(_this.resetStoreCallbacks.map(function (fn) { return fn(); })); })\n            .then(function () { return _this.reFetchObservableQueries(); });\n    };\n    ApolloClient.prototype.clearStore = function () {\n        var _this = this;\n        return Promise.resolve()\n            .then(function () { return _this.queryManager.clearStore({\n            discardWatches: true,\n        }); })\n            .then(function () { return Promise.all(_this.clearStoreCallbacks.map(function (fn) { return fn(); })); });\n    };\n    ApolloClient.prototype.onResetStore = function (cb) {\n        var _this = this;\n        this.resetStoreCallbacks.push(cb);\n        return function () {\n            _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function (c) { return c !== cb; });\n        };\n    };\n    ApolloClient.prototype.onClearStore = function (cb) {\n        var _this = this;\n        this.clearStoreCallbacks.push(cb);\n        return function () {\n            _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function (c) { return c !== cb; });\n        };\n    };\n    ApolloClient.prototype.reFetchObservableQueries = function (includeStandby) {\n        return this.queryManager.reFetchObservableQueries(includeStandby);\n    };\n    ApolloClient.prototype.refetchQueries = function (options) {\n        var map = this.queryManager.refetchQueries(options);\n        var queries = [];\n        var results = [];\n        map.forEach(function (result, obsQuery) {\n            queries.push(obsQuery);\n            results.push(result);\n        });\n        var result = Promise.all(results);\n        result.queries = queries;\n        result.results = results;\n        result.catch(function (error) {\n            __DEV__ && globals.invariant.debug(\"In client.refetchQueries, Promise.all promise rejected with error \".concat(error));\n        });\n        return result;\n    };\n    ApolloClient.prototype.getObservableQueries = function (include) {\n        if (include === void 0) { include = \"active\"; }\n        return this.queryManager.getObservableQueries(include);\n    };\n    ApolloClient.prototype.extract = function (optimistic) {\n        return this.cache.extract(optimistic);\n    };\n    ApolloClient.prototype.restore = function (serializedState) {\n        return this.cache.restore(serializedState);\n    };\n    ApolloClient.prototype.addResolvers = function (resolvers) {\n        this.localState.addResolvers(resolvers);\n    };\n    ApolloClient.prototype.setResolvers = function (resolvers) {\n        this.localState.setResolvers(resolvers);\n    };\n    ApolloClient.prototype.getResolvers = function () {\n        return this.localState.getResolvers();\n    };\n    ApolloClient.prototype.setLocalStateFragmentMatcher = function (fragmentMatcher) {\n        this.localState.setFragmentMatcher(fragmentMatcher);\n    };\n    ApolloClient.prototype.setLink = function (newLink) {\n        this.link = this.queryManager.link = newLink;\n    };\n    return ApolloClient;\n}());\n\ntsInvariant.setVerbosity(globals.DEV ? \"log\" : \"silent\");\n\nexports.ApolloCache = cache.ApolloCache;\nexports.Cache = cache.Cache;\nexports.InMemoryCache = cache.InMemoryCache;\nexports.MissingFieldError = cache.MissingFieldError;\nexports.defaultDataIdFromObject = cache.defaultDataIdFromObject;\nexports.makeVar = cache.makeVar;\nexports.Observable = utilities.Observable;\nexports.isReference = utilities.isReference;\nexports.makeReference = utilities.makeReference;\nexports.mergeOptions = utilities.mergeOptions;\nexports.ApolloError = errors.ApolloError;\nexports.isApolloError = errors.isApolloError;\nexports.fromError = utils.fromError;\nexports.fromPromise = utils.fromPromise;\nexports.throwServerError = utils.throwServerError;\nexports.toPromise = utils.toPromise;\nexports.setLogVerbosity = tsInvariant.setVerbosity;\nexports.disableExperimentalFragmentVariables = graphqlTag.disableExperimentalFragmentVariables;\nexports.disableFragmentWarnings = graphqlTag.disableFragmentWarnings;\nexports.enableExperimentalFragmentVariables = graphqlTag.enableExperimentalFragmentVariables;\nexports.gql = graphqlTag.gql;\nexports.resetCaches = graphqlTag.resetCaches;\nexports.ApolloClient = ApolloClient;\nexports.ObservableQuery = ObservableQuery;\nfor (var k in core) {\n    if (k !== 'default' && !exports.hasOwnProperty(k)) exports[k] = core[k];\n}\nfor (var k in http) {\n    if (k !== 'default' && !exports.hasOwnProperty(k)) exports[k] = http[k];\n}\n//# sourceMappingURL=core.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvY29yZS9jb3JlLmNqcz9mOTFmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE4QyxjQUFjOztBQUU1RCxjQUFjLG1CQUFPLENBQUMseUZBQXNCO0FBQzVDLFlBQVksbUJBQU8sQ0FBQyxvQkFBTztBQUMzQixXQUFXLG1CQUFPLENBQUMsc0VBQWM7QUFDakMsV0FBVyxtQkFBTyxDQUFDLHNFQUFjO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxvQ0FBZTtBQUN0QyxZQUFZLG1CQUFPLENBQUMsK0RBQVU7QUFDOUIsZ0JBQWdCLG1CQUFPLENBQUMsMkVBQWM7QUFDdEMsYUFBYSxtQkFBTyxDQUFDLGtFQUFXO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyx3QkFBUztBQUMvQixZQUFZLG1CQUFPLENBQUMseUVBQWU7QUFDbkMsa0JBQWtCLG1CQUFPLENBQUMsbUVBQWM7QUFDeEMsaUJBQWlCLG1CQUFPLENBQUMsZ0NBQWE7O0FBRXRDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNEQUFzRDtBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEVBQUU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQSx3REFBd0QsYUFBYSxtRUFBbUU7QUFDeEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztB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QUFDQTtBQUNBLHVGQUF1RixpQkFBaUIsRUFBRTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsaUJBQWlCLEVBQUU7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG9CQUFvQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0BhcG9sbG8vY2xpZW50L2NvcmUvY29yZS5janMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBnbG9iYWxzID0gcmVxdWlyZSgnLi4vdXRpbGl0aWVzL2dsb2JhbHMnKTtcbnZhciB0c2xpYiA9IHJlcXVpcmUoJ3RzbGliJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4uL2xpbmsvY29yZScpO1xudmFyIGh0dHAgPSByZXF1aXJlKCcuLi9saW5rL2h0dHAnKTtcbnZhciBlcXVhbGl0eSA9IHJlcXVpcmUoJ0B3cnkvZXF1YWxpdHknKTtcbnZhciBjYWNoZSA9IHJlcXVpcmUoJy4uL2NhY2hlJyk7XG52YXIgdXRpbGl0aWVzID0gcmVxdWlyZSgnLi4vdXRpbGl0aWVzJyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG52YXIgZ3JhcGhxbCA9IHJlcXVpcmUoJ2dyYXBocWwnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL2xpbmsvdXRpbHMnKTtcbnZhciB0c0ludmFyaWFudCA9IHJlcXVpcmUoJ3RzLWludmFyaWFudCcpO1xudmFyIGdyYXBocWxUYWcgPSByZXF1aXJlKCdncmFwaHFsLXRhZycpO1xuXG52YXIgdmVyc2lvbiA9ICczLjcuMSc7XG5cbmZ1bmN0aW9uIGlzRXhlY3V0aW9uUGF0Y2hJbmNyZW1lbnRhbFJlc3VsdCh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlLmluY3JlbWVudGFsO1xufVxuXG5leHBvcnRzLk5ldHdvcmtTdGF0dXMgPSB2b2lkIDA7XG4oZnVuY3Rpb24gKE5ldHdvcmtTdGF0dXMpIHtcbiAgICBOZXR3b3JrU3RhdHVzW05ldHdvcmtTdGF0dXNbXCJsb2FkaW5nXCJdID0gMV0gPSBcImxvYWRpbmdcIjtcbiAgICBOZXR3b3JrU3RhdHVzW05ldHdvcmtTdGF0dXNbXCJzZXRWYXJpYWJsZXNcIl0gPSAyXSA9IFwic2V0VmFyaWFibGVzXCI7XG4gICAgTmV0d29ya1N0YXR1c1tOZXR3b3JrU3RhdHVzW1wiZmV0Y2hNb3JlXCJdID0gM10gPSBcImZldGNoTW9yZVwiO1xuICAgIE5ldHdvcmtTdGF0dXNbTmV0d29ya1N0YXR1c1tcInJlZmV0Y2hcIl0gPSA0XSA9IFwicmVmZXRjaFwiO1xuICAgIE5ldHdvcmtTdGF0dXNbTmV0d29ya1N0YXR1c1tcInBvbGxcIl0gPSA2XSA9IFwicG9sbFwiO1xuICAgIE5ldHdvcmtTdGF0dXNbTmV0d29ya1N0YXR1c1tcInJlYWR5XCJdID0gN10gPSBcInJlYWR5XCI7XG4gICAgTmV0d29ya1N0YXR1c1tOZXR3b3JrU3RhdHVzW1wiZXJyb3JcIl0gPSA4XSA9IFwiZXJyb3JcIjtcbn0pKGV4cG9ydHMuTmV0d29ya1N0YXR1cyB8fCAoZXhwb3J0cy5OZXR3b3JrU3RhdHVzID0ge30pKTtcbmZ1bmN0aW9uIGlzTmV0d29ya1JlcXVlc3RJbkZsaWdodChuZXR3b3JrU3RhdHVzKSB7XG4gICAgcmV0dXJuIG5ldHdvcmtTdGF0dXMgPyBuZXR3b3JrU3RhdHVzIDwgNyA6IGZhbHNlO1xufVxuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbiwgaGFzT3duUHJvcGVydHkkMSA9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcbnZhciBPYnNlcnZhYmxlUXVlcnkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhPYnNlcnZhYmxlUXVlcnksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT2JzZXJ2YWJsZVF1ZXJ5KF9hKSB7XG4gICAgICAgIHZhciBxdWVyeU1hbmFnZXIgPSBfYS5xdWVyeU1hbmFnZXIsIHF1ZXJ5SW5mbyA9IF9hLnF1ZXJ5SW5mbywgb3B0aW9ucyA9IF9hLm9wdGlvbnM7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgc3ViT2JzZXJ2ZXIgPSBvYnNlcnZlci5fc3Vic2NyaXB0aW9uLl9vYnNlcnZlcjtcbiAgICAgICAgICAgICAgICBpZiAoc3ViT2JzZXJ2ZXIgJiYgIXN1Yk9ic2VydmVyLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Yk9ic2VydmVyLmVycm9yID0gZGVmYXVsdFN1YnNjcmlwdGlvbk9ic2VydmVyRXJyb3JDYWxsYmFjaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHsgfVxuICAgICAgICAgICAgdmFyIGZpcnN0ID0gIV90aGlzLm9ic2VydmVycy5zaXplO1xuICAgICAgICAgICAgX3RoaXMub2JzZXJ2ZXJzLmFkZChvYnNlcnZlcik7XG4gICAgICAgICAgICB2YXIgbGFzdCA9IF90aGlzLmxhc3Q7XG4gICAgICAgICAgICBpZiAobGFzdCAmJiBsYXN0LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IgJiYgb2JzZXJ2ZXIuZXJyb3IobGFzdC5lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsYXN0ICYmIGxhc3QucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCAmJiBvYnNlcnZlci5uZXh0KGxhc3QucmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlb2JzZXJ2ZSgpLmNhdGNoKGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5vYnNlcnZlcnMuZGVsZXRlKG9ic2VydmVyKSAmJiAhX3RoaXMub2JzZXJ2ZXJzLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudGVhckRvd25RdWVyeSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9ic2VydmVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgX3RoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgX3RoaXMucXVlcnlJbmZvID0gcXVlcnlJbmZvO1xuICAgICAgICBfdGhpcy5xdWVyeU1hbmFnZXIgPSBxdWVyeU1hbmFnZXI7XG4gICAgICAgIF90aGlzLmlzVG9ybkRvd24gPSBmYWxzZTtcbiAgICAgICAgdmFyIF9iID0gcXVlcnlNYW5hZ2VyLmRlZmF1bHRPcHRpb25zLndhdGNoUXVlcnksIF9jID0gX2IgPT09IHZvaWQgMCA/IHt9IDogX2IsIF9kID0gX2MuZmV0Y2hQb2xpY3ksIGRlZmF1bHRGZXRjaFBvbGljeSA9IF9kID09PSB2b2lkIDAgPyBcImNhY2hlLWZpcnN0XCIgOiBfZDtcbiAgICAgICAgdmFyIF9lID0gb3B0aW9ucy5mZXRjaFBvbGljeSwgZmV0Y2hQb2xpY3kgPSBfZSA9PT0gdm9pZCAwID8gZGVmYXVsdEZldGNoUG9saWN5IDogX2UsIF9mID0gb3B0aW9ucy5pbml0aWFsRmV0Y2hQb2xpY3ksIGluaXRpYWxGZXRjaFBvbGljeSA9IF9mID09PSB2b2lkIDAgPyAoZmV0Y2hQb2xpY3kgPT09IFwic3RhbmRieVwiID8gZGVmYXVsdEZldGNoUG9saWN5IDogZmV0Y2hQb2xpY3kpIDogX2Y7XG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgaW5pdGlhbEZldGNoUG9saWN5OiBpbml0aWFsRmV0Y2hQb2xpY3ksIGZldGNoUG9saWN5OiBmZXRjaFBvbGljeSB9KTtcbiAgICAgICAgX3RoaXMucXVlcnlJZCA9IHF1ZXJ5SW5mby5xdWVyeUlkIHx8IHF1ZXJ5TWFuYWdlci5nZW5lcmF0ZVF1ZXJ5SWQoKTtcbiAgICAgICAgdmFyIG9wRGVmID0gdXRpbGl0aWVzLmdldE9wZXJhdGlvbkRlZmluaXRpb24oX3RoaXMucXVlcnkpO1xuICAgICAgICBfdGhpcy5xdWVyeU5hbWUgPSBvcERlZiAmJiBvcERlZi5uYW1lICYmIG9wRGVmLm5hbWUudmFsdWU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUsIFwicXVlcnlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5TWFuYWdlci50cmFuc2Zvcm0odGhpcy5vcHRpb25zLnF1ZXJ5KS5kb2N1bWVudDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLCBcInZhcmlhYmxlc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy52YXJpYWJsZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBvYnNlcnZlciA9IHtcbiAgICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2JzZXJ2ZXJzLmRlbGV0ZShvYnNlcnZlcik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMub2JzZXJ2ZXJzLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnF1ZXJ5TWFuYWdlci5yZW1vdmVRdWVyeShfdGhpcy5xdWVyeUlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiByZWplY3QsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IF90aGlzLnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5nZXRDdXJyZW50UmVzdWx0ID0gZnVuY3Rpb24gKHNhdmVBc0xhc3RSZXN1bHQpIHtcbiAgICAgICAgaWYgKHNhdmVBc0xhc3RSZXN1bHQgPT09IHZvaWQgMCkgeyBzYXZlQXNMYXN0UmVzdWx0ID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgbGFzdFJlc3VsdCA9IHRoaXMuZ2V0TGFzdFJlc3VsdCh0cnVlKTtcbiAgICAgICAgdmFyIG5ldHdvcmtTdGF0dXMgPSB0aGlzLnF1ZXJ5SW5mby5uZXR3b3JrU3RhdHVzIHx8XG4gICAgICAgICAgICAobGFzdFJlc3VsdCAmJiBsYXN0UmVzdWx0Lm5ldHdvcmtTdGF0dXMpIHx8XG4gICAgICAgICAgICBleHBvcnRzLk5ldHdvcmtTdGF0dXMucmVhZHk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgbGFzdFJlc3VsdCksIHsgbG9hZGluZzogaXNOZXR3b3JrUmVxdWVzdEluRmxpZ2h0KG5ldHdvcmtTdGF0dXMpLCBuZXR3b3JrU3RhdHVzOiBuZXR3b3JrU3RhdHVzIH0pO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLm9wdGlvbnMuZmV0Y2hQb2xpY3ksIGZldGNoUG9saWN5ID0gX2EgPT09IHZvaWQgMCA/IFwiY2FjaGUtZmlyc3RcIiA6IF9hO1xuICAgICAgICBpZiAoZmV0Y2hQb2xpY3kgPT09ICduZXR3b3JrLW9ubHknIHx8XG4gICAgICAgICAgICBmZXRjaFBvbGljeSA9PT0gJ25vLWNhY2hlJyB8fFxuICAgICAgICAgICAgZmV0Y2hQb2xpY3kgPT09ICdzdGFuZGJ5JyB8fFxuICAgICAgICAgICAgdGhpcy5xdWVyeU1hbmFnZXIudHJhbnNmb3JtKHRoaXMub3B0aW9ucy5xdWVyeSkuaGFzRm9yY2VkUmVzb2x2ZXJzKSA7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRpZmYgPSB0aGlzLnF1ZXJ5SW5mby5nZXREaWZmKCk7XG4gICAgICAgICAgICBpZiAoZGlmZi5jb21wbGV0ZSB8fCB0aGlzLm9wdGlvbnMucmV0dXJuUGFydGlhbERhdGEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZGF0YSA9IGRpZmYucmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVxdWFsaXR5LmVxdWFsKHJlc3VsdC5kYXRhLCB7fSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZGF0YSA9IHZvaWQgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaWZmLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlc3VsdC5wYXJ0aWFsO1xuICAgICAgICAgICAgICAgIGlmIChkaWZmLmNvbXBsZXRlICYmXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5uZXR3b3JrU3RhdHVzID09PSBleHBvcnRzLk5ldHdvcmtTdGF0dXMubG9hZGluZyAmJlxuICAgICAgICAgICAgICAgICAgICAoZmV0Y2hQb2xpY3kgPT09ICdjYWNoZS1maXJzdCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoUG9saWN5ID09PSAnY2FjaGUtb25seScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5uZXR3b3JrU3RhdHVzID0gZXhwb3J0cy5OZXR3b3JrU3RhdHVzLnJlYWR5O1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wYXJ0aWFsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfX0RFVl9fICYmXG4gICAgICAgICAgICAgICAgIWRpZmYuY29tcGxldGUgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5vcHRpb25zLnBhcnRpYWxSZWZldGNoICYmXG4gICAgICAgICAgICAgICAgIXJlc3VsdC5sb2FkaW5nICYmXG4gICAgICAgICAgICAgICAgIXJlc3VsdC5kYXRhICYmXG4gICAgICAgICAgICAgICAgIXJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgICAgIGxvZ01pc3NpbmdGaWVsZEVycm9ycyhkaWZmLm1pc3NpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzYXZlQXNMYXN0UmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxhc3RSZXN1bHQocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5pc0RpZmZlcmVudEZyb21MYXN0UmVzdWx0ID0gZnVuY3Rpb24gKG5ld1Jlc3VsdCwgdmFyaWFibGVzKSB7XG4gICAgICAgIHJldHVybiAoIXRoaXMubGFzdCB8fFxuICAgICAgICAgICAgIWVxdWFsaXR5LmVxdWFsKHRoaXMubGFzdC5yZXN1bHQsIG5ld1Jlc3VsdCkgfHxcbiAgICAgICAgICAgICh2YXJpYWJsZXMgJiYgIWVxdWFsaXR5LmVxdWFsKHRoaXMubGFzdC52YXJpYWJsZXMsIHZhcmlhYmxlcykpKTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUuZ2V0TGFzdCA9IGZ1bmN0aW9uIChrZXksIHZhcmlhYmxlc011c3RNYXRjaCkge1xuICAgICAgICB2YXIgbGFzdCA9IHRoaXMubGFzdDtcbiAgICAgICAgaWYgKGxhc3QgJiZcbiAgICAgICAgICAgIGxhc3Rba2V5XSAmJlxuICAgICAgICAgICAgKCF2YXJpYWJsZXNNdXN0TWF0Y2ggfHwgZXF1YWxpdHkuZXF1YWwobGFzdC52YXJpYWJsZXMsIHRoaXMudmFyaWFibGVzKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXN0W2tleV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUuZ2V0TGFzdFJlc3VsdCA9IGZ1bmN0aW9uICh2YXJpYWJsZXNNdXN0TWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGFzdChcInJlc3VsdFwiLCB2YXJpYWJsZXNNdXN0TWF0Y2gpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5nZXRMYXN0RXJyb3IgPSBmdW5jdGlvbiAodmFyaWFibGVzTXVzdE1hdGNoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldExhc3QoXCJlcnJvclwiLCB2YXJpYWJsZXNNdXN0TWF0Y2gpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5yZXNldExhc3RSZXN1bHRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWxldGUgdGhpcy5sYXN0O1xuICAgICAgICB0aGlzLmlzVG9ybkRvd24gPSBmYWxzZTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUucmVzZXRRdWVyeVN0b3JlRXJyb3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnF1ZXJ5TWFuYWdlci5yZXNldEVycm9ycyh0aGlzLnF1ZXJ5SWQpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5yZWZldGNoID0gZnVuY3Rpb24gKHZhcmlhYmxlcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciByZW9ic2VydmVPcHRpb25zID0ge1xuICAgICAgICAgICAgcG9sbEludGVydmFsOiAwLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgZmV0Y2hQb2xpY3kgPSB0aGlzLm9wdGlvbnMuZmV0Y2hQb2xpY3k7XG4gICAgICAgIGlmIChmZXRjaFBvbGljeSA9PT0gJ2NhY2hlLWFuZC1uZXR3b3JrJykge1xuICAgICAgICAgICAgcmVvYnNlcnZlT3B0aW9ucy5mZXRjaFBvbGljeSA9IGZldGNoUG9saWN5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZldGNoUG9saWN5ID09PSAnbm8tY2FjaGUnKSB7XG4gICAgICAgICAgICByZW9ic2VydmVPcHRpb25zLmZldGNoUG9saWN5ID0gJ25vLWNhY2hlJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlb2JzZXJ2ZU9wdGlvbnMuZmV0Y2hQb2xpY3kgPSAnbmV0d29yay1vbmx5JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoX19ERVZfXyAmJiB2YXJpYWJsZXMgJiYgaGFzT3duUHJvcGVydHkkMS5jYWxsKHZhcmlhYmxlcywgXCJ2YXJpYWJsZXNcIikpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeURlZiA9IHV0aWxpdGllcy5nZXRRdWVyeURlZmluaXRpb24odGhpcy5xdWVyeSk7XG4gICAgICAgICAgICB2YXIgdmFycyA9IHF1ZXJ5RGVmLnZhcmlhYmxlRGVmaW5pdGlvbnM7XG4gICAgICAgICAgICBpZiAoIXZhcnMgfHwgIXZhcnMuc29tZShmdW5jdGlvbiAodikgeyByZXR1cm4gdi52YXJpYWJsZS5uYW1lLnZhbHVlID09PSBcInZhcmlhYmxlc1wiOyB9KSkge1xuICAgICAgICAgICAgICAgIF9fREVWX18gJiYgZ2xvYmFscy5pbnZhcmlhbnQud2FybihcIkNhbGxlZCByZWZldGNoKFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeSh2YXJpYWJsZXMpLCBcIikgZm9yIHF1ZXJ5IFwiKS5jb25jYXQoKChfYSA9IHF1ZXJ5RGVmLm5hbWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52YWx1ZSkgfHwgSlNPTi5zdHJpbmdpZnkocXVlcnlEZWYpLCBcIiwgd2hpY2ggZG9lcyBub3QgZGVjbGFyZSBhICR2YXJpYWJsZXMgdmFyaWFibGUuXFxuRGlkIHlvdSBtZWFuIHRvIGNhbGwgcmVmZXRjaCh2YXJpYWJsZXMpIGluc3RlYWQgb2YgcmVmZXRjaCh7IHZhcmlhYmxlcyB9KT9cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YXJpYWJsZXMgJiYgIWVxdWFsaXR5LmVxdWFsKHRoaXMub3B0aW9ucy52YXJpYWJsZXMsIHZhcmlhYmxlcykpIHtcbiAgICAgICAgICAgIHJlb2JzZXJ2ZU9wdGlvbnMudmFyaWFibGVzID0gdGhpcy5vcHRpb25zLnZhcmlhYmxlcyA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMudmFyaWFibGVzKSwgdmFyaWFibGVzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnF1ZXJ5SW5mby5yZXNldExhc3RXcml0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZW9ic2VydmUocmVvYnNlcnZlT3B0aW9ucywgZXhwb3J0cy5OZXR3b3JrU3RhdHVzLnJlZmV0Y2gpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5mZXRjaE1vcmUgPSBmdW5jdGlvbiAoZmV0Y2hNb3JlT3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY29tYmluZWRPcHRpb25zID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIChmZXRjaE1vcmVPcHRpb25zLnF1ZXJ5ID8gZmV0Y2hNb3JlT3B0aW9ucyA6IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpLCB7IHF1ZXJ5OiB0aGlzLnF1ZXJ5IH0pLCBmZXRjaE1vcmVPcHRpb25zKSwgeyB2YXJpYWJsZXM6IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMudmFyaWFibGVzKSwgZmV0Y2hNb3JlT3B0aW9ucy52YXJpYWJsZXMpIH0pKSksIHsgZmV0Y2hQb2xpY3k6IFwibm8tY2FjaGVcIiB9KTtcbiAgICAgICAgdmFyIHFpZCA9IHRoaXMucXVlcnlNYW5hZ2VyLmdlbmVyYXRlUXVlcnlJZCgpO1xuICAgICAgICB2YXIgcXVlcnlJbmZvID0gdGhpcy5xdWVyeUluZm87XG4gICAgICAgIHZhciBvcmlnaW5hbE5ldHdvcmtTdGF0dXMgPSBxdWVyeUluZm8ubmV0d29ya1N0YXR1cztcbiAgICAgICAgcXVlcnlJbmZvLm5ldHdvcmtTdGF0dXMgPSBleHBvcnRzLk5ldHdvcmtTdGF0dXMuZmV0Y2hNb3JlO1xuICAgICAgICBpZiAoY29tYmluZWRPcHRpb25zLm5vdGlmeU9uTmV0d29ya1N0YXR1c0NoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVwZGF0ZWRRdWVyeVNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlNYW5hZ2VyLmZldGNoUXVlcnkocWlkLCBjb21iaW5lZE9wdGlvbnMsIGV4cG9ydHMuTmV0d29ya1N0YXR1cy5mZXRjaE1vcmUpLnRoZW4oZnVuY3Rpb24gKGZldGNoTW9yZVJlc3VsdCkge1xuICAgICAgICAgICAgX3RoaXMucXVlcnlNYW5hZ2VyLnJlbW92ZVF1ZXJ5KHFpZCk7XG4gICAgICAgICAgICBpZiAocXVlcnlJbmZvLm5ldHdvcmtTdGF0dXMgPT09IGV4cG9ydHMuTmV0d29ya1N0YXR1cy5mZXRjaE1vcmUpIHtcbiAgICAgICAgICAgICAgICBxdWVyeUluZm8ubmV0d29ya1N0YXR1cyA9IG9yaWdpbmFsTmV0d29ya1N0YXR1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnF1ZXJ5TWFuYWdlci5jYWNoZS5iYXRjaCh7XG4gICAgICAgICAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoY2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZVF1ZXJ5ID0gZmV0Y2hNb3JlT3B0aW9ucy51cGRhdGVRdWVyeTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZVF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS51cGRhdGVRdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IF90aGlzLnF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogX3RoaXMudmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblBhcnRpYWxEYXRhOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGltaXN0aWM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHByZXZpb3VzKSB7IHJldHVybiB1cGRhdGVRdWVyeShwcmV2aW91cywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoTW9yZVJlc3VsdDogZmV0Y2hNb3JlUmVzdWx0LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiBjb21iaW5lZE9wdGlvbnMudmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUud3JpdGVRdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IGNvbWJpbmVkT3B0aW9ucy5xdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IGNvbWJpbmVkT3B0aW9ucy52YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZmV0Y2hNb3JlUmVzdWx0LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25XYXRjaFVwZGF0ZWQ6IGZ1bmN0aW9uICh3YXRjaCkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkUXVlcnlTZXQuYWRkKHdhdGNoLnF1ZXJ5KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hNb3JlUmVzdWx0O1xuICAgICAgICB9KS5maW5hbGx5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdXBkYXRlZFF1ZXJ5U2V0LmhhcyhfdGhpcy5xdWVyeSkpIHtcbiAgICAgICAgICAgICAgICByZW9ic2VydmVDYWNoZUZpcnN0KF90aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnN1YnNjcmliZVRvTW9yZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB0aGlzLnF1ZXJ5TWFuYWdlclxuICAgICAgICAgICAgLnN0YXJ0R3JhcGhRTFN1YnNjcmlwdGlvbih7XG4gICAgICAgICAgICBxdWVyeTogb3B0aW9ucy5kb2N1bWVudCxcbiAgICAgICAgICAgIHZhcmlhYmxlczogb3B0aW9ucy52YXJpYWJsZXMsXG4gICAgICAgICAgICBjb250ZXh0OiBvcHRpb25zLmNvbnRleHQsXG4gICAgICAgIH0pXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uIChzdWJzY3JpcHRpb25EYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZVF1ZXJ5ID0gb3B0aW9ucy51cGRhdGVRdWVyeTtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlUXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlUXVlcnkoZnVuY3Rpb24gKHByZXZpb3VzLCBfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlcyA9IF9hLnZhcmlhYmxlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVRdWVyeShwcmV2aW91cywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbkRhdGE6IHN1YnNjcmlwdGlvbkRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfX0RFVl9fICYmIGdsb2JhbHMuaW52YXJpYW50LmVycm9yKCdVbmhhbmRsZWQgR3JhcGhRTCBzdWJzY3JpcHRpb24gZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdWJzY3JpcHRpb25zLmRlbGV0ZShzdWJzY3JpcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAobmV3T3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW9ic2VydmUobmV3T3B0aW9ucyk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnNldFZhcmlhYmxlcyA9IGZ1bmN0aW9uICh2YXJpYWJsZXMpIHtcbiAgICAgICAgaWYgKGVxdWFsaXR5LmVxdWFsKHRoaXMudmFyaWFibGVzLCB2YXJpYWJsZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYnNlcnZlcnMuc2l6ZVxuICAgICAgICAgICAgICAgID8gdGhpcy5yZXN1bHQoKVxuICAgICAgICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zLnZhcmlhYmxlcyA9IHZhcmlhYmxlcztcbiAgICAgICAgaWYgKCF0aGlzLm9ic2VydmVycy5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVvYnNlcnZlKHtcbiAgICAgICAgICAgIGZldGNoUG9saWN5OiB0aGlzLm9wdGlvbnMuaW5pdGlhbEZldGNoUG9saWN5LFxuICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgIH0sIGV4cG9ydHMuTmV0d29ya1N0YXR1cy5zZXRWYXJpYWJsZXMpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS51cGRhdGVRdWVyeSA9IGZ1bmN0aW9uIChtYXBGbikge1xuICAgICAgICB2YXIgcXVlcnlNYW5hZ2VyID0gdGhpcy5xdWVyeU1hbmFnZXI7XG4gICAgICAgIHZhciByZXN1bHQgPSBxdWVyeU1hbmFnZXIuY2FjaGUuZGlmZih7XG4gICAgICAgICAgICBxdWVyeTogdGhpcy5vcHRpb25zLnF1ZXJ5LFxuICAgICAgICAgICAgdmFyaWFibGVzOiB0aGlzLnZhcmlhYmxlcyxcbiAgICAgICAgICAgIHJldHVyblBhcnRpYWxEYXRhOiB0cnVlLFxuICAgICAgICAgICAgb3B0aW1pc3RpYzogZmFsc2UsXG4gICAgICAgIH0pLnJlc3VsdDtcbiAgICAgICAgdmFyIG5ld1Jlc3VsdCA9IG1hcEZuKHJlc3VsdCwge1xuICAgICAgICAgICAgdmFyaWFibGVzOiB0aGlzLnZhcmlhYmxlcyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChuZXdSZXN1bHQpIHtcbiAgICAgICAgICAgIHF1ZXJ5TWFuYWdlci5jYWNoZS53cml0ZVF1ZXJ5KHtcbiAgICAgICAgICAgICAgICBxdWVyeTogdGhpcy5vcHRpb25zLnF1ZXJ5LFxuICAgICAgICAgICAgICAgIGRhdGE6IG5ld1Jlc3VsdCxcbiAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IHRoaXMudmFyaWFibGVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBxdWVyeU1hbmFnZXIuYnJvYWRjYXN0UXVlcmllcygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnN0YXJ0UG9sbGluZyA9IGZ1bmN0aW9uIChwb2xsSW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnBvbGxJbnRlcnZhbCA9IHBvbGxJbnRlcnZhbDtcbiAgICAgICAgdGhpcy51cGRhdGVQb2xsaW5nKCk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnN0b3BQb2xsaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMucG9sbEludGVydmFsID0gMDtcbiAgICAgICAgdGhpcy51cGRhdGVQb2xsaW5nKCk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLmFwcGx5TmV4dEZldGNoUG9saWN5ID0gZnVuY3Rpb24gKHJlYXNvbiwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5uZXh0RmV0Y2hQb2xpY3kpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IG9wdGlvbnMuZmV0Y2hQb2xpY3ksIGZldGNoUG9saWN5ID0gX2EgPT09IHZvaWQgMCA/IFwiY2FjaGUtZmlyc3RcIiA6IF9hLCBfYiA9IG9wdGlvbnMuaW5pdGlhbEZldGNoUG9saWN5LCBpbml0aWFsRmV0Y2hQb2xpY3kgPSBfYiA9PT0gdm9pZCAwID8gZmV0Y2hQb2xpY3kgOiBfYjtcbiAgICAgICAgICAgIGlmIChmZXRjaFBvbGljeSA9PT0gXCJzdGFuZGJ5XCIpIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLm5leHRGZXRjaFBvbGljeSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5mZXRjaFBvbGljeSA9IG9wdGlvbnMubmV4dEZldGNoUG9saWN5KGZldGNoUG9saWN5LCB7XG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogcmVhc29uLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZhYmxlOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsRmV0Y2hQb2xpY3k6IGluaXRpYWxGZXRjaFBvbGljeSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlYXNvbiA9PT0gXCJ2YXJpYWJsZXMtY2hhbmdlZFwiKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5mZXRjaFBvbGljeSA9IGluaXRpYWxGZXRjaFBvbGljeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZmV0Y2hQb2xpY3kgPSBvcHRpb25zLm5leHRGZXRjaFBvbGljeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW9ucy5mZXRjaFBvbGljeTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbiAob3B0aW9ucywgbmV3TmV0d29ya1N0YXR1cykge1xuICAgICAgICB0aGlzLnF1ZXJ5TWFuYWdlci5zZXRPYnNlcnZhYmxlUXVlcnkodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5TWFuYWdlci5mZXRjaFF1ZXJ5T2JzZXJ2YWJsZSh0aGlzLnF1ZXJ5SWQsIG9wdGlvbnMsIG5ld05ldHdvcmtTdGF0dXMpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS51cGRhdGVQb2xsaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5xdWVyeU1hbmFnZXIuc3NyTW9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHBvbGxpbmdJbmZvID0gX2EucG9sbGluZ0luZm8sIHBvbGxJbnRlcnZhbCA9IF9hLm9wdGlvbnMucG9sbEludGVydmFsO1xuICAgICAgICBpZiAoIXBvbGxJbnRlcnZhbCkge1xuICAgICAgICAgICAgaWYgKHBvbGxpbmdJbmZvKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHBvbGxpbmdJbmZvLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBvbGxpbmdJbmZvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb2xsaW5nSW5mbyAmJlxuICAgICAgICAgICAgcG9sbGluZ0luZm8uaW50ZXJ2YWwgPT09IHBvbGxJbnRlcnZhbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF9fREVWX18gPyBnbG9iYWxzLmludmFyaWFudChwb2xsSW50ZXJ2YWwsICdBdHRlbXB0ZWQgdG8gc3RhcnQgYSBwb2xsaW5nIHF1ZXJ5IHdpdGhvdXQgYSBwb2xsaW5nIGludGVydmFsLicpIDogZ2xvYmFscy5pbnZhcmlhbnQocG9sbEludGVydmFsLCAxMik7XG4gICAgICAgIHZhciBpbmZvID0gcG9sbGluZ0luZm8gfHwgKHRoaXMucG9sbGluZ0luZm8gPSB7fSk7XG4gICAgICAgIGluZm8uaW50ZXJ2YWwgPSBwb2xsSW50ZXJ2YWw7XG4gICAgICAgIHZhciBtYXliZUZldGNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnBvbGxpbmdJbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05ldHdvcmtSZXF1ZXN0SW5GbGlnaHQoX3RoaXMucXVlcnlJbmZvLm5ldHdvcmtTdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlb2JzZXJ2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmZXRjaFBvbGljeTogX3RoaXMub3B0aW9ucy5pbml0aWFsRmV0Y2hQb2xpY3kgPT09ICduby1jYWNoZScgPyAnbm8tY2FjaGUnIDogJ25ldHdvcmstb25seScsXG4gICAgICAgICAgICAgICAgICAgIH0sIGV4cG9ydHMuTmV0d29ya1N0YXR1cy5wb2xsKS50aGVuKHBvbGwsIHBvbGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcG9sbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHBvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW5mbyA9IF90aGlzLnBvbGxpbmdJbmZvO1xuICAgICAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaW5mby50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBpbmZvLnRpbWVvdXQgPSBzZXRUaW1lb3V0KG1heWJlRmV0Y2gsIGluZm8uaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBwb2xsKCk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLnVwZGF0ZUxhc3RSZXN1bHQgPSBmdW5jdGlvbiAobmV3UmVzdWx0LCB2YXJpYWJsZXMpIHtcbiAgICAgICAgaWYgKHZhcmlhYmxlcyA9PT0gdm9pZCAwKSB7IHZhcmlhYmxlcyA9IHRoaXMudmFyaWFibGVzOyB9XG4gICAgICAgIHRoaXMubGFzdCA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCB0aGlzLmxhc3QpLCB7IHJlc3VsdDogdGhpcy5xdWVyeU1hbmFnZXIuYXNzdW1lSW1tdXRhYmxlUmVzdWx0c1xuICAgICAgICAgICAgICAgID8gbmV3UmVzdWx0XG4gICAgICAgICAgICAgICAgOiB1dGlsaXRpZXMuY2xvbmVEZWVwKG5ld1Jlc3VsdCksIHZhcmlhYmxlczogdmFyaWFibGVzIH0pO1xuICAgICAgICBpZiAoIXV0aWxpdGllcy5pc05vbkVtcHR5QXJyYXkobmV3UmVzdWx0LmVycm9ycykpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxhc3QuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdDtcbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUucmVvYnNlcnZlID0gZnVuY3Rpb24gKG5ld09wdGlvbnMsIG5ld05ldHdvcmtTdGF0dXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5pc1Rvcm5Eb3duID0gZmFsc2U7XG4gICAgICAgIHZhciB1c2VEaXNwb3NhYmxlQ29uY2FzdCA9IG5ld05ldHdvcmtTdGF0dXMgPT09IGV4cG9ydHMuTmV0d29ya1N0YXR1cy5yZWZldGNoIHx8XG4gICAgICAgICAgICBuZXdOZXR3b3JrU3RhdHVzID09PSBleHBvcnRzLk5ldHdvcmtTdGF0dXMuZmV0Y2hNb3JlIHx8XG4gICAgICAgICAgICBuZXdOZXR3b3JrU3RhdHVzID09PSBleHBvcnRzLk5ldHdvcmtTdGF0dXMucG9sbDtcbiAgICAgICAgdmFyIG9sZFZhcmlhYmxlcyA9IHRoaXMub3B0aW9ucy52YXJpYWJsZXM7XG4gICAgICAgIHZhciBvbGRGZXRjaFBvbGljeSA9IHRoaXMub3B0aW9ucy5mZXRjaFBvbGljeTtcbiAgICAgICAgdmFyIG1lcmdlZE9wdGlvbnMgPSB1dGlsaXRpZXMuY29tcGFjdCh0aGlzLm9wdGlvbnMsIG5ld09wdGlvbnMgfHwge30pO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHVzZURpc3Bvc2FibGVDb25jYXN0XG4gICAgICAgICAgICA/IG1lcmdlZE9wdGlvbnNcbiAgICAgICAgICAgIDogYXNzaWduKHRoaXMub3B0aW9ucywgbWVyZ2VkT3B0aW9ucyk7XG4gICAgICAgIGlmICghdXNlRGlzcG9zYWJsZUNvbmNhc3QpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUG9sbGluZygpO1xuICAgICAgICAgICAgaWYgKG5ld09wdGlvbnMgJiZcbiAgICAgICAgICAgICAgICBuZXdPcHRpb25zLnZhcmlhYmxlcyAmJlxuICAgICAgICAgICAgICAgICFlcXVhbGl0eS5lcXVhbChuZXdPcHRpb25zLnZhcmlhYmxlcywgb2xkVmFyaWFibGVzKSAmJlxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZmV0Y2hQb2xpY3kgIT09IFwic3RhbmRieVwiICYmXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5mZXRjaFBvbGljeSA9PT0gb2xkRmV0Y2hQb2xpY3kpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5TmV4dEZldGNoUG9saWN5KFwidmFyaWFibGVzLWNoYW5nZWRcIiwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld05ldHdvcmtTdGF0dXMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdOZXR3b3JrU3RhdHVzID0gZXhwb3J0cy5OZXR3b3JrU3RhdHVzLnNldFZhcmlhYmxlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhcmlhYmxlcyA9IG9wdGlvbnMudmFyaWFibGVzICYmIHRzbGliLl9fYXNzaWduKHt9LCBvcHRpb25zLnZhcmlhYmxlcyk7XG4gICAgICAgIHZhciBjb25jYXN0ID0gdGhpcy5mZXRjaChvcHRpb25zLCBuZXdOZXR3b3JrU3RhdHVzKTtcbiAgICAgICAgdmFyIG9ic2VydmVyID0ge1xuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlcG9ydFJlc3VsdChyZXN1bHQsIHZhcmlhYmxlcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlcG9ydEVycm9yKGVycm9yLCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF1c2VEaXNwb3NhYmxlQ29uY2FzdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uY2FzdCAmJiB0aGlzLm9ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25jYXN0LnJlbW92ZU9ic2VydmVyKHRoaXMub2JzZXJ2ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb25jYXN0ID0gY29uY2FzdDtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIgPSBvYnNlcnZlcjtcbiAgICAgICAgfVxuICAgICAgICBjb25jYXN0LmFkZE9ic2VydmVyKG9ic2VydmVyKTtcbiAgICAgICAgcmV0dXJuIGNvbmNhc3QucHJvbWlzZTtcbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRSZXN1bHQodGhpcy5nZXRDdXJyZW50UmVzdWx0KGZhbHNlKSwgdGhpcy52YXJpYWJsZXMpO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS5yZXBvcnRSZXN1bHQgPSBmdW5jdGlvbiAocmVzdWx0LCB2YXJpYWJsZXMpIHtcbiAgICAgICAgdmFyIGxhc3RFcnJvciA9IHRoaXMuZ2V0TGFzdEVycm9yKCk7XG4gICAgICAgIGlmIChsYXN0RXJyb3IgfHwgdGhpcy5pc0RpZmZlcmVudEZyb21MYXN0UmVzdWx0KHJlc3VsdCwgdmFyaWFibGVzKSkge1xuICAgICAgICAgICAgaWYgKGxhc3RFcnJvciB8fCAhcmVzdWx0LnBhcnRpYWwgfHwgdGhpcy5vcHRpb25zLnJldHVyblBhcnRpYWxEYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVMYXN0UmVzdWx0KHJlc3VsdCwgdmFyaWFibGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHV0aWxpdGllcy5pdGVyYXRlT2JzZXJ2ZXJzU2FmZWx5KHRoaXMub2JzZXJ2ZXJzLCAnbmV4dCcsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9ic2VydmFibGVRdWVyeS5wcm90b3R5cGUucmVwb3J0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IsIHZhcmlhYmxlcykge1xuICAgICAgICB2YXIgZXJyb3JSZXN1bHQgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgdGhpcy5nZXRMYXN0UmVzdWx0KCkpLCB7IGVycm9yOiBlcnJvciwgZXJyb3JzOiBlcnJvci5ncmFwaFFMRXJyb3JzLCBuZXR3b3JrU3RhdHVzOiBleHBvcnRzLk5ldHdvcmtTdGF0dXMuZXJyb3IsIGxvYWRpbmc6IGZhbHNlIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZUxhc3RSZXN1bHQoZXJyb3JSZXN1bHQsIHZhcmlhYmxlcyk7XG4gICAgICAgIHV0aWxpdGllcy5pdGVyYXRlT2JzZXJ2ZXJzU2FmZWx5KHRoaXMub2JzZXJ2ZXJzLCAnZXJyb3InLCB0aGlzLmxhc3QuZXJyb3IgPSBlcnJvcik7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlUXVlcnkucHJvdG90eXBlLmhhc09ic2VydmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2JzZXJ2ZXJzLnNpemUgPiAwO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZVF1ZXJ5LnByb3RvdHlwZS50ZWFyRG93blF1ZXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc1Rvcm5Eb3duKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5jb25jYXN0ICYmIHRoaXMub2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY29uY2FzdC5yZW1vdmVPYnNlcnZlcih0aGlzLm9ic2VydmVyKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNvbmNhc3Q7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5vYnNlcnZlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0b3BQb2xsaW5nKCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzdWIpIHsgcmV0dXJuIHN1Yi51bnN1YnNjcmliZSgpOyB9KTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmNsZWFyKCk7XG4gICAgICAgIHRoaXMucXVlcnlNYW5hZ2VyLnN0b3BRdWVyeSh0aGlzLnF1ZXJ5SWQpO1xuICAgICAgICB0aGlzLm9ic2VydmVycy5jbGVhcigpO1xuICAgICAgICB0aGlzLmlzVG9ybkRvd24gPSB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIE9ic2VydmFibGVRdWVyeTtcbn0odXRpbGl0aWVzLk9ic2VydmFibGUpKTtcbnV0aWxpdGllcy5maXhPYnNlcnZhYmxlU3ViY2xhc3MoT2JzZXJ2YWJsZVF1ZXJ5KTtcbmZ1bmN0aW9uIHJlb2JzZXJ2ZUNhY2hlRmlyc3Qob2JzUXVlcnkpIHtcbiAgICB2YXIgX2EgPSBvYnNRdWVyeS5vcHRpb25zLCBmZXRjaFBvbGljeSA9IF9hLmZldGNoUG9saWN5LCBuZXh0RmV0Y2hQb2xpY3kgPSBfYS5uZXh0RmV0Y2hQb2xpY3k7XG4gICAgaWYgKGZldGNoUG9saWN5ID09PSBcImNhY2hlLWFuZC1uZXR3b3JrXCIgfHxcbiAgICAgICAgZmV0Y2hQb2xpY3kgPT09IFwibmV0d29yay1vbmx5XCIpIHtcbiAgICAgICAgcmV0dXJuIG9ic1F1ZXJ5LnJlb2JzZXJ2ZSh7XG4gICAgICAgICAgICBmZXRjaFBvbGljeTogXCJjYWNoZS1maXJzdFwiLFxuICAgICAgICAgICAgbmV4dEZldGNoUG9saWN5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0RmV0Y2hQb2xpY3kgPSBuZXh0RmV0Y2hQb2xpY3k7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXh0RmV0Y2hQb2xpY3kgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dEZldGNoUG9saWN5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaFBvbGljeTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb2JzUXVlcnkucmVvYnNlcnZlKCk7XG59XG5mdW5jdGlvbiBkZWZhdWx0U3Vic2NyaXB0aW9uT2JzZXJ2ZXJFcnJvckNhbGxiYWNrKGVycm9yKSB7XG4gICAgX19ERVZfXyAmJiBnbG9iYWxzLmludmFyaWFudC5lcnJvcignVW5oYW5kbGVkIGVycm9yJywgZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhY2spO1xufVxuZnVuY3Rpb24gbG9nTWlzc2luZ0ZpZWxkRXJyb3JzKG1pc3NpbmcpIHtcbiAgICBpZiAoX19ERVZfXyAmJiBtaXNzaW5nKSB7XG4gICAgICAgIF9fREVWX18gJiYgZ2xvYmFscy5pbnZhcmlhbnQuZGVidWcoXCJNaXNzaW5nIGNhY2hlIHJlc3VsdCBmaWVsZHM6IFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShtaXNzaW5nKSksIG1pc3NpbmcpO1xuICAgIH1cbn1cblxudmFyIExvY2FsU3RhdGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvY2FsU3RhdGUoX2EpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gX2EuY2FjaGUsIGNsaWVudCA9IF9hLmNsaWVudCwgcmVzb2x2ZXJzID0gX2EucmVzb2x2ZXJzLCBmcmFnbWVudE1hdGNoZXIgPSBfYS5mcmFnbWVudE1hdGNoZXI7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBjYWNoZTtcbiAgICAgICAgaWYgKGNsaWVudCkge1xuICAgICAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc29sdmVycykge1xuICAgICAgICAgICAgdGhpcy5hZGRSZXNvbHZlcnMocmVzb2x2ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhZ21lbnRNYXRjaGVyKSB7XG4gICAgICAgICAgICB0aGlzLnNldEZyYWdtZW50TWF0Y2hlcihmcmFnbWVudE1hdGNoZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIExvY2FsU3RhdGUucHJvdG90eXBlLmFkZFJlc29sdmVycyA9IGZ1bmN0aW9uIChyZXNvbHZlcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yZXNvbHZlcnMgPSB0aGlzLnJlc29sdmVycyB8fCB7fTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzb2x2ZXJzKSkge1xuICAgICAgICAgICAgcmVzb2x2ZXJzLmZvckVhY2goZnVuY3Rpb24gKHJlc29sdmVyR3JvdXApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXNvbHZlcnMgPSB1dGlsaXRpZXMubWVyZ2VEZWVwKF90aGlzLnJlc29sdmVycywgcmVzb2x2ZXJHcm91cCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZXJzID0gdXRpbGl0aWVzLm1lcmdlRGVlcCh0aGlzLnJlc29sdmVycywgcmVzb2x2ZXJzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUuc2V0UmVzb2x2ZXJzID0gZnVuY3Rpb24gKHJlc29sdmVycykge1xuICAgICAgICB0aGlzLnJlc29sdmVycyA9IHt9O1xuICAgICAgICB0aGlzLmFkZFJlc29sdmVycyhyZXNvbHZlcnMpO1xuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUuZ2V0UmVzb2x2ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlcnMgfHwge307XG4gICAgfTtcbiAgICBMb2NhbFN0YXRlLnByb3RvdHlwZS5ydW5SZXNvbHZlcnMgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGRvY3VtZW50ID0gX2EuZG9jdW1lbnQsIHJlbW90ZVJlc3VsdCA9IF9hLnJlbW90ZVJlc3VsdCwgY29udGV4dCA9IF9hLmNvbnRleHQsIHZhcmlhYmxlcyA9IF9hLnZhcmlhYmxlcywgX2IgPSBfYS5vbmx5UnVuRm9yY2VkUmVzb2x2ZXJzLCBvbmx5UnVuRm9yY2VkUmVzb2x2ZXJzID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2I7XG4gICAgICAgIHJldHVybiB0c2xpYi5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0c2xpYi5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLnJlc29sdmVEb2N1bWVudChkb2N1bWVudCwgcmVtb3RlUmVzdWx0LmRhdGEsIGNvbnRleHQsIHZhcmlhYmxlcywgdGhpcy5mcmFnbWVudE1hdGNoZXIsIG9ubHlSdW5Gb3JjZWRSZXNvbHZlcnMpLnRoZW4oZnVuY3Rpb24gKGxvY2FsUmVzdWx0KSB7IHJldHVybiAodHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIHJlbW90ZVJlc3VsdCksIHsgZGF0YTogbG9jYWxSZXN1bHQucmVzdWx0IH0pKTsgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHJlbW90ZVJlc3VsdF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMb2NhbFN0YXRlLnByb3RvdHlwZS5zZXRGcmFnbWVudE1hdGNoZXIgPSBmdW5jdGlvbiAoZnJhZ21lbnRNYXRjaGVyKSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRNYXRjaGVyID0gZnJhZ21lbnRNYXRjaGVyO1xuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUuZ2V0RnJhZ21lbnRNYXRjaGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcmFnbWVudE1hdGNoZXI7XG4gICAgfTtcbiAgICBMb2NhbFN0YXRlLnByb3RvdHlwZS5jbGllbnRRdWVyeSA9IGZ1bmN0aW9uIChkb2N1bWVudCkge1xuICAgICAgICBpZiAodXRpbGl0aWVzLmhhc0RpcmVjdGl2ZXMoWydjbGllbnQnXSwgZG9jdW1lbnQpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXNvbHZlcnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBMb2NhbFN0YXRlLnByb3RvdHlwZS5zZXJ2ZXJRdWVyeSA9IGZ1bmN0aW9uIChkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gdXRpbGl0aWVzLnJlbW92ZUNsaWVudFNldHNGcm9tRG9jdW1lbnQoZG9jdW1lbnQpO1xuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUucHJlcGFyZUNvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB2YXIgY2FjaGUgPSB0aGlzLmNhY2hlO1xuICAgICAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGNvbnRleHQpLCB7IGNhY2hlOiBjYWNoZSwgZ2V0Q2FjaGVLZXk6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGUuaWRlbnRpZnkob2JqKTtcbiAgICAgICAgICAgIH0gfSk7XG4gICAgfTtcbiAgICBMb2NhbFN0YXRlLnByb3RvdHlwZS5hZGRFeHBvcnRlZFZhcmlhYmxlcyA9IGZ1bmN0aW9uIChkb2N1bWVudCwgdmFyaWFibGVzLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh2YXJpYWJsZXMgPT09IHZvaWQgMCkgeyB2YXJpYWJsZXMgPSB7fTsgfVxuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7IGNvbnRleHQgPSB7fTsgfVxuICAgICAgICByZXR1cm4gdHNsaWIuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWIuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5yZXNvbHZlRG9jdW1lbnQoZG9jdW1lbnQsIHRoaXMuYnVpbGRSb290VmFsdWVGcm9tQ2FjaGUoZG9jdW1lbnQsIHZhcmlhYmxlcykgfHwge30sIHRoaXMucHJlcGFyZUNvbnRleHQoY29udGV4dCksIHZhcmlhYmxlcykudGhlbihmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCB2YXJpYWJsZXMpLCBkYXRhLmV4cG9ydGVkVmFyaWFibGVzKSk7IH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0c2xpYi5fX2Fzc2lnbih7fSwgdmFyaWFibGVzKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMb2NhbFN0YXRlLnByb3RvdHlwZS5zaG91bGRGb3JjZVJlc29sdmVycyA9IGZ1bmN0aW9uIChkb2N1bWVudCkge1xuICAgICAgICB2YXIgZm9yY2VSZXNvbHZlcnMgPSBmYWxzZTtcbiAgICAgICAgZ3JhcGhxbC52aXNpdChkb2N1bWVudCwge1xuICAgICAgICAgICAgRGlyZWN0aXZlOiB7XG4gICAgICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm5hbWUudmFsdWUgPT09ICdjbGllbnQnICYmIG5vZGUuYXJndW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JjZVJlc29sdmVycyA9IG5vZGUuYXJndW1lbnRzLnNvbWUoZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcmcubmFtZS52YWx1ZSA9PT0gJ2Fsd2F5cycgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnLnZhbHVlLmtpbmQgPT09ICdCb29sZWFuVmFsdWUnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZy52YWx1ZS52YWx1ZSA9PT0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvcmNlUmVzb2x2ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdyYXBocWwuQlJFQUs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb3JjZVJlc29sdmVycztcbiAgICB9O1xuICAgIExvY2FsU3RhdGUucHJvdG90eXBlLmJ1aWxkUm9vdFZhbHVlRnJvbUNhY2hlID0gZnVuY3Rpb24gKGRvY3VtZW50LCB2YXJpYWJsZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZGlmZih7XG4gICAgICAgICAgICBxdWVyeTogdXRpbGl0aWVzLmJ1aWxkUXVlcnlGcm9tU2VsZWN0aW9uU2V0KGRvY3VtZW50KSxcbiAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgcmV0dXJuUGFydGlhbERhdGE6IHRydWUsXG4gICAgICAgICAgICBvcHRpbWlzdGljOiBmYWxzZSxcbiAgICAgICAgfSkucmVzdWx0O1xuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUucmVzb2x2ZURvY3VtZW50ID0gZnVuY3Rpb24gKGRvY3VtZW50LCByb290VmFsdWUsIGNvbnRleHQsIHZhcmlhYmxlcywgZnJhZ21lbnRNYXRjaGVyLCBvbmx5UnVuRm9yY2VkUmVzb2x2ZXJzKSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHsgY29udGV4dCA9IHt9OyB9XG4gICAgICAgIGlmICh2YXJpYWJsZXMgPT09IHZvaWQgMCkgeyB2YXJpYWJsZXMgPSB7fTsgfVxuICAgICAgICBpZiAoZnJhZ21lbnRNYXRjaGVyID09PSB2b2lkIDApIHsgZnJhZ21lbnRNYXRjaGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfTsgfVxuICAgICAgICBpZiAob25seVJ1bkZvcmNlZFJlc29sdmVycyA9PT0gdm9pZCAwKSB7IG9ubHlSdW5Gb3JjZWRSZXNvbHZlcnMgPSBmYWxzZTsgfVxuICAgICAgICByZXR1cm4gdHNsaWIuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWFpbkRlZmluaXRpb24sIGZyYWdtZW50cywgZnJhZ21lbnRNYXAsIGRlZmluaXRpb25PcGVyYXRpb24sIGRlZmF1bHRPcGVyYXRpb25UeXBlLCBfYSwgY2FjaGUsIGNsaWVudCwgZXhlY0NvbnRleHQ7XG4gICAgICAgICAgICByZXR1cm4gdHNsaWIuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgbWFpbkRlZmluaXRpb24gPSB1dGlsaXRpZXMuZ2V0TWFpbkRlZmluaXRpb24oZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIGZyYWdtZW50cyA9IHV0aWxpdGllcy5nZXRGcmFnbWVudERlZmluaXRpb25zKGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICBmcmFnbWVudE1hcCA9IHV0aWxpdGllcy5jcmVhdGVGcmFnbWVudE1hcChmcmFnbWVudHMpO1xuICAgICAgICAgICAgICAgIGRlZmluaXRpb25PcGVyYXRpb24gPSBtYWluRGVmaW5pdGlvblxuICAgICAgICAgICAgICAgICAgICAub3BlcmF0aW9uO1xuICAgICAgICAgICAgICAgIGRlZmF1bHRPcGVyYXRpb25UeXBlID0gZGVmaW5pdGlvbk9wZXJhdGlvblxuICAgICAgICAgICAgICAgICAgICA/IGRlZmluaXRpb25PcGVyYXRpb24uY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbk9wZXJhdGlvbi5zbGljZSgxKVxuICAgICAgICAgICAgICAgICAgICA6ICdRdWVyeSc7XG4gICAgICAgICAgICAgICAgX2EgPSB0aGlzLCBjYWNoZSA9IF9hLmNhY2hlLCBjbGllbnQgPSBfYS5jbGllbnQ7XG4gICAgICAgICAgICAgICAgZXhlY0NvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50TWFwOiBmcmFnbWVudE1hcCxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGNvbnRleHQpLCB7IGNhY2hlOiBjYWNoZSwgY2xpZW50OiBjbGllbnQgfSksXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudE1hdGNoZXI6IGZyYWdtZW50TWF0Y2hlcixcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdE9wZXJhdGlvblR5cGU6IGRlZmF1bHRPcGVyYXRpb25UeXBlLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRlZFZhcmlhYmxlczoge30sXG4gICAgICAgICAgICAgICAgICAgIG9ubHlSdW5Gb3JjZWRSZXNvbHZlcnM6IG9ubHlSdW5Gb3JjZWRSZXNvbHZlcnMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMucmVzb2x2ZVNlbGVjdGlvblNldChtYWluRGVmaW5pdGlvbi5zZWxlY3Rpb25TZXQsIHJvb3RWYWx1ZSwgZXhlY0NvbnRleHQpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0ZWRWYXJpYWJsZXM6IGV4ZWNDb250ZXh0LmV4cG9ydGVkVmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICB9KTsgfSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTG9jYWxTdGF0ZS5wcm90b3R5cGUucmVzb2x2ZVNlbGVjdGlvblNldCA9IGZ1bmN0aW9uIChzZWxlY3Rpb25TZXQsIHJvb3RWYWx1ZSwgZXhlY0NvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGZyYWdtZW50TWFwLCBjb250ZXh0LCB2YXJpYWJsZXMsIHJlc3VsdHNUb01lcmdlLCBleGVjdXRlO1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0c2xpYi5fX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudE1hcCA9IGV4ZWNDb250ZXh0LmZyYWdtZW50TWFwLCBjb250ZXh0ID0gZXhlY0NvbnRleHQuY29udGV4dCwgdmFyaWFibGVzID0gZXhlY0NvbnRleHQudmFyaWFibGVzO1xuICAgICAgICAgICAgICAgIHJlc3VsdHNUb01lcmdlID0gW3Jvb3RWYWx1ZV07XG4gICAgICAgICAgICAgICAgZXhlY3V0ZSA9IGZ1bmN0aW9uIChzZWxlY3Rpb24pIHsgcmV0dXJuIHRzbGliLl9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50LCB0eXBlQ29uZGl0aW9uO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHNsaWIuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXV0aWxpdGllcy5zaG91bGRJbmNsdWRlKHNlbGVjdGlvbiwgdmFyaWFibGVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXRpbGl0aWVzLmlzRmllbGQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5yZXNvbHZlRmllbGQoc2VsZWN0aW9uLCByb290VmFsdWUsIGV4ZWNDb250ZXh0KS50aGVuKGZ1bmN0aW9uIChmaWVsZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWVsZFJlc3VsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzVG9NZXJnZS5wdXNoKChfYSA9IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYVt1dGlsaXRpZXMucmVzdWx0S2V5TmFtZUZyb21GaWVsZChzZWxlY3Rpb24pXSA9IGZpZWxkUmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXRpbGl0aWVzLmlzSW5saW5lRnJhZ21lbnQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBmcmFnbWVudE1hcFtzZWxlY3Rpb24ubmFtZS52YWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19ERVZfXyA/IGdsb2JhbHMuaW52YXJpYW50KGZyYWdtZW50LCBcIk5vIGZyYWdtZW50IG5hbWVkIFwiLmNvbmNhdChzZWxlY3Rpb24ubmFtZS52YWx1ZSkpIDogZ2xvYmFscy5pbnZhcmlhbnQoZnJhZ21lbnQsIDExKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnbWVudCAmJiBmcmFnbWVudC50eXBlQ29uZGl0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZUNvbmRpdGlvbiA9IGZyYWdtZW50LnR5cGVDb25kaXRpb24ubmFtZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhlY0NvbnRleHQuZnJhZ21lbnRNYXRjaGVyKHJvb3RWYWx1ZSwgdHlwZUNvbmRpdGlvbiwgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLnJlc29sdmVTZWxlY3Rpb25TZXQoZnJhZ21lbnQuc2VsZWN0aW9uU2V0LCByb290VmFsdWUsIGV4ZWNDb250ZXh0KS50aGVuKGZ1bmN0aW9uIChmcmFnbWVudFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNUb01lcmdlLnB1c2goZnJhZ21lbnRSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pOyB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgUHJvbWlzZS5hbGwoc2VsZWN0aW9uU2V0LnNlbGVjdGlvbnMubWFwKGV4ZWN1dGUpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1dGlsaXRpZXMubWVyZ2VEZWVwQXJyYXkocmVzdWx0c1RvTWVyZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMb2NhbFN0YXRlLnByb3RvdHlwZS5yZXNvbHZlRmllbGQgPSBmdW5jdGlvbiAoZmllbGQsIHJvb3RWYWx1ZSwgZXhlY0NvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRzbGliLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZhcmlhYmxlcywgZmllbGROYW1lLCBhbGlhc2VkRmllbGROYW1lLCBhbGlhc1VzZWQsIGRlZmF1bHRSZXN1bHQsIHJlc3VsdFByb21pc2UsIHJlc29sdmVyVHlwZSwgcmVzb2x2ZXJNYXAsIHJlc29sdmU7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlcyA9IGV4ZWNDb250ZXh0LnZhcmlhYmxlcztcbiAgICAgICAgICAgICAgICBmaWVsZE5hbWUgPSBmaWVsZC5uYW1lLnZhbHVlO1xuICAgICAgICAgICAgICAgIGFsaWFzZWRGaWVsZE5hbWUgPSB1dGlsaXRpZXMucmVzdWx0S2V5TmFtZUZyb21GaWVsZChmaWVsZCk7XG4gICAgICAgICAgICAgICAgYWxpYXNVc2VkID0gZmllbGROYW1lICE9PSBhbGlhc2VkRmllbGROYW1lO1xuICAgICAgICAgICAgICAgIGRlZmF1bHRSZXN1bHQgPSByb290VmFsdWVbYWxpYXNlZEZpZWxkTmFtZV0gfHwgcm9vdFZhbHVlW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICAgICAgcmVzdWx0UHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShkZWZhdWx0UmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAoIWV4ZWNDb250ZXh0Lm9ubHlSdW5Gb3JjZWRSZXNvbHZlcnMgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG91bGRGb3JjZVJlc29sdmVycyhmaWVsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZXJUeXBlID0gcm9vdFZhbHVlLl9fdHlwZW5hbWUgfHwgZXhlY0NvbnRleHQuZGVmYXVsdE9wZXJhdGlvblR5cGU7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVyTWFwID0gdGhpcy5yZXNvbHZlcnMgJiYgdGhpcy5yZXNvbHZlcnNbcmVzb2x2ZXJUeXBlXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVyTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlID0gcmVzb2x2ZXJNYXBbYWxpYXNVc2VkID8gZmllbGROYW1lIDogYWxpYXNlZEZpZWxkTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY2FjaGUuY2FjaGVTbG90LndpdGhWYWx1ZSh0aGlzLmNhY2hlLCByZXNvbHZlLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbGl0aWVzLmFyZ3VtZW50c09iamVjdEZyb21GaWVsZChmaWVsZCwgdmFyaWFibGVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhlY0NvbnRleHQuY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBmaWVsZDogZmllbGQsIGZyYWdtZW50TWFwOiBleGVjQ29udGV4dC5mcmFnbWVudE1hcCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHJlc3VsdFByb21pc2UudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHsgcmVzdWx0ID0gZGVmYXVsdFJlc3VsdDsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZC5kaXJlY3RpdmVzLmZvckVhY2goZnVuY3Rpb24gKGRpcmVjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aXZlLm5hbWUudmFsdWUgPT09ICdleHBvcnQnICYmIGRpcmVjdGl2ZS5hcmd1bWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZS5hcmd1bWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZy5uYW1lLnZhbHVlID09PSAnYXMnICYmIGFyZy52YWx1ZS5raW5kID09PSAnU3RyaW5nVmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWNDb250ZXh0LmV4cG9ydGVkVmFyaWFibGVzW2FyZy52YWx1ZS52YWx1ZV0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmllbGQuc2VsZWN0aW9uU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlc29sdmVTdWJTZWxlY3RlZEFycmF5KGZpZWxkLCByZXN1bHQsIGV4ZWNDb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5zZWxlY3Rpb25TZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucmVzb2x2ZVNlbGVjdGlvblNldChmaWVsZC5zZWxlY3Rpb25TZXQsIHJlc3VsdCwgZXhlY0NvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMb2NhbFN0YXRlLnByb3RvdHlwZS5yZXNvbHZlU3ViU2VsZWN0ZWRBcnJheSA9IGZ1bmN0aW9uIChmaWVsZCwgcmVzdWx0LCBleGVjQ29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocmVzdWx0Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlc29sdmVTdWJTZWxlY3RlZEFycmF5KGZpZWxkLCBpdGVtLCBleGVjQ29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmllbGQuc2VsZWN0aW9uU2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnJlc29sdmVTZWxlY3Rpb25TZXQoZmllbGQuc2VsZWN0aW9uU2V0LCBpdGVtLCBleGVjQ29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBMb2NhbFN0YXRlO1xufSgpKTtcblxudmFyIGRlc3RydWN0aXZlTWV0aG9kQ291bnRzID0gbmV3ICh1dGlsaXRpZXMuY2FuVXNlV2Vha01hcCA/IFdlYWtNYXAgOiBNYXApKCk7XG5mdW5jdGlvbiB3cmFwRGVzdHJ1Y3RpdmVDYWNoZU1ldGhvZChjYWNoZSwgbWV0aG9kTmFtZSkge1xuICAgIHZhciBvcmlnaW5hbCA9IGNhY2hlW21ldGhvZE5hbWVdO1xuICAgIGlmICh0eXBlb2Ygb3JpZ2luYWwgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWNoZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRlc3RydWN0aXZlTWV0aG9kQ291bnRzLnNldChjYWNoZSwgKGRlc3RydWN0aXZlTWV0aG9kQ291bnRzLmdldChjYWNoZSkgKyAxKSAlIDFlMTUpO1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gY2FuY2VsTm90aWZ5VGltZW91dChpbmZvKSB7XG4gICAgaWYgKGluZm9bXCJub3RpZnlUaW1lb3V0XCJdKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChpbmZvW1wibm90aWZ5VGltZW91dFwiXSk7XG4gICAgICAgIGluZm9bXCJub3RpZnlUaW1lb3V0XCJdID0gdm9pZCAwO1xuICAgIH1cbn1cbnZhciBRdWVyeUluZm8gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFF1ZXJ5SW5mbyhxdWVyeU1hbmFnZXIsIHF1ZXJ5SWQpIHtcbiAgICAgICAgaWYgKHF1ZXJ5SWQgPT09IHZvaWQgMCkgeyBxdWVyeUlkID0gcXVlcnlNYW5hZ2VyLmdlbmVyYXRlUXVlcnlJZCgpOyB9XG4gICAgICAgIHRoaXMucXVlcnlJZCA9IHF1ZXJ5SWQ7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0UmVxdWVzdElkID0gMTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLnN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9ic2VydmFibGVRdWVyeSA9IG51bGw7XG4gICAgICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGUgPSBxdWVyeU1hbmFnZXIuY2FjaGU7XG4gICAgICAgIGlmICghZGVzdHJ1Y3RpdmVNZXRob2RDb3VudHMuaGFzKGNhY2hlKSkge1xuICAgICAgICAgICAgZGVzdHJ1Y3RpdmVNZXRob2RDb3VudHMuc2V0KGNhY2hlLCAwKTtcbiAgICAgICAgICAgIHdyYXBEZXN0cnVjdGl2ZUNhY2hlTWV0aG9kKGNhY2hlLCBcImV2aWN0XCIpO1xuICAgICAgICAgICAgd3JhcERlc3RydWN0aXZlQ2FjaGVNZXRob2QoY2FjaGUsIFwibW9kaWZ5XCIpO1xuICAgICAgICAgICAgd3JhcERlc3RydWN0aXZlQ2FjaGVNZXRob2QoY2FjaGUsIFwicmVzZXRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUXVlcnlJbmZvLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgIHZhciBuZXR3b3JrU3RhdHVzID0gcXVlcnkubmV0d29ya1N0YXR1cyB8fCBleHBvcnRzLk5ldHdvcmtTdGF0dXMubG9hZGluZztcbiAgICAgICAgaWYgKHRoaXMudmFyaWFibGVzICYmXG4gICAgICAgICAgICB0aGlzLm5ldHdvcmtTdGF0dXMgIT09IGV4cG9ydHMuTmV0d29ya1N0YXR1cy5sb2FkaW5nICYmXG4gICAgICAgICAgICAhZXF1YWxpdHkuZXF1YWwodGhpcy52YXJpYWJsZXMsIHF1ZXJ5LnZhcmlhYmxlcykpIHtcbiAgICAgICAgICAgIG5ldHdvcmtTdGF0dXMgPSBleHBvcnRzLk5ldHdvcmtTdGF0dXMuc2V0VmFyaWFibGVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXF1YWxpdHkuZXF1YWwocXVlcnkudmFyaWFibGVzLCB0aGlzLnZhcmlhYmxlcykpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdERpZmYgPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7XG4gICAgICAgICAgICBkb2N1bWVudDogcXVlcnkuZG9jdW1lbnQsXG4gICAgICAgICAgICB2YXJpYWJsZXM6IHF1ZXJ5LnZhcmlhYmxlcyxcbiAgICAgICAgICAgIG5ldHdvcmtFcnJvcjogbnVsbCxcbiAgICAgICAgICAgIGdyYXBoUUxFcnJvcnM6IHRoaXMuZ3JhcGhRTEVycm9ycyB8fCBbXSxcbiAgICAgICAgICAgIG5ldHdvcmtTdGF0dXM6IG5ldHdvcmtTdGF0dXMsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocXVlcnkub2JzZXJ2YWJsZVF1ZXJ5KSB7XG4gICAgICAgICAgICB0aGlzLnNldE9ic2VydmFibGVRdWVyeShxdWVyeS5vYnNlcnZhYmxlUXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChxdWVyeS5sYXN0UmVxdWVzdElkKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RSZXF1ZXN0SWQgPSBxdWVyeS5sYXN0UmVxdWVzdElkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgUXVlcnlJbmZvLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FuY2VsTm90aWZ5VGltZW91dCh0aGlzKTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgIH07XG4gICAgUXVlcnlJbmZvLnByb3RvdHlwZS5nZXREaWZmID0gZnVuY3Rpb24gKHZhcmlhYmxlcykge1xuICAgICAgICBpZiAodmFyaWFibGVzID09PSB2b2lkIDApIHsgdmFyaWFibGVzID0gdGhpcy52YXJpYWJsZXM7IH1cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmdldERpZmZPcHRpb25zKHZhcmlhYmxlcyk7XG4gICAgICAgIGlmICh0aGlzLmxhc3REaWZmICYmIGVxdWFsaXR5LmVxdWFsKG9wdGlvbnMsIHRoaXMubGFzdERpZmYub3B0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhc3REaWZmLmRpZmY7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVXYXRjaCh0aGlzLnZhcmlhYmxlcyA9IHZhcmlhYmxlcyk7XG4gICAgICAgIHZhciBvcSA9IHRoaXMub2JzZXJ2YWJsZVF1ZXJ5O1xuICAgICAgICBpZiAob3EgJiYgb3Eub3B0aW9ucy5mZXRjaFBvbGljeSA9PT0gXCJuby1jYWNoZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4geyBjb21wbGV0ZTogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlmZiA9IHRoaXMuY2FjaGUuZGlmZihvcHRpb25zKTtcbiAgICAgICAgdGhpcy51cGRhdGVMYXN0RGlmZihkaWZmLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgfTtcbiAgICBRdWVyeUluZm8ucHJvdG90eXBlLnVwZGF0ZUxhc3REaWZmID0gZnVuY3Rpb24gKGRpZmYsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5sYXN0RGlmZiA9IGRpZmYgPyB7XG4gICAgICAgICAgICBkaWZmOiBkaWZmLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyB8fCB0aGlzLmdldERpZmZPcHRpb25zKCksXG4gICAgICAgIH0gOiB2b2lkIDA7XG4gICAgfTtcbiAgICBRdWVyeUluZm8ucHJvdG90eXBlLmdldERpZmZPcHRpb25zID0gZnVuY3Rpb24gKHZhcmlhYmxlcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh2YXJpYWJsZXMgPT09IHZvaWQgMCkgeyB2YXJpYWJsZXMgPSB0aGlzLnZhcmlhYmxlczsgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcXVlcnk6IHRoaXMuZG9jdW1lbnQsXG4gICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgIHJldHVyblBhcnRpYWxEYXRhOiB0cnVlLFxuICAgICAgICAgICAgb3B0aW1pc3RpYzogdHJ1ZSxcbiAgICAgICAgICAgIGNhbm9uaXplUmVzdWx0czogKF9hID0gdGhpcy5vYnNlcnZhYmxlUXVlcnkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcHRpb25zLmNhbm9uaXplUmVzdWx0cyxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFF1ZXJ5SW5mby5wcm90b3R5cGUuc2V0RGlmZiA9IGZ1bmN0aW9uIChkaWZmKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBvbGREaWZmID0gdGhpcy5sYXN0RGlmZiAmJiB0aGlzLmxhc3REaWZmLmRpZmY7XG4gICAgICAgIHRoaXMudXBkYXRlTGFzdERpZmYoZGlmZik7XG4gICAgICAgIGlmICghdGhpcy5kaXJ0eSAmJlxuICAgICAgICAgICAgIWVxdWFsaXR5LmVxdWFsKG9sZERpZmYgJiYgb2xkRGlmZi5yZXN1bHQsIGRpZmYgJiYgZGlmZi5yZXN1bHQpKSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5ub3RpZnlUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5ub3RpZnkoKTsgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFF1ZXJ5SW5mby5wcm90b3R5cGUuc2V0T2JzZXJ2YWJsZVF1ZXJ5ID0gZnVuY3Rpb24gKG9xKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvcSA9PT0gdGhpcy5vYnNlcnZhYmxlUXVlcnkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLm9xTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLmRlbGV0ZSh0aGlzLm9xTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZVF1ZXJ5ID0gb3E7XG4gICAgICAgIGlmIChvcSkge1xuICAgICAgICAgICAgb3FbXCJxdWVyeUluZm9cIl0gPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuYWRkKHRoaXMub3FMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlmZiA9IF90aGlzLmdldERpZmYoKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlmZi5mcm9tT3B0aW1pc3RpY1RyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG9xW1wib2JzZXJ2ZVwiXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVvYnNlcnZlQ2FjaGVGaXJzdChvcSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5vcUxpc3RlbmVyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBRdWVyeUluZm8ucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY2FuY2VsTm90aWZ5VGltZW91dCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkTm90aWZ5KCkpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7IHJldHVybiBsaXN0ZW5lcihfdGhpcyk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9O1xuICAgIFF1ZXJ5SW5mby5wcm90b3R5cGUuc2hvdWxkTm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuZGlydHkgfHwgIXRoaXMubGlzdGVuZXJzLnNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOZXR3b3JrUmVxdWVzdEluRmxpZ2h0KHRoaXMubmV0d29ya1N0YXR1cykgJiZcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2YWJsZVF1ZXJ5KSB7XG4gICAgICAgICAgICB2YXIgZmV0Y2hQb2xpY3kgPSB0aGlzLm9ic2VydmFibGVRdWVyeS5vcHRpb25zLmZldGNoUG9saWN5O1xuICAgICAgICAgICAgaWYgKGZldGNoUG9saWN5ICE9PSBcImNhY2hlLW9ubHlcIiAmJlxuICAgICAgICAgICAgICAgIGZldGNoUG9saWN5ICE9PSBcImNhY2hlLWFuZC1uZXR3b3JrXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBRdWVyeUluZm8ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5zdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsID0gUXVlcnlJbmZvLnByb3RvdHlwZS5jYW5jZWw7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoc3ViKSB7IHJldHVybiBzdWIudW5zdWJzY3JpYmUoKTsgfSk7XG4gICAgICAgICAgICB2YXIgb3EgPSB0aGlzLm9ic2VydmFibGVRdWVyeTtcbiAgICAgICAgICAgIGlmIChvcSlcbiAgICAgICAgICAgICAgICBvcS5zdG9wUG9sbGluZygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBRdWVyeUluZm8ucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBRdWVyeUluZm8ucHJvdG90eXBlLnVwZGF0ZVdhdGNoID0gZnVuY3Rpb24gKHZhcmlhYmxlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodmFyaWFibGVzID09PSB2b2lkIDApIHsgdmFyaWFibGVzID0gdGhpcy52YXJpYWJsZXM7IH1cbiAgICAgICAgdmFyIG9xID0gdGhpcy5vYnNlcnZhYmxlUXVlcnk7XG4gICAgICAgIGlmIChvcSAmJiBvcS5vcHRpb25zLmZldGNoUG9saWN5ID09PSBcIm5vLWNhY2hlXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2F0Y2hPcHRpb25zID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIHRoaXMuZ2V0RGlmZk9wdGlvbnModmFyaWFibGVzKSksIHsgd2F0Y2hlcjogdGhpcywgY2FsbGJhY2s6IGZ1bmN0aW9uIChkaWZmKSB7IHJldHVybiBfdGhpcy5zZXREaWZmKGRpZmYpOyB9IH0pO1xuICAgICAgICBpZiAoIXRoaXMubGFzdFdhdGNoIHx8XG4gICAgICAgICAgICAhZXF1YWxpdHkuZXF1YWwod2F0Y2hPcHRpb25zLCB0aGlzLmxhc3RXYXRjaCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbCA9IHRoaXMuY2FjaGUud2F0Y2godGhpcy5sYXN0V2F0Y2ggPSB3YXRjaE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBRdWVyeUluZm8ucHJvdG90eXBlLnJlc2V0TGFzdFdyaXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxhc3RXcml0ZSA9IHZvaWQgMDtcbiAgICB9O1xuICAgIFF1ZXJ5SW5mby5wcm90b3R5cGUuc2hvdWxkV3JpdGUgPSBmdW5jdGlvbiAocmVzdWx0LCB2YXJpYWJsZXMpIHtcbiAgICAgICAgdmFyIGxhc3RXcml0ZSA9IHRoaXMubGFzdFdyaXRlO1xuICAgICAgICByZXR1cm4gIShsYXN0V3JpdGUgJiZcbiAgICAgICAgICAgIGxhc3RXcml0ZS5kbUNvdW50ID09PSBkZXN0cnVjdGl2ZU1ldGhvZENvdW50cy5nZXQodGhpcy5jYWNoZSkgJiZcbiAgICAgICAgICAgIGVxdWFsaXR5LmVxdWFsKHZhcmlhYmxlcywgbGFzdFdyaXRlLnZhcmlhYmxlcykgJiZcbiAgICAgICAgICAgIGVxdWFsaXR5LmVxdWFsKHJlc3VsdC5kYXRhLCBsYXN0V3JpdGUucmVzdWx0LmRhdGEpKTtcbiAgICB9O1xuICAgIFF1ZXJ5SW5mby5wcm90b3R5cGUubWFya1Jlc3VsdCA9IGZ1bmN0aW9uIChyZXN1bHQsIGRvY3VtZW50LCBvcHRpb25zLCBjYWNoZVdyaXRlQmVoYXZpb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGdyYXBoUUxFcnJvcnMgPSB1dGlsaXRpZXMuaXNOb25FbXB0eUFycmF5KHJlc3VsdC5lcnJvcnMpXG4gICAgICAgICAgICA/IHJlc3VsdC5lcnJvcnMuc2xpY2UoMClcbiAgICAgICAgICAgIDogW107XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgaWYgKCdpbmNyZW1lbnRhbCcgaW4gcmVzdWx0ICYmIHV0aWxpdGllcy5pc05vbkVtcHR5QXJyYXkocmVzdWx0LmluY3JlbWVudGFsKSkge1xuICAgICAgICAgICAgdmFyIG1lcmdlZERhdGFfMSA9IHRoaXMuZ2V0RGlmZigpLnJlc3VsdDtcbiAgICAgICAgICAgIHZhciBtZXJnZXJfMSA9IG5ldyB1dGlsaXRpZXMuRGVlcE1lcmdlcigpO1xuICAgICAgICAgICAgcmVzdWx0LmluY3JlbWVudGFsLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBfYS5kYXRhLCBwYXRoID0gX2EucGF0aCwgZXJyb3JzID0gX2EuZXJyb3JzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBwYXRoW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNOdW1lcmljS2V5ID0gIWlzTmFOKCtrZXkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50XzEgPSBpc051bWVyaWNLZXkgPyBbXSA6IHt9O1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRfMVtrZXldID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHBhcmVudF8xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYXBoUUxFcnJvcnMucHVzaC5hcHBseShncmFwaFFMRXJyb3JzLCBlcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXJnZWREYXRhXzEgPSBtZXJnZXJfMS5tZXJnZShtZXJnZWREYXRhXzEsIGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQuZGF0YSA9IG1lcmdlZERhdGFfMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyYXBoUUxFcnJvcnMgPSBncmFwaFFMRXJyb3JzO1xuICAgICAgICBpZiAob3B0aW9ucy5mZXRjaFBvbGljeSA9PT0gJ25vLWNhY2hlJykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVMYXN0RGlmZih7IHJlc3VsdDogcmVzdWx0LmRhdGEsIGNvbXBsZXRlOiB0cnVlIH0sIHRoaXMuZ2V0RGlmZk9wdGlvbnMob3B0aW9ucy52YXJpYWJsZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjYWNoZVdyaXRlQmVoYXZpb3IgIT09IDApIHtcbiAgICAgICAgICAgIGlmIChzaG91bGRXcml0ZVJlc3VsdChyZXN1bHQsIG9wdGlvbnMuZXJyb3JQb2xpY3kpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZS5wZXJmb3JtVHJhbnNhY3Rpb24oZnVuY3Rpb24gKGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zaG91bGRXcml0ZShyZXN1bHQsIG9wdGlvbnMudmFyaWFibGVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUud3JpdGVRdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IGRvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHJlc3VsdC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogb3B0aW9ucy52YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcndyaXRlOiBjYWNoZVdyaXRlQmVoYXZpb3IgPT09IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxhc3RXcml0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IG9wdGlvbnMudmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRtQ291bnQ6IGRlc3RydWN0aXZlTWV0aG9kQ291bnRzLmdldChfdGhpcy5jYWNoZSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmxhc3REaWZmICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubGFzdERpZmYuZGlmZi5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5kYXRhID0gX3RoaXMubGFzdERpZmYuZGlmZi5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaWZmT3B0aW9ucyA9IF90aGlzLmdldERpZmZPcHRpb25zKG9wdGlvbnMudmFyaWFibGVzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpZmYgPSBjYWNoZS5kaWZmKGRpZmZPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5zdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVXYXRjaChvcHRpb25zLnZhcmlhYmxlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlTGFzdERpZmYoZGlmZiwgZGlmZk9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZi5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmRhdGEgPSBkaWZmLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0V3JpdGUgPSB2b2lkIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFF1ZXJ5SW5mby5wcm90b3R5cGUubWFya1JlYWR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLm5ldHdvcmtFcnJvciA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLm5ldHdvcmtTdGF0dXMgPSBleHBvcnRzLk5ldHdvcmtTdGF0dXMucmVhZHk7XG4gICAgfTtcbiAgICBRdWVyeUluZm8ucHJvdG90eXBlLm1hcmtFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICB0aGlzLm5ldHdvcmtTdGF0dXMgPSBleHBvcnRzLk5ldHdvcmtTdGF0dXMuZXJyb3I7XG4gICAgICAgIHRoaXMubGFzdFdyaXRlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIGlmIChlcnJvci5ncmFwaFFMRXJyb3JzKSB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoUUxFcnJvcnMgPSBlcnJvci5ncmFwaFFMRXJyb3JzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvci5uZXR3b3JrRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMubmV0d29ya0Vycm9yID0gZXJyb3IubmV0d29ya0Vycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9O1xuICAgIHJldHVybiBRdWVyeUluZm87XG59KCkpO1xuZnVuY3Rpb24gc2hvdWxkV3JpdGVSZXN1bHQocmVzdWx0LCBlcnJvclBvbGljeSkge1xuICAgIGlmIChlcnJvclBvbGljeSA9PT0gdm9pZCAwKSB7IGVycm9yUG9saWN5ID0gXCJub25lXCI7IH1cbiAgICB2YXIgaWdub3JlRXJyb3JzID0gZXJyb3JQb2xpY3kgPT09IFwiaWdub3JlXCIgfHxcbiAgICAgICAgZXJyb3JQb2xpY3kgPT09IFwiYWxsXCI7XG4gICAgdmFyIHdyaXRlV2l0aEVycm9ycyA9ICF1dGlsaXRpZXMuZ3JhcGhRTFJlc3VsdEhhc0Vycm9yKHJlc3VsdCk7XG4gICAgaWYgKCF3cml0ZVdpdGhFcnJvcnMgJiYgaWdub3JlRXJyb3JzICYmIHJlc3VsdC5kYXRhKSB7XG4gICAgICAgIHdyaXRlV2l0aEVycm9ycyA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB3cml0ZVdpdGhFcnJvcnM7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgUXVlcnlNYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBRdWVyeU1hbmFnZXIoX2EpIHtcbiAgICAgICAgdmFyIGNhY2hlID0gX2EuY2FjaGUsIGxpbmsgPSBfYS5saW5rLCBkZWZhdWx0T3B0aW9ucyA9IF9hLmRlZmF1bHRPcHRpb25zLCBfYiA9IF9hLnF1ZXJ5RGVkdXBsaWNhdGlvbiwgcXVlcnlEZWR1cGxpY2F0aW9uID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2IsIG9uQnJvYWRjYXN0ID0gX2Eub25Ccm9hZGNhc3QsIF9jID0gX2Euc3NyTW9kZSwgc3NyTW9kZSA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jLCBfZCA9IF9hLmNsaWVudEF3YXJlbmVzcywgY2xpZW50QXdhcmVuZXNzID0gX2QgPT09IHZvaWQgMCA/IHt9IDogX2QsIGxvY2FsU3RhdGUgPSBfYS5sb2NhbFN0YXRlLCBhc3N1bWVJbW11dGFibGVSZXN1bHRzID0gX2EuYXNzdW1lSW1tdXRhYmxlUmVzdWx0cztcbiAgICAgICAgdGhpcy5jbGllbnRBd2FyZW5lc3MgPSB7fTtcbiAgICAgICAgdGhpcy5xdWVyaWVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmZldGNoQ2FuY2VsRm5zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybUNhY2hlID0gbmV3ICh1dGlsaXRpZXMuY2FuVXNlV2Vha01hcCA/IFdlYWtNYXAgOiBNYXApKCk7XG4gICAgICAgIHRoaXMucXVlcnlJZENvdW50ZXIgPSAxO1xuICAgICAgICB0aGlzLnJlcXVlc3RJZENvdW50ZXIgPSAxO1xuICAgICAgICB0aGlzLm11dGF0aW9uSWRDb3VudGVyID0gMTtcbiAgICAgICAgdGhpcy5pbkZsaWdodExpbmtPYnNlcnZhYmxlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jYWNoZSA9IGNhY2hlO1xuICAgICAgICB0aGlzLmxpbmsgPSBsaW5rO1xuICAgICAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0gZGVmYXVsdE9wdGlvbnMgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5xdWVyeURlZHVwbGljYXRpb24gPSBxdWVyeURlZHVwbGljYXRpb247XG4gICAgICAgIHRoaXMuY2xpZW50QXdhcmVuZXNzID0gY2xpZW50QXdhcmVuZXNzO1xuICAgICAgICB0aGlzLmxvY2FsU3RhdGUgPSBsb2NhbFN0YXRlIHx8IG5ldyBMb2NhbFN0YXRlKHsgY2FjaGU6IGNhY2hlIH0pO1xuICAgICAgICB0aGlzLnNzck1vZGUgPSBzc3JNb2RlO1xuICAgICAgICB0aGlzLmFzc3VtZUltbXV0YWJsZVJlc3VsdHMgPSAhIWFzc3VtZUltbXV0YWJsZVJlc3VsdHM7XG4gICAgICAgIGlmICgodGhpcy5vbkJyb2FkY2FzdCA9IG9uQnJvYWRjYXN0KSkge1xuICAgICAgICAgICAgdGhpcy5tdXRhdGlvblN0b3JlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucXVlcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChfaW5mbywgcXVlcnlJZCkge1xuICAgICAgICAgICAgX3RoaXMuc3RvcFF1ZXJ5Tm9Ccm9hZGNhc3QocXVlcnlJZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbmNlbFBlbmRpbmdGZXRjaGVzKF9fREVWX18gPyBuZXcgZ2xvYmFscy5JbnZhcmlhbnRFcnJvcignUXVlcnlNYW5hZ2VyIHN0b3BwZWQgd2hpbGUgcXVlcnkgd2FzIGluIGZsaWdodCcpIDogbmV3IGdsb2JhbHMuSW52YXJpYW50RXJyb3IoMTMpKTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuY2FuY2VsUGVuZGluZ0ZldGNoZXMgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5mZXRjaENhbmNlbEZucy5mb3JFYWNoKGZ1bmN0aW9uIChjYW5jZWwpIHsgcmV0dXJuIGNhbmNlbChlcnJvcik7IH0pO1xuICAgICAgICB0aGlzLmZldGNoQ2FuY2VsRm5zLmNsZWFyKCk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLm11dGF0ZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2IsIF9jO1xuICAgICAgICB2YXIgbXV0YXRpb24gPSBfYS5tdXRhdGlvbiwgdmFyaWFibGVzID0gX2EudmFyaWFibGVzLCBvcHRpbWlzdGljUmVzcG9uc2UgPSBfYS5vcHRpbWlzdGljUmVzcG9uc2UsIHVwZGF0ZVF1ZXJpZXMgPSBfYS51cGRhdGVRdWVyaWVzLCBfZCA9IF9hLnJlZmV0Y2hRdWVyaWVzLCByZWZldGNoUXVlcmllcyA9IF9kID09PSB2b2lkIDAgPyBbXSA6IF9kLCBfZSA9IF9hLmF3YWl0UmVmZXRjaFF1ZXJpZXMsIGF3YWl0UmVmZXRjaFF1ZXJpZXMgPSBfZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZSwgdXBkYXRlV2l0aFByb3h5Rm4gPSBfYS51cGRhdGUsIG9uUXVlcnlVcGRhdGVkID0gX2Eub25RdWVyeVVwZGF0ZWQsIF9mID0gX2EuZmV0Y2hQb2xpY3ksIGZldGNoUG9saWN5ID0gX2YgPT09IHZvaWQgMCA/ICgoX2IgPSB0aGlzLmRlZmF1bHRPcHRpb25zLm11dGF0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZldGNoUG9saWN5KSB8fCBcIm5ldHdvcmstb25seVwiIDogX2YsIF9nID0gX2EuZXJyb3JQb2xpY3ksIGVycm9yUG9saWN5ID0gX2cgPT09IHZvaWQgMCA/ICgoX2MgPSB0aGlzLmRlZmF1bHRPcHRpb25zLm11dGF0ZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmVycm9yUG9saWN5KSB8fCBcIm5vbmVcIiA6IF9nLCBrZWVwUm9vdEZpZWxkcyA9IF9hLmtlZXBSb290RmllbGRzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgcmV0dXJuIHRzbGliLl9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG11dGF0aW9uSWQsIF9oLCBkb2N1bWVudCwgaGFzQ2xpZW50RXhwb3J0cywgbXV0YXRpb25TdG9yZVZhbHVlLCBzZWxmO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfaikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2oubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX19ERVZfXyA/IGdsb2JhbHMuaW52YXJpYW50KG11dGF0aW9uLCAnbXV0YXRpb24gb3B0aW9uIGlzIHJlcXVpcmVkLiBZb3UgbXVzdCBzcGVjaWZ5IHlvdXIgR3JhcGhRTCBkb2N1bWVudCBpbiB0aGUgbXV0YXRpb24gb3B0aW9uLicpIDogZ2xvYmFscy5pbnZhcmlhbnQobXV0YXRpb24sIDE0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fREVWX18gPyBnbG9iYWxzLmludmFyaWFudChmZXRjaFBvbGljeSA9PT0gJ25ldHdvcmstb25seScgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaFBvbGljeSA9PT0gJ25vLWNhY2hlJywgXCJNdXRhdGlvbnMgc3VwcG9ydCBvbmx5ICduZXR3b3JrLW9ubHknIG9yICduby1jYWNoZScgZmV0Y2hQb2xpY3kgc3RyaW5ncy4gVGhlIGRlZmF1bHQgYG5ldHdvcmstb25seWAgYmVoYXZpb3IgYXV0b21hdGljYWxseSB3cml0ZXMgbXV0YXRpb24gcmVzdWx0cyB0byB0aGUgY2FjaGUuIFBhc3NpbmcgYG5vLWNhY2hlYCBza2lwcyB0aGUgY2FjaGUgd3JpdGUuXCIpIDogZ2xvYmFscy5pbnZhcmlhbnQoZmV0Y2hQb2xpY3kgPT09ICduZXR3b3JrLW9ubHknIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hQb2xpY3kgPT09ICduby1jYWNoZScsIDE1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uSWQgPSB0aGlzLmdlbmVyYXRlTXV0YXRpb25JZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2ggPSB0aGlzLnRyYW5zZm9ybShtdXRhdGlvbiksIGRvY3VtZW50ID0gX2guZG9jdW1lbnQsIGhhc0NsaWVudEV4cG9ydHMgPSBfaC5oYXNDbGllbnRFeHBvcnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24gPSB0aGlzLmNhY2hlLnRyYW5zZm9ybUZvckxpbmsoZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzID0gdGhpcy5nZXRWYXJpYWJsZXMobXV0YXRpb24sIHZhcmlhYmxlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc0NsaWVudEV4cG9ydHMpIHJldHVybiBbMywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHRoaXMubG9jYWxTdGF0ZS5hZGRFeHBvcnRlZFZhcmlhYmxlcyhtdXRhdGlvbiwgdmFyaWFibGVzLCBjb250ZXh0KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlcyA9IChfai5zZW50KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2oubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvblN0b3JlVmFsdWUgPSB0aGlzLm11dGF0aW9uU3RvcmUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5tdXRhdGlvblN0b3JlW211dGF0aW9uSWRdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbjogbXV0YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpbWlzdGljUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcmtNdXRhdGlvbk9wdGltaXN0aWMob3B0aW1pc3RpY1Jlc3BvbnNlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uSWQ6IG11dGF0aW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50OiBtdXRhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoUG9saWN5OiBmZXRjaFBvbGljeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JQb2xpY3k6IGVycm9yUG9saWN5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVRdWVyaWVzOiB1cGRhdGVRdWVyaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IHVwZGF0ZVdpdGhQcm94eUZuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZWVwUm9vdEZpZWxkczoga2VlcFJvb3RGaWVsZHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJyb2FkY2FzdFF1ZXJpZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1dGlsaXRpZXMuYXN5bmNNYXAoc2VsZi5nZXRPYnNlcnZhYmxlRnJvbUxpbmsobXV0YXRpb24sIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBjb250ZXh0KSwgeyBvcHRpbWlzdGljUmVzcG9uc2U6IG9wdGltaXN0aWNSZXNwb25zZSB9KSwgdmFyaWFibGVzLCBmYWxzZSksIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1dGlsaXRpZXMuZ3JhcGhRTFJlc3VsdEhhc0Vycm9yKHJlc3VsdCkgJiYgZXJyb3JQb2xpY3kgPT09ICdub25lJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuQXBvbGxvRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaFFMRXJyb3JzOiByZXN1bHQuZXJyb3JzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uU3RvcmVWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uU3RvcmVWYWx1ZS5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25TdG9yZVZhbHVlLmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZVJlc3VsdCA9IHRzbGliLl9fYXNzaWduKHt9LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZWZldGNoUXVlcmllcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXRjaFF1ZXJpZXMgPSByZWZldGNoUXVlcmllcyhzdG9yZVJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JQb2xpY3kgPT09ICdpZ25vcmUnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbGl0aWVzLmdyYXBoUUxSZXN1bHRIYXNFcnJvcihzdG9yZVJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3RvcmVSZXN1bHQuZXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYubWFya011dGF0aW9uUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbklkOiBtdXRhdGlvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogc3RvcmVSZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ6IG11dGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoUG9saWN5OiBmZXRjaFBvbGljeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvclBvbGljeTogZXJyb3JQb2xpY3ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGU6IHVwZGF0ZVdpdGhQcm94eUZuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVF1ZXJpZXM6IHVwZGF0ZVF1ZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXRSZWZldGNoUXVlcmllczogYXdhaXRSZWZldGNoUXVlcmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZldGNoUXVlcmllczogcmVmZXRjaFF1ZXJpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlT3B0aW1pc3RpYzogb3B0aW1pc3RpY1Jlc3BvbnNlID8gbXV0YXRpb25JZCA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblF1ZXJ5VXBkYXRlZDogb25RdWVyeVVwZGF0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2VlcFJvb3RGaWVsZHM6IGtlZXBSb290RmllbGRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLnN1YnNjcmliZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoc3RvcmVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJyb2FkY2FzdFF1ZXJpZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHN0b3JlUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtdXRhdGlvblN0b3JlVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25TdG9yZVZhbHVlLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25TdG9yZVZhbHVlLmVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW1pc3RpY1Jlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2FjaGUucmVtb3ZlT3B0aW1pc3RpYyhtdXRhdGlvbklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5icm9hZGNhc3RRdWVyaWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVyciBpbnN0YW5jZW9mIGVycm9ycy5BcG9sbG9FcnJvciA/IGVyciA6IG5ldyBlcnJvcnMuQXBvbGxvRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrRXJyb3I6IGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5tYXJrTXV0YXRpb25SZXN1bHQgPSBmdW5jdGlvbiAobXV0YXRpb24sIGNhY2hlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChjYWNoZSA9PT0gdm9pZCAwKSB7IGNhY2hlID0gdGhpcy5jYWNoZTsgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gbXV0YXRpb24ucmVzdWx0O1xuICAgICAgICB2YXIgY2FjaGVXcml0ZXMgPSBbXTtcbiAgICAgICAgdmFyIHNraXBDYWNoZSA9IG11dGF0aW9uLmZldGNoUG9saWN5ID09PSBcIm5vLWNhY2hlXCI7XG4gICAgICAgIGlmICghc2tpcENhY2hlICYmIHNob3VsZFdyaXRlUmVzdWx0KHJlc3VsdCwgbXV0YXRpb24uZXJyb3JQb2xpY3kpKSB7XG4gICAgICAgICAgICBjYWNoZVdyaXRlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdC5kYXRhLFxuICAgICAgICAgICAgICAgIGRhdGFJZDogJ1JPT1RfTVVUQVRJT04nLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBtdXRhdGlvbi5kb2N1bWVudCxcbiAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IG11dGF0aW9uLnZhcmlhYmxlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHVwZGF0ZVF1ZXJpZXNfMSA9IG11dGF0aW9uLnVwZGF0ZVF1ZXJpZXM7XG4gICAgICAgICAgICBpZiAodXBkYXRlUXVlcmllc18xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKF9hLCBxdWVyeUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvYnNlcnZhYmxlUXVlcnkgPSBfYS5vYnNlcnZhYmxlUXVlcnk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBxdWVyeU5hbWUgPSBvYnNlcnZhYmxlUXVlcnkgJiYgb2JzZXJ2YWJsZVF1ZXJ5LnF1ZXJ5TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFxdWVyeU5hbWUgfHwgIWhhc093blByb3BlcnR5LmNhbGwodXBkYXRlUXVlcmllc18xLCBxdWVyeU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZXIgPSB1cGRhdGVRdWVyaWVzXzFbcXVlcnlOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9iID0gX3RoaXMucXVlcmllcy5nZXQocXVlcnlJZCksIGRvY3VtZW50ID0gX2IuZG9jdW1lbnQsIHZhcmlhYmxlcyA9IF9iLnZhcmlhYmxlcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9jID0gY2FjaGUuZGlmZih7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogZG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblBhcnRpYWxEYXRhOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW1pc3RpYzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pLCBjdXJyZW50UXVlcnlSZXN1bHQgPSBfYy5yZXN1bHQsIGNvbXBsZXRlID0gX2MuY29tcGxldGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZSAmJiBjdXJyZW50UXVlcnlSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0UXVlcnlSZXN1bHQgPSB1cGRhdGVyKGN1cnJlbnRRdWVyeVJlc3VsdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uUmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlOYW1lOiBkb2N1bWVudCAmJiB1dGlsaXRpZXMuZ2V0T3BlcmF0aW9uTmFtZShkb2N1bWVudCkgfHwgdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5VmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0UXVlcnlSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZVdyaXRlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBuZXh0UXVlcnlSZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFJZDogJ1JPT1RfUVVFUlknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogZG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhY2hlV3JpdGVzLmxlbmd0aCA+IDAgfHxcbiAgICAgICAgICAgIG11dGF0aW9uLnJlZmV0Y2hRdWVyaWVzIHx8XG4gICAgICAgICAgICBtdXRhdGlvbi51cGRhdGUgfHxcbiAgICAgICAgICAgIG11dGF0aW9uLm9uUXVlcnlVcGRhdGVkIHx8XG4gICAgICAgICAgICBtdXRhdGlvbi5yZW1vdmVPcHRpbWlzdGljKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0c18xID0gW107XG4gICAgICAgICAgICB0aGlzLnJlZmV0Y2hRdWVyaWVzKHtcbiAgICAgICAgICAgICAgICB1cGRhdGVDYWNoZTogZnVuY3Rpb24gKGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2tpcENhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZVdyaXRlcy5mb3JFYWNoKGZ1bmN0aW9uICh3cml0ZSkgeyByZXR1cm4gY2FjaGUud3JpdGUod3JpdGUpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlID0gbXV0YXRpb24udXBkYXRlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNraXBDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaWZmID0gY2FjaGUuZGlmZih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBcIlJPT1RfTVVUQVRJT05cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IF90aGlzLnRyYW5zZm9ybShtdXRhdGlvbi5kb2N1bWVudCkuYXNRdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiBtdXRhdGlvbi52YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGltaXN0aWM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5QYXJ0aWFsRGF0YTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZi5jb21wbGV0ZSAmJiAhKGlzRXhlY3V0aW9uUGF0Y2hJbmNyZW1lbnRhbFJlc3VsdChyZXN1bHQpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgcmVzdWx0KSwgeyBkYXRhOiBkaWZmLnJlc3VsdCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUoY2FjaGUsIHJlc3VsdCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IG11dGF0aW9uLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiBtdXRhdGlvbi52YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNraXBDYWNoZSAmJiAhbXV0YXRpb24ua2VlcFJvb3RGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLm1vZGlmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdST09UX01VVEFUSU9OJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHM6IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IF9hLmZpZWxkTmFtZSwgREVMRVRFID0gX2EuREVMRVRFO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmllbGROYW1lID09PSBcIl9fdHlwZW5hbWVcIiA/IHZhbHVlIDogREVMRVRFO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5jbHVkZTogbXV0YXRpb24ucmVmZXRjaFF1ZXJpZXMsXG4gICAgICAgICAgICAgICAgb3B0aW1pc3RpYzogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmVtb3ZlT3B0aW1pc3RpYzogbXV0YXRpb24ucmVtb3ZlT3B0aW1pc3RpYyxcbiAgICAgICAgICAgICAgICBvblF1ZXJ5VXBkYXRlZDogbXV0YXRpb24ub25RdWVyeVVwZGF0ZWQgfHwgbnVsbCxcbiAgICAgICAgICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0c18xLnB1c2gocmVzdWx0KTsgfSk7XG4gICAgICAgICAgICBpZiAobXV0YXRpb24uYXdhaXRSZWZldGNoUXVlcmllcyB8fCBtdXRhdGlvbi5vblF1ZXJ5VXBkYXRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChyZXN1bHRzXzEpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzdWx0OyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLm1hcmtNdXRhdGlvbk9wdGltaXN0aWMgPSBmdW5jdGlvbiAob3B0aW1pc3RpY1Jlc3BvbnNlLCBtdXRhdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZGF0YSA9IHR5cGVvZiBvcHRpbWlzdGljUmVzcG9uc2UgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyBvcHRpbWlzdGljUmVzcG9uc2UobXV0YXRpb24udmFyaWFibGVzKVxuICAgICAgICAgICAgOiBvcHRpbWlzdGljUmVzcG9uc2U7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlLnJlY29yZE9wdGltaXN0aWNUcmFuc2FjdGlvbihmdW5jdGlvbiAoY2FjaGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubWFya011dGF0aW9uUmVzdWx0KHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBtdXRhdGlvbiksIHsgcmVzdWx0OiB7IGRhdGE6IGRhdGEgfSB9KSwgY2FjaGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgX19ERVZfXyAmJiBnbG9iYWxzLmludmFyaWFudC5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIG11dGF0aW9uLm11dGF0aW9uSWQpO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5mZXRjaFF1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5SWQsIG9wdGlvbnMsIG5ldHdvcmtTdGF0dXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hRdWVyeU9ic2VydmFibGUocXVlcnlJZCwgb3B0aW9ucywgbmV0d29ya1N0YXR1cykucHJvbWlzZTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuZ2V0UXVlcnlTdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0b3JlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5xdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKGluZm8sIHF1ZXJ5SWQpIHtcbiAgICAgICAgICAgIHN0b3JlW3F1ZXJ5SWRdID0ge1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlczogaW5mby52YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgbmV0d29ya1N0YXR1czogaW5mby5uZXR3b3JrU3RhdHVzLFxuICAgICAgICAgICAgICAgIG5ldHdvcmtFcnJvcjogaW5mby5uZXR3b3JrRXJyb3IsXG4gICAgICAgICAgICAgICAgZ3JhcGhRTEVycm9yczogaW5mby5ncmFwaFFMRXJyb3JzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdG9yZTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUucmVzZXRFcnJvcnMgPSBmdW5jdGlvbiAocXVlcnlJZCkge1xuICAgICAgICB2YXIgcXVlcnlJbmZvID0gdGhpcy5xdWVyaWVzLmdldChxdWVyeUlkKTtcbiAgICAgICAgaWYgKHF1ZXJ5SW5mbykge1xuICAgICAgICAgICAgcXVlcnlJbmZvLm5ldHdvcmtFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHF1ZXJ5SW5mby5ncmFwaFFMRXJyb3JzID0gW107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKGRvY3VtZW50KSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1DYWNoZSA9IHRoaXMudHJhbnNmb3JtQ2FjaGU7XG4gICAgICAgIGlmICghdHJhbnNmb3JtQ2FjaGUuaGFzKGRvY3VtZW50KSkge1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkID0gdGhpcy5jYWNoZS50cmFuc2Zvcm1Eb2N1bWVudChkb2N1bWVudCk7XG4gICAgICAgICAgICB2YXIgbm9Db25uZWN0aW9uID0gdXRpbGl0aWVzLnJlbW92ZUNvbm5lY3Rpb25EaXJlY3RpdmVGcm9tRG9jdW1lbnQodHJhbnNmb3JtZWQpO1xuICAgICAgICAgICAgdmFyIGNsaWVudFF1ZXJ5ID0gdGhpcy5sb2NhbFN0YXRlLmNsaWVudFF1ZXJ5KHRyYW5zZm9ybWVkKTtcbiAgICAgICAgICAgIHZhciBzZXJ2ZXJRdWVyeSA9IG5vQ29ubmVjdGlvbiAmJiB0aGlzLmxvY2FsU3RhdGUuc2VydmVyUXVlcnkobm9Db25uZWN0aW9uKTtcbiAgICAgICAgICAgIHZhciBjYWNoZUVudHJ5XzEgPSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQ6IHRyYW5zZm9ybWVkLFxuICAgICAgICAgICAgICAgIGhhc0NsaWVudEV4cG9ydHM6IHV0aWxpdGllcy5oYXNDbGllbnRFeHBvcnRzKHRyYW5zZm9ybWVkKSxcbiAgICAgICAgICAgICAgICBoYXNGb3JjZWRSZXNvbHZlcnM6IHRoaXMubG9jYWxTdGF0ZS5zaG91bGRGb3JjZVJlc29sdmVycyh0cmFuc2Zvcm1lZCksXG4gICAgICAgICAgICAgICAgY2xpZW50UXVlcnk6IGNsaWVudFF1ZXJ5LFxuICAgICAgICAgICAgICAgIHNlcnZlclF1ZXJ5OiBzZXJ2ZXJRdWVyeSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFyczogdXRpbGl0aWVzLmdldERlZmF1bHRWYWx1ZXModXRpbGl0aWVzLmdldE9wZXJhdGlvbkRlZmluaXRpb24odHJhbnNmb3JtZWQpKSxcbiAgICAgICAgICAgICAgICBhc1F1ZXJ5OiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgdHJhbnNmb3JtZWQpLCB7IGRlZmluaXRpb25zOiB0cmFuc2Zvcm1lZC5kZWZpbml0aW9ucy5tYXAoZnVuY3Rpb24gKGRlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi5raW5kID09PSBcIk9wZXJhdGlvbkRlZmluaXRpb25cIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZi5vcGVyYXRpb24gIT09IFwicXVlcnlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgZGVmKSwgeyBvcGVyYXRpb246IFwicXVlcnlcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWY7XG4gICAgICAgICAgICAgICAgICAgIH0pIH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGFkZCA9IGZ1bmN0aW9uIChkb2MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9jICYmICF0cmFuc2Zvcm1DYWNoZS5oYXMoZG9jKSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1DYWNoZS5zZXQoZG9jLCBjYWNoZUVudHJ5XzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhZGQoZG9jdW1lbnQpO1xuICAgICAgICAgICAgYWRkKHRyYW5zZm9ybWVkKTtcbiAgICAgICAgICAgIGFkZChjbGllbnRRdWVyeSk7XG4gICAgICAgICAgICBhZGQoc2VydmVyUXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1DYWNoZS5nZXQoZG9jdW1lbnQpO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5nZXRWYXJpYWJsZXMgPSBmdW5jdGlvbiAoZG9jdW1lbnQsIHZhcmlhYmxlcykge1xuICAgICAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIHRoaXMudHJhbnNmb3JtKGRvY3VtZW50KS5kZWZhdWx0VmFycyksIHZhcmlhYmxlcyk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLndhdGNoUXVlcnkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHZhcmlhYmxlczogdGhpcy5nZXRWYXJpYWJsZXMob3B0aW9ucy5xdWVyeSwgb3B0aW9ucy52YXJpYWJsZXMpIH0pO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubm90aWZ5T25OZXR3b3JrU3RhdHVzQ2hhbmdlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgb3B0aW9ucy5ub3RpZnlPbk5ldHdvcmtTdGF0dXNDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcXVlcnlJbmZvID0gbmV3IFF1ZXJ5SW5mbyh0aGlzKTtcbiAgICAgICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZVF1ZXJ5KHtcbiAgICAgICAgICAgIHF1ZXJ5TWFuYWdlcjogdGhpcyxcbiAgICAgICAgICAgIHF1ZXJ5SW5mbzogcXVlcnlJbmZvLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucXVlcmllcy5zZXQob2JzZXJ2YWJsZS5xdWVyeUlkLCBxdWVyeUluZm8pO1xuICAgICAgICBxdWVyeUluZm8uaW5pdCh7XG4gICAgICAgICAgICBkb2N1bWVudDogb2JzZXJ2YWJsZS5xdWVyeSxcbiAgICAgICAgICAgIG9ic2VydmFibGVRdWVyeTogb2JzZXJ2YWJsZSxcbiAgICAgICAgICAgIHZhcmlhYmxlczogb2JzZXJ2YWJsZS52YXJpYWJsZXMsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiAob3B0aW9ucywgcXVlcnlJZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAocXVlcnlJZCA9PT0gdm9pZCAwKSB7IHF1ZXJ5SWQgPSB0aGlzLmdlbmVyYXRlUXVlcnlJZCgpOyB9XG4gICAgICAgIF9fREVWX18gPyBnbG9iYWxzLmludmFyaWFudChvcHRpb25zLnF1ZXJ5LCAncXVlcnkgb3B0aW9uIGlzIHJlcXVpcmVkLiBZb3UgbXVzdCBzcGVjaWZ5IHlvdXIgR3JhcGhRTCBkb2N1bWVudCAnICtcbiAgICAgICAgICAgICdpbiB0aGUgcXVlcnkgb3B0aW9uLicpIDogZ2xvYmFscy5pbnZhcmlhbnQob3B0aW9ucy5xdWVyeSwgMTYpO1xuICAgICAgICBfX0RFVl9fID8gZ2xvYmFscy5pbnZhcmlhbnQob3B0aW9ucy5xdWVyeS5raW5kID09PSAnRG9jdW1lbnQnLCAnWW91IG11c3Qgd3JhcCB0aGUgcXVlcnkgc3RyaW5nIGluIGEgXCJncWxcIiB0YWcuJykgOiBnbG9iYWxzLmludmFyaWFudChvcHRpb25zLnF1ZXJ5LmtpbmQgPT09ICdEb2N1bWVudCcsIDE3KTtcbiAgICAgICAgX19ERVZfXyA/IGdsb2JhbHMuaW52YXJpYW50KCFvcHRpb25zLnJldHVyblBhcnRpYWxEYXRhLCAncmV0dXJuUGFydGlhbERhdGEgb3B0aW9uIG9ubHkgc3VwcG9ydGVkIG9uIHdhdGNoUXVlcnkuJykgOiBnbG9iYWxzLmludmFyaWFudCghb3B0aW9ucy5yZXR1cm5QYXJ0aWFsRGF0YSwgMTgpO1xuICAgICAgICBfX0RFVl9fID8gZ2xvYmFscy5pbnZhcmlhbnQoIW9wdGlvbnMucG9sbEludGVydmFsLCAncG9sbEludGVydmFsIG9wdGlvbiBvbmx5IHN1cHBvcnRlZCBvbiB3YXRjaFF1ZXJ5LicpIDogZ2xvYmFscy5pbnZhcmlhbnQoIW9wdGlvbnMucG9sbEludGVydmFsLCAxOSk7XG4gICAgICAgIHJldHVybiB0aGlzLmZldGNoUXVlcnkocXVlcnlJZCwgb3B0aW9ucykuZmluYWxseShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zdG9wUXVlcnkocXVlcnlJZCk7IH0pO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5nZW5lcmF0ZVF1ZXJ5SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcodGhpcy5xdWVyeUlkQ291bnRlcisrKTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuZ2VuZXJhdGVSZXF1ZXN0SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RJZENvdW50ZXIrKztcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuZ2VuZXJhdGVNdXRhdGlvbklkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHRoaXMubXV0YXRpb25JZENvdW50ZXIrKyk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnN0b3BRdWVyeUluU3RvcmUgPSBmdW5jdGlvbiAocXVlcnlJZCkge1xuICAgICAgICB0aGlzLnN0b3BRdWVyeUluU3RvcmVOb0Jyb2FkY2FzdChxdWVyeUlkKTtcbiAgICAgICAgdGhpcy5icm9hZGNhc3RRdWVyaWVzKCk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnN0b3BRdWVyeUluU3RvcmVOb0Jyb2FkY2FzdCA9IGZ1bmN0aW9uIChxdWVyeUlkKSB7XG4gICAgICAgIHZhciBxdWVyeUluZm8gPSB0aGlzLnF1ZXJpZXMuZ2V0KHF1ZXJ5SWQpO1xuICAgICAgICBpZiAocXVlcnlJbmZvKVxuICAgICAgICAgICAgcXVlcnlJbmZvLnN0b3AoKTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuY2xlYXJTdG9yZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGRpc2NhcmRXYXRjaGVzOiB0cnVlLFxuICAgICAgICB9OyB9XG4gICAgICAgIHRoaXMuY2FuY2VsUGVuZGluZ0ZldGNoZXMoX19ERVZfXyA/IG5ldyBnbG9iYWxzLkludmFyaWFudEVycm9yKCdTdG9yZSByZXNldCB3aGlsZSBxdWVyeSB3YXMgaW4gZmxpZ2h0IChub3QgY29tcGxldGVkIGluIGxpbmsgY2hhaW4pJykgOiBuZXcgZ2xvYmFscy5JbnZhcmlhbnRFcnJvcigyMCkpO1xuICAgICAgICB0aGlzLnF1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAocXVlcnlJbmZvKSB7XG4gICAgICAgICAgICBpZiAocXVlcnlJbmZvLm9ic2VydmFibGVRdWVyeSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5SW5mby5uZXR3b3JrU3RhdHVzID0gZXhwb3J0cy5OZXR3b3JrU3RhdHVzLmxvYWRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWVyeUluZm8uc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMubXV0YXRpb25TdG9yZSkge1xuICAgICAgICAgICAgdGhpcy5tdXRhdGlvblN0b3JlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5yZXNldChvcHRpb25zKTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuZ2V0T2JzZXJ2YWJsZVF1ZXJpZXMgPSBmdW5jdGlvbiAoaW5jbHVkZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoaW5jbHVkZSA9PT0gdm9pZCAwKSB7IGluY2x1ZGUgPSBcImFjdGl2ZVwiOyB9XG4gICAgICAgIHZhciBxdWVyaWVzID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgcXVlcnlOYW1lc0FuZERvY3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBsZWdhY3lRdWVyeU9wdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGluY2x1ZGUpKSB7XG4gICAgICAgICAgICBpbmNsdWRlLmZvckVhY2goZnVuY3Rpb24gKGRlc2MpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlc2MgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlOYW1lc0FuZERvY3Muc2V0KGRlc2MsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodXRpbGl0aWVzLmlzRG9jdW1lbnROb2RlKGRlc2MpKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5TmFtZXNBbmREb2NzLnNldChfdGhpcy50cmFuc2Zvcm0oZGVzYykuZG9jdW1lbnQsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodXRpbGl0aWVzLmlzTm9uTnVsbE9iamVjdChkZXNjKSAmJiBkZXNjLnF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZ2FjeVF1ZXJ5T3B0aW9ucy5hZGQoZGVzYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5xdWVyaWVzLmZvckVhY2goZnVuY3Rpb24gKF9hLCBxdWVyeUlkKSB7XG4gICAgICAgICAgICB2YXIgb3EgPSBfYS5vYnNlcnZhYmxlUXVlcnksIGRvY3VtZW50ID0gX2EuZG9jdW1lbnQ7XG4gICAgICAgICAgICBpZiAob3EpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZSA9PT0gXCJhbGxcIikge1xuICAgICAgICAgICAgICAgICAgICBxdWVyaWVzLnNldChxdWVyeUlkLCBvcSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHF1ZXJ5TmFtZSA9IG9xLnF1ZXJ5TmFtZSwgZmV0Y2hQb2xpY3kgPSBvcS5vcHRpb25zLmZldGNoUG9saWN5O1xuICAgICAgICAgICAgICAgIGlmIChmZXRjaFBvbGljeSA9PT0gXCJzdGFuZGJ5XCIgfHxcbiAgICAgICAgICAgICAgICAgICAgKGluY2x1ZGUgPT09IFwiYWN0aXZlXCIgJiYgIW9xLmhhc09ic2VydmVycygpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlID09PSBcImFjdGl2ZVwiIHx8XG4gICAgICAgICAgICAgICAgICAgIChxdWVyeU5hbWUgJiYgcXVlcnlOYW1lc0FuZERvY3MuaGFzKHF1ZXJ5TmFtZSkpIHx8XG4gICAgICAgICAgICAgICAgICAgIChkb2N1bWVudCAmJiBxdWVyeU5hbWVzQW5kRG9jcy5oYXMoZG9jdW1lbnQpKSkge1xuICAgICAgICAgICAgICAgICAgICBxdWVyaWVzLnNldChxdWVyeUlkLCBvcSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWVyeU5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeU5hbWVzQW5kRG9jcy5zZXQocXVlcnlOYW1lLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlOYW1lc0FuZERvY3Muc2V0KGRvY3VtZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobGVnYWN5UXVlcnlPcHRpb25zLnNpemUpIHtcbiAgICAgICAgICAgIGxlZ2FjeVF1ZXJ5T3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIHF1ZXJ5SWQgPSB1dGlsaXRpZXMubWFrZVVuaXF1ZUlkKFwibGVnYWN5T25lVGltZVF1ZXJ5XCIpO1xuICAgICAgICAgICAgICAgIHZhciBxdWVyeUluZm8gPSBfdGhpcy5nZXRRdWVyeShxdWVyeUlkKS5pbml0KHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ6IG9wdGlvbnMucXVlcnksXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogb3B0aW9ucy52YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIG9xID0gbmV3IE9ic2VydmFibGVRdWVyeSh7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5TWFuYWdlcjogX3RoaXMsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5SW5mbzogcXVlcnlJbmZvLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgZmV0Y2hQb2xpY3k6IFwibmV0d29yay1vbmx5XCIgfSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZ2xvYmFscy5pbnZhcmlhbnQob3EucXVlcnlJZCA9PT0gcXVlcnlJZCk7XG4gICAgICAgICAgICAgICAgcXVlcnlJbmZvLnNldE9ic2VydmFibGVRdWVyeShvcSk7XG4gICAgICAgICAgICAgICAgcXVlcmllcy5zZXQocXVlcnlJZCwgb3EpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9fREVWX18gJiYgcXVlcnlOYW1lc0FuZERvY3Muc2l6ZSkge1xuICAgICAgICAgICAgcXVlcnlOYW1lc0FuZERvY3MuZm9yRWFjaChmdW5jdGlvbiAoaW5jbHVkZWQsIG5hbWVPckRvYykge1xuICAgICAgICAgICAgICAgIGlmICghaW5jbHVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX19ERVZfXyAmJiBnbG9iYWxzLmludmFyaWFudC53YXJuKFwiVW5rbm93biBxdWVyeSBcIi5jb25jYXQodHlwZW9mIG5hbWVPckRvYyA9PT0gXCJzdHJpbmdcIiA/IFwibmFtZWQgXCIgOiBcIlwiKS5jb25jYXQoSlNPTi5zdHJpbmdpZnkobmFtZU9yRG9jLCBudWxsLCAyKSwgXCIgcmVxdWVzdGVkIGluIHJlZmV0Y2hRdWVyaWVzIG9wdGlvbnMuaW5jbHVkZSBhcnJheVwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHF1ZXJpZXM7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnJlRmV0Y2hPYnNlcnZhYmxlUXVlcmllcyA9IGZ1bmN0aW9uIChpbmNsdWRlU3RhbmRieSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoaW5jbHVkZVN0YW5kYnkgPT09IHZvaWQgMCkgeyBpbmNsdWRlU3RhbmRieSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBvYnNlcnZhYmxlUXVlcnlQcm9taXNlcyA9IFtdO1xuICAgICAgICB0aGlzLmdldE9ic2VydmFibGVRdWVyaWVzKGluY2x1ZGVTdGFuZGJ5ID8gXCJhbGxcIiA6IFwiYWN0aXZlXCIpLmZvckVhY2goZnVuY3Rpb24gKG9ic2VydmFibGVRdWVyeSwgcXVlcnlJZCkge1xuICAgICAgICAgICAgdmFyIGZldGNoUG9saWN5ID0gb2JzZXJ2YWJsZVF1ZXJ5Lm9wdGlvbnMuZmV0Y2hQb2xpY3k7XG4gICAgICAgICAgICBvYnNlcnZhYmxlUXVlcnkucmVzZXRMYXN0UmVzdWx0cygpO1xuICAgICAgICAgICAgaWYgKGluY2x1ZGVTdGFuZGJ5IHx8XG4gICAgICAgICAgICAgICAgKGZldGNoUG9saWN5ICE9PSBcInN0YW5kYnlcIiAmJlxuICAgICAgICAgICAgICAgICAgICBmZXRjaFBvbGljeSAhPT0gXCJjYWNoZS1vbmx5XCIpKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2YWJsZVF1ZXJ5UHJvbWlzZXMucHVzaChvYnNlcnZhYmxlUXVlcnkucmVmZXRjaCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmdldFF1ZXJ5KHF1ZXJ5SWQpLnNldERpZmYobnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJyb2FkY2FzdFF1ZXJpZXMoKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG9ic2VydmFibGVRdWVyeVByb21pc2VzKTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuc2V0T2JzZXJ2YWJsZVF1ZXJ5ID0gZnVuY3Rpb24gKG9ic2VydmFibGVRdWVyeSkge1xuICAgICAgICB0aGlzLmdldFF1ZXJ5KG9ic2VydmFibGVRdWVyeS5xdWVyeUlkKS5zZXRPYnNlcnZhYmxlUXVlcnkob2JzZXJ2YWJsZVF1ZXJ5KTtcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuc3RhcnRHcmFwaFFMU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBxdWVyeSA9IF9hLnF1ZXJ5LCBmZXRjaFBvbGljeSA9IF9hLmZldGNoUG9saWN5LCBlcnJvclBvbGljeSA9IF9hLmVycm9yUG9saWN5LCB2YXJpYWJsZXMgPSBfYS52YXJpYWJsZXMsIF9iID0gX2EuY29udGV4dCwgY29udGV4dCA9IF9iID09PSB2b2lkIDAgPyB7fSA6IF9iO1xuICAgICAgICBxdWVyeSA9IHRoaXMudHJhbnNmb3JtKHF1ZXJ5KS5kb2N1bWVudDtcbiAgICAgICAgdmFyaWFibGVzID0gdGhpcy5nZXRWYXJpYWJsZXMocXVlcnksIHZhcmlhYmxlcyk7XG4gICAgICAgIHZhciBtYWtlT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uICh2YXJpYWJsZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRPYnNlcnZhYmxlRnJvbUxpbmsocXVlcnksIGNvbnRleHQsIHZhcmlhYmxlcykubWFwKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmV0Y2hQb2xpY3kgIT09ICduby1jYWNoZScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFdyaXRlUmVzdWx0KHJlc3VsdCwgZXJyb3JQb2xpY3kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jYWNoZS53cml0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUlkOiAnUk9PVF9TVUJTQ1JJUFRJT04nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYnJvYWRjYXN0UXVlcmllcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodXRpbGl0aWVzLmdyYXBoUUxSZXN1bHRIYXNFcnJvcihyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnMuQXBvbGxvRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGhRTEVycm9yczogcmVzdWx0LmVycm9ycyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtKHF1ZXJ5KS5oYXNDbGllbnRFeHBvcnRzKSB7XG4gICAgICAgICAgICB2YXIgb2JzZXJ2YWJsZVByb21pc2VfMSA9IHRoaXMubG9jYWxTdGF0ZS5hZGRFeHBvcnRlZFZhcmlhYmxlcyhxdWVyeSwgdmFyaWFibGVzLCBjb250ZXh0KS50aGVuKG1ha2VPYnNlcnZhYmxlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdXRpbGl0aWVzLk9ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YiA9IG51bGw7XG4gICAgICAgICAgICAgICAgb2JzZXJ2YWJsZVByb21pc2VfMS50aGVuKGZ1bmN0aW9uIChvYnNlcnZhYmxlKSB7IHJldHVybiBzdWIgPSBvYnNlcnZhYmxlLnN1YnNjcmliZShvYnNlcnZlcik7IH0sIG9ic2VydmVyLmVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3ViICYmIHN1Yi51bnN1YnNjcmliZSgpOyB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ha2VPYnNlcnZhYmxlKHZhcmlhYmxlcyk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnN0b3BRdWVyeSA9IGZ1bmN0aW9uIChxdWVyeUlkKSB7XG4gICAgICAgIHRoaXMuc3RvcFF1ZXJ5Tm9Ccm9hZGNhc3QocXVlcnlJZCk7XG4gICAgICAgIHRoaXMuYnJvYWRjYXN0UXVlcmllcygpO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5zdG9wUXVlcnlOb0Jyb2FkY2FzdCA9IGZ1bmN0aW9uIChxdWVyeUlkKSB7XG4gICAgICAgIHRoaXMuc3RvcFF1ZXJ5SW5TdG9yZU5vQnJvYWRjYXN0KHF1ZXJ5SWQpO1xuICAgICAgICB0aGlzLnJlbW92ZVF1ZXJ5KHF1ZXJ5SWQpO1xuICAgIH07XG4gICAgUXVlcnlNYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmVRdWVyeSA9IGZ1bmN0aW9uIChxdWVyeUlkKSB7XG4gICAgICAgIHRoaXMuZmV0Y2hDYW5jZWxGbnMuZGVsZXRlKHF1ZXJ5SWQpO1xuICAgICAgICBpZiAodGhpcy5xdWVyaWVzLmhhcyhxdWVyeUlkKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRRdWVyeShxdWVyeUlkKS5zdG9wKCk7XG4gICAgICAgICAgICB0aGlzLnF1ZXJpZXMuZGVsZXRlKHF1ZXJ5SWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLmJyb2FkY2FzdFF1ZXJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm9uQnJvYWRjYXN0KVxuICAgICAgICAgICAgdGhpcy5vbkJyb2FkY2FzdCgpO1xuICAgICAgICB0aGlzLnF1ZXJpZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5mbykgeyByZXR1cm4gaW5mby5ub3RpZnkoKTsgfSk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLmdldExvY2FsU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsU3RhdGU7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLmdldE9ic2VydmFibGVGcm9tTGluayA9IGZ1bmN0aW9uIChxdWVyeSwgY29udGV4dCwgdmFyaWFibGVzLCBkZWR1cGxpY2F0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGRlZHVwbGljYXRpb24gPT09IHZvaWQgMCkgeyBkZWR1cGxpY2F0aW9uID0gKF9hID0gY29udGV4dCA9PT0gbnVsbCB8fCBjb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZXh0LnF1ZXJ5RGVkdXBsaWNhdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5xdWVyeURlZHVwbGljYXRpb247IH1cbiAgICAgICAgdmFyIG9ic2VydmFibGU7XG4gICAgICAgIHZhciBzZXJ2ZXJRdWVyeSA9IHRoaXMudHJhbnNmb3JtKHF1ZXJ5KS5zZXJ2ZXJRdWVyeTtcbiAgICAgICAgaWYgKHNlcnZlclF1ZXJ5KSB7XG4gICAgICAgICAgICB2YXIgX2IgPSB0aGlzLCBpbkZsaWdodExpbmtPYnNlcnZhYmxlc18xID0gX2IuaW5GbGlnaHRMaW5rT2JzZXJ2YWJsZXMsIGxpbmsgPSBfYi5saW5rO1xuICAgICAgICAgICAgdmFyIG9wZXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBxdWVyeTogc2VydmVyUXVlcnksXG4gICAgICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uTmFtZTogdXRpbGl0aWVzLmdldE9wZXJhdGlvbk5hbWUoc2VydmVyUXVlcnkpIHx8IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLnByZXBhcmVDb250ZXh0KHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBjb250ZXh0KSwgeyBmb3JjZUZldGNoOiAhZGVkdXBsaWNhdGlvbiB9KSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29udGV4dCA9IG9wZXJhdGlvbi5jb250ZXh0O1xuICAgICAgICAgICAgaWYgKGRlZHVwbGljYXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgYnlWYXJpYWJsZXNfMSA9IGluRmxpZ2h0TGlua09ic2VydmFibGVzXzEuZ2V0KHNlcnZlclF1ZXJ5KSB8fCBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgaW5GbGlnaHRMaW5rT2JzZXJ2YWJsZXNfMS5zZXQoc2VydmVyUXVlcnksIGJ5VmFyaWFibGVzXzEpO1xuICAgICAgICAgICAgICAgIHZhciB2YXJKc29uXzEgPSBjYWNoZS5jYW5vbmljYWxTdHJpbmdpZnkodmFyaWFibGVzKTtcbiAgICAgICAgICAgICAgICBvYnNlcnZhYmxlID0gYnlWYXJpYWJsZXNfMS5nZXQodmFySnNvbl8xKTtcbiAgICAgICAgICAgICAgICBpZiAoIW9ic2VydmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmNhc3QgPSBuZXcgdXRpbGl0aWVzLkNvbmNhc3QoW1xuICAgICAgICAgICAgICAgICAgICAgICAgY29yZS5leGVjdXRlKGxpbmssIG9wZXJhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIGJ5VmFyaWFibGVzXzEuc2V0KHZhckpzb25fMSwgb2JzZXJ2YWJsZSA9IGNvbmNhc3QpO1xuICAgICAgICAgICAgICAgICAgICBjb25jYXN0LmJlZm9yZU5leHQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ5VmFyaWFibGVzXzEuZGVsZXRlKHZhckpzb25fMSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBieVZhcmlhYmxlc18xLnNpemUgPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5GbGlnaHRMaW5rT2JzZXJ2YWJsZXNfMS5kZWxldGUoc2VydmVyUXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZhYmxlID0gbmV3IHV0aWxpdGllcy5Db25jYXN0KFtcbiAgICAgICAgICAgICAgICAgICAgY29yZS5leGVjdXRlKGxpbmssIG9wZXJhdGlvbilcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9ic2VydmFibGUgPSBuZXcgdXRpbGl0aWVzLkNvbmNhc3QoW1xuICAgICAgICAgICAgICAgIHV0aWxpdGllcy5PYnNlcnZhYmxlLm9mKHsgZGF0YToge30gfSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgY29udGV4dCA9IHRoaXMucHJlcGFyZUNvbnRleHQoY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNsaWVudFF1ZXJ5ID0gdGhpcy50cmFuc2Zvcm0ocXVlcnkpLmNsaWVudFF1ZXJ5O1xuICAgICAgICBpZiAoY2xpZW50UXVlcnkpIHtcbiAgICAgICAgICAgIG9ic2VydmFibGUgPSB1dGlsaXRpZXMuYXN5bmNNYXAob2JzZXJ2YWJsZSwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5sb2NhbFN0YXRlLnJ1blJlc29sdmVycyh7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50OiBjbGllbnRRdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlUmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLmdldFJlc3VsdHNGcm9tTGluayA9IGZ1bmN0aW9uIChxdWVyeUluZm8sIGNhY2hlV3JpdGVCZWhhdmlvciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmVxdWVzdElkID0gcXVlcnlJbmZvLmxhc3RSZXF1ZXN0SWQgPSB0aGlzLmdlbmVyYXRlUmVxdWVzdElkKCk7XG4gICAgICAgIG9wdGlvbnMgPSB1dGlsaXRpZXMuY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgICAgICB2YXIgbGlua0RvY3VtZW50ID0gdGhpcy5jYWNoZS50cmFuc2Zvcm1Gb3JMaW5rKHRoaXMudHJhbnNmb3JtKHF1ZXJ5SW5mby5kb2N1bWVudCkuZG9jdW1lbnQpO1xuICAgICAgICByZXR1cm4gdXRpbGl0aWVzLmFzeW5jTWFwKHRoaXMuZ2V0T2JzZXJ2YWJsZUZyb21MaW5rKGxpbmtEb2N1bWVudCwgb3B0aW9ucy5jb250ZXh0LCBvcHRpb25zLnZhcmlhYmxlcyksIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHZhciBncmFwaFFMRXJyb3JzID0gdXRpbGl0aWVzLmlzTm9uRW1wdHlBcnJheShyZXN1bHQuZXJyb3JzKVxuICAgICAgICAgICAgICAgID8gcmVzdWx0LmVycm9ycy5zbGljZSgwKVxuICAgICAgICAgICAgICAgIDogW107XG4gICAgICAgICAgICBpZiAoJ2luY3JlbWVudGFsJyBpbiByZXN1bHQgJiYgdXRpbGl0aWVzLmlzTm9uRW1wdHlBcnJheShyZXN1bHQuaW5jcmVtZW50YWwpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmluY3JlbWVudGFsLmZvckVhY2goZnVuY3Rpb24gKGluY3JlbWVudGFsUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmNyZW1lbnRhbFJlc3VsdC5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoUUxFcnJvcnMucHVzaC5hcHBseShncmFwaFFMRXJyb3JzLCBpbmNyZW1lbnRhbFJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaGFzRXJyb3JzID0gdXRpbGl0aWVzLmlzTm9uRW1wdHlBcnJheShncmFwaFFMRXJyb3JzKTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0SWQgPj0gcXVlcnlJbmZvLmxhc3RSZXF1ZXN0SWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzRXJyb3JzICYmIG9wdGlvbnMuZXJyb3JQb2xpY3kgPT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHF1ZXJ5SW5mby5tYXJrRXJyb3IobmV3IGVycm9ycy5BcG9sbG9FcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBncmFwaFFMRXJyb3JzOiBncmFwaFFMRXJyb3JzLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHF1ZXJ5SW5mby5tYXJrUmVzdWx0KHJlc3VsdCwgbGlua0RvY3VtZW50LCBvcHRpb25zLCBjYWNoZVdyaXRlQmVoYXZpb3IpO1xuICAgICAgICAgICAgICAgIHF1ZXJ5SW5mby5tYXJrUmVhZHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhcXIgPSB7XG4gICAgICAgICAgICAgICAgZGF0YTogcmVzdWx0LmRhdGEsXG4gICAgICAgICAgICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgbmV0d29ya1N0YXR1czogZXhwb3J0cy5OZXR3b3JrU3RhdHVzLnJlYWR5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChoYXNFcnJvcnMgJiYgb3B0aW9ucy5lcnJvclBvbGljeSAhPT0gXCJpZ25vcmVcIikge1xuICAgICAgICAgICAgICAgIGFxci5lcnJvcnMgPSBncmFwaFFMRXJyb3JzO1xuICAgICAgICAgICAgICAgIGFxci5uZXR3b3JrU3RhdHVzID0gZXhwb3J0cy5OZXR3b3JrU3RhdHVzLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFxcjtcbiAgICAgICAgfSwgZnVuY3Rpb24gKG5ldHdvcmtFcnJvcikge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gZXJyb3JzLmlzQXBvbGxvRXJyb3IobmV0d29ya0Vycm9yKVxuICAgICAgICAgICAgICAgID8gbmV0d29ya0Vycm9yXG4gICAgICAgICAgICAgICAgOiBuZXcgZXJyb3JzLkFwb2xsb0Vycm9yKHsgbmV0d29ya0Vycm9yOiBuZXR3b3JrRXJyb3IgfSk7XG4gICAgICAgICAgICBpZiAocmVxdWVzdElkID49IHF1ZXJ5SW5mby5sYXN0UmVxdWVzdElkKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlJbmZvLm1hcmtFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLmZldGNoUXVlcnlPYnNlcnZhYmxlID0gZnVuY3Rpb24gKHF1ZXJ5SWQsIG9wdGlvbnMsIG5ldHdvcmtTdGF0dXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG5ldHdvcmtTdGF0dXMgPT09IHZvaWQgMCkgeyBuZXR3b3JrU3RhdHVzID0gZXhwb3J0cy5OZXR3b3JrU3RhdHVzLmxvYWRpbmc7IH1cbiAgICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy50cmFuc2Zvcm0ob3B0aW9ucy5xdWVyeSkuZG9jdW1lbnQ7XG4gICAgICAgIHZhciB2YXJpYWJsZXMgPSB0aGlzLmdldFZhcmlhYmxlcyhxdWVyeSwgb3B0aW9ucy52YXJpYWJsZXMpO1xuICAgICAgICB2YXIgcXVlcnlJbmZvID0gdGhpcy5nZXRRdWVyeShxdWVyeUlkKTtcbiAgICAgICAgdmFyIGRlZmF1bHRzID0gdGhpcy5kZWZhdWx0T3B0aW9ucy53YXRjaFF1ZXJ5O1xuICAgICAgICB2YXIgX2EgPSBvcHRpb25zLmZldGNoUG9saWN5LCBmZXRjaFBvbGljeSA9IF9hID09PSB2b2lkIDAgPyBkZWZhdWx0cyAmJiBkZWZhdWx0cy5mZXRjaFBvbGljeSB8fCBcImNhY2hlLWZpcnN0XCIgOiBfYSwgX2IgPSBvcHRpb25zLmVycm9yUG9saWN5LCBlcnJvclBvbGljeSA9IF9iID09PSB2b2lkIDAgPyBkZWZhdWx0cyAmJiBkZWZhdWx0cy5lcnJvclBvbGljeSB8fCBcIm5vbmVcIiA6IF9iLCBfYyA9IG9wdGlvbnMucmV0dXJuUGFydGlhbERhdGEsIHJldHVyblBhcnRpYWxEYXRhID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2MsIF9kID0gb3B0aW9ucy5ub3RpZnlPbk5ldHdvcmtTdGF0dXNDaGFuZ2UsIG5vdGlmeU9uTmV0d29ya1N0YXR1c0NoYW5nZSA9IF9kID09PSB2b2lkIDAgPyBmYWxzZSA6IF9kLCBfZSA9IG9wdGlvbnMuY29udGV4dCwgY29udGV4dCA9IF9lID09PSB2b2lkIDAgPyB7fSA6IF9lO1xuICAgICAgICB2YXIgbm9ybWFsaXplZCA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICAgIHZhcmlhYmxlczogdmFyaWFibGVzLFxuICAgICAgICAgICAgZmV0Y2hQb2xpY3k6IGZldGNoUG9saWN5LFxuICAgICAgICAgICAgZXJyb3JQb2xpY3k6IGVycm9yUG9saWN5LFxuICAgICAgICAgICAgcmV0dXJuUGFydGlhbERhdGE6IHJldHVyblBhcnRpYWxEYXRhLFxuICAgICAgICAgICAgbm90aWZ5T25OZXR3b3JrU3RhdHVzQ2hhbmdlOiBub3RpZnlPbk5ldHdvcmtTdGF0dXNDaGFuZ2UsXG4gICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGZyb21WYXJpYWJsZXMgPSBmdW5jdGlvbiAodmFyaWFibGVzKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkLnZhcmlhYmxlcyA9IHZhcmlhYmxlcztcbiAgICAgICAgICAgIHZhciBjb25jYXN0U291cmNlcyA9IF90aGlzLmZldGNoUXVlcnlCeVBvbGljeShxdWVyeUluZm8sIG5vcm1hbGl6ZWQsIG5ldHdvcmtTdGF0dXMpO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQuZmV0Y2hQb2xpY3kgIT09IFwic3RhbmRieVwiICYmXG4gICAgICAgICAgICAgICAgY29uY2FzdFNvdXJjZXMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgIHF1ZXJ5SW5mby5vYnNlcnZhYmxlUXVlcnkpIHtcbiAgICAgICAgICAgICAgICBxdWVyeUluZm8ub2JzZXJ2YWJsZVF1ZXJ5W1wiYXBwbHlOZXh0RmV0Y2hQb2xpY3lcIl0oXCJhZnRlci1mZXRjaFwiLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb25jYXN0U291cmNlcztcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNsZWFudXBDYW5jZWxGbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmZldGNoQ2FuY2VsRm5zLmRlbGV0ZShxdWVyeUlkKTsgfTtcbiAgICAgICAgdGhpcy5mZXRjaENhbmNlbEZucy5zZXQocXVlcnlJZCwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgY2xlYW51cENhbmNlbEZuKCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmNhc3QuY2FuY2VsKHJlYXNvbik7IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNvbmNhc3QgPSBuZXcgdXRpbGl0aWVzLkNvbmNhc3QodGhpcy50cmFuc2Zvcm0obm9ybWFsaXplZC5xdWVyeSkuaGFzQ2xpZW50RXhwb3J0c1xuICAgICAgICAgICAgPyB0aGlzLmxvY2FsU3RhdGUuYWRkRXhwb3J0ZWRWYXJpYWJsZXMobm9ybWFsaXplZC5xdWVyeSwgbm9ybWFsaXplZC52YXJpYWJsZXMsIG5vcm1hbGl6ZWQuY29udGV4dCkudGhlbihmcm9tVmFyaWFibGVzKVxuICAgICAgICAgICAgOiBmcm9tVmFyaWFibGVzKG5vcm1hbGl6ZWQudmFyaWFibGVzKSk7XG4gICAgICAgIGNvbmNhc3QucHJvbWlzZS50aGVuKGNsZWFudXBDYW5jZWxGbiwgY2xlYW51cENhbmNlbEZuKTtcbiAgICAgICAgcmV0dXJuIGNvbmNhc3Q7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnJlZmV0Y2hRdWVyaWVzID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB1cGRhdGVDYWNoZSA9IF9hLnVwZGF0ZUNhY2hlLCBpbmNsdWRlID0gX2EuaW5jbHVkZSwgX2IgPSBfYS5vcHRpbWlzdGljLCBvcHRpbWlzdGljID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2IsIF9jID0gX2EucmVtb3ZlT3B0aW1pc3RpYywgcmVtb3ZlT3B0aW1pc3RpYyA9IF9jID09PSB2b2lkIDAgPyBvcHRpbWlzdGljID8gdXRpbGl0aWVzLm1ha2VVbmlxdWVJZChcInJlZmV0Y2hRdWVyaWVzXCIpIDogdm9pZCAwIDogX2MsIG9uUXVlcnlVcGRhdGVkID0gX2Eub25RdWVyeVVwZGF0ZWQ7XG4gICAgICAgIHZhciBpbmNsdWRlZFF1ZXJpZXNCeUlkID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAoaW5jbHVkZSkge1xuICAgICAgICAgICAgdGhpcy5nZXRPYnNlcnZhYmxlUXVlcmllcyhpbmNsdWRlKS5mb3JFYWNoKGZ1bmN0aW9uIChvcSwgcXVlcnlJZCkge1xuICAgICAgICAgICAgICAgIGluY2x1ZGVkUXVlcmllc0J5SWQuc2V0KHF1ZXJ5SWQsIHtcbiAgICAgICAgICAgICAgICAgICAgb3E6IG9xLFxuICAgICAgICAgICAgICAgICAgICBsYXN0RGlmZjogX3RoaXMuZ2V0UXVlcnkocXVlcnlJZCkuZ2V0RGlmZigpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdHMgPSBuZXcgTWFwO1xuICAgICAgICBpZiAodXBkYXRlQ2FjaGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuYmF0Y2goe1xuICAgICAgICAgICAgICAgIHVwZGF0ZTogdXBkYXRlQ2FjaGUsXG4gICAgICAgICAgICAgICAgb3B0aW1pc3RpYzogb3B0aW1pc3RpYyAmJiByZW1vdmVPcHRpbWlzdGljIHx8IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlbW92ZU9wdGltaXN0aWM6IHJlbW92ZU9wdGltaXN0aWMsXG4gICAgICAgICAgICAgICAgb25XYXRjaFVwZGF0ZWQ6IGZ1bmN0aW9uICh3YXRjaCwgZGlmZiwgbGFzdERpZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9xID0gd2F0Y2gud2F0Y2hlciBpbnN0YW5jZW9mIFF1ZXJ5SW5mbyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgd2F0Y2gud2F0Y2hlci5vYnNlcnZhYmxlUXVlcnk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uUXVlcnlVcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZWRRdWVyaWVzQnlJZC5kZWxldGUob3EucXVlcnlJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG9uUXVlcnlVcGRhdGVkKG9xLCBkaWZmLCBsYXN0RGlmZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBvcS5yZWZldGNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMuc2V0KG9xLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uUXVlcnlVcGRhdGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZWRRdWVyaWVzQnlJZC5zZXQob3EucXVlcnlJZCwgeyBvcTogb3EsIGxhc3REaWZmOiBsYXN0RGlmZiwgZGlmZjogZGlmZiB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5jbHVkZWRRdWVyaWVzQnlJZC5zaXplKSB7XG4gICAgICAgICAgICBpbmNsdWRlZFF1ZXJpZXNCeUlkLmZvckVhY2goZnVuY3Rpb24gKF9hLCBxdWVyeUlkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9xID0gX2Eub3EsIGxhc3REaWZmID0gX2EubGFzdERpZmYsIGRpZmYgPSBfYS5kaWZmO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKG9uUXVlcnlVcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGlmZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZm8gPSBvcVtcInF1ZXJ5SW5mb1wiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm8ucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYgPSBpbmZvLmdldERpZmYoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBvblF1ZXJ5VXBkYXRlZChvcSwgZGlmZiwgbGFzdERpZmYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW9uUXVlcnlVcGRhdGVkIHx8IHJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBvcS5yZWZldGNoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMuc2V0KG9xLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocXVlcnlJZC5pbmRleE9mKFwibGVnYWN5T25lVGltZVF1ZXJ5XCIpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RvcFF1ZXJ5Tm9Ccm9hZGNhc3QocXVlcnlJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbW92ZU9wdGltaXN0aWMpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUucmVtb3ZlT3B0aW1pc3RpYyhyZW1vdmVPcHRpbWlzdGljKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuICAgIFF1ZXJ5TWFuYWdlci5wcm90b3R5cGUuZmV0Y2hRdWVyeUJ5UG9saWN5ID0gZnVuY3Rpb24gKHF1ZXJ5SW5mbywgX2EsIG5ldHdvcmtTdGF0dXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHF1ZXJ5ID0gX2EucXVlcnksIHZhcmlhYmxlcyA9IF9hLnZhcmlhYmxlcywgZmV0Y2hQb2xpY3kgPSBfYS5mZXRjaFBvbGljeSwgcmVmZXRjaFdyaXRlUG9saWN5ID0gX2EucmVmZXRjaFdyaXRlUG9saWN5LCBlcnJvclBvbGljeSA9IF9hLmVycm9yUG9saWN5LCByZXR1cm5QYXJ0aWFsRGF0YSA9IF9hLnJldHVyblBhcnRpYWxEYXRhLCBjb250ZXh0ID0gX2EuY29udGV4dCwgbm90aWZ5T25OZXR3b3JrU3RhdHVzQ2hhbmdlID0gX2Eubm90aWZ5T25OZXR3b3JrU3RhdHVzQ2hhbmdlO1xuICAgICAgICB2YXIgb2xkTmV0d29ya1N0YXR1cyA9IHF1ZXJ5SW5mby5uZXR3b3JrU3RhdHVzO1xuICAgICAgICBxdWVyeUluZm8uaW5pdCh7XG4gICAgICAgICAgICBkb2N1bWVudDogdGhpcy50cmFuc2Zvcm0ocXVlcnkpLmRvY3VtZW50LFxuICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICBuZXR3b3JrU3RhdHVzOiBuZXR3b3JrU3RhdHVzLFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHJlYWRDYWNoZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHF1ZXJ5SW5mby5nZXREaWZmKHZhcmlhYmxlcyk7IH07XG4gICAgICAgIHZhciByZXN1bHRzRnJvbUNhY2hlID0gZnVuY3Rpb24gKGRpZmYsIG5ldHdvcmtTdGF0dXMpIHtcbiAgICAgICAgICAgIGlmIChuZXR3b3JrU3RhdHVzID09PSB2b2lkIDApIHsgbmV0d29ya1N0YXR1cyA9IHF1ZXJ5SW5mby5uZXR3b3JrU3RhdHVzIHx8IGV4cG9ydHMuTmV0d29ya1N0YXR1cy5sb2FkaW5nOyB9XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGRpZmYucmVzdWx0O1xuICAgICAgICAgICAgaWYgKF9fREVWX18gJiZcbiAgICAgICAgICAgICAgICAhcmV0dXJuUGFydGlhbERhdGEgJiZcbiAgICAgICAgICAgICAgICAhZXF1YWxpdHkuZXF1YWwoZGF0YSwge30pKSB7XG4gICAgICAgICAgICAgICAgbG9nTWlzc2luZ0ZpZWxkRXJyb3JzKGRpZmYubWlzc2luZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZnJvbURhdGEgPSBmdW5jdGlvbiAoZGF0YSkgeyByZXR1cm4gdXRpbGl0aWVzLk9ic2VydmFibGUub2YodHNsaWIuX19hc3NpZ24oeyBkYXRhOiBkYXRhLCBsb2FkaW5nOiBpc05ldHdvcmtSZXF1ZXN0SW5GbGlnaHQobmV0d29ya1N0YXR1cyksIG5ldHdvcmtTdGF0dXM6IG5ldHdvcmtTdGF0dXMgfSwgKGRpZmYuY29tcGxldGUgPyBudWxsIDogeyBwYXJ0aWFsOiB0cnVlIH0pKSk7IH07XG4gICAgICAgICAgICBpZiAoZGF0YSAmJiBfdGhpcy50cmFuc2Zvcm0ocXVlcnkpLmhhc0ZvcmNlZFJlc29sdmVycykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5sb2NhbFN0YXRlLnJ1blJlc29sdmVycyh7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50OiBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3RlUmVzdWx0OiB7IGRhdGE6IGRhdGEgfSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiB2YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgIG9ubHlSdW5Gb3JjZWRSZXNvbHZlcnM6IHRydWUsXG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzb2x2ZWQpIHsgcmV0dXJuIGZyb21EYXRhKHJlc29sdmVkLmRhdGEgfHwgdm9pZCAwKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnJvbURhdGEoZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjYWNoZVdyaXRlQmVoYXZpb3IgPSBmZXRjaFBvbGljeSA9PT0gXCJuby1jYWNoZVwiID8gMCA6XG4gICAgICAgICAgICAobmV0d29ya1N0YXR1cyA9PT0gZXhwb3J0cy5OZXR3b3JrU3RhdHVzLnJlZmV0Y2ggJiZcbiAgICAgICAgICAgICAgICByZWZldGNoV3JpdGVQb2xpY3kgIT09IFwibWVyZ2VcIikgPyAxXG4gICAgICAgICAgICAgICAgOiAyO1xuICAgICAgICB2YXIgcmVzdWx0c0Zyb21MaW5rID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2V0UmVzdWx0c0Zyb21MaW5rKHF1ZXJ5SW5mbywgY2FjaGVXcml0ZUJlaGF2aW9yLCB7XG4gICAgICAgICAgICB2YXJpYWJsZXM6IHZhcmlhYmxlcyxcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICBmZXRjaFBvbGljeTogZmV0Y2hQb2xpY3ksXG4gICAgICAgICAgICBlcnJvclBvbGljeTogZXJyb3JQb2xpY3ksXG4gICAgICAgIH0pOyB9O1xuICAgICAgICB2YXIgc2hvdWxkTm90aWZ5ID0gbm90aWZ5T25OZXR3b3JrU3RhdHVzQ2hhbmdlICYmXG4gICAgICAgICAgICB0eXBlb2Ygb2xkTmV0d29ya1N0YXR1cyA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgICAgICAgb2xkTmV0d29ya1N0YXR1cyAhPT0gbmV0d29ya1N0YXR1cyAmJlxuICAgICAgICAgICAgaXNOZXR3b3JrUmVxdWVzdEluRmxpZ2h0KG5ldHdvcmtTdGF0dXMpO1xuICAgICAgICBzd2l0Y2ggKGZldGNoUG9saWN5KSB7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FzZSBcImNhY2hlLWZpcnN0XCI6IHtcbiAgICAgICAgICAgICAgICB2YXIgZGlmZiA9IHJlYWRDYWNoZSgpO1xuICAgICAgICAgICAgICAgIGlmIChkaWZmLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzRnJvbUNhY2hlKGRpZmYsIHF1ZXJ5SW5mby5tYXJrUmVhZHkoKSksXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5QYXJ0aWFsRGF0YSB8fCBzaG91bGROb3RpZnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNGcm9tQ2FjaGUoZGlmZiksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzRnJvbUxpbmsoKSxcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c0Zyb21MaW5rKCksXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJjYWNoZS1hbmQtbmV0d29ya1wiOiB7XG4gICAgICAgICAgICAgICAgdmFyIGRpZmYgPSByZWFkQ2FjaGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlmZi5jb21wbGV0ZSB8fCByZXR1cm5QYXJ0aWFsRGF0YSB8fCBzaG91bGROb3RpZnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNGcm9tQ2FjaGUoZGlmZiksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzRnJvbUxpbmsoKSxcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c0Zyb21MaW5rKCksXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJjYWNoZS1vbmx5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c0Zyb21DYWNoZShyZWFkQ2FjaGUoKSwgcXVlcnlJbmZvLm1hcmtSZWFkeSgpKSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgY2FzZSBcIm5ldHdvcmstb25seVwiOlxuICAgICAgICAgICAgICAgIGlmIChzaG91bGROb3RpZnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNGcm9tQ2FjaGUocmVhZENhY2hlKCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c0Zyb21MaW5rKCksXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbcmVzdWx0c0Zyb21MaW5rKCldO1xuICAgICAgICAgICAgY2FzZSBcIm5vLWNhY2hlXCI6XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZE5vdGlmeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c0Zyb21DYWNoZShxdWVyeUluZm8uZ2V0RGlmZigpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNGcm9tTGluaygpLFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW3Jlc3VsdHNGcm9tTGluaygpXTtcbiAgICAgICAgICAgIGNhc2UgXCJzdGFuZGJ5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLmdldFF1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5SWQpIHtcbiAgICAgICAgaWYgKHF1ZXJ5SWQgJiYgIXRoaXMucXVlcmllcy5oYXMocXVlcnlJZCkpIHtcbiAgICAgICAgICAgIHRoaXMucXVlcmllcy5zZXQocXVlcnlJZCwgbmV3IFF1ZXJ5SW5mbyh0aGlzLCBxdWVyeUlkKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcmllcy5nZXQocXVlcnlJZCk7XG4gICAgfTtcbiAgICBRdWVyeU1hbmFnZXIucHJvdG90eXBlLnByZXBhcmVDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0ge307IH1cbiAgICAgICAgdmFyIG5ld0NvbnRleHQgPSB0aGlzLmxvY2FsU3RhdGUucHJlcGFyZUNvbnRleHQoY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgbmV3Q29udGV4dCksIHsgY2xpZW50QXdhcmVuZXNzOiB0aGlzLmNsaWVudEF3YXJlbmVzcyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBRdWVyeU1hbmFnZXI7XG59KCkpO1xuXG52YXIgaGFzU3VnZ2VzdGVkRGV2dG9vbHMgPSBmYWxzZTtcbnZhciBBcG9sbG9DbGllbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFwb2xsb0NsaWVudChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVzZXRTdG9yZUNhbGxiYWNrcyA9IFtdO1xuICAgICAgICB0aGlzLmNsZWFyU3RvcmVDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgdmFyIHVyaSA9IG9wdGlvbnMudXJpLCBjcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHMsIGhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMsIGNhY2hlID0gb3B0aW9ucy5jYWNoZSwgX2EgPSBvcHRpb25zLnNzck1vZGUsIHNzck1vZGUgPSBfYSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYSwgX2IgPSBvcHRpb25zLnNzckZvcmNlRmV0Y2hEZWxheSwgc3NyRm9yY2VGZXRjaERlbGF5ID0gX2IgPT09IHZvaWQgMCA/IDAgOiBfYiwgX2MgPSBvcHRpb25zLmNvbm5lY3RUb0RldlRvb2xzLCBjb25uZWN0VG9EZXZUb29scyA9IF9jID09PSB2b2lkIDAgPyB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgIXdpbmRvdy5fX0FQT0xMT19DTElFTlRfXyAmJlxuICAgICAgICAgICAgX19ERVZfXyA6IF9jLCBfZCA9IG9wdGlvbnMucXVlcnlEZWR1cGxpY2F0aW9uLCBxdWVyeURlZHVwbGljYXRpb24gPSBfZCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9kLCBkZWZhdWx0T3B0aW9ucyA9IG9wdGlvbnMuZGVmYXVsdE9wdGlvbnMsIF9lID0gb3B0aW9ucy5hc3N1bWVJbW11dGFibGVSZXN1bHRzLCBhc3N1bWVJbW11dGFibGVSZXN1bHRzID0gX2UgPT09IHZvaWQgMCA/IGZhbHNlIDogX2UsIHJlc29sdmVycyA9IG9wdGlvbnMucmVzb2x2ZXJzLCB0eXBlRGVmcyA9IG9wdGlvbnMudHlwZURlZnMsIGZyYWdtZW50TWF0Y2hlciA9IG9wdGlvbnMuZnJhZ21lbnRNYXRjaGVyLCBjbGllbnRBd2FyZW5lc3NOYW1lID0gb3B0aW9ucy5uYW1lLCBjbGllbnRBd2FyZW5lc3NWZXJzaW9uID0gb3B0aW9ucy52ZXJzaW9uO1xuICAgICAgICB2YXIgbGluayA9IG9wdGlvbnMubGluaztcbiAgICAgICAgaWYgKCFsaW5rKSB7XG4gICAgICAgICAgICBsaW5rID0gdXJpXG4gICAgICAgICAgICAgICAgPyBuZXcgaHR0cC5IdHRwTGluayh7IHVyaTogdXJpLCBjcmVkZW50aWFsczogY3JlZGVudGlhbHMsIGhlYWRlcnM6IGhlYWRlcnMgfSlcbiAgICAgICAgICAgICAgICA6IGNvcmUuQXBvbGxvTGluay5lbXB0eSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2FjaGUpIHtcbiAgICAgICAgICAgIHRocm93IF9fREVWX18gPyBuZXcgZ2xvYmFscy5JbnZhcmlhbnRFcnJvcihcIlRvIGluaXRpYWxpemUgQXBvbGxvIENsaWVudCwgeW91IG11c3Qgc3BlY2lmeSBhICdjYWNoZScgcHJvcGVydHkgXCIgK1xuICAgICAgICAgICAgICAgIFwiaW4gdGhlIG9wdGlvbnMgb2JqZWN0LiBcXG5cIiArXG4gICAgICAgICAgICAgICAgXCJGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpc2l0OiBodHRwczovL2dvLmFwb2xsby5kZXYvYy9kb2NzXCIpIDogbmV3IGdsb2JhbHMuSW52YXJpYW50RXJyb3IoOSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saW5rID0gbGluaztcbiAgICAgICAgdGhpcy5jYWNoZSA9IGNhY2hlO1xuICAgICAgICB0aGlzLmRpc2FibGVOZXR3b3JrRmV0Y2hlcyA9IHNzck1vZGUgfHwgc3NyRm9yY2VGZXRjaERlbGF5ID4gMDtcbiAgICAgICAgdGhpcy5xdWVyeURlZHVwbGljYXRpb24gPSBxdWVyeURlZHVwbGljYXRpb247XG4gICAgICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucyB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLnR5cGVEZWZzID0gdHlwZURlZnM7XG4gICAgICAgIGlmIChzc3JGb3JjZUZldGNoRGVsYXkpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gKF90aGlzLmRpc2FibGVOZXR3b3JrRmV0Y2hlcyA9IGZhbHNlKTsgfSwgc3NyRm9yY2VGZXRjaERlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhdGNoUXVlcnkgPSB0aGlzLndhdGNoUXVlcnkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMucXVlcnkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5tdXRhdGUgPSB0aGlzLm11dGF0ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlc2V0U3RvcmUgPSB0aGlzLnJlc2V0U3RvcmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZUZldGNoT2JzZXJ2YWJsZVF1ZXJpZXMgPSB0aGlzLnJlRmV0Y2hPYnNlcnZhYmxlUXVlcmllcy5iaW5kKHRoaXMpO1xuICAgICAgICBpZiAoY29ubmVjdFRvRGV2VG9vbHMgJiYgdHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHdpbmRvdy5fX0FQT0xMT19DTElFTlRfXyA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNTdWdnZXN0ZWREZXZ0b29scyAmJiBfX0RFVl9fKSB7XG4gICAgICAgICAgICBoYXNTdWdnZXN0ZWREZXZ0b29scyA9IHRydWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQgJiZcbiAgICAgICAgICAgICAgICB3aW5kb3cudG9wID09PSB3aW5kb3cuc2VsZiAmJlxuICAgICAgICAgICAgICAgICF3aW5kb3cuX19BUE9MTE9fREVWVE9PTFNfR0xPQkFMX0hPT0tfXykge1xuICAgICAgICAgICAgICAgIHZhciBuYXYgPSB3aW5kb3cubmF2aWdhdG9yO1xuICAgICAgICAgICAgICAgIHZhciB1YSA9IG5hdiAmJiBuYXYudXNlckFnZW50O1xuICAgICAgICAgICAgICAgIHZhciB1cmwgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB1YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodWEuaW5kZXhPZihcIkNocm9tZS9cIikgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJodHRwczovL2Nocm9tZS5nb29nbGUuY29tL3dlYnN0b3JlL2RldGFpbC9cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhcG9sbG8tY2xpZW50LWRldmVsb3Blci10L2pka2tua2tiZWJiYXBpbGdvZWNjY2lnbGtmYm1ibmZtXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodWEuaW5kZXhPZihcIkZpcmVmb3gvXCIpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaHR0cHM6Ly9hZGRvbnMubW96aWxsYS5vcmcvZW4tVVMvZmlyZWZveC9hZGRvbi9hcG9sbG8tZGV2ZWxvcGVyLXRvb2xzL1wiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgX19ERVZfXyAmJiBnbG9iYWxzLmludmFyaWFudC5sb2coXCJEb3dubG9hZCB0aGUgQXBvbGxvIERldlRvb2xzIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcImV4cGVyaWVuY2U6IFwiICsgdXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5sb2NhbFN0YXRlID0gbmV3IExvY2FsU3RhdGUoe1xuICAgICAgICAgICAgY2FjaGU6IGNhY2hlLFxuICAgICAgICAgICAgY2xpZW50OiB0aGlzLFxuICAgICAgICAgICAgcmVzb2x2ZXJzOiByZXNvbHZlcnMsXG4gICAgICAgICAgICBmcmFnbWVudE1hdGNoZXI6IGZyYWdtZW50TWF0Y2hlcixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucXVlcnlNYW5hZ2VyID0gbmV3IFF1ZXJ5TWFuYWdlcih7XG4gICAgICAgICAgICBjYWNoZTogdGhpcy5jYWNoZSxcbiAgICAgICAgICAgIGxpbms6IHRoaXMubGluayxcbiAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zOiB0aGlzLmRlZmF1bHRPcHRpb25zLFxuICAgICAgICAgICAgcXVlcnlEZWR1cGxpY2F0aW9uOiBxdWVyeURlZHVwbGljYXRpb24sXG4gICAgICAgICAgICBzc3JNb2RlOiBzc3JNb2RlLFxuICAgICAgICAgICAgY2xpZW50QXdhcmVuZXNzOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogY2xpZW50QXdhcmVuZXNzTmFtZSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBjbGllbnRBd2FyZW5lc3NWZXJzaW9uLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxvY2FsU3RhdGU6IHRoaXMubG9jYWxTdGF0ZSxcbiAgICAgICAgICAgIGFzc3VtZUltbXV0YWJsZVJlc3VsdHM6IGFzc3VtZUltbXV0YWJsZVJlc3VsdHMsXG4gICAgICAgICAgICBvbkJyb2FkY2FzdDogY29ubmVjdFRvRGV2VG9vbHMgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmRldlRvb2xzSG9va0NiKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRldlRvb2xzSG9va0NiKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJpZXM6IF90aGlzLnF1ZXJ5TWFuYWdlci5nZXRRdWVyeVN0b3JlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25zOiBfdGhpcy5xdWVyeU1hbmFnZXIubXV0YXRpb25TdG9yZSB8fCB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhV2l0aE9wdGltaXN0aWNSZXN1bHRzOiBfdGhpcy5jYWNoZS5leHRyYWN0KHRydWUpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IDogdm9pZCAwLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnF1ZXJ5TWFuYWdlci5zdG9wKCk7XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLndhdGNoUXVlcnkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5kZWZhdWx0T3B0aW9ucy53YXRjaFF1ZXJ5KSB7XG4gICAgICAgICAgICBvcHRpb25zID0gdXRpbGl0aWVzLm1lcmdlT3B0aW9ucyh0aGlzLmRlZmF1bHRPcHRpb25zLndhdGNoUXVlcnksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVOZXR3b3JrRmV0Y2hlcyAmJlxuICAgICAgICAgICAgKG9wdGlvbnMuZmV0Y2hQb2xpY3kgPT09ICduZXR3b3JrLW9ubHknIHx8XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5mZXRjaFBvbGljeSA9PT0gJ2NhY2hlLWFuZC1uZXR3b3JrJykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgZmV0Y2hQb2xpY3k6ICdjYWNoZS1maXJzdCcgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlNYW5hZ2VyLndhdGNoUXVlcnkob3B0aW9ucyk7XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdE9wdGlvbnMucXVlcnkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB1dGlsaXRpZXMubWVyZ2VPcHRpb25zKHRoaXMuZGVmYXVsdE9wdGlvbnMucXVlcnksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIF9fREVWX18gPyBnbG9iYWxzLmludmFyaWFudChvcHRpb25zLmZldGNoUG9saWN5ICE9PSAnY2FjaGUtYW5kLW5ldHdvcmsnLCAnVGhlIGNhY2hlLWFuZC1uZXR3b3JrIGZldGNoUG9saWN5IGRvZXMgbm90IHdvcmsgd2l0aCBjbGllbnQucXVlcnksIGJlY2F1c2UgJyArXG4gICAgICAgICAgICAnY2xpZW50LnF1ZXJ5IGNhbiBvbmx5IHJldHVybiBhIHNpbmdsZSByZXN1bHQuIFBsZWFzZSB1c2UgY2xpZW50LndhdGNoUXVlcnkgJyArXG4gICAgICAgICAgICAndG8gcmVjZWl2ZSBtdWx0aXBsZSByZXN1bHRzIGZyb20gdGhlIGNhY2hlIGFuZCB0aGUgbmV0d29yaywgb3IgY29uc2lkZXIgJyArXG4gICAgICAgICAgICAndXNpbmcgYSBkaWZmZXJlbnQgZmV0Y2hQb2xpY3ksIHN1Y2ggYXMgY2FjaGUtZmlyc3Qgb3IgbmV0d29yay1vbmx5LicpIDogZ2xvYmFscy5pbnZhcmlhbnQob3B0aW9ucy5mZXRjaFBvbGljeSAhPT0gJ2NhY2hlLWFuZC1uZXR3b3JrJywgMTApO1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlTmV0d29ya0ZldGNoZXMgJiYgb3B0aW9ucy5mZXRjaFBvbGljeSA9PT0gJ25ldHdvcmstb25seScpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgZmV0Y2hQb2xpY3k6ICdjYWNoZS1maXJzdCcgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlNYW5hZ2VyLnF1ZXJ5KG9wdGlvbnMpO1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5tdXRhdGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5kZWZhdWx0T3B0aW9ucy5tdXRhdGUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB1dGlsaXRpZXMubWVyZ2VPcHRpb25zKHRoaXMuZGVmYXVsdE9wdGlvbnMubXV0YXRlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeU1hbmFnZXIubXV0YXRlKG9wdGlvbnMpO1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeU1hbmFnZXIuc3RhcnRHcmFwaFFMU3Vic2NyaXB0aW9uKG9wdGlvbnMpO1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5yZWFkUXVlcnkgPSBmdW5jdGlvbiAob3B0aW9ucywgb3B0aW1pc3RpYykge1xuICAgICAgICBpZiAob3B0aW1pc3RpYyA9PT0gdm9pZCAwKSB7IG9wdGltaXN0aWMgPSBmYWxzZTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZS5yZWFkUXVlcnkob3B0aW9ucywgb3B0aW1pc3RpYyk7XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLnJlYWRGcmFnbWVudCA9IGZ1bmN0aW9uIChvcHRpb25zLCBvcHRpbWlzdGljKSB7XG4gICAgICAgIGlmIChvcHRpbWlzdGljID09PSB2b2lkIDApIHsgb3B0aW1pc3RpYyA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlLnJlYWRGcmFnbWVudChvcHRpb25zLCBvcHRpbWlzdGljKTtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUud3JpdGVRdWVyeSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuY2FjaGUud3JpdGVRdWVyeShvcHRpb25zKTtcbiAgICAgICAgdGhpcy5xdWVyeU1hbmFnZXIuYnJvYWRjYXN0UXVlcmllcygpO1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS53cml0ZUZyYWdtZW50ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jYWNoZS53cml0ZUZyYWdtZW50KG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnF1ZXJ5TWFuYWdlci5icm9hZGNhc3RRdWVyaWVzKCk7XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLl9fYWN0aW9uSG9va0ZvckRldlRvb2xzID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHRoaXMuZGV2VG9vbHNIb29rQ2IgPSBjYjtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUuX19yZXF1ZXN0UmF3ID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgcmV0dXJuIGNvcmUuZXhlY3V0ZSh0aGlzLmxpbmssIHBheWxvYWQpO1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5yZXNldFN0b3JlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnF1ZXJ5TWFuYWdlci5jbGVhclN0b3JlKHtcbiAgICAgICAgICAgIGRpc2NhcmRXYXRjaGVzOiBmYWxzZSxcbiAgICAgICAgfSk7IH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBQcm9taXNlLmFsbChfdGhpcy5yZXNldFN0b3JlQ2FsbGJhY2tzLm1hcChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pKTsgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnJlRmV0Y2hPYnNlcnZhYmxlUXVlcmllcygpOyB9KTtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUuY2xlYXJTdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5xdWVyeU1hbmFnZXIuY2xlYXJTdG9yZSh7XG4gICAgICAgICAgICBkaXNjYXJkV2F0Y2hlczogdHJ1ZSxcbiAgICAgICAgfSk7IH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBQcm9taXNlLmFsbChfdGhpcy5jbGVhclN0b3JlQ2FsbGJhY2tzLm1hcChmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH0pKTsgfSk7XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLm9uUmVzZXRTdG9yZSA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJlc2V0U3RvcmVDYWxsYmFja3MucHVzaChjYik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5yZXNldFN0b3JlQ2FsbGJhY2tzID0gX3RoaXMucmVzZXRTdG9yZUNhbGxiYWNrcy5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMgIT09IGNiOyB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUub25DbGVhclN0b3JlID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY2xlYXJTdG9yZUNhbGxiYWNrcy5wdXNoKGNiKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmNsZWFyU3RvcmVDYWxsYmFja3MgPSBfdGhpcy5jbGVhclN0b3JlQ2FsbGJhY2tzLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYyAhPT0gY2I7IH0pO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5yZUZldGNoT2JzZXJ2YWJsZVF1ZXJpZXMgPSBmdW5jdGlvbiAoaW5jbHVkZVN0YW5kYnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlNYW5hZ2VyLnJlRmV0Y2hPYnNlcnZhYmxlUXVlcmllcyhpbmNsdWRlU3RhbmRieSk7XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLnJlZmV0Y2hRdWVyaWVzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMucXVlcnlNYW5hZ2VyLnJlZmV0Y2hRdWVyaWVzKG9wdGlvbnMpO1xuICAgICAgICB2YXIgcXVlcmllcyA9IFtdO1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICBtYXAuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0LCBvYnNRdWVyeSkge1xuICAgICAgICAgICAgcXVlcmllcy5wdXNoKG9ic1F1ZXJ5KTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFByb21pc2UuYWxsKHJlc3VsdHMpO1xuICAgICAgICByZXN1bHQucXVlcmllcyA9IHF1ZXJpZXM7XG4gICAgICAgIHJlc3VsdC5yZXN1bHRzID0gcmVzdWx0cztcbiAgICAgICAgcmVzdWx0LmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgX19ERVZfXyAmJiBnbG9iYWxzLmludmFyaWFudC5kZWJ1ZyhcIkluIGNsaWVudC5yZWZldGNoUXVlcmllcywgUHJvbWlzZS5hbGwgcHJvbWlzZSByZWplY3RlZCB3aXRoIGVycm9yIFwiLmNvbmNhdChlcnJvcikpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUuZ2V0T2JzZXJ2YWJsZVF1ZXJpZXMgPSBmdW5jdGlvbiAoaW5jbHVkZSkge1xuICAgICAgICBpZiAoaW5jbHVkZSA9PT0gdm9pZCAwKSB7IGluY2x1ZGUgPSBcImFjdGl2ZVwiOyB9XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5TWFuYWdlci5nZXRPYnNlcnZhYmxlUXVlcmllcyhpbmNsdWRlKTtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUuZXh0cmFjdCA9IGZ1bmN0aW9uIChvcHRpbWlzdGljKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlLmV4dHJhY3Qob3B0aW1pc3RpYyk7XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLnJlc3RvcmUgPSBmdW5jdGlvbiAoc2VyaWFsaXplZFN0YXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlLnJlc3RvcmUoc2VyaWFsaXplZFN0YXRlKTtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUuYWRkUmVzb2x2ZXJzID0gZnVuY3Rpb24gKHJlc29sdmVycykge1xuICAgICAgICB0aGlzLmxvY2FsU3RhdGUuYWRkUmVzb2x2ZXJzKHJlc29sdmVycyk7XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLnNldFJlc29sdmVycyA9IGZ1bmN0aW9uIChyZXNvbHZlcnMpIHtcbiAgICAgICAgdGhpcy5sb2NhbFN0YXRlLnNldFJlc29sdmVycyhyZXNvbHZlcnMpO1xuICAgIH07XG4gICAgQXBvbGxvQ2xpZW50LnByb3RvdHlwZS5nZXRSZXNvbHZlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsU3RhdGUuZ2V0UmVzb2x2ZXJzKCk7XG4gICAgfTtcbiAgICBBcG9sbG9DbGllbnQucHJvdG90eXBlLnNldExvY2FsU3RhdGVGcmFnbWVudE1hdGNoZXIgPSBmdW5jdGlvbiAoZnJhZ21lbnRNYXRjaGVyKSB7XG4gICAgICAgIHRoaXMubG9jYWxTdGF0ZS5zZXRGcmFnbWVudE1hdGNoZXIoZnJhZ21lbnRNYXRjaGVyKTtcbiAgICB9O1xuICAgIEFwb2xsb0NsaWVudC5wcm90b3R5cGUuc2V0TGluayA9IGZ1bmN0aW9uIChuZXdMaW5rKSB7XG4gICAgICAgIHRoaXMubGluayA9IHRoaXMucXVlcnlNYW5hZ2VyLmxpbmsgPSBuZXdMaW5rO1xuICAgIH07XG4gICAgcmV0dXJuIEFwb2xsb0NsaWVudDtcbn0oKSk7XG5cbnRzSW52YXJpYW50LnNldFZlcmJvc2l0eShnbG9iYWxzLkRFViA/IFwibG9nXCIgOiBcInNpbGVudFwiKTtcblxuZXhwb3J0cy5BcG9sbG9DYWNoZSA9IGNhY2hlLkFwb2xsb0NhY2hlO1xuZXhwb3J0cy5DYWNoZSA9IGNhY2hlLkNhY2hlO1xuZXhwb3J0cy5Jbk1lbW9yeUNhY2hlID0gY2FjaGUuSW5NZW1vcnlDYWNoZTtcbmV4cG9ydHMuTWlzc2luZ0ZpZWxkRXJyb3IgPSBjYWNoZS5NaXNzaW5nRmllbGRFcnJvcjtcbmV4cG9ydHMuZGVmYXVsdERhdGFJZEZyb21PYmplY3QgPSBjYWNoZS5kZWZhdWx0RGF0YUlkRnJvbU9iamVjdDtcbmV4cG9ydHMubWFrZVZhciA9IGNhY2hlLm1ha2VWYXI7XG5leHBvcnRzLk9ic2VydmFibGUgPSB1dGlsaXRpZXMuT2JzZXJ2YWJsZTtcbmV4cG9ydHMuaXNSZWZlcmVuY2UgPSB1dGlsaXRpZXMuaXNSZWZlcmVuY2U7XG5leHBvcnRzLm1ha2VSZWZlcmVuY2UgPSB1dGlsaXRpZXMubWFrZVJlZmVyZW5jZTtcbmV4cG9ydHMubWVyZ2VPcHRpb25zID0gdXRpbGl0aWVzLm1lcmdlT3B0aW9ucztcbmV4cG9ydHMuQXBvbGxvRXJyb3IgPSBlcnJvcnMuQXBvbGxvRXJyb3I7XG5leHBvcnRzLmlzQXBvbGxvRXJyb3IgPSBlcnJvcnMuaXNBcG9sbG9FcnJvcjtcbmV4cG9ydHMuZnJvbUVycm9yID0gdXRpbHMuZnJvbUVycm9yO1xuZXhwb3J0cy5mcm9tUHJvbWlzZSA9IHV0aWxzLmZyb21Qcm9taXNlO1xuZXhwb3J0cy50aHJvd1NlcnZlckVycm9yID0gdXRpbHMudGhyb3dTZXJ2ZXJFcnJvcjtcbmV4cG9ydHMudG9Qcm9taXNlID0gdXRpbHMudG9Qcm9taXNlO1xuZXhwb3J0cy5zZXRMb2dWZXJib3NpdHkgPSB0c0ludmFyaWFudC5zZXRWZXJib3NpdHk7XG5leHBvcnRzLmRpc2FibGVFeHBlcmltZW50YWxGcmFnbWVudFZhcmlhYmxlcyA9IGdyYXBocWxUYWcuZGlzYWJsZUV4cGVyaW1lbnRhbEZyYWdtZW50VmFyaWFibGVzO1xuZXhwb3J0cy5kaXNhYmxlRnJhZ21lbnRXYXJuaW5ncyA9IGdyYXBocWxUYWcuZGlzYWJsZUZyYWdtZW50V2FybmluZ3M7XG5leHBvcnRzLmVuYWJsZUV4cGVyaW1lbnRhbEZyYWdtZW50VmFyaWFibGVzID0gZ3JhcGhxbFRhZy5lbmFibGVFeHBlcmltZW50YWxGcmFnbWVudFZhcmlhYmxlcztcbmV4cG9ydHMuZ3FsID0gZ3JhcGhxbFRhZy5ncWw7XG5leHBvcnRzLnJlc2V0Q2FjaGVzID0gZ3JhcGhxbFRhZy5yZXNldENhY2hlcztcbmV4cG9ydHMuQXBvbGxvQ2xpZW50ID0gQXBvbGxvQ2xpZW50O1xuZXhwb3J0cy5PYnNlcnZhYmxlUXVlcnkgPSBPYnNlcnZhYmxlUXVlcnk7XG5mb3IgKHZhciBrIGluIGNvcmUpIHtcbiAgICBpZiAoayAhPT0gJ2RlZmF1bHQnICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KGspKSBleHBvcnRzW2tdID0gY29yZVtrXTtcbn1cbmZvciAodmFyIGsgaW4gaHR0cCkge1xuICAgIGlmIChrICE9PSAnZGVmYXVsdCcgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkoaykpIGV4cG9ydHNba10gPSBodHRwW2tdO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29yZS5janMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@apollo/client/core/core.cjs\n");

/***/ }),

/***/ "./node_modules/@apollo/client/errors/errors.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/@apollo/client/errors/errors.cjs ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar tslib = __webpack_require__(/*! tslib */ \"tslib\");\n__webpack_require__(/*! ../utilities/globals */ \"./node_modules/@apollo/client/utilities/globals/globals.cjs\");\nvar utilities = __webpack_require__(/*! ../utilities */ \"./node_modules/@apollo/client/utilities/utilities.cjs\");\n\nfunction isApolloError(err) {\n    return err.hasOwnProperty('graphQLErrors');\n}\nvar generateErrorMessage = function (err) {\n    var message = '';\n    if (utilities.isNonEmptyArray(err.graphQLErrors) || utilities.isNonEmptyArray(err.clientErrors)) {\n        var errors = (err.graphQLErrors || [])\n            .concat(err.clientErrors || []);\n        errors.forEach(function (error) {\n            var errorMessage = error\n                ? error.message\n                : 'Error message not found.';\n            message += \"\".concat(errorMessage, \"\\n\");\n        });\n    }\n    if (err.networkError) {\n        message += \"\".concat(err.networkError.message, \"\\n\");\n    }\n    message = message.replace(/\\n$/, '');\n    return message;\n};\nvar ApolloError = (function (_super) {\n    tslib.__extends(ApolloError, _super);\n    function ApolloError(_a) {\n        var graphQLErrors = _a.graphQLErrors, clientErrors = _a.clientErrors, networkError = _a.networkError, errorMessage = _a.errorMessage, extraInfo = _a.extraInfo;\n        var _this = _super.call(this, errorMessage) || this;\n        _this.graphQLErrors = graphQLErrors || [];\n        _this.clientErrors = clientErrors || [];\n        _this.networkError = networkError || null;\n        _this.message = errorMessage || generateErrorMessage(_this);\n        _this.extraInfo = extraInfo;\n        _this.__proto__ = ApolloError.prototype;\n        return _this;\n    }\n    return ApolloError;\n}(Error));\n\nexports.ApolloError = ApolloError;\nexports.isApolloError = isApolloError;\n//# sourceMappingURL=errors.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvZXJyb3JzL2Vycm9ycy5janM/YzMzOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBOEMsY0FBYzs7QUFFNUQsWUFBWSxtQkFBTyxDQUFDLG9CQUFPO0FBQzNCLG1CQUFPLENBQUMseUZBQXNCO0FBQzlCLGdCQUFnQixtQkFBTyxDQUFDLDJFQUFjOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9lcnJvcnMvZXJyb3JzLmNqcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHRzbGliID0gcmVxdWlyZSgndHNsaWInKTtcbnJlcXVpcmUoJy4uL3V0aWxpdGllcy9nbG9iYWxzJyk7XG52YXIgdXRpbGl0aWVzID0gcmVxdWlyZSgnLi4vdXRpbGl0aWVzJyk7XG5cbmZ1bmN0aW9uIGlzQXBvbGxvRXJyb3IoZXJyKSB7XG4gICAgcmV0dXJuIGVyci5oYXNPd25Qcm9wZXJ0eSgnZ3JhcGhRTEVycm9ycycpO1xufVxudmFyIGdlbmVyYXRlRXJyb3JNZXNzYWdlID0gZnVuY3Rpb24gKGVycikge1xuICAgIHZhciBtZXNzYWdlID0gJyc7XG4gICAgaWYgKHV0aWxpdGllcy5pc05vbkVtcHR5QXJyYXkoZXJyLmdyYXBoUUxFcnJvcnMpIHx8IHV0aWxpdGllcy5pc05vbkVtcHR5QXJyYXkoZXJyLmNsaWVudEVycm9ycykpIHtcbiAgICAgICAgdmFyIGVycm9ycyA9IChlcnIuZ3JhcGhRTEVycm9ycyB8fCBbXSlcbiAgICAgICAgICAgIC5jb25jYXQoZXJyLmNsaWVudEVycm9ycyB8fCBbXSk7XG4gICAgICAgIGVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IGVycm9yXG4gICAgICAgICAgICAgICAgPyBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgOiAnRXJyb3IgbWVzc2FnZSBub3QgZm91bmQuJztcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCJcIi5jb25jYXQoZXJyb3JNZXNzYWdlLCBcIlxcblwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlcnIubmV0d29ya0Vycm9yKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gXCJcIi5jb25jYXQoZXJyLm5ldHdvcmtFcnJvci5tZXNzYWdlLCBcIlxcblwiKTtcbiAgICB9XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZSgvXFxuJC8sICcnKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbn07XG52YXIgQXBvbGxvRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhBcG9sbG9FcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcG9sbG9FcnJvcihfYSkge1xuICAgICAgICB2YXIgZ3JhcGhRTEVycm9ycyA9IF9hLmdyYXBoUUxFcnJvcnMsIGNsaWVudEVycm9ycyA9IF9hLmNsaWVudEVycm9ycywgbmV0d29ya0Vycm9yID0gX2EubmV0d29ya0Vycm9yLCBlcnJvck1lc3NhZ2UgPSBfYS5lcnJvck1lc3NhZ2UsIGV4dHJhSW5mbyA9IF9hLmV4dHJhSW5mbztcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZXJyb3JNZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5ncmFwaFFMRXJyb3JzID0gZ3JhcGhRTEVycm9ycyB8fCBbXTtcbiAgICAgICAgX3RoaXMuY2xpZW50RXJyb3JzID0gY2xpZW50RXJyb3JzIHx8IFtdO1xuICAgICAgICBfdGhpcy5uZXR3b3JrRXJyb3IgPSBuZXR3b3JrRXJyb3IgfHwgbnVsbDtcbiAgICAgICAgX3RoaXMubWVzc2FnZSA9IGVycm9yTWVzc2FnZSB8fCBnZW5lcmF0ZUVycm9yTWVzc2FnZShfdGhpcyk7XG4gICAgICAgIF90aGlzLmV4dHJhSW5mbyA9IGV4dHJhSW5mbztcbiAgICAgICAgX3RoaXMuX19wcm90b19fID0gQXBvbGxvRXJyb3IucHJvdG90eXBlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBBcG9sbG9FcnJvcjtcbn0oRXJyb3IpKTtcblxuZXhwb3J0cy5BcG9sbG9FcnJvciA9IEFwb2xsb0Vycm9yO1xuZXhwb3J0cy5pc0Fwb2xsb0Vycm9yID0gaXNBcG9sbG9FcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5janMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@apollo/client/errors/errors.cjs\n");

/***/ }),

/***/ "./node_modules/@apollo/client/link/core/core.cjs":
/*!********************************************************!*\
  !*** ./node_modules/@apollo/client/link/core/core.cjs ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar globals = __webpack_require__(/*! ../../utilities/globals */ \"./node_modules/@apollo/client/utilities/globals/globals.cjs\");\nvar tslib = __webpack_require__(/*! tslib */ \"tslib\");\nvar utilities = __webpack_require__(/*! ../../utilities */ \"./node_modules/@apollo/client/utilities/utilities.cjs\");\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/@apollo/client/link/utils/utils.cjs\");\n\nfunction passthrough(op, forward) {\n    return (forward ? forward(op) : utilities.Observable.of());\n}\nfunction toLink(handler) {\n    return typeof handler === 'function' ? new ApolloLink(handler) : handler;\n}\nfunction isTerminating(link) {\n    return link.request.length <= 1;\n}\nvar LinkError = (function (_super) {\n    tslib.__extends(LinkError, _super);\n    function LinkError(message, link) {\n        var _this = _super.call(this, message) || this;\n        _this.link = link;\n        return _this;\n    }\n    return LinkError;\n}(Error));\nvar ApolloLink = (function () {\n    function ApolloLink(request) {\n        if (request)\n            this.request = request;\n    }\n    ApolloLink.empty = function () {\n        return new ApolloLink(function () { return utilities.Observable.of(); });\n    };\n    ApolloLink.from = function (links) {\n        if (links.length === 0)\n            return ApolloLink.empty();\n        return links.map(toLink).reduce(function (x, y) { return x.concat(y); });\n    };\n    ApolloLink.split = function (test, left, right) {\n        var leftLink = toLink(left);\n        var rightLink = toLink(right || new ApolloLink(passthrough));\n        if (isTerminating(leftLink) && isTerminating(rightLink)) {\n            return new ApolloLink(function (operation) {\n                return test(operation)\n                    ? leftLink.request(operation) || utilities.Observable.of()\n                    : rightLink.request(operation) || utilities.Observable.of();\n            });\n        }\n        else {\n            return new ApolloLink(function (operation, forward) {\n                return test(operation)\n                    ? leftLink.request(operation, forward) || utilities.Observable.of()\n                    : rightLink.request(operation, forward) || utilities.Observable.of();\n            });\n        }\n    };\n    ApolloLink.execute = function (link, operation) {\n        return (link.request(utils.createOperation(operation.context, utils.transformOperation(utils.validateOperation(operation)))) || utilities.Observable.of());\n    };\n    ApolloLink.concat = function (first, second) {\n        var firstLink = toLink(first);\n        if (isTerminating(firstLink)) {\n            __DEV__ && globals.invariant.warn(new LinkError(\"You are calling concat on a terminating link, which will have no effect\", firstLink));\n            return firstLink;\n        }\n        var nextLink = toLink(second);\n        if (isTerminating(nextLink)) {\n            return new ApolloLink(function (operation) {\n                return firstLink.request(operation, function (op) { return nextLink.request(op) || utilities.Observable.of(); }) || utilities.Observable.of();\n            });\n        }\n        else {\n            return new ApolloLink(function (operation, forward) {\n                return (firstLink.request(operation, function (op) {\n                    return nextLink.request(op, forward) || utilities.Observable.of();\n                }) || utilities.Observable.of());\n            });\n        }\n    };\n    ApolloLink.prototype.split = function (test, left, right) {\n        return this.concat(ApolloLink.split(test, left, right || new ApolloLink(passthrough)));\n    };\n    ApolloLink.prototype.concat = function (next) {\n        return ApolloLink.concat(this, next);\n    };\n    ApolloLink.prototype.request = function (operation, forward) {\n        throw __DEV__ ? new globals.InvariantError('request is not implemented') : new globals.InvariantError(21);\n    };\n    ApolloLink.prototype.onError = function (error, observer) {\n        if (observer && observer.error) {\n            observer.error(error);\n            return false;\n        }\n        throw error;\n    };\n    ApolloLink.prototype.setOnError = function (fn) {\n        this.onError = fn;\n        return this;\n    };\n    return ApolloLink;\n}());\n\nvar empty = ApolloLink.empty;\n\nvar from = ApolloLink.from;\n\nvar split = ApolloLink.split;\n\nvar concat = ApolloLink.concat;\n\nvar execute = ApolloLink.execute;\n\nexports.ApolloLink = ApolloLink;\nexports.concat = concat;\nexports.empty = empty;\nexports.execute = execute;\nexports.from = from;\nexports.split = split;\n//# sourceMappingURL=core.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvbGluay9jb3JlL2NvcmUuY2pzPzkzMjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQThDLGNBQWM7O0FBRTVELGNBQWMsbUJBQU8sQ0FBQyw0RkFBeUI7QUFDL0MsWUFBWSxtQkFBTyxDQUFDLG9CQUFPO0FBQzNCLGdCQUFnQixtQkFBTyxDQUFDLDhFQUFpQjtBQUN6QyxZQUFZLG1CQUFPLENBQUMsb0VBQVU7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGtDQUFrQyxFQUFFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELG9CQUFvQixFQUFFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSwwREFBMEQsRUFBRTtBQUMvSCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvbGluay9jb3JlL2NvcmUuY2pzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxpdGllcy9nbG9iYWxzJyk7XG52YXIgdHNsaWIgPSByZXF1aXJlKCd0c2xpYicpO1xudmFyIHV0aWxpdGllcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxpdGllcycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gcGFzc3Rocm91Z2gob3AsIGZvcndhcmQpIHtcbiAgICByZXR1cm4gKGZvcndhcmQgPyBmb3J3YXJkKG9wKSA6IHV0aWxpdGllcy5PYnNlcnZhYmxlLm9mKCkpO1xufVxuZnVuY3Rpb24gdG9MaW5rKGhhbmRsZXIpIHtcbiAgICByZXR1cm4gdHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicgPyBuZXcgQXBvbGxvTGluayhoYW5kbGVyKSA6IGhhbmRsZXI7XG59XG5mdW5jdGlvbiBpc1Rlcm1pbmF0aW5nKGxpbmspIHtcbiAgICByZXR1cm4gbGluay5yZXF1ZXN0Lmxlbmd0aCA8PSAxO1xufVxudmFyIExpbmtFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKExpbmtFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaW5rRXJyb3IobWVzc2FnZSwgbGluaykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5saW5rID0gbGluaztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTGlua0Vycm9yO1xufShFcnJvcikpO1xudmFyIEFwb2xsb0xpbmsgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFwb2xsb0xpbmsocmVxdWVzdCkge1xuICAgICAgICBpZiAocmVxdWVzdClcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgfVxuICAgIEFwb2xsb0xpbmsuZW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXBvbGxvTGluayhmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsaXRpZXMuT2JzZXJ2YWJsZS5vZigpOyB9KTtcbiAgICB9O1xuICAgIEFwb2xsb0xpbmsuZnJvbSA9IGZ1bmN0aW9uIChsaW5rcykge1xuICAgICAgICBpZiAobGlua3MubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIEFwb2xsb0xpbmsuZW1wdHkoKTtcbiAgICAgICAgcmV0dXJuIGxpbmtzLm1hcCh0b0xpbmspLnJlZHVjZShmdW5jdGlvbiAoeCwgeSkgeyByZXR1cm4geC5jb25jYXQoeSk7IH0pO1xuICAgIH07XG4gICAgQXBvbGxvTGluay5zcGxpdCA9IGZ1bmN0aW9uICh0ZXN0LCBsZWZ0LCByaWdodCkge1xuICAgICAgICB2YXIgbGVmdExpbmsgPSB0b0xpbmsobGVmdCk7XG4gICAgICAgIHZhciByaWdodExpbmsgPSB0b0xpbmsocmlnaHQgfHwgbmV3IEFwb2xsb0xpbmsocGFzc3Rocm91Z2gpKTtcbiAgICAgICAgaWYgKGlzVGVybWluYXRpbmcobGVmdExpbmspICYmIGlzVGVybWluYXRpbmcocmlnaHRMaW5rKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcG9sbG9MaW5rKGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVzdChvcGVyYXRpb24pXG4gICAgICAgICAgICAgICAgICAgID8gbGVmdExpbmsucmVxdWVzdChvcGVyYXRpb24pIHx8IHV0aWxpdGllcy5PYnNlcnZhYmxlLm9mKClcbiAgICAgICAgICAgICAgICAgICAgOiByaWdodExpbmsucmVxdWVzdChvcGVyYXRpb24pIHx8IHV0aWxpdGllcy5PYnNlcnZhYmxlLm9mKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXBvbGxvTGluayhmdW5jdGlvbiAob3BlcmF0aW9uLCBmb3J3YXJkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlc3Qob3BlcmF0aW9uKVxuICAgICAgICAgICAgICAgICAgICA/IGxlZnRMaW5rLnJlcXVlc3Qob3BlcmF0aW9uLCBmb3J3YXJkKSB8fCB1dGlsaXRpZXMuT2JzZXJ2YWJsZS5vZigpXG4gICAgICAgICAgICAgICAgICAgIDogcmlnaHRMaW5rLnJlcXVlc3Qob3BlcmF0aW9uLCBmb3J3YXJkKSB8fCB1dGlsaXRpZXMuT2JzZXJ2YWJsZS5vZigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFwb2xsb0xpbmsuZXhlY3V0ZSA9IGZ1bmN0aW9uIChsaW5rLCBvcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIChsaW5rLnJlcXVlc3QodXRpbHMuY3JlYXRlT3BlcmF0aW9uKG9wZXJhdGlvbi5jb250ZXh0LCB1dGlscy50cmFuc2Zvcm1PcGVyYXRpb24odXRpbHMudmFsaWRhdGVPcGVyYXRpb24ob3BlcmF0aW9uKSkpKSB8fCB1dGlsaXRpZXMuT2JzZXJ2YWJsZS5vZigpKTtcbiAgICB9O1xuICAgIEFwb2xsb0xpbmsuY29uY2F0ID0gZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgICAgdmFyIGZpcnN0TGluayA9IHRvTGluayhmaXJzdCk7XG4gICAgICAgIGlmIChpc1Rlcm1pbmF0aW5nKGZpcnN0TGluaykpIHtcbiAgICAgICAgICAgIF9fREVWX18gJiYgZ2xvYmFscy5pbnZhcmlhbnQud2FybihuZXcgTGlua0Vycm9yKFwiWW91IGFyZSBjYWxsaW5nIGNvbmNhdCBvbiBhIHRlcm1pbmF0aW5nIGxpbmssIHdoaWNoIHdpbGwgaGF2ZSBubyBlZmZlY3RcIiwgZmlyc3RMaW5rKSk7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3RMaW5rO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXh0TGluayA9IHRvTGluayhzZWNvbmQpO1xuICAgICAgICBpZiAoaXNUZXJtaW5hdGluZyhuZXh0TGluaykpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXBvbGxvTGluayhmdW5jdGlvbiAob3BlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0TGluay5yZXF1ZXN0KG9wZXJhdGlvbiwgZnVuY3Rpb24gKG9wKSB7IHJldHVybiBuZXh0TGluay5yZXF1ZXN0KG9wKSB8fCB1dGlsaXRpZXMuT2JzZXJ2YWJsZS5vZigpOyB9KSB8fCB1dGlsaXRpZXMuT2JzZXJ2YWJsZS5vZigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFwb2xsb0xpbmsoZnVuY3Rpb24gKG9wZXJhdGlvbiwgZm9yd2FyZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoZmlyc3RMaW5rLnJlcXVlc3Qob3BlcmF0aW9uLCBmdW5jdGlvbiAob3ApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHRMaW5rLnJlcXVlc3Qob3AsIGZvcndhcmQpIHx8IHV0aWxpdGllcy5PYnNlcnZhYmxlLm9mKCk7XG4gICAgICAgICAgICAgICAgfSkgfHwgdXRpbGl0aWVzLk9ic2VydmFibGUub2YoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXBvbGxvTGluay5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAodGVzdCwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uY2F0KEFwb2xsb0xpbmsuc3BsaXQodGVzdCwgbGVmdCwgcmlnaHQgfHwgbmV3IEFwb2xsb0xpbmsocGFzc3Rocm91Z2gpKSk7XG4gICAgfTtcbiAgICBBcG9sbG9MaW5rLnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICByZXR1cm4gQXBvbGxvTGluay5jb25jYXQodGhpcywgbmV4dCk7XG4gICAgfTtcbiAgICBBcG9sbG9MaW5rLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG9wZXJhdGlvbiwgZm9yd2FyZCkge1xuICAgICAgICB0aHJvdyBfX0RFVl9fID8gbmV3IGdsb2JhbHMuSW52YXJpYW50RXJyb3IoJ3JlcXVlc3QgaXMgbm90IGltcGxlbWVudGVkJykgOiBuZXcgZ2xvYmFscy5JbnZhcmlhbnRFcnJvcigyMSk7XG4gICAgfTtcbiAgICBBcG9sbG9MaW5rLnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBvYnNlcnZlcikge1xuICAgICAgICBpZiAob2JzZXJ2ZXIgJiYgb2JzZXJ2ZXIuZXJyb3IpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9O1xuICAgIEFwb2xsb0xpbmsucHJvdG90eXBlLnNldE9uRXJyb3IgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdGhpcy5vbkVycm9yID0gZm47XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIEFwb2xsb0xpbms7XG59KCkpO1xuXG52YXIgZW1wdHkgPSBBcG9sbG9MaW5rLmVtcHR5O1xuXG52YXIgZnJvbSA9IEFwb2xsb0xpbmsuZnJvbTtcblxudmFyIHNwbGl0ID0gQXBvbGxvTGluay5zcGxpdDtcblxudmFyIGNvbmNhdCA9IEFwb2xsb0xpbmsuY29uY2F0O1xuXG52YXIgZXhlY3V0ZSA9IEFwb2xsb0xpbmsuZXhlY3V0ZTtcblxuZXhwb3J0cy5BcG9sbG9MaW5rID0gQXBvbGxvTGluaztcbmV4cG9ydHMuY29uY2F0ID0gY29uY2F0O1xuZXhwb3J0cy5lbXB0eSA9IGVtcHR5O1xuZXhwb3J0cy5leGVjdXRlID0gZXhlY3V0ZTtcbmV4cG9ydHMuZnJvbSA9IGZyb207XG5leHBvcnRzLnNwbGl0ID0gc3BsaXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3JlLmNqcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@apollo/client/link/core/core.cjs\n");

/***/ }),

/***/ "./node_modules/@apollo/client/link/http/http.cjs":
/*!********************************************************!*\
  !*** ./node_modules/@apollo/client/link/http/http.cjs ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar globals = __webpack_require__(/*! ../../utilities/globals */ \"./node_modules/@apollo/client/utilities/globals/globals.cjs\");\nvar tslib = __webpack_require__(/*! tslib */ \"tslib\");\nvar utilities = __webpack_require__(/*! ../../utilities */ \"./node_modules/@apollo/client/utilities/utilities.cjs\");\nvar utils = __webpack_require__(/*! ../utils */ \"./node_modules/@apollo/client/link/utils/utils.cjs\");\nvar graphql = __webpack_require__(/*! graphql */ \"graphql\");\nvar core = __webpack_require__(/*! ../core */ \"./node_modules/@apollo/client/link/core/core.cjs\");\n\ntypeof WeakMap === 'function' &&\n    globals.maybe(function () { return navigator.product; }) !== 'ReactNative';\nvar canUseSymbol = typeof Symbol === 'function' &&\n    typeof Symbol.for === 'function';\nvar canUseAsyncIteratorSymbol = canUseSymbol && Symbol.asyncIterator;\ntypeof globals.maybe(function () { return window.document.createElement; }) === \"function\";\nglobals.maybe(function () { return navigator.userAgent.indexOf(\"jsdom\") >= 0; }) || false;\n\nfunction isNodeResponse(value) {\n    return !!value.body;\n}\nfunction isReadableStream(value) {\n    return !!value.getReader;\n}\nfunction isAsyncIterableIterator(value) {\n    return !!(canUseAsyncIteratorSymbol &&\n        value[Symbol.asyncIterator]);\n}\nfunction isStreamableBlob(value) {\n    return !!value.stream;\n}\nfunction isBlob(value) {\n    return !!value.arrayBuffer;\n}\nfunction isNodeReadableStream(value) {\n    return !!value.pipe;\n}\n\nfunction asyncIterator(source) {\n    var _a;\n    var iterator = source[Symbol.asyncIterator]();\n    return _a = {\n            next: function () {\n                return iterator.next();\n            }\n        },\n        _a[Symbol.asyncIterator] = function () {\n            return this;\n        },\n        _a;\n}\n\nfunction nodeStreamIterator(stream) {\n    var cleanup = null;\n    var error = null;\n    var done = false;\n    var data = [];\n    var waiting = [];\n    function onData(chunk) {\n        if (error)\n            return;\n        if (waiting.length) {\n            var shiftedArr = waiting.shift();\n            if (Array.isArray(shiftedArr) && shiftedArr[0]) {\n                return shiftedArr[0]({ value: chunk, done: false });\n            }\n        }\n        data.push(chunk);\n    }\n    function onError(err) {\n        error = err;\n        var all = waiting.slice();\n        all.forEach(function (pair) {\n            pair[1](err);\n        });\n        !cleanup || cleanup();\n    }\n    function onEnd() {\n        done = true;\n        var all = waiting.slice();\n        all.forEach(function (pair) {\n            pair[0]({ value: undefined, done: true });\n        });\n        !cleanup || cleanup();\n    }\n    cleanup = function () {\n        cleanup = null;\n        stream.removeListener(\"data\", onData);\n        stream.removeListener(\"error\", onError);\n        stream.removeListener(\"end\", onEnd);\n        stream.removeListener(\"finish\", onEnd);\n        stream.removeListener(\"close\", onEnd);\n    };\n    stream.on(\"data\", onData);\n    stream.on(\"error\", onError);\n    stream.on(\"end\", onEnd);\n    stream.on(\"finish\", onEnd);\n    stream.on(\"close\", onEnd);\n    function getNext() {\n        return new Promise(function (resolve, reject) {\n            if (error)\n                return reject(error);\n            if (data.length)\n                return resolve({ value: data.shift(), done: false });\n            if (done)\n                return resolve({ value: undefined, done: true });\n            waiting.push([resolve, reject]);\n        });\n    }\n    var iterator = {\n        next: function () {\n            return getNext();\n        },\n    };\n    if (utilities.canUseAsyncIteratorSymbol) {\n        iterator[Symbol.asyncIterator] = function () {\n            return this;\n        };\n    }\n    return iterator;\n}\n\nfunction promiseIterator(promise) {\n    var resolved = false;\n    var iterator = {\n        next: function () {\n            if (resolved)\n                return Promise.resolve({\n                    value: undefined,\n                    done: true,\n                });\n            resolved = true;\n            return new Promise(function (resolve, reject) {\n                promise\n                    .then(function (value) {\n                    resolve({ value: value, done: false });\n                })\n                    .catch(reject);\n            });\n        },\n    };\n    if (utilities.canUseAsyncIteratorSymbol) {\n        iterator[Symbol.asyncIterator] = function () {\n            return this;\n        };\n    }\n    return iterator;\n}\n\nfunction readerIterator(reader) {\n    var iterator = {\n        next: function () {\n            return reader.read();\n        },\n    };\n    if (utilities.canUseAsyncIteratorSymbol) {\n        iterator[Symbol.asyncIterator] = function () {\n            return this;\n        };\n    }\n    return iterator;\n}\n\nfunction responseIterator(response) {\n    var body = response;\n    if (isNodeResponse(response))\n        body = response.body;\n    if (isAsyncIterableIterator(body))\n        return asyncIterator(body);\n    if (isReadableStream(body))\n        return readerIterator(body.getReader());\n    if (isStreamableBlob(body)) {\n        return readerIterator(body.stream().getReader());\n    }\n    if (isBlob(body))\n        return promiseIterator(body.arrayBuffer());\n    if (isNodeReadableStream(body))\n        return nodeStreamIterator(body);\n    throw new Error(\"Unknown body type for responseIterator. Please pass a streamable response.\");\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction readMultipartBody(response, observer) {\n    var _a, _b, _c;\n    return tslib.__awaiter(this, void 0, void 0, function () {\n        var decoder, contentType, delimiter, boundaryVal, boundary, buffer, iterator, running, _d, value, done, chunk, bi, message, i, headers, contentType_1, body, result;\n        var _e;\n        return tslib.__generator(this, function (_f) {\n            switch (_f.label) {\n                case 0:\n                    if (TextDecoder === undefined) {\n                        throw new Error(\"TextDecoder must be defined in the environment: please import a polyfill.\");\n                    }\n                    decoder = new TextDecoder(\"utf-8\");\n                    contentType = (_a = response.headers) === null || _a === void 0 ? void 0 : _a.get('content-type');\n                    delimiter = \"boundary=\";\n                    boundaryVal = (contentType === null || contentType === void 0 ? void 0 : contentType.includes(delimiter))\n                        ? contentType === null || contentType === void 0 ? void 0 : contentType.substring((contentType === null || contentType === void 0 ? void 0 : contentType.indexOf(delimiter)) + delimiter.length).replace(/['\"]/g, \"\").replace(/\\;(.*)/gm, \"\").trim()\n                        : \"-\";\n                    boundary = \"--\".concat(boundaryVal);\n                    buffer = \"\";\n                    iterator = responseIterator(response);\n                    running = true;\n                    _f.label = 1;\n                case 1:\n                    if (!running) return [3, 3];\n                    return [4, iterator.next()];\n                case 2:\n                    _d = _f.sent(), value = _d.value, done = _d.done;\n                    chunk = typeof value === \"string\" ? value : decoder.decode(value);\n                    running = !done;\n                    buffer += chunk;\n                    bi = buffer.indexOf(boundary);\n                    while (bi > -1) {\n                        message = void 0;\n                        _e = [\n                            buffer.slice(0, bi),\n                            buffer.slice(bi + boundary.length),\n                        ], message = _e[0], buffer = _e[1];\n                        if (message.trim()) {\n                            i = message.indexOf(\"\\r\\n\\r\\n\");\n                            headers = parseHeaders(message.slice(0, i));\n                            contentType_1 = headers[\"content-type\"];\n                            if (contentType_1 &&\n                                contentType_1.toLowerCase().indexOf(\"application/json\") === -1) {\n                                throw new Error(\"Unsupported patch content type: application/json is required.\");\n                            }\n                            body = message.slice(i);\n                            try {\n                                result = parseJsonBody(response, body.replace(\"\\r\\n\", \"\"));\n                                if (Object.keys(result).length > 1 ||\n                                    \"data\" in result ||\n                                    \"incremental\" in result ||\n                                    \"errors\" in result) {\n                                    (_b = observer.next) === null || _b === void 0 ? void 0 : _b.call(observer, result);\n                                }\n                            }\n                            catch (err) {\n                                handleError(err, observer);\n                            }\n                        }\n                        bi = buffer.indexOf(boundary);\n                    }\n                    return [3, 1];\n                case 3:\n                    (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);\n                    return [2];\n            }\n        });\n    });\n}\nfunction parseHeaders(headerText) {\n    var headersInit = {};\n    headerText.split(\"\\n\").forEach(function (line) {\n        var i = line.indexOf(\":\");\n        if (i > -1) {\n            var name_1 = line.slice(0, i).trim().toLowerCase();\n            var value = line.slice(i + 1).trim();\n            headersInit[name_1] = value;\n        }\n    });\n    return headersInit;\n}\nfunction parseJsonBody(response, bodyText) {\n    if (response.status >= 300) {\n        var getResult = function () {\n            try {\n                return JSON.parse(bodyText);\n            }\n            catch (err) {\n                return bodyText;\n            }\n        };\n        utils.throwServerError(response, getResult(), \"Response not successful: Received status code \".concat(response.status));\n    }\n    try {\n        return JSON.parse(bodyText);\n    }\n    catch (err) {\n        var parseError = err;\n        parseError.name = \"ServerParseError\";\n        parseError.response = response;\n        parseError.statusCode = response.status;\n        parseError.bodyText = bodyText;\n        throw parseError;\n    }\n}\nfunction handleError(err, observer) {\n    var _a, _b;\n    if (err.name === \"AbortError\")\n        return;\n    if (err.result && err.result.errors && err.result.data) {\n        (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, err.result);\n    }\n    (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, err);\n}\nfunction readJsonBody(response, operation, observer) {\n    parseAndCheckHttpResponse(operation)(response)\n        .then(function (result) {\n        var _a, _b;\n        (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, result);\n        (_b = observer.complete) === null || _b === void 0 ? void 0 : _b.call(observer);\n    })\n        .catch(function (err) { return handleError(err, observer); });\n}\nfunction parseAndCheckHttpResponse(operations) {\n    return function (response) {\n        return response\n            .text()\n            .then(function (bodyText) { return parseJsonBody(response, bodyText); })\n            .then(function (result) {\n            if (response.status >= 300) {\n                utils.throwServerError(response, result, \"Response not successful: Received status code \".concat(response.status));\n            }\n            if (!Array.isArray(result) &&\n                !hasOwnProperty.call(result, \"data\") &&\n                !hasOwnProperty.call(result, \"errors\")) {\n                utils.throwServerError(response, result, \"Server response was missing for query '\".concat(Array.isArray(operations)\n                    ? operations.map(function (op) { return op.operationName; })\n                    : operations.operationName, \"'.\"));\n            }\n            return result;\n        });\n    };\n}\n\nvar serializeFetchParameter = function (p, label) {\n    var serialized;\n    try {\n        serialized = JSON.stringify(p);\n    }\n    catch (e) {\n        var parseError = __DEV__ ? new globals.InvariantError(\"Network request failed. \".concat(label, \" is not serializable: \").concat(e.message)) : new globals.InvariantError(23);\n        parseError.parseError = e;\n        throw parseError;\n    }\n    return serialized;\n};\n\nvar defaultHttpOptions = {\n    includeQuery: true,\n    includeExtensions: false,\n    preserveHeaderCase: false,\n};\nvar defaultHeaders = {\n    accept: '*/*',\n    'content-type': 'application/json',\n};\nvar defaultOptions = {\n    method: 'POST',\n};\nvar fallbackHttpConfig = {\n    http: defaultHttpOptions,\n    headers: defaultHeaders,\n    options: defaultOptions,\n};\nvar defaultPrinter = function (ast, printer) { return printer(ast); };\nfunction selectHttpOptionsAndBody(operation, fallbackConfig) {\n    var configs = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        configs[_i - 2] = arguments[_i];\n    }\n    configs.unshift(fallbackConfig);\n    return selectHttpOptionsAndBodyInternal.apply(void 0, tslib.__spreadArray([operation,\n        defaultPrinter], configs, false));\n}\nfunction selectHttpOptionsAndBodyInternal(operation, printer) {\n    var configs = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        configs[_i - 2] = arguments[_i];\n    }\n    var options = {};\n    var http = {};\n    configs.forEach(function (config) {\n        options = tslib.__assign(tslib.__assign(tslib.__assign({}, options), config.options), { headers: tslib.__assign(tslib.__assign({}, options.headers), config.headers) });\n        if (config.credentials) {\n            options.credentials = config.credentials;\n        }\n        http = tslib.__assign(tslib.__assign({}, http), config.http);\n    });\n    options.headers = removeDuplicateHeaders(options.headers, http.preserveHeaderCase);\n    var operationName = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;\n    var body = { operationName: operationName, variables: variables };\n    if (http.includeExtensions)\n        body.extensions = extensions;\n    if (http.includeQuery)\n        body.query = printer(query, graphql.print);\n    return {\n        options: options,\n        body: body,\n    };\n}\nfunction removeDuplicateHeaders(headers, preserveHeaderCase) {\n    if (!preserveHeaderCase) {\n        var normalizedHeaders_1 = Object.create(null);\n        Object.keys(Object(headers)).forEach(function (name) {\n            normalizedHeaders_1[name.toLowerCase()] = headers[name];\n        });\n        return normalizedHeaders_1;\n    }\n    var headerData = Object.create(null);\n    Object.keys(Object(headers)).forEach(function (name) {\n        headerData[name.toLowerCase()] = { originalName: name, value: headers[name] };\n    });\n    var normalizedHeaders = Object.create(null);\n    Object.keys(headerData).forEach(function (name) {\n        normalizedHeaders[headerData[name].originalName] = headerData[name].value;\n    });\n    return normalizedHeaders;\n}\n\nvar checkFetcher = function (fetcher) {\n    if (!fetcher && typeof fetch === 'undefined') {\n        throw __DEV__ ? new globals.InvariantError(\"\\n\\\"fetch\\\" has not been found globally and no fetcher has been configured. To fix this, install a fetch package (like https://www.npmjs.com/package/cross-fetch), instantiate the fetcher, and pass it into your HttpLink constructor. For example:\\n\\nimport fetch from 'cross-fetch';\\nimport { ApolloClient, HttpLink } from '@apollo/client';\\nconst client = new ApolloClient({\\n  link: new HttpLink({ uri: '/graphql', fetch })\\n});\\n    \") : new globals.InvariantError(22);\n    }\n};\n\nvar createSignalIfSupported = function () {\n    if (typeof AbortController === 'undefined')\n        return { controller: false, signal: false };\n    var controller = new AbortController();\n    var signal = controller.signal;\n    return { controller: controller, signal: signal };\n};\n\nvar selectURI = function (operation, fallbackURI) {\n    var context = operation.getContext();\n    var contextURI = context.uri;\n    if (contextURI) {\n        return contextURI;\n    }\n    else if (typeof fallbackURI === 'function') {\n        return fallbackURI(operation);\n    }\n    else {\n        return fallbackURI || '/graphql';\n    }\n};\n\nfunction rewriteURIForGET(chosenURI, body) {\n    var queryParams = [];\n    var addQueryParam = function (key, value) {\n        queryParams.push(\"\".concat(key, \"=\").concat(encodeURIComponent(value)));\n    };\n    if ('query' in body) {\n        addQueryParam('query', body.query);\n    }\n    if (body.operationName) {\n        addQueryParam('operationName', body.operationName);\n    }\n    if (body.variables) {\n        var serializedVariables = void 0;\n        try {\n            serializedVariables = serializeFetchParameter(body.variables, 'Variables map');\n        }\n        catch (parseError) {\n            return { parseError: parseError };\n        }\n        addQueryParam('variables', serializedVariables);\n    }\n    if (body.extensions) {\n        var serializedExtensions = void 0;\n        try {\n            serializedExtensions = serializeFetchParameter(body.extensions, 'Extensions map');\n        }\n        catch (parseError) {\n            return { parseError: parseError };\n        }\n        addQueryParam('extensions', serializedExtensions);\n    }\n    var fragment = '', preFragment = chosenURI;\n    var fragmentStart = chosenURI.indexOf('#');\n    if (fragmentStart !== -1) {\n        fragment = chosenURI.substr(fragmentStart);\n        preFragment = chosenURI.substr(0, fragmentStart);\n    }\n    var queryParamsPrefix = preFragment.indexOf('?') === -1 ? '?' : '&';\n    var newURI = preFragment + queryParamsPrefix + queryParams.join('&') + fragment;\n    return { newURI: newURI };\n}\n\nvar backupFetch = utilities.maybe(function () { return fetch; });\nvar createHttpLink = function (linkOptions) {\n    if (linkOptions === void 0) { linkOptions = {}; }\n    var _a = linkOptions.uri, uri = _a === void 0 ? '/graphql' : _a, preferredFetch = linkOptions.fetch, _b = linkOptions.print, print = _b === void 0 ? defaultPrinter : _b, includeExtensions = linkOptions.includeExtensions, preserveHeaderCase = linkOptions.preserveHeaderCase, useGETForQueries = linkOptions.useGETForQueries, _c = linkOptions.includeUnusedVariables, includeUnusedVariables = _c === void 0 ? false : _c, requestOptions = tslib.__rest(linkOptions, [\"uri\", \"fetch\", \"print\", \"includeExtensions\", \"preserveHeaderCase\", \"useGETForQueries\", \"includeUnusedVariables\"]);\n    if (__DEV__) {\n        checkFetcher(preferredFetch || backupFetch);\n    }\n    var linkConfig = {\n        http: { includeExtensions: includeExtensions, preserveHeaderCase: preserveHeaderCase },\n        options: requestOptions.fetchOptions,\n        credentials: requestOptions.credentials,\n        headers: requestOptions.headers,\n    };\n    return new core.ApolloLink(function (operation) {\n        var chosenURI = selectURI(operation, uri);\n        var context = operation.getContext();\n        var clientAwarenessHeaders = {};\n        if (context.clientAwareness) {\n            var _a = context.clientAwareness, name_1 = _a.name, version = _a.version;\n            if (name_1) {\n                clientAwarenessHeaders['apollographql-client-name'] = name_1;\n            }\n            if (version) {\n                clientAwarenessHeaders['apollographql-client-version'] = version;\n            }\n        }\n        var contextHeaders = tslib.__assign(tslib.__assign({}, clientAwarenessHeaders), context.headers);\n        var contextConfig = {\n            http: context.http,\n            options: context.fetchOptions,\n            credentials: context.credentials,\n            headers: contextHeaders,\n        };\n        var _b = selectHttpOptionsAndBodyInternal(operation, print, fallbackHttpConfig, linkConfig, contextConfig), options = _b.options, body = _b.body;\n        if (body.variables && !includeUnusedVariables) {\n            var unusedNames_1 = new Set(Object.keys(body.variables));\n            graphql.visit(operation.query, {\n                Variable: function (node, _key, parent) {\n                    if (parent && parent.kind !== 'VariableDefinition') {\n                        unusedNames_1.delete(node.name.value);\n                    }\n                },\n            });\n            if (unusedNames_1.size) {\n                body.variables = tslib.__assign({}, body.variables);\n                unusedNames_1.forEach(function (name) {\n                    delete body.variables[name];\n                });\n            }\n        }\n        var controller;\n        if (!options.signal) {\n            var _c = createSignalIfSupported(), _controller = _c.controller, signal = _c.signal;\n            controller = _controller;\n            if (controller)\n                options.signal = signal;\n        }\n        var definitionIsMutation = function (d) {\n            return d.kind === 'OperationDefinition' && d.operation === 'mutation';\n        };\n        if (useGETForQueries &&\n            !operation.query.definitions.some(definitionIsMutation)) {\n            options.method = 'GET';\n        }\n        if (utilities.hasDirectives(['defer'], operation.query)) {\n            options.headers.accept = \"multipart/mixed; deferSpec=20220824, application/json\";\n        }\n        if (options.method === 'GET') {\n            var _d = rewriteURIForGET(chosenURI, body), newURI = _d.newURI, parseError = _d.parseError;\n            if (parseError) {\n                return utils.fromError(parseError);\n            }\n            chosenURI = newURI;\n        }\n        else {\n            try {\n                options.body = serializeFetchParameter(body, 'Payload');\n            }\n            catch (parseError) {\n                return utils.fromError(parseError);\n            }\n        }\n        return new utilities.Observable(function (observer) {\n            var currentFetch = preferredFetch || utilities.maybe(function () { return fetch; }) || backupFetch;\n            currentFetch(chosenURI, options)\n                .then(function (response) {\n                var _a;\n                operation.setContext({ response: response });\n                var ctype = (_a = response.headers) === null || _a === void 0 ? void 0 : _a.get('content-type');\n                if (ctype !== null && /^multipart\\/mixed/i.test(ctype)) {\n                    return readMultipartBody(response, observer);\n                }\n                else {\n                    return readJsonBody(response, operation, observer);\n                }\n            })\n                .catch(function (err) { return handleError(err, observer); });\n            return function () {\n                if (controller)\n                    controller.abort();\n            };\n        });\n    });\n};\n\nvar HttpLink = (function (_super) {\n    tslib.__extends(HttpLink, _super);\n    function HttpLink(options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this, createHttpLink(options).request) || this;\n        _this.options = options;\n        return _this;\n    }\n    return HttpLink;\n}(core.ApolloLink));\n\nexports.HttpLink = HttpLink;\nexports.checkFetcher = checkFetcher;\nexports.createHttpLink = createHttpLink;\nexports.createSignalIfSupported = createSignalIfSupported;\nexports.defaultPrinter = defaultPrinter;\nexports.fallbackHttpConfig = fallbackHttpConfig;\nexports.parseAndCheckHttpResponse = parseAndCheckHttpResponse;\nexports.rewriteURIForGET = rewriteURIForGET;\nexports.selectHttpOptionsAndBody = selectHttpOptionsAndBody;\nexports.selectHttpOptionsAndBodyInternal = selectHttpOptionsAndBodyInternal;\nexports.selectURI = selectURI;\nexports.serializeFetchParameter = serializeFetchParameter;\n//# sourceMappingURL=http.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvbGluay9odHRwL2h0dHAuY2pzPzc2ZTYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQThDLGNBQWM7O0FBRTVELGNBQWMsbUJBQU8sQ0FBQyw0RkFBeUI7QUFDL0MsWUFBWSxtQkFBTyxDQUFDLG9CQUFPO0FBQzNCLGdCQUFnQixtQkFBTyxDQUFDLDhFQUFpQjtBQUN6QyxZQUFZLG1CQUFPLENBQUMsb0VBQVU7QUFDOUIsY0FBYyxtQkFBTyxDQUFDLHdCQUFTO0FBQy9CLFdBQVcsbUJBQU8sQ0FBQyxpRUFBUzs7QUFFNUI7QUFDQSwrQkFBK0IsMEJBQTBCLEVBQUU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHNDQUFzQyxFQUFFO0FBQzFFLDJCQUEyQixrREFBa0QsRUFBRTs7QUFFL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw0QkFBNEI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwrQkFBK0I7QUFDcEQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsbUNBQW1DO0FBQ25F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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxjQUFjLEVBQUU7QUFDOUY7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFCQUFxQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix1Q0FBdUMsbUNBQW1DLEVBQUU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0BhcG9sbG8vY2xpZW50L2xpbmsvaHR0cC9odHRwLmNqcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGdsb2JhbHMgPSByZXF1aXJlKCcuLi8uLi91dGlsaXRpZXMvZ2xvYmFscycpO1xudmFyIHRzbGliID0gcmVxdWlyZSgndHNsaWInKTtcbnZhciB1dGlsaXRpZXMgPSByZXF1aXJlKCcuLi8uLi91dGlsaXRpZXMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgZ3JhcGhxbCA9IHJlcXVpcmUoJ2dyYXBocWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG50eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIGdsb2JhbHMubWF5YmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmF2aWdhdG9yLnByb2R1Y3Q7IH0pICE9PSAnUmVhY3ROYXRpdmUnO1xudmFyIGNhblVzZVN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgU3ltYm9sLmZvciA9PT0gJ2Z1bmN0aW9uJztcbnZhciBjYW5Vc2VBc3luY0l0ZXJhdG9yU3ltYm9sID0gY2FuVXNlU3ltYm9sICYmIFN5bWJvbC5hc3luY0l0ZXJhdG9yO1xudHlwZW9mIGdsb2JhbHMubWF5YmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQ7IH0pID09PSBcImZ1bmN0aW9uXCI7XG5nbG9iYWxzLm1heWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcImpzZG9tXCIpID49IDA7IH0pIHx8IGZhbHNlO1xuXG5mdW5jdGlvbiBpc05vZGVSZXNwb25zZSh2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlLmJvZHk7XG59XG5mdW5jdGlvbiBpc1JlYWRhYmxlU3RyZWFtKHZhbHVlKSB7XG4gICAgcmV0dXJuICEhdmFsdWUuZ2V0UmVhZGVyO1xufVxuZnVuY3Rpb24gaXNBc3luY0l0ZXJhYmxlSXRlcmF0b3IodmFsdWUpIHtcbiAgICByZXR1cm4gISEoY2FuVXNlQXN5bmNJdGVyYXRvclN5bWJvbCAmJlxuICAgICAgICB2YWx1ZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0pO1xufVxuZnVuY3Rpb24gaXNTdHJlYW1hYmxlQmxvYih2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlLnN0cmVhbTtcbn1cbmZ1bmN0aW9uIGlzQmxvYih2YWx1ZSkge1xuICAgIHJldHVybiAhIXZhbHVlLmFycmF5QnVmZmVyO1xufVxuZnVuY3Rpb24gaXNOb2RlUmVhZGFibGVTdHJlYW0odmFsdWUpIHtcbiAgICByZXR1cm4gISF2YWx1ZS5waXBlO1xufVxuXG5mdW5jdGlvbiBhc3luY0l0ZXJhdG9yKHNvdXJjZSkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgaXRlcmF0b3IgPSBzb3VyY2VbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgcmV0dXJuIF9hID0ge1xuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9hW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBfYTtcbn1cblxuZnVuY3Rpb24gbm9kZVN0cmVhbUl0ZXJhdG9yKHN0cmVhbSkge1xuICAgIHZhciBjbGVhbnVwID0gbnVsbDtcbiAgICB2YXIgZXJyb3IgPSBudWxsO1xuICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgdmFyIGRhdGEgPSBbXTtcbiAgICB2YXIgd2FpdGluZyA9IFtdO1xuICAgIGZ1bmN0aW9uIG9uRGF0YShjaHVuaykge1xuICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh3YWl0aW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHNoaWZ0ZWRBcnIgPSB3YWl0aW5nLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzaGlmdGVkQXJyKSAmJiBzaGlmdGVkQXJyWzBdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoaWZ0ZWRBcnJbMF0oeyB2YWx1ZTogY2h1bmssIGRvbmU6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRhdGEucHVzaChjaHVuayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uRXJyb3IoZXJyKSB7XG4gICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICB2YXIgYWxsID0gd2FpdGluZy5zbGljZSgpO1xuICAgICAgICBhbGwuZm9yRWFjaChmdW5jdGlvbiAocGFpcikge1xuICAgICAgICAgICAgcGFpclsxXShlcnIpO1xuICAgICAgICB9KTtcbiAgICAgICAgIWNsZWFudXAgfHwgY2xlYW51cCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkVuZCgpIHtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIHZhciBhbGwgPSB3YWl0aW5nLnNsaWNlKCk7XG4gICAgICAgIGFsbC5mb3JFYWNoKGZ1bmN0aW9uIChwYWlyKSB7XG4gICAgICAgICAgICBwYWlyWzBdKHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgICFjbGVhbnVwIHx8IGNsZWFudXAoKTtcbiAgICB9XG4gICAgY2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYW51cCA9IG51bGw7XG4gICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcihcImRhdGFcIiwgb25EYXRhKTtcbiAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgb25FcnJvcik7XG4gICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcihcImVuZFwiLCBvbkVuZCk7XG4gICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcihcImZpbmlzaFwiLCBvbkVuZCk7XG4gICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIG9uRW5kKTtcbiAgICB9O1xuICAgIHN0cmVhbS5vbihcImRhdGFcIiwgb25EYXRhKTtcbiAgICBzdHJlYW0ub24oXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICBzdHJlYW0ub24oXCJlbmRcIiwgb25FbmQpO1xuICAgIHN0cmVhbS5vbihcImZpbmlzaFwiLCBvbkVuZCk7XG4gICAgc3RyZWFtLm9uKFwiY2xvc2VcIiwgb25FbmQpO1xuICAgIGZ1bmN0aW9uIGdldE5leHQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyB2YWx1ZTogZGF0YS5zaGlmdCgpLCBkb25lOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHdhaXRpbmcucHVzaChbcmVzb2x2ZSwgcmVqZWN0XSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXROZXh0KCk7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBpZiAodXRpbGl0aWVzLmNhblVzZUFzeW5jSXRlcmF0b3JTeW1ib2wpIHtcbiAgICAgICAgaXRlcmF0b3JbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBpdGVyYXRvcjtcbn1cblxuZnVuY3Rpb24gcHJvbWlzZUl0ZXJhdG9yKHByb21pc2UpIHtcbiAgICB2YXIgcmVzb2x2ZWQgPSBmYWxzZTtcbiAgICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IHZhbHVlOiB2YWx1ZSwgZG9uZTogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGlmICh1dGlsaXRpZXMuY2FuVXNlQXN5bmNJdGVyYXRvclN5bWJvbCkge1xuICAgICAgICBpdGVyYXRvcltTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG5mdW5jdGlvbiByZWFkZXJJdGVyYXRvcihyZWFkZXIpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZCgpO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgaWYgKHV0aWxpdGllcy5jYW5Vc2VBc3luY0l0ZXJhdG9yU3ltYm9sKSB7XG4gICAgICAgIGl0ZXJhdG9yW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gaXRlcmF0b3I7XG59XG5cbmZ1bmN0aW9uIHJlc3BvbnNlSXRlcmF0b3IocmVzcG9uc2UpIHtcbiAgICB2YXIgYm9keSA9IHJlc3BvbnNlO1xuICAgIGlmIChpc05vZGVSZXNwb25zZShyZXNwb25zZSkpXG4gICAgICAgIGJvZHkgPSByZXNwb25zZS5ib2R5O1xuICAgIGlmIChpc0FzeW5jSXRlcmFibGVJdGVyYXRvcihib2R5KSlcbiAgICAgICAgcmV0dXJuIGFzeW5jSXRlcmF0b3IoYm9keSk7XG4gICAgaWYgKGlzUmVhZGFibGVTdHJlYW0oYm9keSkpXG4gICAgICAgIHJldHVybiByZWFkZXJJdGVyYXRvcihib2R5LmdldFJlYWRlcigpKTtcbiAgICBpZiAoaXNTdHJlYW1hYmxlQmxvYihib2R5KSkge1xuICAgICAgICByZXR1cm4gcmVhZGVySXRlcmF0b3IoYm9keS5zdHJlYW0oKS5nZXRSZWFkZXIoKSk7XG4gICAgfVxuICAgIGlmIChpc0Jsb2IoYm9keSkpXG4gICAgICAgIHJldHVybiBwcm9taXNlSXRlcmF0b3IoYm9keS5hcnJheUJ1ZmZlcigpKTtcbiAgICBpZiAoaXNOb2RlUmVhZGFibGVTdHJlYW0oYm9keSkpXG4gICAgICAgIHJldHVybiBub2RlU3RyZWFtSXRlcmF0b3IoYm9keSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBib2R5IHR5cGUgZm9yIHJlc3BvbnNlSXRlcmF0b3IuIFBsZWFzZSBwYXNzIGEgc3RyZWFtYWJsZSByZXNwb25zZS5cIik7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiByZWFkTXVsdGlwYXJ0Qm9keShyZXNwb25zZSwgb2JzZXJ2ZXIpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICByZXR1cm4gdHNsaWIuX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZWNvZGVyLCBjb250ZW50VHlwZSwgZGVsaW1pdGVyLCBib3VuZGFyeVZhbCwgYm91bmRhcnksIGJ1ZmZlciwgaXRlcmF0b3IsIHJ1bm5pbmcsIF9kLCB2YWx1ZSwgZG9uZSwgY2h1bmssIGJpLCBtZXNzYWdlLCBpLCBoZWFkZXJzLCBjb250ZW50VHlwZV8xLCBib2R5LCByZXN1bHQ7XG4gICAgICAgIHZhciBfZTtcbiAgICAgICAgcmV0dXJuIHRzbGliLl9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZikge1xuICAgICAgICAgICAgc3dpdGNoIChfZi5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKFRleHREZWNvZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRleHREZWNvZGVyIG11c3QgYmUgZGVmaW5lZCBpbiB0aGUgZW52aXJvbm1lbnQ6IHBsZWFzZSBpbXBvcnQgYSBwb2x5ZmlsbC5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IChfYSA9IHJlc3BvbnNlLmhlYWRlcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoJ2NvbnRlbnQtdHlwZScpO1xuICAgICAgICAgICAgICAgICAgICBkZWxpbWl0ZXIgPSBcImJvdW5kYXJ5PVwiO1xuICAgICAgICAgICAgICAgICAgICBib3VuZGFyeVZhbCA9IChjb250ZW50VHlwZSA9PT0gbnVsbCB8fCBjb250ZW50VHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGVudFR5cGUuaW5jbHVkZXMoZGVsaW1pdGVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29udGVudFR5cGUgPT09IG51bGwgfHwgY29udGVudFR5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRlbnRUeXBlLnN1YnN0cmluZygoY29udGVudFR5cGUgPT09IG51bGwgfHwgY29udGVudFR5cGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRlbnRUeXBlLmluZGV4T2YoZGVsaW1pdGVyKSkgKyBkZWxpbWl0ZXIubGVuZ3RoKS5yZXBsYWNlKC9bJ1wiXS9nLCBcIlwiKS5yZXBsYWNlKC9cXDsoLiopL2dtLCBcIlwiKS50cmltKClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCItXCI7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5ID0gXCItLVwiLmNvbmNhdChib3VuZGFyeVZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gcmVzcG9uc2VJdGVyYXRvcihyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfZi5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJ1bm5pbmcpIHJldHVybiBbMywgM107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgaXRlcmF0b3IubmV4dCgpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIF9kID0gX2Yuc2VudCgpLCB2YWx1ZSA9IF9kLnZhbHVlLCBkb25lID0gX2QuZG9uZTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZSA6IGRlY29kZXIuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZyA9ICFkb25lO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIgKz0gY2h1bms7XG4gICAgICAgICAgICAgICAgICAgIGJpID0gYnVmZmVyLmluZGV4T2YoYm91bmRhcnkpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYmkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5zbGljZSgwLCBiaSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyLnNsaWNlKGJpICsgYm91bmRhcnkubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sIG1lc3NhZ2UgPSBfZVswXSwgYnVmZmVyID0gX2VbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS50cmltKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gbWVzc2FnZS5pbmRleE9mKFwiXFxyXFxuXFxyXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnMgPSBwYXJzZUhlYWRlcnMobWVzc2FnZS5zbGljZSgwLCBpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGVfMSA9IGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlXzEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGVfMS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJhcHBsaWNhdGlvbi9qc29uXCIpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBwYXRjaCBjb250ZW50IHR5cGU6IGFwcGxpY2F0aW9uL2pzb24gaXMgcmVxdWlyZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gbWVzc2FnZS5zbGljZShpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBwYXJzZUpzb25Cb2R5KHJlc3BvbnNlLCBib2R5LnJlcGxhY2UoXCJcXHJcXG5cIiwgXCJcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMocmVzdWx0KS5sZW5ndGggPiAxIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRhdGFcIiBpbiByZXN1bHQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaW5jcmVtZW50YWxcIiBpbiByZXN1bHQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZXJyb3JzXCIgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2IgPSBvYnNlcnZlci5uZXh0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChvYnNlcnZlciwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGVyciwgb2JzZXJ2ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJpID0gYnVmZmVyLmluZGV4T2YoYm91bmRhcnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgMV07XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAoX2MgPSBvYnNlcnZlci5jb21wbGV0ZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwob2JzZXJ2ZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlSGVhZGVycyhoZWFkZXJUZXh0KSB7XG4gICAgdmFyIGhlYWRlcnNJbml0ID0ge307XG4gICAgaGVhZGVyVGV4dC5zcGxpdChcIlxcblwiKS5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBpID0gbGluZS5pbmRleE9mKFwiOlwiKTtcbiAgICAgICAgaWYgKGkgPiAtMSkge1xuICAgICAgICAgICAgdmFyIG5hbWVfMSA9IGxpbmUuc2xpY2UoMCwgaSkudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBsaW5lLnNsaWNlKGkgKyAxKS50cmltKCk7XG4gICAgICAgICAgICBoZWFkZXJzSW5pdFtuYW1lXzFdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaGVhZGVyc0luaXQ7XG59XG5mdW5jdGlvbiBwYXJzZUpzb25Cb2R5KHJlc3BvbnNlLCBib2R5VGV4dCkge1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gMzAwKSB7XG4gICAgICAgIHZhciBnZXRSZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGJvZHlUZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYm9keVRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHV0aWxzLnRocm93U2VydmVyRXJyb3IocmVzcG9uc2UsIGdldFJlc3VsdCgpLCBcIlJlc3BvbnNlIG5vdCBzdWNjZXNzZnVsOiBSZWNlaXZlZCBzdGF0dXMgY29kZSBcIi5jb25jYXQocmVzcG9uc2Uuc3RhdHVzKSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGJvZHlUZXh0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICB2YXIgcGFyc2VFcnJvciA9IGVycjtcbiAgICAgICAgcGFyc2VFcnJvci5uYW1lID0gXCJTZXJ2ZXJQYXJzZUVycm9yXCI7XG4gICAgICAgIHBhcnNlRXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgcGFyc2VFcnJvci5zdGF0dXNDb2RlID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgICAgICBwYXJzZUVycm9yLmJvZHlUZXh0ID0gYm9keVRleHQ7XG4gICAgICAgIHRocm93IHBhcnNlRXJyb3I7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyLCBvYnNlcnZlcikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKGVyci5uYW1lID09PSBcIkFib3J0RXJyb3JcIilcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChlcnIucmVzdWx0ICYmIGVyci5yZXN1bHQuZXJyb3JzICYmIGVyci5yZXN1bHQuZGF0YSkge1xuICAgICAgICAoX2EgPSBvYnNlcnZlci5uZXh0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvYnNlcnZlciwgZXJyLnJlc3VsdCk7XG4gICAgfVxuICAgIChfYiA9IG9ic2VydmVyLmVycm9yKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChvYnNlcnZlciwgZXJyKTtcbn1cbmZ1bmN0aW9uIHJlYWRKc29uQm9keShyZXNwb25zZSwgb3BlcmF0aW9uLCBvYnNlcnZlcikge1xuICAgIHBhcnNlQW5kQ2hlY2tIdHRwUmVzcG9uc2Uob3BlcmF0aW9uKShyZXNwb25zZSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAoX2EgPSBvYnNlcnZlci5uZXh0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvYnNlcnZlciwgcmVzdWx0KTtcbiAgICAgICAgKF9iID0gb2JzZXJ2ZXIuY29tcGxldGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKG9ic2VydmVyKTtcbiAgICB9KVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikgeyByZXR1cm4gaGFuZGxlRXJyb3IoZXJyLCBvYnNlcnZlcik7IH0pO1xufVxuZnVuY3Rpb24gcGFyc2VBbmRDaGVja0h0dHBSZXNwb25zZShvcGVyYXRpb25zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2VcbiAgICAgICAgICAgIC50ZXh0KClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChib2R5VGV4dCkgeyByZXR1cm4gcGFyc2VKc29uQm9keShyZXNwb25zZSwgYm9keVRleHQpOyB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSAzMDApIHtcbiAgICAgICAgICAgICAgICB1dGlscy50aHJvd1NlcnZlckVycm9yKHJlc3BvbnNlLCByZXN1bHQsIFwiUmVzcG9uc2Ugbm90IHN1Y2Nlc3NmdWw6IFJlY2VpdmVkIHN0YXR1cyBjb2RlIFwiLmNvbmNhdChyZXNwb25zZS5zdGF0dXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZXN1bHQpICYmXG4gICAgICAgICAgICAgICAgIWhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBcImRhdGFcIikgJiZcbiAgICAgICAgICAgICAgICAhaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIFwiZXJyb3JzXCIpKSB7XG4gICAgICAgICAgICAgICAgdXRpbHMudGhyb3dTZXJ2ZXJFcnJvcihyZXNwb25zZSwgcmVzdWx0LCBcIlNlcnZlciByZXNwb25zZSB3YXMgbWlzc2luZyBmb3IgcXVlcnkgJ1wiLmNvbmNhdChBcnJheS5pc0FycmF5KG9wZXJhdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgID8gb3BlcmF0aW9ucy5tYXAoZnVuY3Rpb24gKG9wKSB7IHJldHVybiBvcC5vcGVyYXRpb25OYW1lOyB9KVxuICAgICAgICAgICAgICAgICAgICA6IG9wZXJhdGlvbnMub3BlcmF0aW9uTmFtZSwgXCInLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuXG52YXIgc2VyaWFsaXplRmV0Y2hQYXJhbWV0ZXIgPSBmdW5jdGlvbiAocCwgbGFiZWwpIHtcbiAgICB2YXIgc2VyaWFsaXplZDtcbiAgICB0cnkge1xuICAgICAgICBzZXJpYWxpemVkID0gSlNPTi5zdHJpbmdpZnkocCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHZhciBwYXJzZUVycm9yID0gX19ERVZfXyA/IG5ldyBnbG9iYWxzLkludmFyaWFudEVycm9yKFwiTmV0d29yayByZXF1ZXN0IGZhaWxlZC4gXCIuY29uY2F0KGxhYmVsLCBcIiBpcyBub3Qgc2VyaWFsaXphYmxlOiBcIikuY29uY2F0KGUubWVzc2FnZSkpIDogbmV3IGdsb2JhbHMuSW52YXJpYW50RXJyb3IoMjMpO1xuICAgICAgICBwYXJzZUVycm9yLnBhcnNlRXJyb3IgPSBlO1xuICAgICAgICB0aHJvdyBwYXJzZUVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbn07XG5cbnZhciBkZWZhdWx0SHR0cE9wdGlvbnMgPSB7XG4gICAgaW5jbHVkZVF1ZXJ5OiB0cnVlLFxuICAgIGluY2x1ZGVFeHRlbnNpb25zOiBmYWxzZSxcbiAgICBwcmVzZXJ2ZUhlYWRlckNhc2U6IGZhbHNlLFxufTtcbnZhciBkZWZhdWx0SGVhZGVycyA9IHtcbiAgICBhY2NlcHQ6ICcqLyonLFxuICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG59O1xudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIG1ldGhvZDogJ1BPU1QnLFxufTtcbnZhciBmYWxsYmFja0h0dHBDb25maWcgPSB7XG4gICAgaHR0cDogZGVmYXVsdEh0dHBPcHRpb25zLFxuICAgIGhlYWRlcnM6IGRlZmF1bHRIZWFkZXJzLFxuICAgIG9wdGlvbnM6IGRlZmF1bHRPcHRpb25zLFxufTtcbnZhciBkZWZhdWx0UHJpbnRlciA9IGZ1bmN0aW9uIChhc3QsIHByaW50ZXIpIHsgcmV0dXJuIHByaW50ZXIoYXN0KTsgfTtcbmZ1bmN0aW9uIHNlbGVjdEh0dHBPcHRpb25zQW5kQm9keShvcGVyYXRpb24sIGZhbGxiYWNrQ29uZmlnKSB7XG4gICAgdmFyIGNvbmZpZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBjb25maWdzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBjb25maWdzLnVuc2hpZnQoZmFsbGJhY2tDb25maWcpO1xuICAgIHJldHVybiBzZWxlY3RIdHRwT3B0aW9uc0FuZEJvZHlJbnRlcm5hbC5hcHBseSh2b2lkIDAsIHRzbGliLl9fc3ByZWFkQXJyYXkoW29wZXJhdGlvbixcbiAgICAgICAgZGVmYXVsdFByaW50ZXJdLCBjb25maWdzLCBmYWxzZSkpO1xufVxuZnVuY3Rpb24gc2VsZWN0SHR0cE9wdGlvbnNBbmRCb2R5SW50ZXJuYWwob3BlcmF0aW9uLCBwcmludGVyKSB7XG4gICAgdmFyIGNvbmZpZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBjb25maWdzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBodHRwID0ge307XG4gICAgY29uZmlncy5mb3JFYWNoKGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgb3B0aW9ucyA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBvcHRpb25zKSwgY29uZmlnLm9wdGlvbnMpLCB7IGhlYWRlcnM6IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBvcHRpb25zLmhlYWRlcnMpLCBjb25maWcuaGVhZGVycykgfSk7XG4gICAgICAgIGlmIChjb25maWcuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY3JlZGVudGlhbHMgPSBjb25maWcuY3JlZGVudGlhbHM7XG4gICAgICAgIH1cbiAgICAgICAgaHR0cCA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBodHRwKSwgY29uZmlnLmh0dHApO1xuICAgIH0pO1xuICAgIG9wdGlvbnMuaGVhZGVycyA9IHJlbW92ZUR1cGxpY2F0ZUhlYWRlcnMob3B0aW9ucy5oZWFkZXJzLCBodHRwLnByZXNlcnZlSGVhZGVyQ2FzZSk7XG4gICAgdmFyIG9wZXJhdGlvbk5hbWUgPSBvcGVyYXRpb24ub3BlcmF0aW9uTmFtZSwgZXh0ZW5zaW9ucyA9IG9wZXJhdGlvbi5leHRlbnNpb25zLCB2YXJpYWJsZXMgPSBvcGVyYXRpb24udmFyaWFibGVzLCBxdWVyeSA9IG9wZXJhdGlvbi5xdWVyeTtcbiAgICB2YXIgYm9keSA9IHsgb3BlcmF0aW9uTmFtZTogb3BlcmF0aW9uTmFtZSwgdmFyaWFibGVzOiB2YXJpYWJsZXMgfTtcbiAgICBpZiAoaHR0cC5pbmNsdWRlRXh0ZW5zaW9ucylcbiAgICAgICAgYm9keS5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICBpZiAoaHR0cC5pbmNsdWRlUXVlcnkpXG4gICAgICAgIGJvZHkucXVlcnkgPSBwcmludGVyKHF1ZXJ5LCBncmFwaHFsLnByaW50KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICBib2R5OiBib2R5LFxuICAgIH07XG59XG5mdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVIZWFkZXJzKGhlYWRlcnMsIHByZXNlcnZlSGVhZGVyQ2FzZSkge1xuICAgIGlmICghcHJlc2VydmVIZWFkZXJDYXNlKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSGVhZGVyc18xID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgT2JqZWN0LmtleXMoT2JqZWN0KGhlYWRlcnMpKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkSGVhZGVyc18xW25hbWUudG9Mb3dlckNhc2UoKV0gPSBoZWFkZXJzW25hbWVdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRIZWFkZXJzXzE7XG4gICAgfVxuICAgIHZhciBoZWFkZXJEYXRhID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBPYmplY3Qua2V5cyhPYmplY3QoaGVhZGVycykpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaGVhZGVyRGF0YVtuYW1lLnRvTG93ZXJDYXNlKCldID0geyBvcmlnaW5hbE5hbWU6IG5hbWUsIHZhbHVlOiBoZWFkZXJzW25hbWVdIH07XG4gICAgfSk7XG4gICAgdmFyIG5vcm1hbGl6ZWRIZWFkZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBPYmplY3Qua2V5cyhoZWFkZXJEYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRIZWFkZXJzW2hlYWRlckRhdGFbbmFtZV0ub3JpZ2luYWxOYW1lXSA9IGhlYWRlckRhdGFbbmFtZV0udmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRIZWFkZXJzO1xufVxuXG52YXIgY2hlY2tGZXRjaGVyID0gZnVuY3Rpb24gKGZldGNoZXIpIHtcbiAgICBpZiAoIWZldGNoZXIgJiYgdHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBfX0RFVl9fID8gbmV3IGdsb2JhbHMuSW52YXJpYW50RXJyb3IoXCJcXG5cXFwiZmV0Y2hcXFwiIGhhcyBub3QgYmVlbiBmb3VuZCBnbG9iYWxseSBhbmQgbm8gZmV0Y2hlciBoYXMgYmVlbiBjb25maWd1cmVkLiBUbyBmaXggdGhpcywgaW5zdGFsbCBhIGZldGNoIHBhY2thZ2UgKGxpa2UgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvY3Jvc3MtZmV0Y2gpLCBpbnN0YW50aWF0ZSB0aGUgZmV0Y2hlciwgYW5kIHBhc3MgaXQgaW50byB5b3VyIEh0dHBMaW5rIGNvbnN0cnVjdG9yLiBGb3IgZXhhbXBsZTpcXG5cXG5pbXBvcnQgZmV0Y2ggZnJvbSAnY3Jvc3MtZmV0Y2gnO1xcbmltcG9ydCB7IEFwb2xsb0NsaWVudCwgSHR0cExpbmsgfSBmcm9tICdAYXBvbGxvL2NsaWVudCc7XFxuY29uc3QgY2xpZW50ID0gbmV3IEFwb2xsb0NsaWVudCh7XFxuICBsaW5rOiBuZXcgSHR0cExpbmsoeyB1cmk6ICcvZ3JhcGhxbCcsIGZldGNoIH0pXFxufSk7XFxuICAgIFwiKSA6IG5ldyBnbG9iYWxzLkludmFyaWFudEVycm9yKDIyKTtcbiAgICB9XG59O1xuXG52YXIgY3JlYXRlU2lnbmFsSWZTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBBYm9ydENvbnRyb2xsZXIgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4geyBjb250cm9sbGVyOiBmYWxzZSwgc2lnbmFsOiBmYWxzZSB9O1xuICAgIHZhciBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHZhciBzaWduYWwgPSBjb250cm9sbGVyLnNpZ25hbDtcbiAgICByZXR1cm4geyBjb250cm9sbGVyOiBjb250cm9sbGVyLCBzaWduYWw6IHNpZ25hbCB9O1xufTtcblxudmFyIHNlbGVjdFVSSSA9IGZ1bmN0aW9uIChvcGVyYXRpb24sIGZhbGxiYWNrVVJJKSB7XG4gICAgdmFyIGNvbnRleHQgPSBvcGVyYXRpb24uZ2V0Q29udGV4dCgpO1xuICAgIHZhciBjb250ZXh0VVJJID0gY29udGV4dC51cmk7XG4gICAgaWYgKGNvbnRleHRVUkkpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRVUkk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBmYWxsYmFja1VSSSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tVUkkob3BlcmF0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFja1VSSSB8fCAnL2dyYXBocWwnO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHJld3JpdGVVUklGb3JHRVQoY2hvc2VuVVJJLCBib2R5KSB7XG4gICAgdmFyIHF1ZXJ5UGFyYW1zID0gW107XG4gICAgdmFyIGFkZFF1ZXJ5UGFyYW0gPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBxdWVyeVBhcmFtcy5wdXNoKFwiXCIuY29uY2F0KGtleSwgXCI9XCIpLmNvbmNhdChlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKSk7XG4gICAgfTtcbiAgICBpZiAoJ3F1ZXJ5JyBpbiBib2R5KSB7XG4gICAgICAgIGFkZFF1ZXJ5UGFyYW0oJ3F1ZXJ5JywgYm9keS5xdWVyeSk7XG4gICAgfVxuICAgIGlmIChib2R5Lm9wZXJhdGlvbk5hbWUpIHtcbiAgICAgICAgYWRkUXVlcnlQYXJhbSgnb3BlcmF0aW9uTmFtZScsIGJvZHkub3BlcmF0aW9uTmFtZSk7XG4gICAgfVxuICAgIGlmIChib2R5LnZhcmlhYmxlcykge1xuICAgICAgICB2YXIgc2VyaWFsaXplZFZhcmlhYmxlcyA9IHZvaWQgMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRWYXJpYWJsZXMgPSBzZXJpYWxpemVGZXRjaFBhcmFtZXRlcihib2R5LnZhcmlhYmxlcywgJ1ZhcmlhYmxlcyBtYXAnKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgcGFyc2VFcnJvcjogcGFyc2VFcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGFkZFF1ZXJ5UGFyYW0oJ3ZhcmlhYmxlcycsIHNlcmlhbGl6ZWRWYXJpYWJsZXMpO1xuICAgIH1cbiAgICBpZiAoYm9keS5leHRlbnNpb25zKSB7XG4gICAgICAgIHZhciBzZXJpYWxpemVkRXh0ZW5zaW9ucyA9IHZvaWQgMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRFeHRlbnNpb25zID0gc2VyaWFsaXplRmV0Y2hQYXJhbWV0ZXIoYm9keS5leHRlbnNpb25zLCAnRXh0ZW5zaW9ucyBtYXAnKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHsgcGFyc2VFcnJvcjogcGFyc2VFcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGFkZFF1ZXJ5UGFyYW0oJ2V4dGVuc2lvbnMnLCBzZXJpYWxpemVkRXh0ZW5zaW9ucyk7XG4gICAgfVxuICAgIHZhciBmcmFnbWVudCA9ICcnLCBwcmVGcmFnbWVudCA9IGNob3NlblVSSTtcbiAgICB2YXIgZnJhZ21lbnRTdGFydCA9IGNob3NlblVSSS5pbmRleE9mKCcjJyk7XG4gICAgaWYgKGZyYWdtZW50U3RhcnQgIT09IC0xKSB7XG4gICAgICAgIGZyYWdtZW50ID0gY2hvc2VuVVJJLnN1YnN0cihmcmFnbWVudFN0YXJ0KTtcbiAgICAgICAgcHJlRnJhZ21lbnQgPSBjaG9zZW5VUkkuc3Vic3RyKDAsIGZyYWdtZW50U3RhcnQpO1xuICAgIH1cbiAgICB2YXIgcXVlcnlQYXJhbXNQcmVmaXggPSBwcmVGcmFnbWVudC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnO1xuICAgIHZhciBuZXdVUkkgPSBwcmVGcmFnbWVudCArIHF1ZXJ5UGFyYW1zUHJlZml4ICsgcXVlcnlQYXJhbXMuam9pbignJicpICsgZnJhZ21lbnQ7XG4gICAgcmV0dXJuIHsgbmV3VVJJOiBuZXdVUkkgfTtcbn1cblxudmFyIGJhY2t1cEZldGNoID0gdXRpbGl0aWVzLm1heWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZldGNoOyB9KTtcbnZhciBjcmVhdGVIdHRwTGluayA9IGZ1bmN0aW9uIChsaW5rT3B0aW9ucykge1xuICAgIGlmIChsaW5rT3B0aW9ucyA9PT0gdm9pZCAwKSB7IGxpbmtPcHRpb25zID0ge307IH1cbiAgICB2YXIgX2EgPSBsaW5rT3B0aW9ucy51cmksIHVyaSA9IF9hID09PSB2b2lkIDAgPyAnL2dyYXBocWwnIDogX2EsIHByZWZlcnJlZEZldGNoID0gbGlua09wdGlvbnMuZmV0Y2gsIF9iID0gbGlua09wdGlvbnMucHJpbnQsIHByaW50ID0gX2IgPT09IHZvaWQgMCA/IGRlZmF1bHRQcmludGVyIDogX2IsIGluY2x1ZGVFeHRlbnNpb25zID0gbGlua09wdGlvbnMuaW5jbHVkZUV4dGVuc2lvbnMsIHByZXNlcnZlSGVhZGVyQ2FzZSA9IGxpbmtPcHRpb25zLnByZXNlcnZlSGVhZGVyQ2FzZSwgdXNlR0VURm9yUXVlcmllcyA9IGxpbmtPcHRpb25zLnVzZUdFVEZvclF1ZXJpZXMsIF9jID0gbGlua09wdGlvbnMuaW5jbHVkZVVudXNlZFZhcmlhYmxlcywgaW5jbHVkZVVudXNlZFZhcmlhYmxlcyA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jLCByZXF1ZXN0T3B0aW9ucyA9IHRzbGliLl9fcmVzdChsaW5rT3B0aW9ucywgW1widXJpXCIsIFwiZmV0Y2hcIiwgXCJwcmludFwiLCBcImluY2x1ZGVFeHRlbnNpb25zXCIsIFwicHJlc2VydmVIZWFkZXJDYXNlXCIsIFwidXNlR0VURm9yUXVlcmllc1wiLCBcImluY2x1ZGVVbnVzZWRWYXJpYWJsZXNcIl0pO1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgIGNoZWNrRmV0Y2hlcihwcmVmZXJyZWRGZXRjaCB8fCBiYWNrdXBGZXRjaCk7XG4gICAgfVxuICAgIHZhciBsaW5rQ29uZmlnID0ge1xuICAgICAgICBodHRwOiB7IGluY2x1ZGVFeHRlbnNpb25zOiBpbmNsdWRlRXh0ZW5zaW9ucywgcHJlc2VydmVIZWFkZXJDYXNlOiBwcmVzZXJ2ZUhlYWRlckNhc2UgfSxcbiAgICAgICAgb3B0aW9uczogcmVxdWVzdE9wdGlvbnMuZmV0Y2hPcHRpb25zLFxuICAgICAgICBjcmVkZW50aWFsczogcmVxdWVzdE9wdGlvbnMuY3JlZGVudGlhbHMsXG4gICAgICAgIGhlYWRlcnM6IHJlcXVlc3RPcHRpb25zLmhlYWRlcnMsXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IGNvcmUuQXBvbGxvTGluayhmdW5jdGlvbiAob3BlcmF0aW9uKSB7XG4gICAgICAgIHZhciBjaG9zZW5VUkkgPSBzZWxlY3RVUkkob3BlcmF0aW9uLCB1cmkpO1xuICAgICAgICB2YXIgY29udGV4dCA9IG9wZXJhdGlvbi5nZXRDb250ZXh0KCk7XG4gICAgICAgIHZhciBjbGllbnRBd2FyZW5lc3NIZWFkZXJzID0ge307XG4gICAgICAgIGlmIChjb250ZXh0LmNsaWVudEF3YXJlbmVzcykge1xuICAgICAgICAgICAgdmFyIF9hID0gY29udGV4dC5jbGllbnRBd2FyZW5lc3MsIG5hbWVfMSA9IF9hLm5hbWUsIHZlcnNpb24gPSBfYS52ZXJzaW9uO1xuICAgICAgICAgICAgaWYgKG5hbWVfMSkge1xuICAgICAgICAgICAgICAgIGNsaWVudEF3YXJlbmVzc0hlYWRlcnNbJ2Fwb2xsb2dyYXBocWwtY2xpZW50LW5hbWUnXSA9IG5hbWVfMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgY2xpZW50QXdhcmVuZXNzSGVhZGVyc1snYXBvbGxvZ3JhcGhxbC1jbGllbnQtdmVyc2lvbiddID0gdmVyc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY29udGV4dEhlYWRlcnMgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgY2xpZW50QXdhcmVuZXNzSGVhZGVycyksIGNvbnRleHQuaGVhZGVycyk7XG4gICAgICAgIHZhciBjb250ZXh0Q29uZmlnID0ge1xuICAgICAgICAgICAgaHR0cDogY29udGV4dC5odHRwLFxuICAgICAgICAgICAgb3B0aW9uczogY29udGV4dC5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICBjcmVkZW50aWFsczogY29udGV4dC5jcmVkZW50aWFscyxcbiAgICAgICAgICAgIGhlYWRlcnM6IGNvbnRleHRIZWFkZXJzLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgX2IgPSBzZWxlY3RIdHRwT3B0aW9uc0FuZEJvZHlJbnRlcm5hbChvcGVyYXRpb24sIHByaW50LCBmYWxsYmFja0h0dHBDb25maWcsIGxpbmtDb25maWcsIGNvbnRleHRDb25maWcpLCBvcHRpb25zID0gX2Iub3B0aW9ucywgYm9keSA9IF9iLmJvZHk7XG4gICAgICAgIGlmIChib2R5LnZhcmlhYmxlcyAmJiAhaW5jbHVkZVVudXNlZFZhcmlhYmxlcykge1xuICAgICAgICAgICAgdmFyIHVudXNlZE5hbWVzXzEgPSBuZXcgU2V0KE9iamVjdC5rZXlzKGJvZHkudmFyaWFibGVzKSk7XG4gICAgICAgICAgICBncmFwaHFsLnZpc2l0KG9wZXJhdGlvbi5xdWVyeSwge1xuICAgICAgICAgICAgICAgIFZhcmlhYmxlOiBmdW5jdGlvbiAobm9kZSwgX2tleSwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LmtpbmQgIT09ICdWYXJpYWJsZURlZmluaXRpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bnVzZWROYW1lc18xLmRlbGV0ZShub2RlLm5hbWUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHVudXNlZE5hbWVzXzEuc2l6ZSkge1xuICAgICAgICAgICAgICAgIGJvZHkudmFyaWFibGVzID0gdHNsaWIuX19hc3NpZ24oe30sIGJvZHkudmFyaWFibGVzKTtcbiAgICAgICAgICAgICAgICB1bnVzZWROYW1lc18xLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGJvZHkudmFyaWFibGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjb250cm9sbGVyO1xuICAgICAgICBpZiAoIW9wdGlvbnMuc2lnbmFsKSB7XG4gICAgICAgICAgICB2YXIgX2MgPSBjcmVhdGVTaWduYWxJZlN1cHBvcnRlZCgpLCBfY29udHJvbGxlciA9IF9jLmNvbnRyb2xsZXIsIHNpZ25hbCA9IF9jLnNpZ25hbDtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIgPSBfY29udHJvbGxlcjtcbiAgICAgICAgICAgIGlmIChjb250cm9sbGVyKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsID0gc2lnbmFsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZWZpbml0aW9uSXNNdXRhdGlvbiA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5raW5kID09PSAnT3BlcmF0aW9uRGVmaW5pdGlvbicgJiYgZC5vcGVyYXRpb24gPT09ICdtdXRhdGlvbic7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh1c2VHRVRGb3JRdWVyaWVzICYmXG4gICAgICAgICAgICAhb3BlcmF0aW9uLnF1ZXJ5LmRlZmluaXRpb25zLnNvbWUoZGVmaW5pdGlvbklzTXV0YXRpb24pKSB7XG4gICAgICAgICAgICBvcHRpb25zLm1ldGhvZCA9ICdHRVQnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1dGlsaXRpZXMuaGFzRGlyZWN0aXZlcyhbJ2RlZmVyJ10sIG9wZXJhdGlvbi5xdWVyeSkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVycy5hY2NlcHQgPSBcIm11bHRpcGFydC9taXhlZDsgZGVmZXJTcGVjPTIwMjIwODI0LCBhcHBsaWNhdGlvbi9qc29uXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMubWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICAgICAgdmFyIF9kID0gcmV3cml0ZVVSSUZvckdFVChjaG9zZW5VUkksIGJvZHkpLCBuZXdVUkkgPSBfZC5uZXdVUkksIHBhcnNlRXJyb3IgPSBfZC5wYXJzZUVycm9yO1xuICAgICAgICAgICAgaWYgKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHMuZnJvbUVycm9yKHBhcnNlRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hvc2VuVVJJID0gbmV3VVJJO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmJvZHkgPSBzZXJpYWxpemVGZXRjaFBhcmFtZXRlcihib2R5LCAnUGF5bG9hZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHMuZnJvbUVycm9yKHBhcnNlRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdXRpbGl0aWVzLk9ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudEZldGNoID0gcHJlZmVycmVkRmV0Y2ggfHwgdXRpbGl0aWVzLm1heWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZldGNoOyB9KSB8fCBiYWNrdXBGZXRjaDtcbiAgICAgICAgICAgIGN1cnJlbnRGZXRjaChjaG9zZW5VUkksIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5zZXRDb250ZXh0KHsgcmVzcG9uc2U6IHJlc3BvbnNlIH0pO1xuICAgICAgICAgICAgICAgIHZhciBjdHlwZSA9IChfYSA9IHJlc3BvbnNlLmhlYWRlcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoJ2NvbnRlbnQtdHlwZScpO1xuICAgICAgICAgICAgICAgIGlmIChjdHlwZSAhPT0gbnVsbCAmJiAvXm11bHRpcGFydFxcL21peGVkL2kudGVzdChjdHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRNdWx0aXBhcnRCb2R5KHJlc3BvbnNlLCBvYnNlcnZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZEpzb25Cb2R5KHJlc3BvbnNlLCBvcGVyYXRpb24sIG9ic2VydmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBoYW5kbGVFcnJvcihlcnIsIG9ic2VydmVyKTsgfSk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyKVxuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbnZhciBIdHRwTGluayA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKEh0dHBMaW5rLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEh0dHBMaW5rKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY3JlYXRlSHR0cExpbmsob3B0aW9ucykucmVxdWVzdCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEh0dHBMaW5rO1xufShjb3JlLkFwb2xsb0xpbmspKTtcblxuZXhwb3J0cy5IdHRwTGluayA9IEh0dHBMaW5rO1xuZXhwb3J0cy5jaGVja0ZldGNoZXIgPSBjaGVja0ZldGNoZXI7XG5leHBvcnRzLmNyZWF0ZUh0dHBMaW5rID0gY3JlYXRlSHR0cExpbms7XG5leHBvcnRzLmNyZWF0ZVNpZ25hbElmU3VwcG9ydGVkID0gY3JlYXRlU2lnbmFsSWZTdXBwb3J0ZWQ7XG5leHBvcnRzLmRlZmF1bHRQcmludGVyID0gZGVmYXVsdFByaW50ZXI7XG5leHBvcnRzLmZhbGxiYWNrSHR0cENvbmZpZyA9IGZhbGxiYWNrSHR0cENvbmZpZztcbmV4cG9ydHMucGFyc2VBbmRDaGVja0h0dHBSZXNwb25zZSA9IHBhcnNlQW5kQ2hlY2tIdHRwUmVzcG9uc2U7XG5leHBvcnRzLnJld3JpdGVVUklGb3JHRVQgPSByZXdyaXRlVVJJRm9yR0VUO1xuZXhwb3J0cy5zZWxlY3RIdHRwT3B0aW9uc0FuZEJvZHkgPSBzZWxlY3RIdHRwT3B0aW9uc0FuZEJvZHk7XG5leHBvcnRzLnNlbGVjdEh0dHBPcHRpb25zQW5kQm9keUludGVybmFsID0gc2VsZWN0SHR0cE9wdGlvbnNBbmRCb2R5SW50ZXJuYWw7XG5leHBvcnRzLnNlbGVjdFVSSSA9IHNlbGVjdFVSSTtcbmV4cG9ydHMuc2VyaWFsaXplRmV0Y2hQYXJhbWV0ZXIgPSBzZXJpYWxpemVGZXRjaFBhcmFtZXRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh0dHAuY2pzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@apollo/client/link/http/http.cjs\n");

/***/ }),

/***/ "./node_modules/@apollo/client/link/utils/utils.cjs":
/*!**********************************************************!*\
  !*** ./node_modules/@apollo/client/link/utils/utils.cjs ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar globals = __webpack_require__(/*! ../../utilities/globals */ \"./node_modules/@apollo/client/utilities/globals/globals.cjs\");\nvar utilities = __webpack_require__(/*! ../../utilities */ \"./node_modules/@apollo/client/utilities/utilities.cjs\");\nvar tslib = __webpack_require__(/*! tslib */ \"tslib\");\n\nfunction fromError(errorValue) {\n    return new utilities.Observable(function (observer) {\n        observer.error(errorValue);\n    });\n}\n\nfunction toPromise(observable) {\n    var completed = false;\n    return new Promise(function (resolve, reject) {\n        observable.subscribe({\n            next: function (data) {\n                if (completed) {\n                    __DEV__ && globals.invariant.warn(\"Promise Wrapper does not support multiple results from Observable\");\n                }\n                else {\n                    completed = true;\n                    resolve(data);\n                }\n            },\n            error: reject,\n        });\n    });\n}\n\nfunction fromPromise(promise) {\n    return new utilities.Observable(function (observer) {\n        promise\n            .then(function (value) {\n            observer.next(value);\n            observer.complete();\n        })\n            .catch(observer.error.bind(observer));\n    });\n}\n\nvar throwServerError = function (response, result, message) {\n    var error = new Error(message);\n    error.name = 'ServerError';\n    error.response = response;\n    error.statusCode = response.status;\n    error.result = result;\n    throw error;\n};\n\nfunction validateOperation(operation) {\n    var OPERATION_FIELDS = [\n        'query',\n        'operationName',\n        'variables',\n        'extensions',\n        'context',\n    ];\n    for (var _i = 0, _a = Object.keys(operation); _i < _a.length; _i++) {\n        var key = _a[_i];\n        if (OPERATION_FIELDS.indexOf(key) < 0) {\n            throw __DEV__ ? new globals.InvariantError(\"illegal argument: \".concat(key)) : new globals.InvariantError(26);\n        }\n    }\n    return operation;\n}\n\nfunction createOperation(starting, operation) {\n    var context = tslib.__assign({}, starting);\n    var setContext = function (next) {\n        if (typeof next === 'function') {\n            context = tslib.__assign(tslib.__assign({}, context), next(context));\n        }\n        else {\n            context = tslib.__assign(tslib.__assign({}, context), next);\n        }\n    };\n    var getContext = function () { return (tslib.__assign({}, context)); };\n    Object.defineProperty(operation, 'setContext', {\n        enumerable: false,\n        value: setContext,\n    });\n    Object.defineProperty(operation, 'getContext', {\n        enumerable: false,\n        value: getContext,\n    });\n    return operation;\n}\n\nfunction transformOperation(operation) {\n    var transformedOperation = {\n        variables: operation.variables || {},\n        extensions: operation.extensions || {},\n        operationName: operation.operationName,\n        query: operation.query,\n    };\n    if (!transformedOperation.operationName) {\n        transformedOperation.operationName =\n            typeof transformedOperation.query !== 'string'\n                ? utilities.getOperationName(transformedOperation.query) || undefined\n                : '';\n    }\n    return transformedOperation;\n}\n\nexports.createOperation = createOperation;\nexports.fromError = fromError;\nexports.fromPromise = fromPromise;\nexports.throwServerError = throwServerError;\nexports.toPromise = toPromise;\nexports.transformOperation = transformOperation;\nexports.validateOperation = validateOperation;\n//# sourceMappingURL=utils.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvbGluay91dGlscy91dGlscy5janM/YzQ1NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBOEMsY0FBYzs7QUFFNUQsY0FBYyxtQkFBTyxDQUFDLDRGQUF5QjtBQUMvQyxnQkFBZ0IsbUJBQU8sQ0FBQyw4RUFBaUI7QUFDekMsWUFBWSxtQkFBTyxDQUFDLG9CQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBLGtDQUFrQywwQkFBMEIsWUFBWTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QztBQUM1Qyw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0BhcG9sbG8vY2xpZW50L2xpbmsvdXRpbHMvdXRpbHMuY2pzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxpdGllcy9nbG9iYWxzJyk7XG52YXIgdXRpbGl0aWVzID0gcmVxdWlyZSgnLi4vLi4vdXRpbGl0aWVzJyk7XG52YXIgdHNsaWIgPSByZXF1aXJlKCd0c2xpYicpO1xuXG5mdW5jdGlvbiBmcm9tRXJyb3IoZXJyb3JWYWx1ZSkge1xuICAgIHJldHVybiBuZXcgdXRpbGl0aWVzLk9ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIG9ic2VydmVyLmVycm9yKGVycm9yVmFsdWUpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiB0b1Byb21pc2Uob2JzZXJ2YWJsZSkge1xuICAgIHZhciBjb21wbGV0ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBvYnNlcnZhYmxlLnN1YnNjcmliZSh7XG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX19ERVZfXyAmJiBnbG9iYWxzLmludmFyaWFudC53YXJuKFwiUHJvbWlzZSBXcmFwcGVyIGRvZXMgbm90IHN1cHBvcnQgbXVsdGlwbGUgcmVzdWx0cyBmcm9tIE9ic2VydmFibGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcjogcmVqZWN0LFxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZnJvbVByb21pc2UocHJvbWlzZSkge1xuICAgIHJldHVybiBuZXcgdXRpbGl0aWVzLk9ic2VydmFibGUoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIHByb21pc2VcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKG9ic2VydmVyLmVycm9yLmJpbmQob2JzZXJ2ZXIpKTtcbiAgICB9KTtcbn1cblxudmFyIHRocm93U2VydmVyRXJyb3IgPSBmdW5jdGlvbiAocmVzcG9uc2UsIHJlc3VsdCwgbWVzc2FnZSkge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICBlcnJvci5uYW1lID0gJ1NlcnZlckVycm9yJztcbiAgICBlcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIGVycm9yLnN0YXR1c0NvZGUgPSByZXNwb25zZS5zdGF0dXM7XG4gICAgZXJyb3IucmVzdWx0ID0gcmVzdWx0O1xuICAgIHRocm93IGVycm9yO1xufTtcblxuZnVuY3Rpb24gdmFsaWRhdGVPcGVyYXRpb24ob3BlcmF0aW9uKSB7XG4gICAgdmFyIE9QRVJBVElPTl9GSUVMRFMgPSBbXG4gICAgICAgICdxdWVyeScsXG4gICAgICAgICdvcGVyYXRpb25OYW1lJyxcbiAgICAgICAgJ3ZhcmlhYmxlcycsXG4gICAgICAgICdleHRlbnNpb25zJyxcbiAgICAgICAgJ2NvbnRleHQnLFxuICAgIF07XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKG9wZXJhdGlvbik7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBfYVtfaV07XG4gICAgICAgIGlmIChPUEVSQVRJT05fRklFTERTLmluZGV4T2Yoa2V5KSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IF9fREVWX18gPyBuZXcgZ2xvYmFscy5JbnZhcmlhbnRFcnJvcihcImlsbGVnYWwgYXJndW1lbnQ6IFwiLmNvbmNhdChrZXkpKSA6IG5ldyBnbG9iYWxzLkludmFyaWFudEVycm9yKDI2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3BlcmF0aW9uO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPcGVyYXRpb24oc3RhcnRpbmcsIG9wZXJhdGlvbikge1xuICAgIHZhciBjb250ZXh0ID0gdHNsaWIuX19hc3NpZ24oe30sIHN0YXJ0aW5nKTtcbiAgICB2YXIgc2V0Q29udGV4dCA9IGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29udGV4dCA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBjb250ZXh0KSwgbmV4dChjb250ZXh0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGNvbnRleHQpLCBuZXh0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGdldENvbnRleHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodHNsaWIuX19hc3NpZ24oe30sIGNvbnRleHQpKTsgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3BlcmF0aW9uLCAnc2V0Q29udGV4dCcsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBzZXRDb250ZXh0LFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcGVyYXRpb24sICdnZXRDb250ZXh0Jywge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IGdldENvbnRleHQsXG4gICAgfSk7XG4gICAgcmV0dXJuIG9wZXJhdGlvbjtcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtT3BlcmF0aW9uKG9wZXJhdGlvbikge1xuICAgIHZhciB0cmFuc2Zvcm1lZE9wZXJhdGlvbiA9IHtcbiAgICAgICAgdmFyaWFibGVzOiBvcGVyYXRpb24udmFyaWFibGVzIHx8IHt9LFxuICAgICAgICBleHRlbnNpb25zOiBvcGVyYXRpb24uZXh0ZW5zaW9ucyB8fCB7fSxcbiAgICAgICAgb3BlcmF0aW9uTmFtZTogb3BlcmF0aW9uLm9wZXJhdGlvbk5hbWUsXG4gICAgICAgIHF1ZXJ5OiBvcGVyYXRpb24ucXVlcnksXG4gICAgfTtcbiAgICBpZiAoIXRyYW5zZm9ybWVkT3BlcmF0aW9uLm9wZXJhdGlvbk5hbWUpIHtcbiAgICAgICAgdHJhbnNmb3JtZWRPcGVyYXRpb24ub3BlcmF0aW9uTmFtZSA9XG4gICAgICAgICAgICB0eXBlb2YgdHJhbnNmb3JtZWRPcGVyYXRpb24ucXVlcnkgIT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyB1dGlsaXRpZXMuZ2V0T3BlcmF0aW9uTmFtZSh0cmFuc2Zvcm1lZE9wZXJhdGlvbi5xdWVyeSkgfHwgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgOiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zZm9ybWVkT3BlcmF0aW9uO1xufVxuXG5leHBvcnRzLmNyZWF0ZU9wZXJhdGlvbiA9IGNyZWF0ZU9wZXJhdGlvbjtcbmV4cG9ydHMuZnJvbUVycm9yID0gZnJvbUVycm9yO1xuZXhwb3J0cy5mcm9tUHJvbWlzZSA9IGZyb21Qcm9taXNlO1xuZXhwb3J0cy50aHJvd1NlcnZlckVycm9yID0gdGhyb3dTZXJ2ZXJFcnJvcjtcbmV4cG9ydHMudG9Qcm9taXNlID0gdG9Qcm9taXNlO1xuZXhwb3J0cy50cmFuc2Zvcm1PcGVyYXRpb24gPSB0cmFuc2Zvcm1PcGVyYXRpb247XG5leHBvcnRzLnZhbGlkYXRlT3BlcmF0aW9uID0gdmFsaWRhdGVPcGVyYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5janMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@apollo/client/link/utils/utils.cjs\n");

/***/ }),

/***/ "./node_modules/@apollo/client/main.cjs":
/*!**********************************************!*\
  !*** ./node_modules/@apollo/client/main.cjs ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar core = __webpack_require__(/*! ./core */ \"./node_modules/@apollo/client/core/core.cjs\");\nvar react = __webpack_require__(/*! ./react */ \"./node_modules/@apollo/client/react/react.cjs\");\n\n\n\nfor (var k in core) {\n\tif (k !== 'default' && !exports.hasOwnProperty(k)) exports[k] = core[k];\n}\nfor (var k in react) {\n\tif (k !== 'default' && !exports.hasOwnProperty(k)) exports[k] = react[k];\n}\n//# sourceMappingURL=main.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvbWFpbi5janM/ODcyMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBOEMsY0FBYzs7QUFFNUQsV0FBVyxtQkFBTyxDQUFDLDJEQUFRO0FBQzNCLFlBQVksbUJBQU8sQ0FBQyw4REFBUzs7OztBQUk3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9tYWluLmNqcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGNvcmUgPSByZXF1aXJlKCcuL2NvcmUnKTtcbnZhciByZWFjdCA9IHJlcXVpcmUoJy4vcmVhY3QnKTtcblxuXG5cbmZvciAodmFyIGsgaW4gY29yZSkge1xuXHRpZiAoayAhPT0gJ2RlZmF1bHQnICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KGspKSBleHBvcnRzW2tdID0gY29yZVtrXTtcbn1cbmZvciAodmFyIGsgaW4gcmVhY3QpIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JyAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShrKSkgZXhwb3J0c1trXSA9IHJlYWN0W2tdO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFpbi5janMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@apollo/client/main.cjs\n");

/***/ }),

/***/ "./node_modules/@apollo/client/react/context/context.cjs":
/*!***************************************************************!*\
  !*** ./node_modules/@apollo/client/react/context/context.cjs ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar globals = __webpack_require__(/*! ../../utilities/globals */ \"./node_modules/@apollo/client/utilities/globals/globals.cjs\");\nvar React = __webpack_require__(/*! react */ \"react\");\nvar utilities = __webpack_require__(/*! ../../utilities */ \"./node_modules/@apollo/client/utilities/utilities.cjs\");\n\nfunction _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n        for (var k in e) {\n            n[k] = e[k];\n        }\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n}\n\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\n\nvar contextKey = utilities.canUseSymbol\n    ? Symbol.for('__APOLLO_CONTEXT__')\n    : '__APOLLO_CONTEXT__';\nfunction getApolloContext() {\n    var context = React__namespace.createContext[contextKey];\n    if (!context) {\n        Object.defineProperty(React__namespace.createContext, contextKey, {\n            value: context = React__namespace.createContext({}),\n            enumerable: false,\n            writable: false,\n            configurable: true,\n        });\n        context.displayName = 'ApolloContext';\n    }\n    return context;\n}\n\nvar ApolloConsumer = function (props) {\n    var ApolloContext = getApolloContext();\n    return (React__namespace.createElement(ApolloContext.Consumer, null, function (context) {\n        __DEV__ ? globals.invariant(context && context.client, 'Could not find \"client\" in the context of ApolloConsumer. ' +\n            'Wrap the root component in an <ApolloProvider>.') : globals.invariant(context && context.client, 27);\n        return props.children(context.client);\n    }));\n};\n\nvar ApolloProvider = function (_a) {\n    var client = _a.client, children = _a.children;\n    var ApolloContext = getApolloContext();\n    return (React__namespace.createElement(ApolloContext.Consumer, null, function (context) {\n        if (context === void 0) { context = {}; }\n        if (client && context.client !== client) {\n            context = Object.assign({}, context, { client: client });\n        }\n        __DEV__ ? globals.invariant(context.client, 'ApolloProvider was not passed a client instance. Make ' +\n            'sure you pass in your client via the \"client\" prop.') : globals.invariant(context.client, 28);\n        return (React__namespace.createElement(ApolloContext.Provider, { value: context }, children));\n    }));\n};\n\nexports.ApolloConsumer = ApolloConsumer;\nexports.ApolloProvider = ApolloProvider;\nexports.getApolloContext = getApolloContext;\nexports.resetApolloContext = getApolloContext;\n//# sourceMappingURL=context.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvcmVhY3QvY29udGV4dC9jb250ZXh0LmNqcz9jMmEzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE4QyxjQUFjOztBQUU1RCxjQUFjLG1CQUFPLENBQUMsNEZBQXlCO0FBQy9DLFlBQVksbUJBQU8sQ0FBQyxvQkFBTztBQUMzQixnQkFBZ0IsbUJBQU8sQ0FBQyw4RUFBaUI7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DO0FBQ0Esc0NBQXNDLFlBQVksaUJBQWlCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxpQkFBaUI7QUFDekYsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvcmVhY3QvY29udGV4dC9jb250ZXh0LmNqcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGdsb2JhbHMgPSByZXF1aXJlKCcuLi8uLi91dGlsaXRpZXMvZ2xvYmFscycpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciB1dGlsaXRpZXMgPSByZXF1aXJlKCcuLi8uLi91dGlsaXRpZXMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2UoZSkge1xuICAgIGlmIChlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7XG4gICAgdmFyIG4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmIChlKSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gZSkge1xuICAgICAgICAgICAgbltrXSA9IGVba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgbltcImRlZmF1bHRcIl0gPSBlO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgUmVhY3RfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZShSZWFjdCk7XG5cbnZhciBjb250ZXh0S2V5ID0gdXRpbGl0aWVzLmNhblVzZVN5bWJvbFxuICAgID8gU3ltYm9sLmZvcignX19BUE9MTE9fQ09OVEVYVF9fJylcbiAgICA6ICdfX0FQT0xMT19DT05URVhUX18nO1xuZnVuY3Rpb24gZ2V0QXBvbGxvQ29udGV4dCgpIHtcbiAgICB2YXIgY29udGV4dCA9IFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlQ29udGV4dFtjb250ZXh0S2V5XTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWN0X19uYW1lc3BhY2UuY3JlYXRlQ29udGV4dCwgY29udGV4dEtleSwge1xuICAgICAgICAgICAgdmFsdWU6IGNvbnRleHQgPSBSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUNvbnRleHQoe30pLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb250ZXh0LmRpc3BsYXlOYW1lID0gJ0Fwb2xsb0NvbnRleHQnO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dDtcbn1cblxudmFyIEFwb2xsb0NvbnN1bWVyID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIEFwb2xsb0NvbnRleHQgPSBnZXRBcG9sbG9Db250ZXh0KCk7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQXBvbGxvQ29udGV4dC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgX19ERVZfXyA/IGdsb2JhbHMuaW52YXJpYW50KGNvbnRleHQgJiYgY29udGV4dC5jbGllbnQsICdDb3VsZCBub3QgZmluZCBcImNsaWVudFwiIGluIHRoZSBjb250ZXh0IG9mIEFwb2xsb0NvbnN1bWVyLiAnICtcbiAgICAgICAgICAgICdXcmFwIHRoZSByb290IGNvbXBvbmVudCBpbiBhbiA8QXBvbGxvUHJvdmlkZXI+LicpIDogZ2xvYmFscy5pbnZhcmlhbnQoY29udGV4dCAmJiBjb250ZXh0LmNsaWVudCwgMjcpO1xuICAgICAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW4oY29udGV4dC5jbGllbnQpO1xuICAgIH0pKTtcbn07XG5cbnZhciBBcG9sbG9Qcm92aWRlciA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBjbGllbnQgPSBfYS5jbGllbnQsIGNoaWxkcmVuID0gX2EuY2hpbGRyZW47XG4gICAgdmFyIEFwb2xsb0NvbnRleHQgPSBnZXRBcG9sbG9Db250ZXh0KCk7XG4gICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQXBvbGxvQ29udGV4dC5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgeyBjb250ZXh0ID0ge307IH1cbiAgICAgICAgaWYgKGNsaWVudCAmJiBjb250ZXh0LmNsaWVudCAhPT0gY2xpZW50KSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gT2JqZWN0LmFzc2lnbih7fSwgY29udGV4dCwgeyBjbGllbnQ6IGNsaWVudCB9KTtcbiAgICAgICAgfVxuICAgICAgICBfX0RFVl9fID8gZ2xvYmFscy5pbnZhcmlhbnQoY29udGV4dC5jbGllbnQsICdBcG9sbG9Qcm92aWRlciB3YXMgbm90IHBhc3NlZCBhIGNsaWVudCBpbnN0YW5jZS4gTWFrZSAnICtcbiAgICAgICAgICAgICdzdXJlIHlvdSBwYXNzIGluIHlvdXIgY2xpZW50IHZpYSB0aGUgXCJjbGllbnRcIiBwcm9wLicpIDogZ2xvYmFscy5pbnZhcmlhbnQoY29udGV4dC5jbGllbnQsIDI4KTtcbiAgICAgICAgcmV0dXJuIChSZWFjdF9fbmFtZXNwYWNlLmNyZWF0ZUVsZW1lbnQoQXBvbGxvQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dCB9LCBjaGlsZHJlbikpO1xuICAgIH0pKTtcbn07XG5cbmV4cG9ydHMuQXBvbGxvQ29uc3VtZXIgPSBBcG9sbG9Db25zdW1lcjtcbmV4cG9ydHMuQXBvbGxvUHJvdmlkZXIgPSBBcG9sbG9Qcm92aWRlcjtcbmV4cG9ydHMuZ2V0QXBvbGxvQ29udGV4dCA9IGdldEFwb2xsb0NvbnRleHQ7XG5leHBvcnRzLnJlc2V0QXBvbGxvQ29udGV4dCA9IGdldEFwb2xsb0NvbnRleHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250ZXh0LmNqcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@apollo/client/react/context/context.cjs\n");

/***/ }),

/***/ "./node_modules/@apollo/client/react/hooks/hooks.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/@apollo/client/react/hooks/hooks.cjs ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar globals = __webpack_require__(/*! ../../utilities/globals */ \"./node_modules/@apollo/client/utilities/globals/globals.cjs\");\nvar React = __webpack_require__(/*! react */ \"react\");\nvar context = __webpack_require__(/*! ../context */ \"./node_modules/@apollo/client/react/context/context.cjs\");\nvar tslib = __webpack_require__(/*! tslib */ \"tslib\");\nvar utilities = __webpack_require__(/*! ../../utilities */ \"./node_modules/@apollo/client/utilities/utilities.cjs\");\nvar equality = __webpack_require__(/*! @wry/equality */ \"@wry/equality\");\nvar core = __webpack_require__(/*! ../../core */ \"./node_modules/@apollo/client/core/core.cjs\");\nvar errors = __webpack_require__(/*! ../../errors */ \"./node_modules/@apollo/client/errors/errors.cjs\");\nvar parser = __webpack_require__(/*! ../parser */ \"./node_modules/@apollo/client/react/parser/parser.cjs\");\n\nfunction _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n        for (var k in e) {\n            n[k] = e[k];\n        }\n    }\n    n[\"default\"] = e;\n    return Object.freeze(n);\n}\n\nvar React__namespace = /*#__PURE__*/_interopNamespace(React);\n\nfunction useApolloClient(override) {\n    var context$1 = React.useContext(context.getApolloContext());\n    var client = override || context$1.client;\n    __DEV__ ? globals.invariant(!!client, 'Could not find \"client\" in the context or passed in as an option. ' +\n        'Wrap the root component in an <ApolloProvider>, or pass an ApolloClient ' +\n        'instance in via options.') : globals.invariant(!!client, 31);\n    return client;\n}\n\nvar didWarnUncachedGetSnapshot = false;\nvar uSESKey = \"useSyncExternalStore\";\nvar realHook = React__namespace[uSESKey];\nvar useSyncExternalStore = realHook || (function (subscribe, getSnapshot, getServerSnapshot) {\n    var value = getSnapshot();\n    if (__DEV__ &&\n        !didWarnUncachedGetSnapshot &&\n        value !== getSnapshot()) {\n        didWarnUncachedGetSnapshot = true;\n        __DEV__ && globals.invariant.error('The result of getSnapshot should be cached to avoid an infinite loop');\n    }\n    var _a = React__namespace.useState({ inst: { value: value, getSnapshot: getSnapshot } }), inst = _a[0].inst, forceUpdate = _a[1];\n    if (utilities.canUseLayoutEffect) {\n        React__namespace.useLayoutEffect(function () {\n            Object.assign(inst, { value: value, getSnapshot: getSnapshot });\n            if (checkIfSnapshotChanged(inst)) {\n                forceUpdate({ inst: inst });\n            }\n        }, [subscribe, value, getSnapshot]);\n    }\n    else {\n        Object.assign(inst, { value: value, getSnapshot: getSnapshot });\n    }\n    React__namespace.useEffect(function () {\n        if (checkIfSnapshotChanged(inst)) {\n            forceUpdate({ inst: inst });\n        }\n        return subscribe(function handleStoreChange() {\n            if (checkIfSnapshotChanged(inst)) {\n                forceUpdate({ inst: inst });\n            }\n        });\n    }, [subscribe]);\n    return value;\n});\nfunction checkIfSnapshotChanged(_a) {\n    var value = _a.value, getSnapshot = _a.getSnapshot;\n    try {\n        return value !== getSnapshot();\n    }\n    catch (_b) {\n        return true;\n    }\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction useQuery(query, options) {\n    if (options === void 0) { options = Object.create(null); }\n    return useInternalState(useApolloClient(options.client), query).useQuery(options);\n}\nfunction useInternalState(client, query) {\n    var stateRef = React.useRef();\n    if (!stateRef.current ||\n        client !== stateRef.current.client ||\n        query !== stateRef.current.query) {\n        stateRef.current = new InternalState(client, query, stateRef.current);\n    }\n    var state = stateRef.current;\n    var _a = React.useState(0); _a[0]; var setTick = _a[1];\n    state.forceUpdate = function () {\n        setTick(function (tick) { return tick + 1; });\n    };\n    return state;\n}\nvar InternalState = (function () {\n    function InternalState(client, query, previous) {\n        this.client = client;\n        this.query = query;\n        this.asyncResolveFns = new Set();\n        this.optionsToIgnoreOnce = new (utilities.canUseWeakSet ? WeakSet : Set)();\n        this.ssrDisabledResult = utilities.maybeDeepFreeze({\n            loading: true,\n            data: void 0,\n            error: void 0,\n            networkStatus: core.NetworkStatus.loading,\n        });\n        this.skipStandbyResult = utilities.maybeDeepFreeze({\n            loading: false,\n            data: void 0,\n            error: void 0,\n            networkStatus: core.NetworkStatus.ready,\n        });\n        this.toQueryResultCache = new (utilities.canUseWeakMap ? WeakMap : Map)();\n        parser.verifyDocumentType(query, parser.DocumentType.Query);\n        var previousResult = previous && previous.result;\n        var previousData = previousResult && previousResult.data;\n        if (previousData) {\n            this.previousData = previousData;\n        }\n    }\n    InternalState.prototype.forceUpdate = function () {\n        __DEV__ && globals.invariant.warn(\"Calling default no-op implementation of InternalState#forceUpdate\");\n    };\n    InternalState.prototype.asyncUpdate = function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this.asyncResolveFns.add(resolve);\n            _this.optionsToIgnoreOnce.add(_this.watchQueryOptions);\n            _this.forceUpdate();\n        });\n    };\n    InternalState.prototype.useQuery = function (options) {\n        var _this = this;\n        this.renderPromises = React.useContext(context.getApolloContext()).renderPromises;\n        this.useOptions(options);\n        var obsQuery = this.useObservableQuery();\n        var result = useSyncExternalStore(React.useCallback(function () {\n            if (_this.renderPromises) {\n                return function () { };\n            }\n            var onNext = function () {\n                var previousResult = _this.result;\n                var result = obsQuery.getCurrentResult();\n                if (previousResult &&\n                    previousResult.loading === result.loading &&\n                    previousResult.networkStatus === result.networkStatus &&\n                    equality.equal(previousResult.data, result.data)) {\n                    return;\n                }\n                _this.setResult(result);\n            };\n            var onError = function (error) {\n                var last = obsQuery[\"last\"];\n                subscription.unsubscribe();\n                try {\n                    obsQuery.resetLastResults();\n                    subscription = obsQuery.subscribe(onNext, onError);\n                }\n                finally {\n                    obsQuery[\"last\"] = last;\n                }\n                if (!hasOwnProperty.call(error, 'graphQLErrors')) {\n                    throw error;\n                }\n                var previousResult = _this.result;\n                if (!previousResult ||\n                    (previousResult && previousResult.loading) ||\n                    !equality.equal(error, previousResult.error)) {\n                    _this.setResult({\n                        data: (previousResult && previousResult.data),\n                        error: error,\n                        loading: false,\n                        networkStatus: core.NetworkStatus.error,\n                    });\n                }\n            };\n            var subscription = obsQuery.subscribe(onNext, onError);\n            return function () { return subscription.unsubscribe(); };\n        }, [\n            obsQuery,\n            this.renderPromises,\n            this.client.disableNetworkFetches,\n        ]), function () { return _this.getCurrentResult(); }, function () { return _this.getCurrentResult(); });\n        this.unsafeHandlePartialRefetch(result);\n        var queryResult = this.toQueryResult(result);\n        if (!queryResult.loading && this.asyncResolveFns.size) {\n            this.asyncResolveFns.forEach(function (resolve) { return resolve(queryResult); });\n            this.asyncResolveFns.clear();\n        }\n        return queryResult;\n    };\n    InternalState.prototype.useOptions = function (options) {\n        var _a;\n        var watchQueryOptions = this.createWatchQueryOptions(this.queryHookOptions = options);\n        var currentWatchQueryOptions = this.watchQueryOptions;\n        if (this.optionsToIgnoreOnce.has(currentWatchQueryOptions) ||\n            !equality.equal(watchQueryOptions, currentWatchQueryOptions)) {\n            this.watchQueryOptions = watchQueryOptions;\n            if (currentWatchQueryOptions && this.observable) {\n                this.optionsToIgnoreOnce.delete(currentWatchQueryOptions);\n                this.observable.reobserve(this.getObsQueryOptions());\n                this.previousData = ((_a = this.result) === null || _a === void 0 ? void 0 : _a.data) || this.previousData;\n                this.result = void 0;\n            }\n        }\n        this.onCompleted = options.onCompleted || InternalState.prototype.onCompleted;\n        this.onError = options.onError || InternalState.prototype.onError;\n        if ((this.renderPromises || this.client.disableNetworkFetches) &&\n            this.queryHookOptions.ssr === false &&\n            !this.queryHookOptions.skip) {\n            this.result = this.ssrDisabledResult;\n        }\n        else if (this.queryHookOptions.skip ||\n            this.watchQueryOptions.fetchPolicy === 'standby') {\n            this.result = this.skipStandbyResult;\n        }\n        else if (this.result === this.ssrDisabledResult ||\n            this.result === this.skipStandbyResult) {\n            this.result = void 0;\n        }\n    };\n    InternalState.prototype.getObsQueryOptions = function () {\n        var toMerge = [];\n        var globalDefaults = this.client.defaultOptions.watchQuery;\n        if (globalDefaults)\n            toMerge.push(globalDefaults);\n        if (this.queryHookOptions.defaultOptions) {\n            toMerge.push(this.queryHookOptions.defaultOptions);\n        }\n        toMerge.push(utilities.compact(this.observable && this.observable.options, this.watchQueryOptions));\n        return toMerge.reduce(core.mergeOptions);\n    };\n    InternalState.prototype.createWatchQueryOptions = function (_a) {\n        var _b;\n        if (_a === void 0) { _a = {}; }\n        var skip = _a.skip; _a.ssr; _a.onCompleted; _a.onError; _a.defaultOptions; var otherOptions = tslib.__rest(_a, [\"skip\", \"ssr\", \"onCompleted\", \"onError\", \"defaultOptions\"]);\n        var watchQueryOptions = Object.assign(otherOptions, { query: this.query });\n        if (this.renderPromises &&\n            (watchQueryOptions.fetchPolicy === 'network-only' ||\n                watchQueryOptions.fetchPolicy === 'cache-and-network')) {\n            watchQueryOptions.fetchPolicy = 'cache-first';\n        }\n        if (!watchQueryOptions.variables) {\n            watchQueryOptions.variables = {};\n        }\n        if (skip) {\n            var _c = watchQueryOptions.fetchPolicy, fetchPolicy = _c === void 0 ? this.getDefaultFetchPolicy() : _c, _d = watchQueryOptions.initialFetchPolicy, initialFetchPolicy = _d === void 0 ? fetchPolicy : _d;\n            Object.assign(watchQueryOptions, {\n                initialFetchPolicy: initialFetchPolicy,\n                fetchPolicy: 'standby',\n            });\n        }\n        else if (!watchQueryOptions.fetchPolicy) {\n            watchQueryOptions.fetchPolicy =\n                ((_b = this.observable) === null || _b === void 0 ? void 0 : _b.options.initialFetchPolicy) ||\n                    this.getDefaultFetchPolicy();\n        }\n        return watchQueryOptions;\n    };\n    InternalState.prototype.getDefaultFetchPolicy = function () {\n        var _a, _b;\n        return (((_a = this.queryHookOptions.defaultOptions) === null || _a === void 0 ? void 0 : _a.fetchPolicy) ||\n            ((_b = this.client.defaultOptions.watchQuery) === null || _b === void 0 ? void 0 : _b.fetchPolicy) ||\n            \"cache-first\");\n    };\n    InternalState.prototype.onCompleted = function (data) { };\n    InternalState.prototype.onError = function (error) { };\n    InternalState.prototype.useObservableQuery = function () {\n        var obsQuery = this.observable =\n            this.renderPromises\n                && this.renderPromises.getSSRObservable(this.watchQueryOptions)\n                || this.observable\n                || this.client.watchQuery(this.getObsQueryOptions());\n        this.obsQueryFields = React.useMemo(function () { return ({\n            refetch: obsQuery.refetch.bind(obsQuery),\n            reobserve: obsQuery.reobserve.bind(obsQuery),\n            fetchMore: obsQuery.fetchMore.bind(obsQuery),\n            updateQuery: obsQuery.updateQuery.bind(obsQuery),\n            startPolling: obsQuery.startPolling.bind(obsQuery),\n            stopPolling: obsQuery.stopPolling.bind(obsQuery),\n            subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery),\n        }); }, [obsQuery]);\n        var ssrAllowed = !(this.queryHookOptions.ssr === false ||\n            this.queryHookOptions.skip);\n        if (this.renderPromises && ssrAllowed) {\n            this.renderPromises.registerSSRObservable(obsQuery);\n            if (obsQuery.getCurrentResult().loading) {\n                this.renderPromises.addObservableQueryPromise(obsQuery);\n            }\n        }\n        return obsQuery;\n    };\n    InternalState.prototype.setResult = function (nextResult) {\n        var previousResult = this.result;\n        if (previousResult && previousResult.data) {\n            this.previousData = previousResult.data;\n        }\n        this.result = nextResult;\n        this.forceUpdate();\n        this.handleErrorOrCompleted(nextResult);\n    };\n    InternalState.prototype.handleErrorOrCompleted = function (result) {\n        var _this = this;\n        if (!result.loading) {\n            Promise.resolve().then(function () {\n                if (result.error) {\n                    _this.onError(result.error);\n                }\n                else if (result.data) {\n                    _this.onCompleted(result.data);\n                }\n            }).catch(function (error) {\n                __DEV__ && globals.invariant.warn(error);\n            });\n        }\n    };\n    InternalState.prototype.getCurrentResult = function () {\n        if (!this.result) {\n            this.handleErrorOrCompleted(this.result = this.observable.getCurrentResult());\n        }\n        return this.result;\n    };\n    InternalState.prototype.toQueryResult = function (result) {\n        var queryResult = this.toQueryResultCache.get(result);\n        if (queryResult)\n            return queryResult;\n        var data = result.data; result.partial; var resultWithoutPartial = tslib.__rest(result, [\"data\", \"partial\"]);\n        this.toQueryResultCache.set(result, queryResult = tslib.__assign(tslib.__assign(tslib.__assign({ data: data }, resultWithoutPartial), this.obsQueryFields), { client: this.client, observable: this.observable, variables: this.observable.variables, called: !this.queryHookOptions.skip, previousData: this.previousData }));\n        if (!queryResult.error && utilities.isNonEmptyArray(result.errors)) {\n            queryResult.error = new errors.ApolloError({ graphQLErrors: result.errors });\n        }\n        return queryResult;\n    };\n    InternalState.prototype.unsafeHandlePartialRefetch = function (result) {\n        if (result.partial &&\n            this.queryHookOptions.partialRefetch &&\n            !result.loading &&\n            (!result.data || Object.keys(result.data).length === 0) &&\n            this.observable.options.fetchPolicy !== 'cache-only') {\n            Object.assign(result, {\n                loading: true,\n                networkStatus: core.NetworkStatus.refetch,\n            });\n            this.observable.refetch();\n        }\n    };\n    return InternalState;\n}());\n\nvar EAGER_METHODS = [\n    'refetch',\n    'reobserve',\n    'fetchMore',\n    'updateQuery',\n    'startPolling',\n    'subscribeToMore',\n];\nfunction useLazyQuery(query, options) {\n    var internalState = useInternalState(useApolloClient(options && options.client), query);\n    var execOptionsRef = React.useRef();\n    var merged = execOptionsRef.current\n        ? utilities.mergeOptions(options, execOptionsRef.current)\n        : options;\n    var useQueryResult = internalState.useQuery(tslib.__assign(tslib.__assign({}, merged), { skip: !execOptionsRef.current }));\n    var initialFetchPolicy = useQueryResult.observable.options.initialFetchPolicy ||\n        internalState.getDefaultFetchPolicy();\n    var result = Object.assign(useQueryResult, {\n        called: !!execOptionsRef.current,\n    });\n    var eagerMethods = React.useMemo(function () {\n        var eagerMethods = {};\n        var _loop_1 = function (key) {\n            var method = result[key];\n            eagerMethods[key] = function () {\n                if (!execOptionsRef.current) {\n                    execOptionsRef.current = Object.create(null);\n                    internalState.forceUpdate();\n                }\n                return method.apply(this, arguments);\n            };\n        };\n        for (var _i = 0, EAGER_METHODS_1 = EAGER_METHODS; _i < EAGER_METHODS_1.length; _i++) {\n            var key = EAGER_METHODS_1[_i];\n            _loop_1(key);\n        }\n        return eagerMethods;\n    }, []);\n    Object.assign(result, eagerMethods);\n    var execute = React.useCallback(function (executeOptions) {\n        execOptionsRef.current = executeOptions ? tslib.__assign(tslib.__assign({}, executeOptions), { fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy }) : {\n            fetchPolicy: initialFetchPolicy,\n        };\n        var promise = internalState\n            .asyncUpdate()\n            .then(function (queryResult) { return Object.assign(queryResult, eagerMethods); });\n        promise.catch(function () { });\n        return promise;\n    }, []);\n    return [execute, result];\n}\n\nfunction useMutation(mutation, options) {\n    var client = useApolloClient(options === null || options === void 0 ? void 0 : options.client);\n    parser.verifyDocumentType(mutation, parser.DocumentType.Mutation);\n    var _a = React.useState({\n        called: false,\n        loading: false,\n        client: client,\n    }), result = _a[0], setResult = _a[1];\n    var ref = React.useRef({\n        result: result,\n        mutationId: 0,\n        isMounted: true,\n        client: client,\n        mutation: mutation,\n        options: options,\n    });\n    {\n        Object.assign(ref.current, { client: client, options: options, mutation: mutation });\n    }\n    var execute = React.useCallback(function (executeOptions) {\n        if (executeOptions === void 0) { executeOptions = {}; }\n        var _a = ref.current, client = _a.client, options = _a.options, mutation = _a.mutation;\n        var baseOptions = tslib.__assign(tslib.__assign({}, options), { mutation: mutation });\n        if (!ref.current.result.loading && !baseOptions.ignoreResults && ref.current.isMounted) {\n            setResult(ref.current.result = {\n                loading: true,\n                error: void 0,\n                data: void 0,\n                called: true,\n                client: client,\n            });\n        }\n        var mutationId = ++ref.current.mutationId;\n        var clientOptions = core.mergeOptions(baseOptions, executeOptions);\n        return client.mutate(clientOptions).then(function (response) {\n            var _a, _b, _c;\n            var data = response.data, errors$1 = response.errors;\n            var error = errors$1 && errors$1.length > 0\n                ? new errors.ApolloError({ graphQLErrors: errors$1 })\n                : void 0;\n            if (mutationId === ref.current.mutationId &&\n                !clientOptions.ignoreResults) {\n                var result_1 = {\n                    called: true,\n                    loading: false,\n                    data: data,\n                    error: error,\n                    client: client,\n                };\n                if (ref.current.isMounted && !equality.equal(ref.current.result, result_1)) {\n                    setResult(ref.current.result = result_1);\n                }\n            }\n            (_b = (_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.onCompleted) === null || _b === void 0 ? void 0 : _b.call(_a, response.data, clientOptions);\n            (_c = executeOptions.onCompleted) === null || _c === void 0 ? void 0 : _c.call(executeOptions, response.data, clientOptions);\n            return response;\n        }).catch(function (error) {\n            var _a, _b, _c, _d;\n            if (mutationId === ref.current.mutationId &&\n                ref.current.isMounted) {\n                var result_2 = {\n                    loading: false,\n                    error: error,\n                    data: void 0,\n                    called: true,\n                    client: client,\n                };\n                if (!equality.equal(ref.current.result, result_2)) {\n                    setResult(ref.current.result = result_2);\n                }\n            }\n            if (((_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.onError) || clientOptions.onError) {\n                (_c = (_b = ref.current.options) === null || _b === void 0 ? void 0 : _b.onError) === null || _c === void 0 ? void 0 : _c.call(_b, error, clientOptions);\n                (_d = executeOptions.onError) === null || _d === void 0 ? void 0 : _d.call(executeOptions, error, clientOptions);\n                return { data: void 0, errors: error };\n            }\n            throw error;\n        });\n    }, []);\n    var reset = React.useCallback(function () {\n        if (ref.current.isMounted) {\n            setResult({ called: false, loading: false, client: client });\n        }\n    }, []);\n    React.useEffect(function () {\n        ref.current.isMounted = true;\n        return function () {\n            ref.current.isMounted = false;\n        };\n    }, []);\n    return [execute, tslib.__assign({ reset: reset }, result)];\n}\n\nfunction useSubscription(subscription, options) {\n    var hasIssuedDeprecationWarningRef = React.useRef(false);\n    var client = useApolloClient(options === null || options === void 0 ? void 0 : options.client);\n    parser.verifyDocumentType(subscription, parser.DocumentType.Subscription);\n    var _a = React.useState({\n        loading: !(options === null || options === void 0 ? void 0 : options.skip),\n        error: void 0,\n        data: void 0,\n        variables: options === null || options === void 0 ? void 0 : options.variables,\n    }), result = _a[0], setResult = _a[1];\n    if (!hasIssuedDeprecationWarningRef.current) {\n        hasIssuedDeprecationWarningRef.current = true;\n        if (options === null || options === void 0 ? void 0 : options.onSubscriptionData) {\n            __DEV__ && globals.invariant.warn(options.onData\n                ? \"'useSubscription' supports only the 'onSubscriptionData' or 'onData' option, but not both. Only the 'onData' option will be used.\"\n                : \"'onSubscriptionData' is deprecated and will be removed in a future major version. Please use the 'onData' option instead.\");\n        }\n        if (options === null || options === void 0 ? void 0 : options.onSubscriptionComplete) {\n            __DEV__ && globals.invariant.warn(options.onComplete\n                ? \"'useSubscription' supports only the 'onSubscriptionComplete' or 'onComplete' option, but not both. Only the 'onComplete' option will be used.\"\n                : \"'onSubscriptionComplete' is deprecated and will be removed in a future major version. Please use the 'onComplete' option instead.\");\n        }\n    }\n    var _b = React.useState(function () {\n        if (options === null || options === void 0 ? void 0 : options.skip) {\n            return null;\n        }\n        return client.subscribe({\n            query: subscription,\n            variables: options === null || options === void 0 ? void 0 : options.variables,\n            fetchPolicy: options === null || options === void 0 ? void 0 : options.fetchPolicy,\n            context: options === null || options === void 0 ? void 0 : options.context,\n        });\n    }), observable = _b[0], setObservable = _b[1];\n    var canResetObservableRef = React.useRef(false);\n    React.useEffect(function () {\n        return function () {\n            canResetObservableRef.current = true;\n        };\n    }, []);\n    var ref = React.useRef({ client: client, subscription: subscription, options: options });\n    React.useEffect(function () {\n        var _a, _b, _c, _d;\n        var shouldResubscribe = options === null || options === void 0 ? void 0 : options.shouldResubscribe;\n        if (typeof shouldResubscribe === 'function') {\n            shouldResubscribe = !!shouldResubscribe(options);\n        }\n        if (options === null || options === void 0 ? void 0 : options.skip) {\n            if (!(options === null || options === void 0 ? void 0 : options.skip) !== !((_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.skip) || canResetObservableRef.current) {\n                setResult({\n                    loading: false,\n                    data: void 0,\n                    error: void 0,\n                    variables: options === null || options === void 0 ? void 0 : options.variables,\n                });\n                setObservable(null);\n                canResetObservableRef.current = false;\n            }\n        }\n        else if ((shouldResubscribe !== false &&\n            (client !== ref.current.client ||\n                subscription !== ref.current.subscription ||\n                (options === null || options === void 0 ? void 0 : options.fetchPolicy) !== ((_b = ref.current.options) === null || _b === void 0 ? void 0 : _b.fetchPolicy) ||\n                !(options === null || options === void 0 ? void 0 : options.skip) !== !((_c = ref.current.options) === null || _c === void 0 ? void 0 : _c.skip) ||\n                !equality.equal(options === null || options === void 0 ? void 0 : options.variables, (_d = ref.current.options) === null || _d === void 0 ? void 0 : _d.variables))) ||\n            canResetObservableRef.current) {\n            setResult({\n                loading: true,\n                data: void 0,\n                error: void 0,\n                variables: options === null || options === void 0 ? void 0 : options.variables,\n            });\n            setObservable(client.subscribe({\n                query: subscription,\n                variables: options === null || options === void 0 ? void 0 : options.variables,\n                fetchPolicy: options === null || options === void 0 ? void 0 : options.fetchPolicy,\n                context: options === null || options === void 0 ? void 0 : options.context,\n            }));\n            canResetObservableRef.current = false;\n        }\n        Object.assign(ref.current, { client: client, subscription: subscription, options: options });\n    }, [client, subscription, options, canResetObservableRef.current]);\n    React.useEffect(function () {\n        if (!observable) {\n            return;\n        }\n        var subscription = observable.subscribe({\n            next: function (fetchResult) {\n                var _a, _b;\n                var result = {\n                    loading: false,\n                    data: fetchResult.data,\n                    error: void 0,\n                    variables: options === null || options === void 0 ? void 0 : options.variables,\n                };\n                setResult(result);\n                if ((_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.onData) {\n                    ref.current.options.onData({\n                        client: client,\n                        data: result\n                    });\n                }\n                else if ((_b = ref.current.options) === null || _b === void 0 ? void 0 : _b.onSubscriptionData) {\n                    ref.current.options.onSubscriptionData({\n                        client: client,\n                        subscriptionData: result\n                    });\n                }\n            },\n            error: function (error) {\n                var _a, _b;\n                setResult({\n                    loading: false,\n                    data: void 0,\n                    error: error,\n                    variables: options === null || options === void 0 ? void 0 : options.variables,\n                });\n                (_b = (_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.onError) === null || _b === void 0 ? void 0 : _b.call(_a, error);\n            },\n            complete: function () {\n                var _a, _b;\n                if ((_a = ref.current.options) === null || _a === void 0 ? void 0 : _a.onComplete) {\n                    ref.current.options.onComplete();\n                }\n                else if ((_b = ref.current.options) === null || _b === void 0 ? void 0 : _b.onSubscriptionComplete) {\n                    ref.current.options.onSubscriptionComplete();\n                }\n            },\n        });\n        return function () {\n            subscription.unsubscribe();\n        };\n    }, [observable]);\n    return result;\n}\n\nfunction useReactiveVar(rv) {\n    var value = rv();\n    var setValue = React.useState(value)[1];\n    React.useEffect(function () {\n        var probablySameValue = rv();\n        if (value !== probablySameValue) {\n            setValue(probablySameValue);\n        }\n        else {\n            return rv.onNextChange(setValue);\n        }\n    }, [value]);\n    return value;\n}\n\nfunction useFragment_experimental(options) {\n    var cache = useApolloClient().cache;\n    var fragment = options.fragment, fragmentName = options.fragmentName, from = options.from, _a = options.optimistic, optimistic = _a === void 0 ? true : _a, rest = tslib.__rest(options, [\"fragment\", \"fragmentName\", \"from\", \"optimistic\"]);\n    var diffOptions = tslib.__assign(tslib.__assign({}, rest), { id: typeof from === \"string\" ? from : cache.identify(from), query: cache[\"getFragmentDoc\"](fragment, fragmentName), optimistic: optimistic });\n    var resultRef = React.useRef();\n    var latestDiff = cache.diff(diffOptions);\n    return useSyncExternalStore(function (forceUpdate) {\n        return cache.watch(tslib.__assign(tslib.__assign({}, diffOptions), { immediate: true, callback: function (diff) {\n                if (!equality.equal(diff, latestDiff)) {\n                    resultRef.current = diffToResult(latestDiff = diff);\n                    forceUpdate();\n                }\n            } }));\n    }, function () {\n        var latestDiffToResult = diffToResult(latestDiff);\n        return resultRef.current &&\n            equality.equal(resultRef.current.data, latestDiffToResult.data)\n            ? resultRef.current\n            : (resultRef.current = latestDiffToResult);\n    });\n}\nfunction diffToResult(diff) {\n    var result = {\n        data: diff.result,\n        complete: !!diff.complete,\n    };\n    if (diff.missing) {\n        result.missing = utilities.mergeDeepArray(diff.missing.map(function (error) { return error.missing; }));\n    }\n    return result;\n}\n\nexports.useApolloClient = useApolloClient;\nexports.useFragment_experimental = useFragment_experimental;\nexports.useLazyQuery = useLazyQuery;\nexports.useMutation = useMutation;\nexports.useQuery = useQuery;\nexports.useReactiveVar = useReactiveVar;\nexports.useSubscription = useSubscription;\n//# sourceMappingURL=hooks.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvcmVhY3QvaG9va3MvaG9va3MuY2pzPzQ3NTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQThDLGNBQWM7O0FBRTVELGNBQWMsbUJBQU8sQ0FBQyw0RkFBeUI7QUFDL0MsWUFBWSxtQkFBTyxDQUFDLG9CQUFPO0FBQzNCLGNBQWMsbUJBQU8sQ0FBQywyRUFBWTtBQUNsQyxZQUFZLG1CQUFPLENBQUMsb0JBQU87QUFDM0IsZ0JBQWdCLG1CQUFPLENBQUMsOEVBQWlCO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyxvQ0FBZTtBQUN0QyxXQUFXLG1CQUFPLENBQUMsK0RBQVk7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLHFFQUFjO0FBQ25DLGFBQWEsbUJBQU8sQ0FBQyx3RUFBVzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUSx5Q0FBeUMsRUFBRTtBQUMzRjtBQUNBO0FBQ0EsaUNBQWlDLHlDQUF5QztBQUMxRTtBQUNBLDZCQUE2QixhQUFhO0FBQzFDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw2QkFBNkIseUNBQXlDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixhQUFhO0FBQzFDO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QiwrQkFBK0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixzQkFBc0IsRUFBRTtBQUM3RztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9yZWFjdC9ob29rcy9ob29rcy5janMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBnbG9iYWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbGl0aWVzL2dsb2JhbHMnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgY29udGV4dCA9IHJlcXVpcmUoJy4uL2NvbnRleHQnKTtcbnZhciB0c2xpYiA9IHJlcXVpcmUoJ3RzbGliJyk7XG52YXIgdXRpbGl0aWVzID0gcmVxdWlyZSgnLi4vLi4vdXRpbGl0aWVzJyk7XG52YXIgZXF1YWxpdHkgPSByZXF1aXJlKCdAd3J5L2VxdWFsaXR5Jyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuLi8uLi9lcnJvcnMnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCcuLi9wYXJzZXInKTtcblxuZnVuY3Rpb24gX2ludGVyb3BOYW1lc3BhY2UoZSkge1xuICAgIGlmIChlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7XG4gICAgdmFyIG4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmIChlKSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gZSkge1xuICAgICAgICAgICAgbltrXSA9IGVba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgbltcImRlZmF1bHRcIl0gPSBlO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgUmVhY3RfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZShSZWFjdCk7XG5cbmZ1bmN0aW9uIHVzZUFwb2xsb0NsaWVudChvdmVycmlkZSkge1xuICAgIHZhciBjb250ZXh0JDEgPSBSZWFjdC51c2VDb250ZXh0KGNvbnRleHQuZ2V0QXBvbGxvQ29udGV4dCgpKTtcbiAgICB2YXIgY2xpZW50ID0gb3ZlcnJpZGUgfHwgY29udGV4dCQxLmNsaWVudDtcbiAgICBfX0RFVl9fID8gZ2xvYmFscy5pbnZhcmlhbnQoISFjbGllbnQsICdDb3VsZCBub3QgZmluZCBcImNsaWVudFwiIGluIHRoZSBjb250ZXh0IG9yIHBhc3NlZCBpbiBhcyBhbiBvcHRpb24uICcgK1xuICAgICAgICAnV3JhcCB0aGUgcm9vdCBjb21wb25lbnQgaW4gYW4gPEFwb2xsb1Byb3ZpZGVyPiwgb3IgcGFzcyBhbiBBcG9sbG9DbGllbnQgJyArXG4gICAgICAgICdpbnN0YW5jZSBpbiB2aWEgb3B0aW9ucy4nKSA6IGdsb2JhbHMuaW52YXJpYW50KCEhY2xpZW50LCAzMSk7XG4gICAgcmV0dXJuIGNsaWVudDtcbn1cblxudmFyIGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90ID0gZmFsc2U7XG52YXIgdVNFU0tleSA9IFwidXNlU3luY0V4dGVybmFsU3RvcmVcIjtcbnZhciByZWFsSG9vayA9IFJlYWN0X19uYW1lc3BhY2VbdVNFU0tleV07XG52YXIgdXNlU3luY0V4dGVybmFsU3RvcmUgPSByZWFsSG9vayB8fCAoZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgdmFyIHZhbHVlID0gZ2V0U25hcHNob3QoKTtcbiAgICBpZiAoX19ERVZfXyAmJlxuICAgICAgICAhZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgJiZcbiAgICAgICAgdmFsdWUgIT09IGdldFNuYXBzaG90KCkpIHtcbiAgICAgICAgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSB0cnVlO1xuICAgICAgICBfX0RFVl9fICYmIGdsb2JhbHMuaW52YXJpYW50LmVycm9yKCdUaGUgcmVzdWx0IG9mIGdldFNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCcpO1xuICAgIH1cbiAgICB2YXIgX2EgPSBSZWFjdF9fbmFtZXNwYWNlLnVzZVN0YXRlKHsgaW5zdDogeyB2YWx1ZTogdmFsdWUsIGdldFNuYXBzaG90OiBnZXRTbmFwc2hvdCB9IH0pLCBpbnN0ID0gX2FbMF0uaW5zdCwgZm9yY2VVcGRhdGUgPSBfYVsxXTtcbiAgICBpZiAodXRpbGl0aWVzLmNhblVzZUxheW91dEVmZmVjdCkge1xuICAgICAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUxheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGluc3QsIHsgdmFsdWU6IHZhbHVlLCBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3QgfSk7XG4gICAgICAgICAgICBpZiAoY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSkge1xuICAgICAgICAgICAgICAgIGZvcmNlVXBkYXRlKHsgaW5zdDogaW5zdCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW3N1YnNjcmliZSwgdmFsdWUsIGdldFNuYXBzaG90XSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBPYmplY3QuYXNzaWduKGluc3QsIHsgdmFsdWU6IHZhbHVlLCBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3QgfSk7XG4gICAgfVxuICAgIFJlYWN0X19uYW1lc3BhY2UudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpIHtcbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKHsgaW5zdDogaW5zdCB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3Vic2NyaWJlKGZ1bmN0aW9uIGhhbmRsZVN0b3JlQ2hhbmdlKCkge1xuICAgICAgICAgICAgaWYgKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpIHtcbiAgICAgICAgICAgICAgICBmb3JjZVVwZGF0ZSh7IGluc3Q6IGluc3QgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sIFtzdWJzY3JpYmVdKTtcbiAgICByZXR1cm4gdmFsdWU7XG59KTtcbmZ1bmN0aW9uIGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoX2EpIHtcbiAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZSwgZ2V0U25hcHNob3QgPSBfYS5nZXRTbmFwc2hvdDtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT09IGdldFNuYXBzaG90KCk7XG4gICAgfVxuICAgIGNhdGNoIChfYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiB1c2VRdWVyeShxdWVyeSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7IH1cbiAgICByZXR1cm4gdXNlSW50ZXJuYWxTdGF0ZSh1c2VBcG9sbG9DbGllbnQob3B0aW9ucy5jbGllbnQpLCBxdWVyeSkudXNlUXVlcnkob3B0aW9ucyk7XG59XG5mdW5jdGlvbiB1c2VJbnRlcm5hbFN0YXRlKGNsaWVudCwgcXVlcnkpIHtcbiAgICB2YXIgc3RhdGVSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgICBpZiAoIXN0YXRlUmVmLmN1cnJlbnQgfHxcbiAgICAgICAgY2xpZW50ICE9PSBzdGF0ZVJlZi5jdXJyZW50LmNsaWVudCB8fFxuICAgICAgICBxdWVyeSAhPT0gc3RhdGVSZWYuY3VycmVudC5xdWVyeSkge1xuICAgICAgICBzdGF0ZVJlZi5jdXJyZW50ID0gbmV3IEludGVybmFsU3RhdGUoY2xpZW50LCBxdWVyeSwgc3RhdGVSZWYuY3VycmVudCk7XG4gICAgfVxuICAgIHZhciBzdGF0ZSA9IHN0YXRlUmVmLmN1cnJlbnQ7XG4gICAgdmFyIF9hID0gUmVhY3QudXNlU3RhdGUoMCk7IF9hWzBdOyB2YXIgc2V0VGljayA9IF9hWzFdO1xuICAgIHN0YXRlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRUaWNrKGZ1bmN0aW9uICh0aWNrKSB7IHJldHVybiB0aWNrICsgMTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gc3RhdGU7XG59XG52YXIgSW50ZXJuYWxTdGF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW50ZXJuYWxTdGF0ZShjbGllbnQsIHF1ZXJ5LCBwcmV2aW91cykge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICB0aGlzLmFzeW5jUmVzb2x2ZUZucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zVG9JZ25vcmVPbmNlID0gbmV3ICh1dGlsaXRpZXMuY2FuVXNlV2Vha1NldCA/IFdlYWtTZXQgOiBTZXQpKCk7XG4gICAgICAgIHRoaXMuc3NyRGlzYWJsZWRSZXN1bHQgPSB1dGlsaXRpZXMubWF5YmVEZWVwRnJlZXplKHtcbiAgICAgICAgICAgIGxvYWRpbmc6IHRydWUsXG4gICAgICAgICAgICBkYXRhOiB2b2lkIDAsXG4gICAgICAgICAgICBlcnJvcjogdm9pZCAwLFxuICAgICAgICAgICAgbmV0d29ya1N0YXR1czogY29yZS5OZXR3b3JrU3RhdHVzLmxvYWRpbmcsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNraXBTdGFuZGJ5UmVzdWx0ID0gdXRpbGl0aWVzLm1heWJlRGVlcEZyZWV6ZSh7XG4gICAgICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGRhdGE6IHZvaWQgMCxcbiAgICAgICAgICAgIGVycm9yOiB2b2lkIDAsXG4gICAgICAgICAgICBuZXR3b3JrU3RhdHVzOiBjb3JlLk5ldHdvcmtTdGF0dXMucmVhZHksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRvUXVlcnlSZXN1bHRDYWNoZSA9IG5ldyAodXRpbGl0aWVzLmNhblVzZVdlYWtNYXAgPyBXZWFrTWFwIDogTWFwKSgpO1xuICAgICAgICBwYXJzZXIudmVyaWZ5RG9jdW1lbnRUeXBlKHF1ZXJ5LCBwYXJzZXIuRG9jdW1lbnRUeXBlLlF1ZXJ5KTtcbiAgICAgICAgdmFyIHByZXZpb3VzUmVzdWx0ID0gcHJldmlvdXMgJiYgcHJldmlvdXMucmVzdWx0O1xuICAgICAgICB2YXIgcHJldmlvdXNEYXRhID0gcHJldmlvdXNSZXN1bHQgJiYgcHJldmlvdXNSZXN1bHQuZGF0YTtcbiAgICAgICAgaWYgKHByZXZpb3VzRGF0YSkge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c0RhdGEgPSBwcmV2aW91c0RhdGE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgSW50ZXJuYWxTdGF0ZS5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9fREVWX18gJiYgZ2xvYmFscy5pbnZhcmlhbnQud2FybihcIkNhbGxpbmcgZGVmYXVsdCBuby1vcCBpbXBsZW1lbnRhdGlvbiBvZiBJbnRlcm5hbFN0YXRlI2ZvcmNlVXBkYXRlXCIpO1xuICAgIH07XG4gICAgSW50ZXJuYWxTdGF0ZS5wcm90b3R5cGUuYXN5bmNVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgX3RoaXMuYXN5bmNSZXNvbHZlRm5zLmFkZChyZXNvbHZlKTtcbiAgICAgICAgICAgIF90aGlzLm9wdGlvbnNUb0lnbm9yZU9uY2UuYWRkKF90aGlzLndhdGNoUXVlcnlPcHRpb25zKTtcbiAgICAgICAgICAgIF90aGlzLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSW50ZXJuYWxTdGF0ZS5wcm90b3R5cGUudXNlUXVlcnkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJlbmRlclByb21pc2VzID0gUmVhY3QudXNlQ29udGV4dChjb250ZXh0LmdldEFwb2xsb0NvbnRleHQoKSkucmVuZGVyUHJvbWlzZXM7XG4gICAgICAgIHRoaXMudXNlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdmFyIG9ic1F1ZXJ5ID0gdGhpcy51c2VPYnNlcnZhYmxlUXVlcnkoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlKFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5yZW5kZXJQcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb25OZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c1Jlc3VsdCA9IF90aGlzLnJlc3VsdDtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gb2JzUXVlcnkuZ2V0Q3VycmVudFJlc3VsdCgpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1Jlc3VsdCAmJlxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1Jlc3VsdC5sb2FkaW5nID09PSByZXN1bHQubG9hZGluZyAmJlxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1Jlc3VsdC5uZXR3b3JrU3RhdHVzID09PSByZXN1bHQubmV0d29ya1N0YXR1cyAmJlxuICAgICAgICAgICAgICAgICAgICBlcXVhbGl0eS5lcXVhbChwcmV2aW91c1Jlc3VsdC5kYXRhLCByZXN1bHQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRSZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgb25FcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHZhciBsYXN0ID0gb2JzUXVlcnlbXCJsYXN0XCJdO1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG9ic1F1ZXJ5LnJlc2V0TGFzdFJlc3VsdHMoKTtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gb2JzUXVlcnkuc3Vic2NyaWJlKG9uTmV4dCwgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBvYnNRdWVyeVtcImxhc3RcIl0gPSBsYXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwoZXJyb3IsICdncmFwaFFMRXJyb3JzJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c1Jlc3VsdCA9IF90aGlzLnJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXZpb3VzUmVzdWx0IHx8XG4gICAgICAgICAgICAgICAgICAgIChwcmV2aW91c1Jlc3VsdCAmJiBwcmV2aW91c1Jlc3VsdC5sb2FkaW5nKSB8fFxuICAgICAgICAgICAgICAgICAgICAhZXF1YWxpdHkuZXF1YWwoZXJyb3IsIHByZXZpb3VzUmVzdWx0LmVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRSZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKHByZXZpb3VzUmVzdWx0ICYmIHByZXZpb3VzUmVzdWx0LmRhdGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrU3RhdHVzOiBjb3JlLk5ldHdvcmtTdGF0dXMuZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gb2JzUXVlcnkuc3Vic2NyaWJlKG9uTmV4dCwgb25FcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7IH07XG4gICAgICAgIH0sIFtcbiAgICAgICAgICAgIG9ic1F1ZXJ5LFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJQcm9taXNlcyxcbiAgICAgICAgICAgIHRoaXMuY2xpZW50LmRpc2FibGVOZXR3b3JrRmV0Y2hlcyxcbiAgICAgICAgXSksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmdldEN1cnJlbnRSZXN1bHQoKTsgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2V0Q3VycmVudFJlc3VsdCgpOyB9KTtcbiAgICAgICAgdGhpcy51bnNhZmVIYW5kbGVQYXJ0aWFsUmVmZXRjaChyZXN1bHQpO1xuICAgICAgICB2YXIgcXVlcnlSZXN1bHQgPSB0aGlzLnRvUXVlcnlSZXN1bHQocmVzdWx0KTtcbiAgICAgICAgaWYgKCFxdWVyeVJlc3VsdC5sb2FkaW5nICYmIHRoaXMuYXN5bmNSZXNvbHZlRm5zLnNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuYXN5bmNSZXNvbHZlRm5zLmZvckVhY2goZnVuY3Rpb24gKHJlc29sdmUpIHsgcmV0dXJuIHJlc29sdmUocXVlcnlSZXN1bHQpOyB9KTtcbiAgICAgICAgICAgIHRoaXMuYXN5bmNSZXNvbHZlRm5zLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHF1ZXJ5UmVzdWx0O1xuICAgIH07XG4gICAgSW50ZXJuYWxTdGF0ZS5wcm90b3R5cGUudXNlT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIHdhdGNoUXVlcnlPcHRpb25zID0gdGhpcy5jcmVhdGVXYXRjaFF1ZXJ5T3B0aW9ucyh0aGlzLnF1ZXJ5SG9va09wdGlvbnMgPSBvcHRpb25zKTtcbiAgICAgICAgdmFyIGN1cnJlbnRXYXRjaFF1ZXJ5T3B0aW9ucyA9IHRoaXMud2F0Y2hRdWVyeU9wdGlvbnM7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNUb0lnbm9yZU9uY2UuaGFzKGN1cnJlbnRXYXRjaFF1ZXJ5T3B0aW9ucykgfHxcbiAgICAgICAgICAgICFlcXVhbGl0eS5lcXVhbCh3YXRjaFF1ZXJ5T3B0aW9ucywgY3VycmVudFdhdGNoUXVlcnlPcHRpb25zKSkge1xuICAgICAgICAgICAgdGhpcy53YXRjaFF1ZXJ5T3B0aW9ucyA9IHdhdGNoUXVlcnlPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRXYXRjaFF1ZXJ5T3B0aW9ucyAmJiB0aGlzLm9ic2VydmFibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNUb0lnbm9yZU9uY2UuZGVsZXRlKGN1cnJlbnRXYXRjaFF1ZXJ5T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZhYmxlLnJlb2JzZXJ2ZSh0aGlzLmdldE9ic1F1ZXJ5T3B0aW9ucygpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzRGF0YSA9ICgoX2EgPSB0aGlzLnJlc3VsdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRhdGEpIHx8IHRoaXMucHJldmlvdXNEYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gdm9pZCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMub25Db21wbGV0ZWQgPSBvcHRpb25zLm9uQ29tcGxldGVkIHx8IEludGVybmFsU3RhdGUucHJvdG90eXBlLm9uQ29tcGxldGVkO1xuICAgICAgICB0aGlzLm9uRXJyb3IgPSBvcHRpb25zLm9uRXJyb3IgfHwgSW50ZXJuYWxTdGF0ZS5wcm90b3R5cGUub25FcnJvcjtcbiAgICAgICAgaWYgKCh0aGlzLnJlbmRlclByb21pc2VzIHx8IHRoaXMuY2xpZW50LmRpc2FibGVOZXR3b3JrRmV0Y2hlcykgJiZcbiAgICAgICAgICAgIHRoaXMucXVlcnlIb29rT3B0aW9ucy5zc3IgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAhdGhpcy5xdWVyeUhvb2tPcHRpb25zLnNraXApIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gdGhpcy5zc3JEaXNhYmxlZFJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnF1ZXJ5SG9va09wdGlvbnMuc2tpcCB8fFxuICAgICAgICAgICAgdGhpcy53YXRjaFF1ZXJ5T3B0aW9ucy5mZXRjaFBvbGljeSA9PT0gJ3N0YW5kYnknKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHRoaXMuc2tpcFN0YW5kYnlSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5yZXN1bHQgPT09IHRoaXMuc3NyRGlzYWJsZWRSZXN1bHQgfHxcbiAgICAgICAgICAgIHRoaXMucmVzdWx0ID09PSB0aGlzLnNraXBTdGFuZGJ5UmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW50ZXJuYWxTdGF0ZS5wcm90b3R5cGUuZ2V0T2JzUXVlcnlPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG9NZXJnZSA9IFtdO1xuICAgICAgICB2YXIgZ2xvYmFsRGVmYXVsdHMgPSB0aGlzLmNsaWVudC5kZWZhdWx0T3B0aW9ucy53YXRjaFF1ZXJ5O1xuICAgICAgICBpZiAoZ2xvYmFsRGVmYXVsdHMpXG4gICAgICAgICAgICB0b01lcmdlLnB1c2goZ2xvYmFsRGVmYXVsdHMpO1xuICAgICAgICBpZiAodGhpcy5xdWVyeUhvb2tPcHRpb25zLmRlZmF1bHRPcHRpb25zKSB7XG4gICAgICAgICAgICB0b01lcmdlLnB1c2godGhpcy5xdWVyeUhvb2tPcHRpb25zLmRlZmF1bHRPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0b01lcmdlLnB1c2godXRpbGl0aWVzLmNvbXBhY3QodGhpcy5vYnNlcnZhYmxlICYmIHRoaXMub2JzZXJ2YWJsZS5vcHRpb25zLCB0aGlzLndhdGNoUXVlcnlPcHRpb25zKSk7XG4gICAgICAgIHJldHVybiB0b01lcmdlLnJlZHVjZShjb3JlLm1lcmdlT3B0aW9ucyk7XG4gICAgfTtcbiAgICBJbnRlcm5hbFN0YXRlLnByb3RvdHlwZS5jcmVhdGVXYXRjaFF1ZXJ5T3B0aW9ucyA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2I7XG4gICAgICAgIGlmIChfYSA9PT0gdm9pZCAwKSB7IF9hID0ge307IH1cbiAgICAgICAgdmFyIHNraXAgPSBfYS5za2lwOyBfYS5zc3I7IF9hLm9uQ29tcGxldGVkOyBfYS5vbkVycm9yOyBfYS5kZWZhdWx0T3B0aW9uczsgdmFyIG90aGVyT3B0aW9ucyA9IHRzbGliLl9fcmVzdChfYSwgW1wic2tpcFwiLCBcInNzclwiLCBcIm9uQ29tcGxldGVkXCIsIFwib25FcnJvclwiLCBcImRlZmF1bHRPcHRpb25zXCJdKTtcbiAgICAgICAgdmFyIHdhdGNoUXVlcnlPcHRpb25zID0gT2JqZWN0LmFzc2lnbihvdGhlck9wdGlvbnMsIHsgcXVlcnk6IHRoaXMucXVlcnkgfSk7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlclByb21pc2VzICYmXG4gICAgICAgICAgICAod2F0Y2hRdWVyeU9wdGlvbnMuZmV0Y2hQb2xpY3kgPT09ICduZXR3b3JrLW9ubHknIHx8XG4gICAgICAgICAgICAgICAgd2F0Y2hRdWVyeU9wdGlvbnMuZmV0Y2hQb2xpY3kgPT09ICdjYWNoZS1hbmQtbmV0d29yaycpKSB7XG4gICAgICAgICAgICB3YXRjaFF1ZXJ5T3B0aW9ucy5mZXRjaFBvbGljeSA9ICdjYWNoZS1maXJzdCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF3YXRjaFF1ZXJ5T3B0aW9ucy52YXJpYWJsZXMpIHtcbiAgICAgICAgICAgIHdhdGNoUXVlcnlPcHRpb25zLnZhcmlhYmxlcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChza2lwKSB7XG4gICAgICAgICAgICB2YXIgX2MgPSB3YXRjaFF1ZXJ5T3B0aW9ucy5mZXRjaFBvbGljeSwgZmV0Y2hQb2xpY3kgPSBfYyA9PT0gdm9pZCAwID8gdGhpcy5nZXREZWZhdWx0RmV0Y2hQb2xpY3koKSA6IF9jLCBfZCA9IHdhdGNoUXVlcnlPcHRpb25zLmluaXRpYWxGZXRjaFBvbGljeSwgaW5pdGlhbEZldGNoUG9saWN5ID0gX2QgPT09IHZvaWQgMCA/IGZldGNoUG9saWN5IDogX2Q7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHdhdGNoUXVlcnlPcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbEZldGNoUG9saWN5OiBpbml0aWFsRmV0Y2hQb2xpY3ksXG4gICAgICAgICAgICAgICAgZmV0Y2hQb2xpY3k6ICdzdGFuZGJ5JyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF3YXRjaFF1ZXJ5T3B0aW9ucy5mZXRjaFBvbGljeSkge1xuICAgICAgICAgICAgd2F0Y2hRdWVyeU9wdGlvbnMuZmV0Y2hQb2xpY3kgPVxuICAgICAgICAgICAgICAgICgoX2IgPSB0aGlzLm9ic2VydmFibGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vcHRpb25zLmluaXRpYWxGZXRjaFBvbGljeSkgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXREZWZhdWx0RmV0Y2hQb2xpY3koKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2F0Y2hRdWVyeU9wdGlvbnM7XG4gICAgfTtcbiAgICBJbnRlcm5hbFN0YXRlLnByb3RvdHlwZS5nZXREZWZhdWx0RmV0Y2hQb2xpY3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoKChfYSA9IHRoaXMucXVlcnlIb29rT3B0aW9ucy5kZWZhdWx0T3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZldGNoUG9saWN5KSB8fFxuICAgICAgICAgICAgKChfYiA9IHRoaXMuY2xpZW50LmRlZmF1bHRPcHRpb25zLndhdGNoUXVlcnkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5mZXRjaFBvbGljeSkgfHxcbiAgICAgICAgICAgIFwiY2FjaGUtZmlyc3RcIik7XG4gICAgfTtcbiAgICBJbnRlcm5hbFN0YXRlLnByb3RvdHlwZS5vbkNvbXBsZXRlZCA9IGZ1bmN0aW9uIChkYXRhKSB7IH07XG4gICAgSW50ZXJuYWxTdGF0ZS5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlcnJvcikgeyB9O1xuICAgIEludGVybmFsU3RhdGUucHJvdG90eXBlLnVzZU9ic2VydmFibGVRdWVyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9ic1F1ZXJ5ID0gdGhpcy5vYnNlcnZhYmxlID1cbiAgICAgICAgICAgIHRoaXMucmVuZGVyUHJvbWlzZXNcbiAgICAgICAgICAgICAgICAmJiB0aGlzLnJlbmRlclByb21pc2VzLmdldFNTUk9ic2VydmFibGUodGhpcy53YXRjaFF1ZXJ5T3B0aW9ucylcbiAgICAgICAgICAgICAgICB8fCB0aGlzLm9ic2VydmFibGVcbiAgICAgICAgICAgICAgICB8fCB0aGlzLmNsaWVudC53YXRjaFF1ZXJ5KHRoaXMuZ2V0T2JzUXVlcnlPcHRpb25zKCkpO1xuICAgICAgICB0aGlzLm9ic1F1ZXJ5RmllbGRzID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgcmVmZXRjaDogb2JzUXVlcnkucmVmZXRjaC5iaW5kKG9ic1F1ZXJ5KSxcbiAgICAgICAgICAgIHJlb2JzZXJ2ZTogb2JzUXVlcnkucmVvYnNlcnZlLmJpbmQob2JzUXVlcnkpLFxuICAgICAgICAgICAgZmV0Y2hNb3JlOiBvYnNRdWVyeS5mZXRjaE1vcmUuYmluZChvYnNRdWVyeSksXG4gICAgICAgICAgICB1cGRhdGVRdWVyeTogb2JzUXVlcnkudXBkYXRlUXVlcnkuYmluZChvYnNRdWVyeSksXG4gICAgICAgICAgICBzdGFydFBvbGxpbmc6IG9ic1F1ZXJ5LnN0YXJ0UG9sbGluZy5iaW5kKG9ic1F1ZXJ5KSxcbiAgICAgICAgICAgIHN0b3BQb2xsaW5nOiBvYnNRdWVyeS5zdG9wUG9sbGluZy5iaW5kKG9ic1F1ZXJ5KSxcbiAgICAgICAgICAgIHN1YnNjcmliZVRvTW9yZTogb2JzUXVlcnkuc3Vic2NyaWJlVG9Nb3JlLmJpbmQob2JzUXVlcnkpLFxuICAgICAgICB9KTsgfSwgW29ic1F1ZXJ5XSk7XG4gICAgICAgIHZhciBzc3JBbGxvd2VkID0gISh0aGlzLnF1ZXJ5SG9va09wdGlvbnMuc3NyID09PSBmYWxzZSB8fFxuICAgICAgICAgICAgdGhpcy5xdWVyeUhvb2tPcHRpb25zLnNraXApO1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJQcm9taXNlcyAmJiBzc3JBbGxvd2VkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclByb21pc2VzLnJlZ2lzdGVyU1NST2JzZXJ2YWJsZShvYnNRdWVyeSk7XG4gICAgICAgICAgICBpZiAob2JzUXVlcnkuZ2V0Q3VycmVudFJlc3VsdCgpLmxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclByb21pc2VzLmFkZE9ic2VydmFibGVRdWVyeVByb21pc2Uob2JzUXVlcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYnNRdWVyeTtcbiAgICB9O1xuICAgIEludGVybmFsU3RhdGUucHJvdG90eXBlLnNldFJlc3VsdCA9IGZ1bmN0aW9uIChuZXh0UmVzdWx0KSB7XG4gICAgICAgIHZhciBwcmV2aW91c1Jlc3VsdCA9IHRoaXMucmVzdWx0O1xuICAgICAgICBpZiAocHJldmlvdXNSZXN1bHQgJiYgcHJldmlvdXNSZXN1bHQuZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c0RhdGEgPSBwcmV2aW91c1Jlc3VsdC5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzdWx0ID0gbmV4dFJlc3VsdDtcbiAgICAgICAgdGhpcy5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICB0aGlzLmhhbmRsZUVycm9yT3JDb21wbGV0ZWQobmV4dFJlc3VsdCk7XG4gICAgfTtcbiAgICBJbnRlcm5hbFN0YXRlLnByb3RvdHlwZS5oYW5kbGVFcnJvck9yQ29tcGxldGVkID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXJlc3VsdC5sb2FkaW5nKSB7XG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uRXJyb3IocmVzdWx0LmVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25Db21wbGV0ZWQocmVzdWx0LmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIF9fREVWX18gJiYgZ2xvYmFscy5pbnZhcmlhbnQud2FybihlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW50ZXJuYWxTdGF0ZS5wcm90b3R5cGUuZ2V0Q3VycmVudFJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvck9yQ29tcGxldGVkKHRoaXMucmVzdWx0ID0gdGhpcy5vYnNlcnZhYmxlLmdldEN1cnJlbnRSZXN1bHQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0O1xuICAgIH07XG4gICAgSW50ZXJuYWxTdGF0ZS5wcm90b3R5cGUudG9RdWVyeVJlc3VsdCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgdmFyIHF1ZXJ5UmVzdWx0ID0gdGhpcy50b1F1ZXJ5UmVzdWx0Q2FjaGUuZ2V0KHJlc3VsdCk7XG4gICAgICAgIGlmIChxdWVyeVJlc3VsdClcbiAgICAgICAgICAgIHJldHVybiBxdWVyeVJlc3VsdDtcbiAgICAgICAgdmFyIGRhdGEgPSByZXN1bHQuZGF0YTsgcmVzdWx0LnBhcnRpYWw7IHZhciByZXN1bHRXaXRob3V0UGFydGlhbCA9IHRzbGliLl9fcmVzdChyZXN1bHQsIFtcImRhdGFcIiwgXCJwYXJ0aWFsXCJdKTtcbiAgICAgICAgdGhpcy50b1F1ZXJ5UmVzdWx0Q2FjaGUuc2V0KHJlc3VsdCwgcXVlcnlSZXN1bHQgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7IGRhdGE6IGRhdGEgfSwgcmVzdWx0V2l0aG91dFBhcnRpYWwpLCB0aGlzLm9ic1F1ZXJ5RmllbGRzKSwgeyBjbGllbnQ6IHRoaXMuY2xpZW50LCBvYnNlcnZhYmxlOiB0aGlzLm9ic2VydmFibGUsIHZhcmlhYmxlczogdGhpcy5vYnNlcnZhYmxlLnZhcmlhYmxlcywgY2FsbGVkOiAhdGhpcy5xdWVyeUhvb2tPcHRpb25zLnNraXAsIHByZXZpb3VzRGF0YTogdGhpcy5wcmV2aW91c0RhdGEgfSkpO1xuICAgICAgICBpZiAoIXF1ZXJ5UmVzdWx0LmVycm9yICYmIHV0aWxpdGllcy5pc05vbkVtcHR5QXJyYXkocmVzdWx0LmVycm9ycykpIHtcbiAgICAgICAgICAgIHF1ZXJ5UmVzdWx0LmVycm9yID0gbmV3IGVycm9ycy5BcG9sbG9FcnJvcih7IGdyYXBoUUxFcnJvcnM6IHJlc3VsdC5lcnJvcnMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHF1ZXJ5UmVzdWx0O1xuICAgIH07XG4gICAgSW50ZXJuYWxTdGF0ZS5wcm90b3R5cGUudW5zYWZlSGFuZGxlUGFydGlhbFJlZmV0Y2ggPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQucGFydGlhbCAmJlxuICAgICAgICAgICAgdGhpcy5xdWVyeUhvb2tPcHRpb25zLnBhcnRpYWxSZWZldGNoICYmXG4gICAgICAgICAgICAhcmVzdWx0LmxvYWRpbmcgJiZcbiAgICAgICAgICAgICghcmVzdWx0LmRhdGEgfHwgT2JqZWN0LmtleXMocmVzdWx0LmRhdGEpLmxlbmd0aCA9PT0gMCkgJiZcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2YWJsZS5vcHRpb25zLmZldGNoUG9saWN5ICE9PSAnY2FjaGUtb25seScpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCB7XG4gICAgICAgICAgICAgICAgbG9hZGluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBuZXR3b3JrU3RhdHVzOiBjb3JlLk5ldHdvcmtTdGF0dXMucmVmZXRjaCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZhYmxlLnJlZmV0Y2goKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEludGVybmFsU3RhdGU7XG59KCkpO1xuXG52YXIgRUFHRVJfTUVUSE9EUyA9IFtcbiAgICAncmVmZXRjaCcsXG4gICAgJ3Jlb2JzZXJ2ZScsXG4gICAgJ2ZldGNoTW9yZScsXG4gICAgJ3VwZGF0ZVF1ZXJ5JyxcbiAgICAnc3RhcnRQb2xsaW5nJyxcbiAgICAnc3Vic2NyaWJlVG9Nb3JlJyxcbl07XG5mdW5jdGlvbiB1c2VMYXp5UXVlcnkocXVlcnksIG9wdGlvbnMpIHtcbiAgICB2YXIgaW50ZXJuYWxTdGF0ZSA9IHVzZUludGVybmFsU3RhdGUodXNlQXBvbGxvQ2xpZW50KG9wdGlvbnMgJiYgb3B0aW9ucy5jbGllbnQpLCBxdWVyeSk7XG4gICAgdmFyIGV4ZWNPcHRpb25zUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gICAgdmFyIG1lcmdlZCA9IGV4ZWNPcHRpb25zUmVmLmN1cnJlbnRcbiAgICAgICAgPyB1dGlsaXRpZXMubWVyZ2VPcHRpb25zKG9wdGlvbnMsIGV4ZWNPcHRpb25zUmVmLmN1cnJlbnQpXG4gICAgICAgIDogb3B0aW9ucztcbiAgICB2YXIgdXNlUXVlcnlSZXN1bHQgPSBpbnRlcm5hbFN0YXRlLnVzZVF1ZXJ5KHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBtZXJnZWQpLCB7IHNraXA6ICFleGVjT3B0aW9uc1JlZi5jdXJyZW50IH0pKTtcbiAgICB2YXIgaW5pdGlhbEZldGNoUG9saWN5ID0gdXNlUXVlcnlSZXN1bHQub2JzZXJ2YWJsZS5vcHRpb25zLmluaXRpYWxGZXRjaFBvbGljeSB8fFxuICAgICAgICBpbnRlcm5hbFN0YXRlLmdldERlZmF1bHRGZXRjaFBvbGljeSgpO1xuICAgIHZhciByZXN1bHQgPSBPYmplY3QuYXNzaWduKHVzZVF1ZXJ5UmVzdWx0LCB7XG4gICAgICAgIGNhbGxlZDogISFleGVjT3B0aW9uc1JlZi5jdXJyZW50LFxuICAgIH0pO1xuICAgIHZhciBlYWdlck1ldGhvZHMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVhZ2VyTWV0aG9kcyA9IHt9O1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSByZXN1bHRba2V5XTtcbiAgICAgICAgICAgIGVhZ2VyTWV0aG9kc1trZXldID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghZXhlY09wdGlvbnNSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBleGVjT3B0aW9uc1JlZi5jdXJyZW50ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxTdGF0ZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIEVBR0VSX01FVEhPRFNfMSA9IEVBR0VSX01FVEhPRFM7IF9pIDwgRUFHRVJfTUVUSE9EU18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IEVBR0VSX01FVEhPRFNfMVtfaV07XG4gICAgICAgICAgICBfbG9vcF8xKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVhZ2VyTWV0aG9kcztcbiAgICB9LCBbXSk7XG4gICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIGVhZ2VyTWV0aG9kcyk7XG4gICAgdmFyIGV4ZWN1dGUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZXhlY3V0ZU9wdGlvbnMpIHtcbiAgICAgICAgZXhlY09wdGlvbnNSZWYuY3VycmVudCA9IGV4ZWN1dGVPcHRpb25zID8gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGV4ZWN1dGVPcHRpb25zKSwgeyBmZXRjaFBvbGljeTogZXhlY3V0ZU9wdGlvbnMuZmV0Y2hQb2xpY3kgfHwgaW5pdGlhbEZldGNoUG9saWN5IH0pIDoge1xuICAgICAgICAgICAgZmV0Y2hQb2xpY3k6IGluaXRpYWxGZXRjaFBvbGljeSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHByb21pc2UgPSBpbnRlcm5hbFN0YXRlXG4gICAgICAgICAgICAuYXN5bmNVcGRhdGUoKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHF1ZXJ5UmVzdWx0KSB7IHJldHVybiBPYmplY3QuYXNzaWduKHF1ZXJ5UmVzdWx0LCBlYWdlck1ldGhvZHMpOyB9KTtcbiAgICAgICAgcHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIFtleGVjdXRlLCByZXN1bHRdO1xufVxuXG5mdW5jdGlvbiB1c2VNdXRhdGlvbihtdXRhdGlvbiwgb3B0aW9ucykge1xuICAgIHZhciBjbGllbnQgPSB1c2VBcG9sbG9DbGllbnQob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCk7XG4gICAgcGFyc2VyLnZlcmlmeURvY3VtZW50VHlwZShtdXRhdGlvbiwgcGFyc2VyLkRvY3VtZW50VHlwZS5NdXRhdGlvbik7XG4gICAgdmFyIF9hID0gUmVhY3QudXNlU3RhdGUoe1xuICAgICAgICBjYWxsZWQ6IGZhbHNlLFxuICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgY2xpZW50OiBjbGllbnQsXG4gICAgfSksIHJlc3VsdCA9IF9hWzBdLCBzZXRSZXN1bHQgPSBfYVsxXTtcbiAgICB2YXIgcmVmID0gUmVhY3QudXNlUmVmKHtcbiAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgIG11dGF0aW9uSWQ6IDAsXG4gICAgICAgIGlzTW91bnRlZDogdHJ1ZSxcbiAgICAgICAgY2xpZW50OiBjbGllbnQsXG4gICAgICAgIG11dGF0aW9uOiBtdXRhdGlvbixcbiAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICB9KTtcbiAgICB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocmVmLmN1cnJlbnQsIHsgY2xpZW50OiBjbGllbnQsIG9wdGlvbnM6IG9wdGlvbnMsIG11dGF0aW9uOiBtdXRhdGlvbiB9KTtcbiAgICB9XG4gICAgdmFyIGV4ZWN1dGUgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZXhlY3V0ZU9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGV4ZWN1dGVPcHRpb25zID09PSB2b2lkIDApIHsgZXhlY3V0ZU9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgX2EgPSByZWYuY3VycmVudCwgY2xpZW50ID0gX2EuY2xpZW50LCBvcHRpb25zID0gX2Eub3B0aW9ucywgbXV0YXRpb24gPSBfYS5tdXRhdGlvbjtcbiAgICAgICAgdmFyIGJhc2VPcHRpb25zID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IG11dGF0aW9uOiBtdXRhdGlvbiB9KTtcbiAgICAgICAgaWYgKCFyZWYuY3VycmVudC5yZXN1bHQubG9hZGluZyAmJiAhYmFzZU9wdGlvbnMuaWdub3JlUmVzdWx0cyAmJiByZWYuY3VycmVudC5pc01vdW50ZWQpIHtcbiAgICAgICAgICAgIHNldFJlc3VsdChyZWYuY3VycmVudC5yZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgbG9hZGluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogdm9pZCAwLFxuICAgICAgICAgICAgICAgIGRhdGE6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBjYWxsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgY2xpZW50OiBjbGllbnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbXV0YXRpb25JZCA9ICsrcmVmLmN1cnJlbnQubXV0YXRpb25JZDtcbiAgICAgICAgdmFyIGNsaWVudE9wdGlvbnMgPSBjb3JlLm1lcmdlT3B0aW9ucyhiYXNlT3B0aW9ucywgZXhlY3V0ZU9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gY2xpZW50Lm11dGF0ZShjbGllbnRPcHRpb25zKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHJlc3BvbnNlLmRhdGEsIGVycm9ycyQxID0gcmVzcG9uc2UuZXJyb3JzO1xuICAgICAgICAgICAgdmFyIGVycm9yID0gZXJyb3JzJDEgJiYgZXJyb3JzJDEubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgID8gbmV3IGVycm9ycy5BcG9sbG9FcnJvcih7IGdyYXBoUUxFcnJvcnM6IGVycm9ycyQxIH0pXG4gICAgICAgICAgICAgICAgOiB2b2lkIDA7XG4gICAgICAgICAgICBpZiAobXV0YXRpb25JZCA9PT0gcmVmLmN1cnJlbnQubXV0YXRpb25JZCAmJlxuICAgICAgICAgICAgICAgICFjbGllbnRPcHRpb25zLmlnbm9yZVJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0XzEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50OiBjbGllbnQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAocmVmLmN1cnJlbnQuaXNNb3VudGVkICYmICFlcXVhbGl0eS5lcXVhbChyZWYuY3VycmVudC5yZXN1bHQsIHJlc3VsdF8xKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRSZXN1bHQocmVmLmN1cnJlbnQucmVzdWx0ID0gcmVzdWx0XzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYiA9IChfYSA9IHJlZi5jdXJyZW50Lm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vbkNvbXBsZXRlZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHJlc3BvbnNlLmRhdGEsIGNsaWVudE9wdGlvbnMpO1xuICAgICAgICAgICAgKF9jID0gZXhlY3V0ZU9wdGlvbnMub25Db21wbGV0ZWQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKGV4ZWN1dGVPcHRpb25zLCByZXNwb25zZS5kYXRhLCBjbGllbnRPcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICBpZiAobXV0YXRpb25JZCA9PT0gcmVmLmN1cnJlbnQubXV0YXRpb25JZCAmJlxuICAgICAgICAgICAgICAgIHJlZi5jdXJyZW50LmlzTW91bnRlZCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHRfMiA9IHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICBjYWxsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudDogY2xpZW50LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKCFlcXVhbGl0eS5lcXVhbChyZWYuY3VycmVudC5yZXN1bHQsIHJlc3VsdF8yKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRSZXN1bHQocmVmLmN1cnJlbnQucmVzdWx0ID0gcmVzdWx0XzIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoKF9hID0gcmVmLmN1cnJlbnQub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9uRXJyb3IpIHx8IGNsaWVudE9wdGlvbnMub25FcnJvcikge1xuICAgICAgICAgICAgICAgIChfYyA9IChfYiA9IHJlZi5jdXJyZW50Lm9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vbkVycm9yKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChfYiwgZXJyb3IsIGNsaWVudE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIChfZCA9IGV4ZWN1dGVPcHRpb25zLm9uRXJyb3IpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKGV4ZWN1dGVPcHRpb25zLCBlcnJvciwgY2xpZW50T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogdm9pZCAwLCBlcnJvcnM6IGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgfSwgW10pO1xuICAgIHZhciByZXNldCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHJlZi5jdXJyZW50LmlzTW91bnRlZCkge1xuICAgICAgICAgICAgc2V0UmVzdWx0KHsgY2FsbGVkOiBmYWxzZSwgbG9hZGluZzogZmFsc2UsIGNsaWVudDogY2xpZW50IH0pO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlZi5jdXJyZW50LmlzTW91bnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZWYuY3VycmVudC5pc01vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIFtleGVjdXRlLCB0c2xpYi5fX2Fzc2lnbih7IHJlc2V0OiByZXNldCB9LCByZXN1bHQpXTtcbn1cblxuZnVuY3Rpb24gdXNlU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbiwgb3B0aW9ucykge1xuICAgIHZhciBoYXNJc3N1ZWREZXByZWNhdGlvbldhcm5pbmdSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgIHZhciBjbGllbnQgPSB1c2VBcG9sbG9DbGllbnQob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCk7XG4gICAgcGFyc2VyLnZlcmlmeURvY3VtZW50VHlwZShzdWJzY3JpcHRpb24sIHBhcnNlci5Eb2N1bWVudFR5cGUuU3Vic2NyaXB0aW9uKTtcbiAgICB2YXIgX2EgPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgICAgIGxvYWRpbmc6ICEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNraXApLFxuICAgICAgICBlcnJvcjogdm9pZCAwLFxuICAgICAgICBkYXRhOiB2b2lkIDAsXG4gICAgICAgIHZhcmlhYmxlczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnZhcmlhYmxlcyxcbiAgICB9KSwgcmVzdWx0ID0gX2FbMF0sIHNldFJlc3VsdCA9IF9hWzFdO1xuICAgIGlmICghaGFzSXNzdWVkRGVwcmVjYXRpb25XYXJuaW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgaGFzSXNzdWVkRGVwcmVjYXRpb25XYXJuaW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9uU3Vic2NyaXB0aW9uRGF0YSkge1xuICAgICAgICAgICAgX19ERVZfXyAmJiBnbG9iYWxzLmludmFyaWFudC53YXJuKG9wdGlvbnMub25EYXRhXG4gICAgICAgICAgICAgICAgPyBcIid1c2VTdWJzY3JpcHRpb24nIHN1cHBvcnRzIG9ubHkgdGhlICdvblN1YnNjcmlwdGlvbkRhdGEnIG9yICdvbkRhdGEnIG9wdGlvbiwgYnV0IG5vdCBib3RoLiBPbmx5IHRoZSAnb25EYXRhJyBvcHRpb24gd2lsbCBiZSB1c2VkLlwiXG4gICAgICAgICAgICAgICAgOiBcIidvblN1YnNjcmlwdGlvbkRhdGEnIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciB2ZXJzaW9uLiBQbGVhc2UgdXNlIHRoZSAnb25EYXRhJyBvcHRpb24gaW5zdGVhZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vblN1YnNjcmlwdGlvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICBfX0RFVl9fICYmIGdsb2JhbHMuaW52YXJpYW50Lndhcm4ob3B0aW9ucy5vbkNvbXBsZXRlXG4gICAgICAgICAgICAgICAgPyBcIid1c2VTdWJzY3JpcHRpb24nIHN1cHBvcnRzIG9ubHkgdGhlICdvblN1YnNjcmlwdGlvbkNvbXBsZXRlJyBvciAnb25Db21wbGV0ZScgb3B0aW9uLCBidXQgbm90IGJvdGguIE9ubHkgdGhlICdvbkNvbXBsZXRlJyBvcHRpb24gd2lsbCBiZSB1c2VkLlwiXG4gICAgICAgICAgICAgICAgOiBcIidvblN1YnNjcmlwdGlvbkNvbXBsZXRlJyBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgdmVyc2lvbi4gUGxlYXNlIHVzZSB0aGUgJ29uQ29tcGxldGUnIG9wdGlvbiBpbnN0ZWFkLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgX2IgPSBSZWFjdC51c2VTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2tpcCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsaWVudC5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgcXVlcnk6IHN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgIHZhcmlhYmxlczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnZhcmlhYmxlcyxcbiAgICAgICAgICAgIGZldGNoUG9saWN5OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZmV0Y2hQb2xpY3ksXG4gICAgICAgICAgICBjb250ZXh0OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY29udGV4dCxcbiAgICAgICAgfSk7XG4gICAgfSksIG9ic2VydmFibGUgPSBfYlswXSwgc2V0T2JzZXJ2YWJsZSA9IF9iWzFdO1xuICAgIHZhciBjYW5SZXNldE9ic2VydmFibGVSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjYW5SZXNldE9ic2VydmFibGVSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHZhciByZWYgPSBSZWFjdC51c2VSZWYoeyBjbGllbnQ6IGNsaWVudCwgc3Vic2NyaXB0aW9uOiBzdWJzY3JpcHRpb24sIG9wdGlvbnM6IG9wdGlvbnMgfSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICB2YXIgc2hvdWxkUmVzdWJzY3JpYmUgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2hvdWxkUmVzdWJzY3JpYmU7XG4gICAgICAgIGlmICh0eXBlb2Ygc2hvdWxkUmVzdWJzY3JpYmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNob3VsZFJlc3Vic2NyaWJlID0gISFzaG91bGRSZXN1YnNjcmliZShvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNraXApIHtcbiAgICAgICAgICAgIGlmICghKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5za2lwKSAhPT0gISgoX2EgPSByZWYuY3VycmVudC5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2tpcCkgfHwgY2FuUmVzZXRPYnNlcnZhYmxlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBzZXRSZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZXM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy52YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2V0T2JzZXJ2YWJsZShudWxsKTtcbiAgICAgICAgICAgICAgICBjYW5SZXNldE9ic2VydmFibGVSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChzaG91bGRSZXN1YnNjcmliZSAhPT0gZmFsc2UgJiZcbiAgICAgICAgICAgIChjbGllbnQgIT09IHJlZi5jdXJyZW50LmNsaWVudCB8fFxuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbiAhPT0gcmVmLmN1cnJlbnQuc3Vic2NyaXB0aW9uIHx8XG4gICAgICAgICAgICAgICAgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mZXRjaFBvbGljeSkgIT09ICgoX2IgPSByZWYuY3VycmVudC5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZmV0Y2hQb2xpY3kpIHx8XG4gICAgICAgICAgICAgICAgIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2tpcCkgIT09ICEoKF9jID0gcmVmLmN1cnJlbnQub3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNraXApIHx8XG4gICAgICAgICAgICAgICAgIWVxdWFsaXR5LmVxdWFsKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy52YXJpYWJsZXMsIChfZCA9IHJlZi5jdXJyZW50Lm9wdGlvbnMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC52YXJpYWJsZXMpKSkgfHxcbiAgICAgICAgICAgIGNhblJlc2V0T2JzZXJ2YWJsZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBzZXRSZXN1bHQoe1xuICAgICAgICAgICAgICAgIGxvYWRpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YTogdm9pZCAwLFxuICAgICAgICAgICAgICAgIGVycm9yOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgdmFyaWFibGVzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudmFyaWFibGVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXRPYnNlcnZhYmxlKGNsaWVudC5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgICAgIHF1ZXJ5OiBzdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgdmFyaWFibGVzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudmFyaWFibGVzLFxuICAgICAgICAgICAgICAgIGZldGNoUG9saWN5OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZmV0Y2hQb2xpY3ksXG4gICAgICAgICAgICAgICAgY29udGV4dDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNvbnRleHQsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBjYW5SZXNldE9ic2VydmFibGVSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocmVmLmN1cnJlbnQsIHsgY2xpZW50OiBjbGllbnQsIHN1YnNjcmlwdGlvbjogc3Vic2NyaXB0aW9uLCBvcHRpb25zOiBvcHRpb25zIH0pO1xuICAgIH0sIFtjbGllbnQsIHN1YnNjcmlwdGlvbiwgb3B0aW9ucywgY2FuUmVzZXRPYnNlcnZhYmxlUmVmLmN1cnJlbnRdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIW9ic2VydmFibGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gb2JzZXJ2YWJsZS5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKGZldGNoUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZmV0Y2hSZXN1bHQuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudmFyaWFibGVzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2V0UmVzdWx0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgaWYgKChfYSA9IHJlZi5jdXJyZW50Lm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vbkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmLmN1cnJlbnQub3B0aW9ucy5vbkRhdGEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50OiBjbGllbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChfYiA9IHJlZi5jdXJyZW50Lm9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vblN1YnNjcmlwdGlvbkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmLmN1cnJlbnQub3B0aW9ucy5vblN1YnNjcmlwdGlvbkRhdGEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50OiBjbGllbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25EYXRhOiByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIHNldFJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudmFyaWFibGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIChfYiA9IChfYSA9IHJlZi5jdXJyZW50Lm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vbkVycm9yKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgZXJyb3IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBpZiAoKF9hID0gcmVmLmN1cnJlbnQub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmLmN1cnJlbnQub3B0aW9ucy5vbkNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChfYiA9IHJlZi5jdXJyZW50Lm9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vblN1YnNjcmlwdGlvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZi5jdXJyZW50Lm9wdGlvbnMub25TdWJzY3JpcHRpb25Db21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH07XG4gICAgfSwgW29ic2VydmFibGVdKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiB1c2VSZWFjdGl2ZVZhcihydikge1xuICAgIHZhciB2YWx1ZSA9IHJ2KCk7XG4gICAgdmFyIHNldFZhbHVlID0gUmVhY3QudXNlU3RhdGUodmFsdWUpWzFdO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9iYWJseVNhbWVWYWx1ZSA9IHJ2KCk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gcHJvYmFibHlTYW1lVmFsdWUpIHtcbiAgICAgICAgICAgIHNldFZhbHVlKHByb2JhYmx5U2FtZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBydi5vbk5leHRDaGFuZ2Uoc2V0VmFsdWUpO1xuICAgICAgICB9XG4gICAgfSwgW3ZhbHVlXSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB1c2VGcmFnbWVudF9leHBlcmltZW50YWwob3B0aW9ucykge1xuICAgIHZhciBjYWNoZSA9IHVzZUFwb2xsb0NsaWVudCgpLmNhY2hlO1xuICAgIHZhciBmcmFnbWVudCA9IG9wdGlvbnMuZnJhZ21lbnQsIGZyYWdtZW50TmFtZSA9IG9wdGlvbnMuZnJhZ21lbnROYW1lLCBmcm9tID0gb3B0aW9ucy5mcm9tLCBfYSA9IG9wdGlvbnMub3B0aW1pc3RpYywgb3B0aW1pc3RpYyA9IF9hID09PSB2b2lkIDAgPyB0cnVlIDogX2EsIHJlc3QgPSB0c2xpYi5fX3Jlc3Qob3B0aW9ucywgW1wiZnJhZ21lbnRcIiwgXCJmcmFnbWVudE5hbWVcIiwgXCJmcm9tXCIsIFwib3B0aW1pc3RpY1wiXSk7XG4gICAgdmFyIGRpZmZPcHRpb25zID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIHJlc3QpLCB7IGlkOiB0eXBlb2YgZnJvbSA9PT0gXCJzdHJpbmdcIiA/IGZyb20gOiBjYWNoZS5pZGVudGlmeShmcm9tKSwgcXVlcnk6IGNhY2hlW1wiZ2V0RnJhZ21lbnREb2NcIl0oZnJhZ21lbnQsIGZyYWdtZW50TmFtZSksIG9wdGltaXN0aWM6IG9wdGltaXN0aWMgfSk7XG4gICAgdmFyIHJlc3VsdFJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICAgIHZhciBsYXRlc3REaWZmID0gY2FjaGUuZGlmZihkaWZmT3B0aW9ucyk7XG4gICAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlKGZ1bmN0aW9uIChmb3JjZVVwZGF0ZSkge1xuICAgICAgICByZXR1cm4gY2FjaGUud2F0Y2godHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGRpZmZPcHRpb25zKSwgeyBpbW1lZGlhdGU6IHRydWUsIGNhbGxiYWNrOiBmdW5jdGlvbiAoZGlmZikge1xuICAgICAgICAgICAgICAgIGlmICghZXF1YWxpdHkuZXF1YWwoZGlmZiwgbGF0ZXN0RGlmZikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0UmVmLmN1cnJlbnQgPSBkaWZmVG9SZXN1bHQobGF0ZXN0RGlmZiA9IGRpZmYpO1xuICAgICAgICAgICAgICAgICAgICBmb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gfSkpO1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxhdGVzdERpZmZUb1Jlc3VsdCA9IGRpZmZUb1Jlc3VsdChsYXRlc3REaWZmKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFJlZi5jdXJyZW50ICYmXG4gICAgICAgICAgICBlcXVhbGl0eS5lcXVhbChyZXN1bHRSZWYuY3VycmVudC5kYXRhLCBsYXRlc3REaWZmVG9SZXN1bHQuZGF0YSlcbiAgICAgICAgICAgID8gcmVzdWx0UmVmLmN1cnJlbnRcbiAgICAgICAgICAgIDogKHJlc3VsdFJlZi5jdXJyZW50ID0gbGF0ZXN0RGlmZlRvUmVzdWx0KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGRpZmZUb1Jlc3VsdChkaWZmKSB7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgZGF0YTogZGlmZi5yZXN1bHQsXG4gICAgICAgIGNvbXBsZXRlOiAhIWRpZmYuY29tcGxldGUsXG4gICAgfTtcbiAgICBpZiAoZGlmZi5taXNzaW5nKSB7XG4gICAgICAgIHJlc3VsdC5taXNzaW5nID0gdXRpbGl0aWVzLm1lcmdlRGVlcEFycmF5KGRpZmYubWlzc2luZy5tYXAoZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBlcnJvci5taXNzaW5nOyB9KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydHMudXNlQXBvbGxvQ2xpZW50ID0gdXNlQXBvbGxvQ2xpZW50O1xuZXhwb3J0cy51c2VGcmFnbWVudF9leHBlcmltZW50YWwgPSB1c2VGcmFnbWVudF9leHBlcmltZW50YWw7XG5leHBvcnRzLnVzZUxhenlRdWVyeSA9IHVzZUxhenlRdWVyeTtcbmV4cG9ydHMudXNlTXV0YXRpb24gPSB1c2VNdXRhdGlvbjtcbmV4cG9ydHMudXNlUXVlcnkgPSB1c2VRdWVyeTtcbmV4cG9ydHMudXNlUmVhY3RpdmVWYXIgPSB1c2VSZWFjdGl2ZVZhcjtcbmV4cG9ydHMudXNlU3Vic2NyaXB0aW9uID0gdXNlU3Vic2NyaXB0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG9va3MuY2pzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@apollo/client/react/hooks/hooks.cjs\n");

/***/ }),

/***/ "./node_modules/@apollo/client/react/parser/parser.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@apollo/client/react/parser/parser.cjs ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar globals = __webpack_require__(/*! ../../utilities/globals */ \"./node_modules/@apollo/client/utilities/globals/globals.cjs\");\n\nexports.DocumentType = void 0;\n(function (DocumentType) {\n    DocumentType[DocumentType[\"Query\"] = 0] = \"Query\";\n    DocumentType[DocumentType[\"Mutation\"] = 1] = \"Mutation\";\n    DocumentType[DocumentType[\"Subscription\"] = 2] = \"Subscription\";\n})(exports.DocumentType || (exports.DocumentType = {}));\nvar cache = new Map();\nfunction operationName(type) {\n    var name;\n    switch (type) {\n        case exports.DocumentType.Query:\n            name = 'Query';\n            break;\n        case exports.DocumentType.Mutation:\n            name = 'Mutation';\n            break;\n        case exports.DocumentType.Subscription:\n            name = 'Subscription';\n            break;\n    }\n    return name;\n}\nfunction parser(document) {\n    var cached = cache.get(document);\n    if (cached)\n        return cached;\n    var variables, type, name;\n    __DEV__ ? globals.invariant(!!document && !!document.kind, \"Argument of \".concat(document, \" passed to parser was not a valid GraphQL \") +\n        \"DocumentNode. You may need to use 'graphql-tag' or another method \" +\n        \"to convert your operation into a document\") : globals.invariant(!!document && !!document.kind, 32);\n    var fragments = [];\n    var queries = [];\n    var mutations = [];\n    var subscriptions = [];\n    for (var _i = 0, _a = document.definitions; _i < _a.length; _i++) {\n        var x = _a[_i];\n        if (x.kind === 'FragmentDefinition') {\n            fragments.push(x);\n            continue;\n        }\n        if (x.kind === 'OperationDefinition') {\n            switch (x.operation) {\n                case 'query':\n                    queries.push(x);\n                    break;\n                case 'mutation':\n                    mutations.push(x);\n                    break;\n                case 'subscription':\n                    subscriptions.push(x);\n                    break;\n            }\n        }\n    }\n    __DEV__ ? globals.invariant(!fragments.length ||\n        (queries.length || mutations.length || subscriptions.length), \"Passing only a fragment to 'graphql' is not yet supported. \" +\n        \"You must include a query, subscription or mutation as well\") : globals.invariant(!fragments.length ||\n        (queries.length || mutations.length || subscriptions.length), 33);\n    __DEV__ ? globals.invariant(queries.length + mutations.length + subscriptions.length <= 1, \"react-apollo only supports a query, subscription, or a mutation per HOC. \" +\n        \"\".concat(document, \" had \").concat(queries.length, \" queries, \").concat(subscriptions.length, \" \") +\n        \"subscriptions and \".concat(mutations.length, \" mutations. \") +\n        \"You can use 'compose' to join multiple operation types to a component\") : globals.invariant(queries.length + mutations.length + subscriptions.length <= 1, 34);\n    type = queries.length ? exports.DocumentType.Query : exports.DocumentType.Mutation;\n    if (!queries.length && !mutations.length)\n        type = exports.DocumentType.Subscription;\n    var definitions = queries.length\n        ? queries\n        : mutations.length\n            ? mutations\n            : subscriptions;\n    __DEV__ ? globals.invariant(definitions.length === 1, \"react-apollo only supports one definition per HOC. \".concat(document, \" had \") +\n        \"\".concat(definitions.length, \" definitions. \") +\n        \"You can use 'compose' to join multiple operation types to a component\") : globals.invariant(definitions.length === 1, 35);\n    var definition = definitions[0];\n    variables = definition.variableDefinitions || [];\n    if (definition.name && definition.name.kind === 'Name') {\n        name = definition.name.value;\n    }\n    else {\n        name = 'data';\n    }\n    var payload = { name: name, type: type, variables: variables };\n    cache.set(document, payload);\n    return payload;\n}\nfunction verifyDocumentType(document, type) {\n    var operation = parser(document);\n    var requiredOperationName = operationName(type);\n    var usedOperationName = operationName(operation.type);\n    __DEV__ ? globals.invariant(operation.type === type, \"Running a \".concat(requiredOperationName, \" requires a graphql \") +\n        \"\".concat(requiredOperationName, \", but a \").concat(usedOperationName, \" was used instead.\")) : globals.invariant(operation.type === type, 36);\n}\n\nexports.operationName = operationName;\nexports.parser = parser;\nexports.verifyDocumentType = verifyDocumentType;\n//# sourceMappingURL=parser.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvcmVhY3QvcGFyc2VyL3BhcnNlci5janM/MzMyNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBOEMsY0FBYzs7QUFFNUQsY0FBYyxtQkFBTyxDQUFDLDRGQUF5Qjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0RBQW9EO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdCQUFnQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AYXBvbGxvL2NsaWVudC9yZWFjdC9wYXJzZXIvcGFyc2VyLmNqcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGdsb2JhbHMgPSByZXF1aXJlKCcuLi8uLi91dGlsaXRpZXMvZ2xvYmFscycpO1xuXG5leHBvcnRzLkRvY3VtZW50VHlwZSA9IHZvaWQgMDtcbihmdW5jdGlvbiAoRG9jdW1lbnRUeXBlKSB7XG4gICAgRG9jdW1lbnRUeXBlW0RvY3VtZW50VHlwZVtcIlF1ZXJ5XCJdID0gMF0gPSBcIlF1ZXJ5XCI7XG4gICAgRG9jdW1lbnRUeXBlW0RvY3VtZW50VHlwZVtcIk11dGF0aW9uXCJdID0gMV0gPSBcIk11dGF0aW9uXCI7XG4gICAgRG9jdW1lbnRUeXBlW0RvY3VtZW50VHlwZVtcIlN1YnNjcmlwdGlvblwiXSA9IDJdID0gXCJTdWJzY3JpcHRpb25cIjtcbn0pKGV4cG9ydHMuRG9jdW1lbnRUeXBlIHx8IChleHBvcnRzLkRvY3VtZW50VHlwZSA9IHt9KSk7XG52YXIgY2FjaGUgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBvcGVyYXRpb25OYW1lKHR5cGUpIHtcbiAgICB2YXIgbmFtZTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBleHBvcnRzLkRvY3VtZW50VHlwZS5RdWVyeTpcbiAgICAgICAgICAgIG5hbWUgPSAnUXVlcnknO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgZXhwb3J0cy5Eb2N1bWVudFR5cGUuTXV0YXRpb246XG4gICAgICAgICAgICBuYW1lID0gJ011dGF0aW9uJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGV4cG9ydHMuRG9jdW1lbnRUeXBlLlN1YnNjcmlwdGlvbjpcbiAgICAgICAgICAgIG5hbWUgPSAnU3Vic2NyaXB0aW9uJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn1cbmZ1bmN0aW9uIHBhcnNlcihkb2N1bWVudCkge1xuICAgIHZhciBjYWNoZWQgPSBjYWNoZS5nZXQoZG9jdW1lbnQpO1xuICAgIGlmIChjYWNoZWQpXG4gICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgdmFyIHZhcmlhYmxlcywgdHlwZSwgbmFtZTtcbiAgICBfX0RFVl9fID8gZ2xvYmFscy5pbnZhcmlhbnQoISFkb2N1bWVudCAmJiAhIWRvY3VtZW50LmtpbmQsIFwiQXJndW1lbnQgb2YgXCIuY29uY2F0KGRvY3VtZW50LCBcIiBwYXNzZWQgdG8gcGFyc2VyIHdhcyBub3QgYSB2YWxpZCBHcmFwaFFMIFwiKSArXG4gICAgICAgIFwiRG9jdW1lbnROb2RlLiBZb3UgbWF5IG5lZWQgdG8gdXNlICdncmFwaHFsLXRhZycgb3IgYW5vdGhlciBtZXRob2QgXCIgK1xuICAgICAgICBcInRvIGNvbnZlcnQgeW91ciBvcGVyYXRpb24gaW50byBhIGRvY3VtZW50XCIpIDogZ2xvYmFscy5pbnZhcmlhbnQoISFkb2N1bWVudCAmJiAhIWRvY3VtZW50LmtpbmQsIDMyKTtcbiAgICB2YXIgZnJhZ21lbnRzID0gW107XG4gICAgdmFyIHF1ZXJpZXMgPSBbXTtcbiAgICB2YXIgbXV0YXRpb25zID0gW107XG4gICAgdmFyIHN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gZG9jdW1lbnQuZGVmaW5pdGlvbnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciB4ID0gX2FbX2ldO1xuICAgICAgICBpZiAoeC5raW5kID09PSAnRnJhZ21lbnREZWZpbml0aW9uJykge1xuICAgICAgICAgICAgZnJhZ21lbnRzLnB1c2goeCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeC5raW5kID09PSAnT3BlcmF0aW9uRGVmaW5pdGlvbicpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoeC5vcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdxdWVyeSc6XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJpZXMucHVzaCh4KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbXV0YXRpb24nOlxuICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbnMucHVzaCh4KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3Vic2NyaXB0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5wdXNoKHgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfX0RFVl9fID8gZ2xvYmFscy5pbnZhcmlhbnQoIWZyYWdtZW50cy5sZW5ndGggfHxcbiAgICAgICAgKHF1ZXJpZXMubGVuZ3RoIHx8IG11dGF0aW9ucy5sZW5ndGggfHwgc3Vic2NyaXB0aW9ucy5sZW5ndGgpLCBcIlBhc3Npbmcgb25seSBhIGZyYWdtZW50IHRvICdncmFwaHFsJyBpcyBub3QgeWV0IHN1cHBvcnRlZC4gXCIgK1xuICAgICAgICBcIllvdSBtdXN0IGluY2x1ZGUgYSBxdWVyeSwgc3Vic2NyaXB0aW9uIG9yIG11dGF0aW9uIGFzIHdlbGxcIikgOiBnbG9iYWxzLmludmFyaWFudCghZnJhZ21lbnRzLmxlbmd0aCB8fFxuICAgICAgICAocXVlcmllcy5sZW5ndGggfHwgbXV0YXRpb25zLmxlbmd0aCB8fCBzdWJzY3JpcHRpb25zLmxlbmd0aCksIDMzKTtcbiAgICBfX0RFVl9fID8gZ2xvYmFscy5pbnZhcmlhbnQocXVlcmllcy5sZW5ndGggKyBtdXRhdGlvbnMubGVuZ3RoICsgc3Vic2NyaXB0aW9ucy5sZW5ndGggPD0gMSwgXCJyZWFjdC1hcG9sbG8gb25seSBzdXBwb3J0cyBhIHF1ZXJ5LCBzdWJzY3JpcHRpb24sIG9yIGEgbXV0YXRpb24gcGVyIEhPQy4gXCIgK1xuICAgICAgICBcIlwiLmNvbmNhdChkb2N1bWVudCwgXCIgaGFkIFwiKS5jb25jYXQocXVlcmllcy5sZW5ndGgsIFwiIHF1ZXJpZXMsIFwiKS5jb25jYXQoc3Vic2NyaXB0aW9ucy5sZW5ndGgsIFwiIFwiKSArXG4gICAgICAgIFwic3Vic2NyaXB0aW9ucyBhbmQgXCIuY29uY2F0KG11dGF0aW9ucy5sZW5ndGgsIFwiIG11dGF0aW9ucy4gXCIpICtcbiAgICAgICAgXCJZb3UgY2FuIHVzZSAnY29tcG9zZScgdG8gam9pbiBtdWx0aXBsZSBvcGVyYXRpb24gdHlwZXMgdG8gYSBjb21wb25lbnRcIikgOiBnbG9iYWxzLmludmFyaWFudChxdWVyaWVzLmxlbmd0aCArIG11dGF0aW9ucy5sZW5ndGggKyBzdWJzY3JpcHRpb25zLmxlbmd0aCA8PSAxLCAzNCk7XG4gICAgdHlwZSA9IHF1ZXJpZXMubGVuZ3RoID8gZXhwb3J0cy5Eb2N1bWVudFR5cGUuUXVlcnkgOiBleHBvcnRzLkRvY3VtZW50VHlwZS5NdXRhdGlvbjtcbiAgICBpZiAoIXF1ZXJpZXMubGVuZ3RoICYmICFtdXRhdGlvbnMubGVuZ3RoKVxuICAgICAgICB0eXBlID0gZXhwb3J0cy5Eb2N1bWVudFR5cGUuU3Vic2NyaXB0aW9uO1xuICAgIHZhciBkZWZpbml0aW9ucyA9IHF1ZXJpZXMubGVuZ3RoXG4gICAgICAgID8gcXVlcmllc1xuICAgICAgICA6IG11dGF0aW9ucy5sZW5ndGhcbiAgICAgICAgICAgID8gbXV0YXRpb25zXG4gICAgICAgICAgICA6IHN1YnNjcmlwdGlvbnM7XG4gICAgX19ERVZfXyA/IGdsb2JhbHMuaW52YXJpYW50KGRlZmluaXRpb25zLmxlbmd0aCA9PT0gMSwgXCJyZWFjdC1hcG9sbG8gb25seSBzdXBwb3J0cyBvbmUgZGVmaW5pdGlvbiBwZXIgSE9DLiBcIi5jb25jYXQoZG9jdW1lbnQsIFwiIGhhZCBcIikgK1xuICAgICAgICBcIlwiLmNvbmNhdChkZWZpbml0aW9ucy5sZW5ndGgsIFwiIGRlZmluaXRpb25zLiBcIikgK1xuICAgICAgICBcIllvdSBjYW4gdXNlICdjb21wb3NlJyB0byBqb2luIG11bHRpcGxlIG9wZXJhdGlvbiB0eXBlcyB0byBhIGNvbXBvbmVudFwiKSA6IGdsb2JhbHMuaW52YXJpYW50KGRlZmluaXRpb25zLmxlbmd0aCA9PT0gMSwgMzUpO1xuICAgIHZhciBkZWZpbml0aW9uID0gZGVmaW5pdGlvbnNbMF07XG4gICAgdmFyaWFibGVzID0gZGVmaW5pdGlvbi52YXJpYWJsZURlZmluaXRpb25zIHx8IFtdO1xuICAgIGlmIChkZWZpbml0aW9uLm5hbWUgJiYgZGVmaW5pdGlvbi5uYW1lLmtpbmQgPT09ICdOYW1lJykge1xuICAgICAgICBuYW1lID0gZGVmaW5pdGlvbi5uYW1lLnZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbmFtZSA9ICdkYXRhJztcbiAgICB9XG4gICAgdmFyIHBheWxvYWQgPSB7IG5hbWU6IG5hbWUsIHR5cGU6IHR5cGUsIHZhcmlhYmxlczogdmFyaWFibGVzIH07XG4gICAgY2FjaGUuc2V0KGRvY3VtZW50LCBwYXlsb2FkKTtcbiAgICByZXR1cm4gcGF5bG9hZDtcbn1cbmZ1bmN0aW9uIHZlcmlmeURvY3VtZW50VHlwZShkb2N1bWVudCwgdHlwZSkge1xuICAgIHZhciBvcGVyYXRpb24gPSBwYXJzZXIoZG9jdW1lbnQpO1xuICAgIHZhciByZXF1aXJlZE9wZXJhdGlvbk5hbWUgPSBvcGVyYXRpb25OYW1lKHR5cGUpO1xuICAgIHZhciB1c2VkT3BlcmF0aW9uTmFtZSA9IG9wZXJhdGlvbk5hbWUob3BlcmF0aW9uLnR5cGUpO1xuICAgIF9fREVWX18gPyBnbG9iYWxzLmludmFyaWFudChvcGVyYXRpb24udHlwZSA9PT0gdHlwZSwgXCJSdW5uaW5nIGEgXCIuY29uY2F0KHJlcXVpcmVkT3BlcmF0aW9uTmFtZSwgXCIgcmVxdWlyZXMgYSBncmFwaHFsIFwiKSArXG4gICAgICAgIFwiXCIuY29uY2F0KHJlcXVpcmVkT3BlcmF0aW9uTmFtZSwgXCIsIGJ1dCBhIFwiKS5jb25jYXQodXNlZE9wZXJhdGlvbk5hbWUsIFwiIHdhcyB1c2VkIGluc3RlYWQuXCIpKSA6IGdsb2JhbHMuaW52YXJpYW50KG9wZXJhdGlvbi50eXBlID09PSB0eXBlLCAzNik7XG59XG5cbmV4cG9ydHMub3BlcmF0aW9uTmFtZSA9IG9wZXJhdGlvbk5hbWU7XG5leHBvcnRzLnBhcnNlciA9IHBhcnNlcjtcbmV4cG9ydHMudmVyaWZ5RG9jdW1lbnRUeXBlID0gdmVyaWZ5RG9jdW1lbnRUeXBlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2VyLmNqcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@apollo/client/react/parser/parser.cjs\n");

/***/ }),

/***/ "./node_modules/@apollo/client/react/react.cjs":
/*!*****************************************************!*\
  !*** ./node_modules/@apollo/client/react/react.cjs ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n__webpack_require__(/*! ../utilities/globals */ \"./node_modules/@apollo/client/utilities/globals/globals.cjs\");\nvar context = __webpack_require__(/*! ./context */ \"./node_modules/@apollo/client/react/context/context.cjs\");\nvar hooks = __webpack_require__(/*! ./hooks */ \"./node_modules/@apollo/client/react/hooks/hooks.cjs\");\nvar parser = __webpack_require__(/*! ./parser */ \"./node_modules/@apollo/client/react/parser/parser.cjs\");\n\n\n\nexports.ApolloConsumer = context.ApolloConsumer;\nexports.ApolloProvider = context.ApolloProvider;\nexports.getApolloContext = context.getApolloContext;\nexports.resetApolloContext = context.resetApolloContext;\nexports.DocumentType = parser.DocumentType;\nexports.operationName = parser.operationName;\nexports.parser = parser.parser;\nfor (var k in hooks) {\n\tif (k !== 'default' && !exports.hasOwnProperty(k)) exports[k] = hooks[k];\n}\n//# sourceMappingURL=react.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvcmVhY3QvcmVhY3QuY2pzPzVkMDUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQThDLGNBQWM7O0FBRTVELG1CQUFPLENBQUMseUZBQXNCO0FBQzlCLGNBQWMsbUJBQU8sQ0FBQywwRUFBVztBQUNqQyxZQUFZLG1CQUFPLENBQUMsb0VBQVM7QUFDN0IsYUFBYSxtQkFBTyxDQUFDLHVFQUFVOzs7O0FBSS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvcmVhY3QvcmVhY3QuY2pzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5yZXF1aXJlKCcuLi91dGlsaXRpZXMvZ2xvYmFscycpO1xudmFyIGNvbnRleHQgPSByZXF1aXJlKCcuL2NvbnRleHQnKTtcbnZhciBob29rcyA9IHJlcXVpcmUoJy4vaG9va3MnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcicpO1xuXG5cblxuZXhwb3J0cy5BcG9sbG9Db25zdW1lciA9IGNvbnRleHQuQXBvbGxvQ29uc3VtZXI7XG5leHBvcnRzLkFwb2xsb1Byb3ZpZGVyID0gY29udGV4dC5BcG9sbG9Qcm92aWRlcjtcbmV4cG9ydHMuZ2V0QXBvbGxvQ29udGV4dCA9IGNvbnRleHQuZ2V0QXBvbGxvQ29udGV4dDtcbmV4cG9ydHMucmVzZXRBcG9sbG9Db250ZXh0ID0gY29udGV4dC5yZXNldEFwb2xsb0NvbnRleHQ7XG5leHBvcnRzLkRvY3VtZW50VHlwZSA9IHBhcnNlci5Eb2N1bWVudFR5cGU7XG5leHBvcnRzLm9wZXJhdGlvbk5hbWUgPSBwYXJzZXIub3BlcmF0aW9uTmFtZTtcbmV4cG9ydHMucGFyc2VyID0gcGFyc2VyLnBhcnNlcjtcbmZvciAodmFyIGsgaW4gaG9va3MpIHtcblx0aWYgKGsgIT09ICdkZWZhdWx0JyAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShrKSkgZXhwb3J0c1trXSA9IGhvb2tzW2tdO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3QuY2pzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@apollo/client/react/react.cjs\n");

/***/ }),

/***/ "./node_modules/@apollo/client/utilities/globals/globals.cjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/globals/globals.cjs ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar tsInvariant = __webpack_require__(/*! ts-invariant */ \"./node_modules/ts-invariant/lib/invariant.cjs\");\nvar process$1 = __webpack_require__(/*! ts-invariant/process */ \"./node_modules/ts-invariant/process/main.cjs\");\nvar graphql = __webpack_require__(/*! graphql */ \"graphql\");\n\nfunction maybe(thunk) {\n    try {\n        return thunk();\n    }\n    catch (_a) { }\n}\n\nvar global$1 = (maybe(function () { return globalThis; }) ||\n    maybe(function () { return window; }) ||\n    maybe(function () { return self; }) ||\n    maybe(function () { return global; }) ||\n    maybe(function () { return maybe.constructor(\"return this\")(); }));\n\nvar __ = \"__\";\nvar GLOBAL_KEY = [__, __].join(\"DEV\");\nfunction getDEV() {\n    try {\n        return Boolean(__DEV__);\n    }\n    catch (_a) {\n        Object.defineProperty(global$1, GLOBAL_KEY, {\n            value: maybe(function () { return \"development\"; }) !== \"production\",\n            enumerable: false,\n            configurable: true,\n            writable: true,\n        });\n        return global$1[GLOBAL_KEY];\n    }\n}\nvar DEV = getDEV();\n\nfunction removeTemporaryGlobals() {\n    return typeof graphql.Source === \"function\" ? process$1.remove() : process$1.remove();\n}\n\nfunction checkDEV() {\n    __DEV__ ? tsInvariant.invariant(\"boolean\" === typeof DEV, DEV) : tsInvariant.invariant(\"boolean\" === typeof DEV, 38);\n}\nremoveTemporaryGlobals();\ncheckDEV();\n\nexports.InvariantError = tsInvariant.InvariantError;\nexports.invariant = tsInvariant.invariant;\nexports.DEV = DEV;\nexports.checkDEV = checkDEV;\nexports.global = global$1;\nexports.maybe = maybe;\n//# sourceMappingURL=globals.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvdXRpbGl0aWVzL2dsb2JhbHMvZ2xvYmFscy5janM/OWU1NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBOEMsY0FBYzs7QUFFNUQsa0JBQWtCLG1CQUFPLENBQUMsbUVBQWM7QUFDeEMsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQXNCO0FBQzlDLGNBQWMsbUJBQU8sQ0FBQyx3QkFBUzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUEsbUNBQW1DLG1CQUFtQixFQUFFO0FBQ3hELHVCQUF1QixlQUFlLEVBQUU7QUFDeEMsdUJBQXVCLGFBQWEsRUFBRTtBQUN0Qyx1QkFBdUIsZUFBZSxFQUFFO0FBQ3hDLHVCQUF1QiwyQ0FBMkMsRUFBRTs7QUFFcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRLGFBQW9CLENBQUMsRUFBRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvdXRpbGl0aWVzL2dsb2JhbHMvZ2xvYmFscy5janMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciB0c0ludmFyaWFudCA9IHJlcXVpcmUoJ3RzLWludmFyaWFudCcpO1xudmFyIHByb2Nlc3MkMSA9IHJlcXVpcmUoJ3RzLWludmFyaWFudC9wcm9jZXNzJyk7XG52YXIgZ3JhcGhxbCA9IHJlcXVpcmUoJ2dyYXBocWwnKTtcblxuZnVuY3Rpb24gbWF5YmUodGh1bmspIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGh1bmsoKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7IH1cbn1cblxudmFyIGdsb2JhbCQxID0gKG1heWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsb2JhbFRoaXM7IH0pIHx8XG4gICAgbWF5YmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gd2luZG93OyB9KSB8fFxuICAgIG1heWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlbGY7IH0pIHx8XG4gICAgbWF5YmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2xvYmFsOyB9KSB8fFxuICAgIG1heWJlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1heWJlLmNvbnN0cnVjdG9yKFwicmV0dXJuIHRoaXNcIikoKTsgfSkpO1xuXG52YXIgX18gPSBcIl9fXCI7XG52YXIgR0xPQkFMX0tFWSA9IFtfXywgX19dLmpvaW4oXCJERVZcIik7XG5mdW5jdGlvbiBnZXRERVYoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oX19ERVZfXyk7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsJDEsIEdMT0JBTF9LRVksIHtcbiAgICAgICAgICAgIHZhbHVlOiBtYXliZShmdW5jdGlvbiAoKSB7IHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOVjsgfSkgIT09IFwicHJvZHVjdGlvblwiLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBnbG9iYWwkMVtHTE9CQUxfS0VZXTtcbiAgICB9XG59XG52YXIgREVWID0gZ2V0REVWKCk7XG5cbmZ1bmN0aW9uIHJlbW92ZVRlbXBvcmFyeUdsb2JhbHMoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBncmFwaHFsLlNvdXJjZSA9PT0gXCJmdW5jdGlvblwiID8gcHJvY2VzcyQxLnJlbW92ZSgpIDogcHJvY2VzcyQxLnJlbW92ZSgpO1xufVxuXG5mdW5jdGlvbiBjaGVja0RFVigpIHtcbiAgICBfX0RFVl9fID8gdHNJbnZhcmlhbnQuaW52YXJpYW50KFwiYm9vbGVhblwiID09PSB0eXBlb2YgREVWLCBERVYpIDogdHNJbnZhcmlhbnQuaW52YXJpYW50KFwiYm9vbGVhblwiID09PSB0eXBlb2YgREVWLCAzOCk7XG59XG5yZW1vdmVUZW1wb3JhcnlHbG9iYWxzKCk7XG5jaGVja0RFVigpO1xuXG5leHBvcnRzLkludmFyaWFudEVycm9yID0gdHNJbnZhcmlhbnQuSW52YXJpYW50RXJyb3I7XG5leHBvcnRzLmludmFyaWFudCA9IHRzSW52YXJpYW50LmludmFyaWFudDtcbmV4cG9ydHMuREVWID0gREVWO1xuZXhwb3J0cy5jaGVja0RFViA9IGNoZWNrREVWO1xuZXhwb3J0cy5nbG9iYWwgPSBnbG9iYWwkMTtcbmV4cG9ydHMubWF5YmUgPSBtYXliZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsb2JhbHMuY2pzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@apollo/client/utilities/globals/globals.cjs\n");

/***/ }),

/***/ "./node_modules/@apollo/client/utilities/utilities.cjs":
/*!*************************************************************!*\
  !*** ./node_modules/@apollo/client/utilities/utilities.cjs ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar globals = __webpack_require__(/*! ./globals */ \"./node_modules/@apollo/client/utilities/globals/globals.cjs\");\nvar graphql = __webpack_require__(/*! graphql */ \"graphql\");\nvar tslib = __webpack_require__(/*! tslib */ \"tslib\");\nvar zenObservableTs = __webpack_require__(/*! zen-observable-ts */ \"./node_modules/zen-observable-ts/index.cjs\");\n__webpack_require__(/*! symbol-observable */ \"symbol-observable\");\n\nfunction shouldInclude(_a, variables) {\n    var directives = _a.directives;\n    if (!directives || !directives.length) {\n        return true;\n    }\n    return getInclusionDirectives(directives).every(function (_a) {\n        var directive = _a.directive, ifArgument = _a.ifArgument;\n        var evaledValue = false;\n        if (ifArgument.value.kind === 'Variable') {\n            evaledValue = variables && variables[ifArgument.value.name.value];\n            __DEV__ ? globals.invariant(evaledValue !== void 0, \"Invalid variable referenced in @\".concat(directive.name.value, \" directive.\")) : globals.invariant(evaledValue !== void 0, 39);\n        }\n        else {\n            evaledValue = ifArgument.value.value;\n        }\n        return directive.name.value === 'skip' ? !evaledValue : evaledValue;\n    });\n}\nfunction getDirectiveNames(root) {\n    var names = [];\n    graphql.visit(root, {\n        Directive: function (node) {\n            names.push(node.name.value);\n        },\n    });\n    return names;\n}\nvar hasAnyDirectives = function (names, root) { return hasDirectives(names, root, false); };\nvar hasAllDirectives = function (names, root) { return hasDirectives(names, root, true); };\nfunction hasDirectives(names, root, all) {\n    var nameSet = new Set(names);\n    var uniqueCount = nameSet.size;\n    graphql.visit(root, {\n        Directive: function (node) {\n            if (nameSet.delete(node.name.value) &&\n                (!all || !nameSet.size)) {\n                return graphql.BREAK;\n            }\n        },\n    });\n    return all ? !nameSet.size : nameSet.size < uniqueCount;\n}\nfunction hasClientExports(document) {\n    return document && hasDirectives(['client', 'export'], document, true);\n}\nfunction isInclusionDirective(_a) {\n    var value = _a.name.value;\n    return value === 'skip' || value === 'include';\n}\nfunction getInclusionDirectives(directives) {\n    var result = [];\n    if (directives && directives.length) {\n        directives.forEach(function (directive) {\n            if (!isInclusionDirective(directive))\n                return;\n            var directiveArguments = directive.arguments;\n            var directiveName = directive.name.value;\n            __DEV__ ? globals.invariant(directiveArguments && directiveArguments.length === 1, \"Incorrect number of arguments for the @\".concat(directiveName, \" directive.\")) : globals.invariant(directiveArguments && directiveArguments.length === 1, 40);\n            var ifArgument = directiveArguments[0];\n            __DEV__ ? globals.invariant(ifArgument.name && ifArgument.name.value === 'if', \"Invalid argument for the @\".concat(directiveName, \" directive.\")) : globals.invariant(ifArgument.name && ifArgument.name.value === 'if', 41);\n            var ifValue = ifArgument.value;\n            __DEV__ ? globals.invariant(ifValue &&\n                (ifValue.kind === 'Variable' || ifValue.kind === 'BooleanValue'), \"Argument for the @\".concat(directiveName, \" directive must be a variable or a boolean value.\")) : globals.invariant(ifValue &&\n                (ifValue.kind === 'Variable' || ifValue.kind === 'BooleanValue'), 42);\n            result.push({ directive: directive, ifArgument: ifArgument });\n        });\n    }\n    return result;\n}\n\nfunction getFragmentQueryDocument(document, fragmentName) {\n    var actualFragmentName = fragmentName;\n    var fragments = [];\n    document.definitions.forEach(function (definition) {\n        if (definition.kind === 'OperationDefinition') {\n            throw __DEV__ ? new globals.InvariantError(\"Found a \".concat(definition.operation, \" operation\").concat(definition.name ? \" named '\".concat(definition.name.value, \"'\") : '', \". \") +\n                'No operations are allowed when using a fragment as a query. Only fragments are allowed.') : new globals.InvariantError(43);\n        }\n        if (definition.kind === 'FragmentDefinition') {\n            fragments.push(definition);\n        }\n    });\n    if (typeof actualFragmentName === 'undefined') {\n        __DEV__ ? globals.invariant(fragments.length === 1, \"Found \".concat(fragments.length, \" fragments. `fragmentName` must be provided when there is not exactly 1 fragment.\")) : globals.invariant(fragments.length === 1, 44);\n        actualFragmentName = fragments[0].name.value;\n    }\n    var query = tslib.__assign(tslib.__assign({}, document), { definitions: tslib.__spreadArray([\n            {\n                kind: 'OperationDefinition',\n                operation: 'query',\n                selectionSet: {\n                    kind: 'SelectionSet',\n                    selections: [\n                        {\n                            kind: 'FragmentSpread',\n                            name: {\n                                kind: 'Name',\n                                value: actualFragmentName,\n                            },\n                        },\n                    ],\n                },\n            }\n        ], document.definitions, true) });\n    return query;\n}\nfunction createFragmentMap(fragments) {\n    if (fragments === void 0) { fragments = []; }\n    var symTable = {};\n    fragments.forEach(function (fragment) {\n        symTable[fragment.name.value] = fragment;\n    });\n    return symTable;\n}\nfunction getFragmentFromSelection(selection, fragmentMap) {\n    switch (selection.kind) {\n        case 'InlineFragment':\n            return selection;\n        case 'FragmentSpread': {\n            var fragmentName = selection.name.value;\n            if (typeof fragmentMap === \"function\") {\n                return fragmentMap(fragmentName);\n            }\n            var fragment = fragmentMap && fragmentMap[fragmentName];\n            __DEV__ ? globals.invariant(fragment, \"No fragment named \".concat(fragmentName)) : globals.invariant(fragment, 45);\n            return fragment || null;\n        }\n        default:\n            return null;\n    }\n}\n\nfunction isNonNullObject(obj) {\n    return obj !== null && typeof obj === 'object';\n}\n\nfunction makeReference(id) {\n    return { __ref: String(id) };\n}\nfunction isReference(obj) {\n    return Boolean(obj && typeof obj === 'object' && typeof obj.__ref === 'string');\n}\nfunction isDocumentNode(value) {\n    return (isNonNullObject(value) &&\n        value.kind === \"Document\" &&\n        Array.isArray(value.definitions));\n}\nfunction isStringValue(value) {\n    return value.kind === 'StringValue';\n}\nfunction isBooleanValue(value) {\n    return value.kind === 'BooleanValue';\n}\nfunction isIntValue(value) {\n    return value.kind === 'IntValue';\n}\nfunction isFloatValue(value) {\n    return value.kind === 'FloatValue';\n}\nfunction isVariable(value) {\n    return value.kind === 'Variable';\n}\nfunction isObjectValue(value) {\n    return value.kind === 'ObjectValue';\n}\nfunction isListValue(value) {\n    return value.kind === 'ListValue';\n}\nfunction isEnumValue(value) {\n    return value.kind === 'EnumValue';\n}\nfunction isNullValue(value) {\n    return value.kind === 'NullValue';\n}\nfunction valueToObjectRepresentation(argObj, name, value, variables) {\n    if (isIntValue(value) || isFloatValue(value)) {\n        argObj[name.value] = Number(value.value);\n    }\n    else if (isBooleanValue(value) || isStringValue(value)) {\n        argObj[name.value] = value.value;\n    }\n    else if (isObjectValue(value)) {\n        var nestedArgObj_1 = {};\n        value.fields.map(function (obj) {\n            return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);\n        });\n        argObj[name.value] = nestedArgObj_1;\n    }\n    else if (isVariable(value)) {\n        var variableValue = (variables || {})[value.name.value];\n        argObj[name.value] = variableValue;\n    }\n    else if (isListValue(value)) {\n        argObj[name.value] = value.values.map(function (listValue) {\n            var nestedArgArrayObj = {};\n            valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);\n            return nestedArgArrayObj[name.value];\n        });\n    }\n    else if (isEnumValue(value)) {\n        argObj[name.value] = value.value;\n    }\n    else if (isNullValue(value)) {\n        argObj[name.value] = null;\n    }\n    else {\n        throw __DEV__ ? new globals.InvariantError(\"The inline argument \\\"\".concat(name.value, \"\\\" of kind \\\"\").concat(value.kind, \"\\\"\") +\n            'is not supported. Use variables instead of inline arguments to ' +\n            'overcome this limitation.') : new globals.InvariantError(54);\n    }\n}\nfunction storeKeyNameFromField(field, variables) {\n    var directivesObj = null;\n    if (field.directives) {\n        directivesObj = {};\n        field.directives.forEach(function (directive) {\n            directivesObj[directive.name.value] = {};\n            if (directive.arguments) {\n                directive.arguments.forEach(function (_a) {\n                    var name = _a.name, value = _a.value;\n                    return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);\n                });\n            }\n        });\n    }\n    var argObj = null;\n    if (field.arguments && field.arguments.length) {\n        argObj = {};\n        field.arguments.forEach(function (_a) {\n            var name = _a.name, value = _a.value;\n            return valueToObjectRepresentation(argObj, name, value, variables);\n        });\n    }\n    return getStoreKeyName(field.name.value, argObj, directivesObj);\n}\nvar KNOWN_DIRECTIVES = [\n    'connection',\n    'include',\n    'skip',\n    'client',\n    'rest',\n    'export',\n];\nvar getStoreKeyName = Object.assign(function (fieldName, args, directives) {\n    if (args &&\n        directives &&\n        directives['connection'] &&\n        directives['connection']['key']) {\n        if (directives['connection']['filter'] &&\n            directives['connection']['filter'].length > 0) {\n            var filterKeys = directives['connection']['filter']\n                ? directives['connection']['filter']\n                : [];\n            filterKeys.sort();\n            var filteredArgs_1 = {};\n            filterKeys.forEach(function (key) {\n                filteredArgs_1[key] = args[key];\n            });\n            return \"\".concat(directives['connection']['key'], \"(\").concat(stringify(filteredArgs_1), \")\");\n        }\n        else {\n            return directives['connection']['key'];\n        }\n    }\n    var completeFieldName = fieldName;\n    if (args) {\n        var stringifiedArgs = stringify(args);\n        completeFieldName += \"(\".concat(stringifiedArgs, \")\");\n    }\n    if (directives) {\n        Object.keys(directives).forEach(function (key) {\n            if (KNOWN_DIRECTIVES.indexOf(key) !== -1)\n                return;\n            if (directives[key] && Object.keys(directives[key]).length) {\n                completeFieldName += \"@\".concat(key, \"(\").concat(stringify(directives[key]), \")\");\n            }\n            else {\n                completeFieldName += \"@\".concat(key);\n            }\n        });\n    }\n    return completeFieldName;\n}, {\n    setStringify: function (s) {\n        var previous = stringify;\n        stringify = s;\n        return previous;\n    },\n});\nvar stringify = function defaultStringify(value) {\n    return JSON.stringify(value, stringifyReplacer);\n};\nfunction stringifyReplacer(_key, value) {\n    if (isNonNullObject(value) && !Array.isArray(value)) {\n        value = Object.keys(value).sort().reduce(function (copy, key) {\n            copy[key] = value[key];\n            return copy;\n        }, {});\n    }\n    return value;\n}\nfunction argumentsObjectFromField(field, variables) {\n    if (field.arguments && field.arguments.length) {\n        var argObj_1 = {};\n        field.arguments.forEach(function (_a) {\n            var name = _a.name, value = _a.value;\n            return valueToObjectRepresentation(argObj_1, name, value, variables);\n        });\n        return argObj_1;\n    }\n    return null;\n}\nfunction resultKeyNameFromField(field) {\n    return field.alias ? field.alias.value : field.name.value;\n}\nfunction getTypenameFromResult(result, selectionSet, fragmentMap) {\n    if (typeof result.__typename === 'string') {\n        return result.__typename;\n    }\n    for (var _i = 0, _a = selectionSet.selections; _i < _a.length; _i++) {\n        var selection = _a[_i];\n        if (isField(selection)) {\n            if (selection.name.value === '__typename') {\n                return result[resultKeyNameFromField(selection)];\n            }\n        }\n        else {\n            var typename = getTypenameFromResult(result, getFragmentFromSelection(selection, fragmentMap).selectionSet, fragmentMap);\n            if (typeof typename === 'string') {\n                return typename;\n            }\n        }\n    }\n}\nfunction isField(selection) {\n    return selection.kind === 'Field';\n}\nfunction isInlineFragment(selection) {\n    return selection.kind === 'InlineFragment';\n}\n\nfunction checkDocument(doc) {\n    __DEV__ ? globals.invariant(doc && doc.kind === 'Document', \"Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \\\"gql\\\" tag? http://docs.apollostack.com/apollo-client/core.html#gql\") : globals.invariant(doc && doc.kind === 'Document', 46);\n    var operations = doc.definitions\n        .filter(function (d) { return d.kind !== 'FragmentDefinition'; })\n        .map(function (definition) {\n        if (definition.kind !== 'OperationDefinition') {\n            throw __DEV__ ? new globals.InvariantError(\"Schema type definitions not allowed in queries. Found: \\\"\".concat(definition.kind, \"\\\"\")) : new globals.InvariantError(47);\n        }\n        return definition;\n    });\n    __DEV__ ? globals.invariant(operations.length <= 1, \"Ambiguous GraphQL document: contains \".concat(operations.length, \" operations\")) : globals.invariant(operations.length <= 1, 48);\n    return doc;\n}\nfunction getOperationDefinition(doc) {\n    checkDocument(doc);\n    return doc.definitions.filter(function (definition) { return definition.kind === 'OperationDefinition'; })[0];\n}\nfunction getOperationName(doc) {\n    return (doc.definitions\n        .filter(function (definition) {\n        return definition.kind === 'OperationDefinition' && definition.name;\n    })\n        .map(function (x) { return x.name.value; })[0] || null);\n}\nfunction getFragmentDefinitions(doc) {\n    return doc.definitions.filter(function (definition) { return definition.kind === 'FragmentDefinition'; });\n}\nfunction getQueryDefinition(doc) {\n    var queryDef = getOperationDefinition(doc);\n    __DEV__ ? globals.invariant(queryDef && queryDef.operation === 'query', 'Must contain a query definition.') : globals.invariant(queryDef && queryDef.operation === 'query', 49);\n    return queryDef;\n}\nfunction getFragmentDefinition(doc) {\n    __DEV__ ? globals.invariant(doc.kind === 'Document', \"Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a \\\"gql\\\" tag? http://docs.apollostack.com/apollo-client/core.html#gql\") : globals.invariant(doc.kind === 'Document', 50);\n    __DEV__ ? globals.invariant(doc.definitions.length <= 1, 'Fragment must have exactly one definition.') : globals.invariant(doc.definitions.length <= 1, 51);\n    var fragmentDef = doc.definitions[0];\n    __DEV__ ? globals.invariant(fragmentDef.kind === 'FragmentDefinition', 'Must be a fragment definition.') : globals.invariant(fragmentDef.kind === 'FragmentDefinition', 52);\n    return fragmentDef;\n}\nfunction getMainDefinition(queryDoc) {\n    checkDocument(queryDoc);\n    var fragmentDefinition;\n    for (var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++) {\n        var definition = _a[_i];\n        if (definition.kind === 'OperationDefinition') {\n            var operation = definition.operation;\n            if (operation === 'query' ||\n                operation === 'mutation' ||\n                operation === 'subscription') {\n                return definition;\n            }\n        }\n        if (definition.kind === 'FragmentDefinition' && !fragmentDefinition) {\n            fragmentDefinition = definition;\n        }\n    }\n    if (fragmentDefinition) {\n        return fragmentDefinition;\n    }\n    throw __DEV__ ? new globals.InvariantError('Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment.') : new globals.InvariantError(53);\n}\nfunction getDefaultValues(definition) {\n    var defaultValues = Object.create(null);\n    var defs = definition && definition.variableDefinitions;\n    if (defs && defs.length) {\n        defs.forEach(function (def) {\n            if (def.defaultValue) {\n                valueToObjectRepresentation(defaultValues, def.variable.name, def.defaultValue);\n            }\n        });\n    }\n    return defaultValues;\n}\n\nfunction filterInPlace(array, test, context) {\n    var target = 0;\n    array.forEach(function (elem, i) {\n        if (test.call(this, elem, i, array)) {\n            array[target++] = elem;\n        }\n    }, context);\n    array.length = target;\n    return array;\n}\n\nvar TYPENAME_FIELD = {\n    kind: 'Field',\n    name: {\n        kind: 'Name',\n        value: '__typename',\n    },\n};\nfunction isEmpty(op, fragmentMap) {\n    return !op || op.selectionSet.selections.every(function (selection) { return selection.kind === 'FragmentSpread' &&\n        isEmpty(fragmentMap[selection.name.value], fragmentMap); });\n}\nfunction nullIfDocIsEmpty(doc) {\n    return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc)))\n        ? null\n        : doc;\n}\nfunction getDirectiveMatcher(directives) {\n    return function directiveMatcher(directive) {\n        return directives.some(function (dir) {\n            return (dir.name && dir.name === directive.name.value) ||\n                (dir.test && dir.test(directive));\n        });\n    };\n}\nfunction removeDirectivesFromDocument(directives, doc) {\n    var variablesInUse = Object.create(null);\n    var variablesToRemove = [];\n    var fragmentSpreadsInUse = Object.create(null);\n    var fragmentSpreadsToRemove = [];\n    var modifiedDoc = nullIfDocIsEmpty(graphql.visit(doc, {\n        Variable: {\n            enter: function (node, _key, parent) {\n                if (parent.kind !== 'VariableDefinition') {\n                    variablesInUse[node.name.value] = true;\n                }\n            },\n        },\n        Field: {\n            enter: function (node) {\n                if (directives && node.directives) {\n                    var shouldRemoveField = directives.some(function (directive) { return directive.remove; });\n                    if (shouldRemoveField &&\n                        node.directives &&\n                        node.directives.some(getDirectiveMatcher(directives))) {\n                        if (node.arguments) {\n                            node.arguments.forEach(function (arg) {\n                                if (arg.value.kind === 'Variable') {\n                                    variablesToRemove.push({\n                                        name: arg.value.name.value,\n                                    });\n                                }\n                            });\n                        }\n                        if (node.selectionSet) {\n                            getAllFragmentSpreadsFromSelectionSet(node.selectionSet).forEach(function (frag) {\n                                fragmentSpreadsToRemove.push({\n                                    name: frag.name.value,\n                                });\n                            });\n                        }\n                        return null;\n                    }\n                }\n            },\n        },\n        FragmentSpread: {\n            enter: function (node) {\n                fragmentSpreadsInUse[node.name.value] = true;\n            },\n        },\n        Directive: {\n            enter: function (node) {\n                if (getDirectiveMatcher(directives)(node)) {\n                    return null;\n                }\n            },\n        },\n    }));\n    if (modifiedDoc &&\n        filterInPlace(variablesToRemove, function (v) { return !!v.name && !variablesInUse[v.name]; }).length) {\n        modifiedDoc = removeArgumentsFromDocument(variablesToRemove, modifiedDoc);\n    }\n    if (modifiedDoc &&\n        filterInPlace(fragmentSpreadsToRemove, function (fs) { return !!fs.name && !fragmentSpreadsInUse[fs.name]; })\n            .length) {\n        modifiedDoc = removeFragmentSpreadFromDocument(fragmentSpreadsToRemove, modifiedDoc);\n    }\n    return modifiedDoc;\n}\nvar addTypenameToDocument = Object.assign(function (doc) {\n    return graphql.visit(doc, {\n        SelectionSet: {\n            enter: function (node, _key, parent) {\n                if (parent &&\n                    parent.kind === 'OperationDefinition') {\n                    return;\n                }\n                var selections = node.selections;\n                if (!selections) {\n                    return;\n                }\n                var skip = selections.some(function (selection) {\n                    return (isField(selection) &&\n                        (selection.name.value === '__typename' ||\n                            selection.name.value.lastIndexOf('__', 0) === 0));\n                });\n                if (skip) {\n                    return;\n                }\n                var field = parent;\n                if (isField(field) &&\n                    field.directives &&\n                    field.directives.some(function (d) { return d.name.value === 'export'; })) {\n                    return;\n                }\n                return tslib.__assign(tslib.__assign({}, node), { selections: tslib.__spreadArray(tslib.__spreadArray([], selections, true), [TYPENAME_FIELD], false) });\n            },\n        },\n    });\n}, {\n    added: function (field) {\n        return field === TYPENAME_FIELD;\n    },\n});\nvar connectionRemoveConfig = {\n    test: function (directive) {\n        var willRemove = directive.name.value === 'connection';\n        if (willRemove) {\n            if (!directive.arguments ||\n                !directive.arguments.some(function (arg) { return arg.name.value === 'key'; })) {\n                __DEV__ && globals.invariant.warn('Removing an @connection directive even though it does not have a key. ' +\n                    'You may want to use the key parameter to specify a store key.');\n            }\n        }\n        return willRemove;\n    },\n};\nfunction removeConnectionDirectiveFromDocument(doc) {\n    return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));\n}\nfunction getArgumentMatcher(config) {\n    return function argumentMatcher(argument) {\n        return config.some(function (aConfig) {\n            return argument.value &&\n                argument.value.kind === 'Variable' &&\n                argument.value.name &&\n                (aConfig.name === argument.value.name.value ||\n                    (aConfig.test && aConfig.test(argument)));\n        });\n    };\n}\nfunction removeArgumentsFromDocument(config, doc) {\n    var argMatcher = getArgumentMatcher(config);\n    return nullIfDocIsEmpty(graphql.visit(doc, {\n        OperationDefinition: {\n            enter: function (node) {\n                return tslib.__assign(tslib.__assign({}, node), { variableDefinitions: node.variableDefinitions ? node.variableDefinitions.filter(function (varDef) {\n                        return !config.some(function (arg) { return arg.name === varDef.variable.name.value; });\n                    }) : [] });\n            },\n        },\n        Field: {\n            enter: function (node) {\n                var shouldRemoveField = config.some(function (argConfig) { return argConfig.remove; });\n                if (shouldRemoveField) {\n                    var argMatchCount_1 = 0;\n                    if (node.arguments) {\n                        node.arguments.forEach(function (arg) {\n                            if (argMatcher(arg)) {\n                                argMatchCount_1 += 1;\n                            }\n                        });\n                    }\n                    if (argMatchCount_1 === 1) {\n                        return null;\n                    }\n                }\n            },\n        },\n        Argument: {\n            enter: function (node) {\n                if (argMatcher(node)) {\n                    return null;\n                }\n            },\n        },\n    }));\n}\nfunction removeFragmentSpreadFromDocument(config, doc) {\n    function enter(node) {\n        if (config.some(function (def) { return def.name === node.name.value; })) {\n            return null;\n        }\n    }\n    return nullIfDocIsEmpty(graphql.visit(doc, {\n        FragmentSpread: { enter: enter },\n        FragmentDefinition: { enter: enter },\n    }));\n}\nfunction getAllFragmentSpreadsFromSelectionSet(selectionSet) {\n    var allFragments = [];\n    selectionSet.selections.forEach(function (selection) {\n        if ((isField(selection) || isInlineFragment(selection)) &&\n            selection.selectionSet) {\n            getAllFragmentSpreadsFromSelectionSet(selection.selectionSet).forEach(function (frag) { return allFragments.push(frag); });\n        }\n        else if (selection.kind === 'FragmentSpread') {\n            allFragments.push(selection);\n        }\n    });\n    return allFragments;\n}\nfunction buildQueryFromSelectionSet(document) {\n    var definition = getMainDefinition(document);\n    var definitionOperation = definition.operation;\n    if (definitionOperation === 'query') {\n        return document;\n    }\n    var modifiedDoc = graphql.visit(document, {\n        OperationDefinition: {\n            enter: function (node) {\n                return tslib.__assign(tslib.__assign({}, node), { operation: 'query' });\n            },\n        },\n    });\n    return modifiedDoc;\n}\nfunction removeClientSetsFromDocument(document) {\n    checkDocument(document);\n    var modifiedDoc = removeDirectivesFromDocument([\n        {\n            test: function (directive) { return directive.name.value === 'client'; },\n            remove: true,\n        },\n    ], document);\n    if (modifiedDoc) {\n        modifiedDoc = graphql.visit(modifiedDoc, {\n            FragmentDefinition: {\n                enter: function (node) {\n                    if (node.selectionSet) {\n                        var isTypenameOnly = node.selectionSet.selections.every(function (selection) {\n                            return isField(selection) && selection.name.value === '__typename';\n                        });\n                        if (isTypenameOnly) {\n                            return null;\n                        }\n                    }\n                },\n            },\n        });\n    }\n    return modifiedDoc;\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction mergeDeep() {\n    var sources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        sources[_i] = arguments[_i];\n    }\n    return mergeDeepArray(sources);\n}\nfunction mergeDeepArray(sources) {\n    var target = sources[0] || {};\n    var count = sources.length;\n    if (count > 1) {\n        var merger = new DeepMerger();\n        for (var i = 1; i < count; ++i) {\n            target = merger.merge(target, sources[i]);\n        }\n    }\n    return target;\n}\nvar defaultReconciler = function (target, source, property) {\n    return this.merge(target[property], source[property]);\n};\nvar DeepMerger = (function () {\n    function DeepMerger(reconciler) {\n        if (reconciler === void 0) { reconciler = defaultReconciler; }\n        this.reconciler = reconciler;\n        this.isObject = isNonNullObject;\n        this.pastCopies = new Set();\n    }\n    DeepMerger.prototype.merge = function (target, source) {\n        var _this = this;\n        var context = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            context[_i - 2] = arguments[_i];\n        }\n        if (isNonNullObject(source) && isNonNullObject(target)) {\n            Object.keys(source).forEach(function (sourceKey) {\n                if (hasOwnProperty.call(target, sourceKey)) {\n                    var targetValue = target[sourceKey];\n                    if (source[sourceKey] !== targetValue) {\n                        var result = _this.reconciler.apply(_this, tslib.__spreadArray([target, source, sourceKey], context, false));\n                        if (result !== targetValue) {\n                            target = _this.shallowCopyForMerge(target);\n                            target[sourceKey] = result;\n                        }\n                    }\n                }\n                else {\n                    target = _this.shallowCopyForMerge(target);\n                    target[sourceKey] = source[sourceKey];\n                }\n            });\n            return target;\n        }\n        return source;\n    };\n    DeepMerger.prototype.shallowCopyForMerge = function (value) {\n        if (isNonNullObject(value)) {\n            if (!this.pastCopies.has(value)) {\n                if (Array.isArray(value)) {\n                    value = value.slice(0);\n                }\n                else {\n                    value = tslib.__assign({ __proto__: Object.getPrototypeOf(value) }, value);\n                }\n                this.pastCopies.add(value);\n            }\n        }\n        return value;\n    };\n    return DeepMerger;\n}());\n\nfunction concatPagination(keyArgs) {\n    if (keyArgs === void 0) { keyArgs = false; }\n    return {\n        keyArgs: keyArgs,\n        merge: function (existing, incoming) {\n            return existing ? tslib.__spreadArray(tslib.__spreadArray([], existing, true), incoming, true) : incoming;\n        },\n    };\n}\nfunction offsetLimitPagination(keyArgs) {\n    if (keyArgs === void 0) { keyArgs = false; }\n    return {\n        keyArgs: keyArgs,\n        merge: function (existing, incoming, _a) {\n            var args = _a.args;\n            var merged = existing ? existing.slice(0) : [];\n            if (incoming) {\n                if (args) {\n                    var _b = args.offset, offset = _b === void 0 ? 0 : _b;\n                    for (var i = 0; i < incoming.length; ++i) {\n                        merged[offset + i] = incoming[i];\n                    }\n                }\n                else {\n                    merged.push.apply(merged, incoming);\n                }\n            }\n            return merged;\n        },\n    };\n}\nfunction relayStylePagination(keyArgs) {\n    if (keyArgs === void 0) { keyArgs = false; }\n    return {\n        keyArgs: keyArgs,\n        read: function (existing, _a) {\n            var canRead = _a.canRead, readField = _a.readField;\n            if (!existing)\n                return existing;\n            var edges = [];\n            var firstEdgeCursor = \"\";\n            var lastEdgeCursor = \"\";\n            existing.edges.forEach(function (edge) {\n                if (canRead(readField(\"node\", edge))) {\n                    edges.push(edge);\n                    if (edge.cursor) {\n                        firstEdgeCursor = firstEdgeCursor || edge.cursor || \"\";\n                        lastEdgeCursor = edge.cursor || lastEdgeCursor;\n                    }\n                }\n            });\n            var _b = existing.pageInfo || {}, startCursor = _b.startCursor, endCursor = _b.endCursor;\n            return tslib.__assign(tslib.__assign({}, getExtras(existing)), { edges: edges, pageInfo: tslib.__assign(tslib.__assign({}, existing.pageInfo), { startCursor: startCursor || firstEdgeCursor, endCursor: endCursor || lastEdgeCursor }) });\n        },\n        merge: function (existing, incoming, _a) {\n            var args = _a.args, isReference = _a.isReference, readField = _a.readField;\n            if (!existing) {\n                existing = makeEmptyData();\n            }\n            if (!incoming) {\n                return existing;\n            }\n            var incomingEdges = incoming.edges ? incoming.edges.map(function (edge) {\n                if (isReference(edge = tslib.__assign({}, edge))) {\n                    edge.cursor = readField(\"cursor\", edge);\n                }\n                return edge;\n            }) : [];\n            if (incoming.pageInfo) {\n                var pageInfo_1 = incoming.pageInfo;\n                var startCursor = pageInfo_1.startCursor, endCursor = pageInfo_1.endCursor;\n                var firstEdge = incomingEdges[0];\n                var lastEdge = incomingEdges[incomingEdges.length - 1];\n                if (firstEdge && startCursor) {\n                    firstEdge.cursor = startCursor;\n                }\n                if (lastEdge && endCursor) {\n                    lastEdge.cursor = endCursor;\n                }\n                var firstCursor = firstEdge && firstEdge.cursor;\n                if (firstCursor && !startCursor) {\n                    incoming = mergeDeep(incoming, {\n                        pageInfo: {\n                            startCursor: firstCursor,\n                        },\n                    });\n                }\n                var lastCursor = lastEdge && lastEdge.cursor;\n                if (lastCursor && !endCursor) {\n                    incoming = mergeDeep(incoming, {\n                        pageInfo: {\n                            endCursor: lastCursor,\n                        },\n                    });\n                }\n            }\n            var prefix = existing.edges;\n            var suffix = [];\n            if (args && args.after) {\n                var index = prefix.findIndex(function (edge) { return edge.cursor === args.after; });\n                if (index >= 0) {\n                    prefix = prefix.slice(0, index + 1);\n                }\n            }\n            else if (args && args.before) {\n                var index = prefix.findIndex(function (edge) { return edge.cursor === args.before; });\n                suffix = index < 0 ? prefix : prefix.slice(index);\n                prefix = [];\n            }\n            else if (incoming.edges) {\n                prefix = [];\n            }\n            var edges = tslib.__spreadArray(tslib.__spreadArray(tslib.__spreadArray([], prefix, true), incomingEdges, true), suffix, true);\n            var pageInfo = tslib.__assign(tslib.__assign({}, incoming.pageInfo), existing.pageInfo);\n            if (incoming.pageInfo) {\n                var _b = incoming.pageInfo, hasPreviousPage = _b.hasPreviousPage, hasNextPage = _b.hasNextPage, startCursor = _b.startCursor, endCursor = _b.endCursor, extras = tslib.__rest(_b, [\"hasPreviousPage\", \"hasNextPage\", \"startCursor\", \"endCursor\"]);\n                Object.assign(pageInfo, extras);\n                if (!prefix.length) {\n                    if (void 0 !== hasPreviousPage)\n                        pageInfo.hasPreviousPage = hasPreviousPage;\n                    if (void 0 !== startCursor)\n                        pageInfo.startCursor = startCursor;\n                }\n                if (!suffix.length) {\n                    if (void 0 !== hasNextPage)\n                        pageInfo.hasNextPage = hasNextPage;\n                    if (void 0 !== endCursor)\n                        pageInfo.endCursor = endCursor;\n                }\n            }\n            return tslib.__assign(tslib.__assign(tslib.__assign({}, getExtras(existing)), getExtras(incoming)), { edges: edges, pageInfo: pageInfo });\n        },\n    };\n}\nvar getExtras = function (obj) { return tslib.__rest(obj, notExtras); };\nvar notExtras = [\"edges\", \"pageInfo\"];\nfunction makeEmptyData() {\n    return {\n        edges: [],\n        pageInfo: {\n            hasPreviousPage: false,\n            hasNextPage: true,\n            startCursor: \"\",\n            endCursor: \"\",\n        },\n    };\n}\n\nvar toString = Object.prototype.toString;\nfunction cloneDeep(value) {\n    return cloneDeepHelper(value);\n}\nfunction cloneDeepHelper(val, seen) {\n    switch (toString.call(val)) {\n        case \"[object Array]\": {\n            seen = seen || new Map;\n            if (seen.has(val))\n                return seen.get(val);\n            var copy_1 = val.slice(0);\n            seen.set(val, copy_1);\n            copy_1.forEach(function (child, i) {\n                copy_1[i] = cloneDeepHelper(child, seen);\n            });\n            return copy_1;\n        }\n        case \"[object Object]\": {\n            seen = seen || new Map;\n            if (seen.has(val))\n                return seen.get(val);\n            var copy_2 = Object.create(Object.getPrototypeOf(val));\n            seen.set(val, copy_2);\n            Object.keys(val).forEach(function (key) {\n                copy_2[key] = cloneDeepHelper(val[key], seen);\n            });\n            return copy_2;\n        }\n        default:\n            return val;\n    }\n}\n\nfunction deepFreeze(value) {\n    var workSet = new Set([value]);\n    workSet.forEach(function (obj) {\n        if (isNonNullObject(obj) && shallowFreeze(obj) === obj) {\n            Object.getOwnPropertyNames(obj).forEach(function (name) {\n                if (isNonNullObject(obj[name]))\n                    workSet.add(obj[name]);\n            });\n        }\n    });\n    return value;\n}\nfunction shallowFreeze(obj) {\n    if (__DEV__ && !Object.isFrozen(obj)) {\n        try {\n            Object.freeze(obj);\n        }\n        catch (e) {\n            if (e instanceof TypeError)\n                return null;\n            throw e;\n        }\n    }\n    return obj;\n}\nfunction maybeDeepFreeze(obj) {\n    if (__DEV__) {\n        deepFreeze(obj);\n    }\n    return obj;\n}\n\nfunction iterateObserversSafely(observers, method, argument) {\n    var observersWithMethod = [];\n    observers.forEach(function (obs) { return obs[method] && observersWithMethod.push(obs); });\n    observersWithMethod.forEach(function (obs) { return obs[method](argument); });\n}\n\nfunction asyncMap(observable, mapFn, catchFn) {\n    return new zenObservableTs.Observable(function (observer) {\n        var next = observer.next, error = observer.error, complete = observer.complete;\n        var activeCallbackCount = 0;\n        var completed = false;\n        var promiseQueue = {\n            then: function (callback) {\n                return new Promise(function (resolve) { return resolve(callback()); });\n            },\n        };\n        function makeCallback(examiner, delegate) {\n            if (examiner) {\n                return function (arg) {\n                    ++activeCallbackCount;\n                    var both = function () { return examiner(arg); };\n                    promiseQueue = promiseQueue.then(both, both).then(function (result) {\n                        --activeCallbackCount;\n                        next && next.call(observer, result);\n                        if (completed) {\n                            handler.complete();\n                        }\n                    }, function (error) {\n                        --activeCallbackCount;\n                        throw error;\n                    }).catch(function (caught) {\n                        error && error.call(observer, caught);\n                    });\n                };\n            }\n            else {\n                return function (arg) { return delegate && delegate.call(observer, arg); };\n            }\n        }\n        var handler = {\n            next: makeCallback(mapFn, next),\n            error: makeCallback(catchFn, error),\n            complete: function () {\n                completed = true;\n                if (!activeCallbackCount) {\n                    complete && complete.call(observer);\n                }\n            },\n        };\n        var sub = observable.subscribe(handler);\n        return function () { return sub.unsubscribe(); };\n    });\n}\n\nvar canUseWeakMap = typeof WeakMap === 'function' &&\n    globals.maybe(function () { return navigator.product; }) !== 'ReactNative';\nvar canUseWeakSet = typeof WeakSet === 'function';\nvar canUseSymbol = typeof Symbol === 'function' &&\n    typeof Symbol.for === 'function';\nvar canUseAsyncIteratorSymbol = canUseSymbol && Symbol.asyncIterator;\nvar canUseDOM = typeof globals.maybe(function () { return window.document.createElement; }) === \"function\";\nvar usingJSDOM = globals.maybe(function () { return navigator.userAgent.indexOf(\"jsdom\") >= 0; }) || false;\nvar canUseLayoutEffect = canUseDOM && !usingJSDOM;\n\nfunction fixObservableSubclass(subclass) {\n    function set(key) {\n        Object.defineProperty(subclass, key, { value: zenObservableTs.Observable });\n    }\n    if (canUseSymbol && Symbol.species) {\n        set(Symbol.species);\n    }\n    set(\"@@species\");\n    return subclass;\n}\n\nfunction isPromiseLike(value) {\n    return value && typeof value.then === \"function\";\n}\nvar Concast = (function (_super) {\n    tslib.__extends(Concast, _super);\n    function Concast(sources) {\n        var _this = _super.call(this, function (observer) {\n            _this.addObserver(observer);\n            return function () { return _this.removeObserver(observer); };\n        }) || this;\n        _this.observers = new Set();\n        _this.promise = new Promise(function (resolve, reject) {\n            _this.resolve = resolve;\n            _this.reject = reject;\n        });\n        _this.handlers = {\n            next: function (result) {\n                if (_this.sub !== null) {\n                    _this.latest = [\"next\", result];\n                    _this.notify(\"next\", result);\n                    iterateObserversSafely(_this.observers, \"next\", result);\n                }\n            },\n            error: function (error) {\n                var sub = _this.sub;\n                if (sub !== null) {\n                    if (sub)\n                        setTimeout(function () { return sub.unsubscribe(); });\n                    _this.sub = null;\n                    _this.latest = [\"error\", error];\n                    _this.reject(error);\n                    _this.notify(\"error\", error);\n                    iterateObserversSafely(_this.observers, \"error\", error);\n                }\n            },\n            complete: function () {\n                var sub = _this.sub;\n                if (sub !== null) {\n                    var value = _this.sources.shift();\n                    if (!value) {\n                        if (sub)\n                            setTimeout(function () { return sub.unsubscribe(); });\n                        _this.sub = null;\n                        if (_this.latest &&\n                            _this.latest[0] === \"next\") {\n                            _this.resolve(_this.latest[1]);\n                        }\n                        else {\n                            _this.resolve();\n                        }\n                        _this.notify(\"complete\");\n                        iterateObserversSafely(_this.observers, \"complete\");\n                    }\n                    else if (isPromiseLike(value)) {\n                        value.then(function (obs) { return _this.sub = obs.subscribe(_this.handlers); });\n                    }\n                    else {\n                        _this.sub = value.subscribe(_this.handlers);\n                    }\n                }\n            },\n        };\n        _this.nextResultListeners = new Set();\n        _this.cancel = function (reason) {\n            _this.reject(reason);\n            _this.sources = [];\n            _this.handlers.complete();\n        };\n        _this.promise.catch(function (_) { });\n        if (typeof sources === \"function\") {\n            sources = [new zenObservableTs.Observable(sources)];\n        }\n        if (isPromiseLike(sources)) {\n            sources.then(function (iterable) { return _this.start(iterable); }, _this.handlers.error);\n        }\n        else {\n            _this.start(sources);\n        }\n        return _this;\n    }\n    Concast.prototype.start = function (sources) {\n        if (this.sub !== void 0)\n            return;\n        this.sources = Array.from(sources);\n        this.handlers.complete();\n    };\n    Concast.prototype.deliverLastMessage = function (observer) {\n        if (this.latest) {\n            var nextOrError = this.latest[0];\n            var method = observer[nextOrError];\n            if (method) {\n                method.call(observer, this.latest[1]);\n            }\n            if (this.sub === null &&\n                nextOrError === \"next\" &&\n                observer.complete) {\n                observer.complete();\n            }\n        }\n    };\n    Concast.prototype.addObserver = function (observer) {\n        if (!this.observers.has(observer)) {\n            this.deliverLastMessage(observer);\n            this.observers.add(observer);\n        }\n    };\n    Concast.prototype.removeObserver = function (observer) {\n        if (this.observers.delete(observer) &&\n            this.observers.size < 1) {\n            this.handlers.complete();\n        }\n    };\n    Concast.prototype.notify = function (method, arg) {\n        var nextResultListeners = this.nextResultListeners;\n        if (nextResultListeners.size) {\n            this.nextResultListeners = new Set;\n            nextResultListeners.forEach(function (listener) { return listener(method, arg); });\n        }\n    };\n    Concast.prototype.beforeNext = function (callback) {\n        var called = false;\n        this.nextResultListeners.add(function (method, arg) {\n            if (!called) {\n                called = true;\n                callback(method, arg);\n            }\n        });\n    };\n    return Concast;\n}(zenObservableTs.Observable));\nfixObservableSubclass(Concast);\n\nfunction isNonEmptyArray(value) {\n    return Array.isArray(value) && value.length > 0;\n}\n\nfunction graphQLResultHasError(result) {\n    return (result.errors && result.errors.length > 0) || false;\n}\n\nfunction compact() {\n    var objects = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        objects[_i] = arguments[_i];\n    }\n    var result = Object.create(null);\n    objects.forEach(function (obj) {\n        if (!obj)\n            return;\n        Object.keys(obj).forEach(function (key) {\n            var value = obj[key];\n            if (value !== void 0) {\n                result[key] = value;\n            }\n        });\n    });\n    return result;\n}\n\nvar prefixCounts = new Map();\nfunction makeUniqueId(prefix) {\n    var count = prefixCounts.get(prefix) || 1;\n    prefixCounts.set(prefix, count + 1);\n    return \"\".concat(prefix, \":\").concat(count, \":\").concat(Math.random().toString(36).slice(2));\n}\n\nfunction stringifyForDisplay(value) {\n    var undefId = makeUniqueId(\"stringifyForDisplay\");\n    return JSON.stringify(value, function (key, value) {\n        return value === void 0 ? undefId : value;\n    }).split(JSON.stringify(undefId)).join(\"<undefined>\");\n}\n\nfunction mergeOptions(defaults, options) {\n    return compact(defaults, options, options.variables && {\n        variables: tslib.__assign(tslib.__assign({}, (defaults && defaults.variables)), options.variables),\n    });\n}\n\nexports.DEV = globals.DEV;\nexports.maybe = globals.maybe;\nexports.Observable = zenObservableTs.Observable;\nexports.Concast = Concast;\nexports.DeepMerger = DeepMerger;\nexports.addTypenameToDocument = addTypenameToDocument;\nexports.argumentsObjectFromField = argumentsObjectFromField;\nexports.asyncMap = asyncMap;\nexports.buildQueryFromSelectionSet = buildQueryFromSelectionSet;\nexports.canUseAsyncIteratorSymbol = canUseAsyncIteratorSymbol;\nexports.canUseDOM = canUseDOM;\nexports.canUseLayoutEffect = canUseLayoutEffect;\nexports.canUseSymbol = canUseSymbol;\nexports.canUseWeakMap = canUseWeakMap;\nexports.canUseWeakSet = canUseWeakSet;\nexports.checkDocument = checkDocument;\nexports.cloneDeep = cloneDeep;\nexports.compact = compact;\nexports.concatPagination = concatPagination;\nexports.createFragmentMap = createFragmentMap;\nexports.fixObservableSubclass = fixObservableSubclass;\nexports.getDefaultValues = getDefaultValues;\nexports.getDirectiveNames = getDirectiveNames;\nexports.getFragmentDefinition = getFragmentDefinition;\nexports.getFragmentDefinitions = getFragmentDefinitions;\nexports.getFragmentFromSelection = getFragmentFromSelection;\nexports.getFragmentQueryDocument = getFragmentQueryDocument;\nexports.getInclusionDirectives = getInclusionDirectives;\nexports.getMainDefinition = getMainDefinition;\nexports.getOperationDefinition = getOperationDefinition;\nexports.getOperationName = getOperationName;\nexports.getQueryDefinition = getQueryDefinition;\nexports.getStoreKeyName = getStoreKeyName;\nexports.getTypenameFromResult = getTypenameFromResult;\nexports.graphQLResultHasError = graphQLResultHasError;\nexports.hasAllDirectives = hasAllDirectives;\nexports.hasAnyDirectives = hasAnyDirectives;\nexports.hasClientExports = hasClientExports;\nexports.hasDirectives = hasDirectives;\nexports.isDocumentNode = isDocumentNode;\nexports.isField = isField;\nexports.isInlineFragment = isInlineFragment;\nexports.isNonEmptyArray = isNonEmptyArray;\nexports.isNonNullObject = isNonNullObject;\nexports.isReference = isReference;\nexports.iterateObserversSafely = iterateObserversSafely;\nexports.makeReference = makeReference;\nexports.makeUniqueId = makeUniqueId;\nexports.maybeDeepFreeze = maybeDeepFreeze;\nexports.mergeDeep = mergeDeep;\nexports.mergeDeepArray = mergeDeepArray;\nexports.mergeOptions = mergeOptions;\nexports.offsetLimitPagination = offsetLimitPagination;\nexports.relayStylePagination = relayStylePagination;\nexports.removeArgumentsFromDocument = removeArgumentsFromDocument;\nexports.removeClientSetsFromDocument = removeClientSetsFromDocument;\nexports.removeConnectionDirectiveFromDocument = removeConnectionDirectiveFromDocument;\nexports.removeDirectivesFromDocument = removeDirectivesFromDocument;\nexports.removeFragmentSpreadFromDocument = removeFragmentSpreadFromDocument;\nexports.resultKeyNameFromField = resultKeyNameFromField;\nexports.shouldInclude = shouldInclude;\nexports.storeKeyNameFromField = storeKeyNameFromField;\nexports.stringifyForDisplay = stringifyForDisplay;\nexports.valueToObjectRepresentation = valueToObjectRepresentation;\n//# sourceMappingURL=utilities.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvdXRpbGl0aWVzL3V0aWxpdGllcy5janM/NGE3ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBOEMsY0FBYzs7QUFFNUQsY0FBYyxtQkFBTyxDQUFDLDhFQUFXO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyx3QkFBUztBQUMvQixZQUFZLG1CQUFPLENBQUMsb0JBQU87QUFDM0Isc0JBQXNCLG1CQUFPLENBQUMscUVBQW1CO0FBQ2pELG1CQUFPLENBQUMsNENBQW1COztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQ0FBK0MsMENBQTBDO0FBQ3pGLCtDQUErQyx5Q0FBeUM7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsK0NBQStDO0FBQ3hFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxjQUFjO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0Es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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGFwb2xsby9jbGllbnQvdXRpbGl0aWVzL3V0aWxpdGllcy5janMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBnbG9iYWxzID0gcmVxdWlyZSgnLi9nbG9iYWxzJyk7XG52YXIgZ3JhcGhxbCA9IHJlcXVpcmUoJ2dyYXBocWwnKTtcbnZhciB0c2xpYiA9IHJlcXVpcmUoJ3RzbGliJyk7XG52YXIgemVuT2JzZXJ2YWJsZVRzID0gcmVxdWlyZSgnemVuLW9ic2VydmFibGUtdHMnKTtcbnJlcXVpcmUoJ3N5bWJvbC1vYnNlcnZhYmxlJyk7XG5cbmZ1bmN0aW9uIHNob3VsZEluY2x1ZGUoX2EsIHZhcmlhYmxlcykge1xuICAgIHZhciBkaXJlY3RpdmVzID0gX2EuZGlyZWN0aXZlcztcbiAgICBpZiAoIWRpcmVjdGl2ZXMgfHwgIWRpcmVjdGl2ZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0SW5jbHVzaW9uRGlyZWN0aXZlcyhkaXJlY3RpdmVzKS5ldmVyeShmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGRpcmVjdGl2ZSA9IF9hLmRpcmVjdGl2ZSwgaWZBcmd1bWVudCA9IF9hLmlmQXJndW1lbnQ7XG4gICAgICAgIHZhciBldmFsZWRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICBpZiAoaWZBcmd1bWVudC52YWx1ZS5raW5kID09PSAnVmFyaWFibGUnKSB7XG4gICAgICAgICAgICBldmFsZWRWYWx1ZSA9IHZhcmlhYmxlcyAmJiB2YXJpYWJsZXNbaWZBcmd1bWVudC52YWx1ZS5uYW1lLnZhbHVlXTtcbiAgICAgICAgICAgIF9fREVWX18gPyBnbG9iYWxzLmludmFyaWFudChldmFsZWRWYWx1ZSAhPT0gdm9pZCAwLCBcIkludmFsaWQgdmFyaWFibGUgcmVmZXJlbmNlZCBpbiBAXCIuY29uY2F0KGRpcmVjdGl2ZS5uYW1lLnZhbHVlLCBcIiBkaXJlY3RpdmUuXCIpKSA6IGdsb2JhbHMuaW52YXJpYW50KGV2YWxlZFZhbHVlICE9PSB2b2lkIDAsIDM5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV2YWxlZFZhbHVlID0gaWZBcmd1bWVudC52YWx1ZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlyZWN0aXZlLm5hbWUudmFsdWUgPT09ICdza2lwJyA/ICFldmFsZWRWYWx1ZSA6IGV2YWxlZFZhbHVlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0RGlyZWN0aXZlTmFtZXMocm9vdCkge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGdyYXBocWwudmlzaXQocm9vdCwge1xuICAgICAgICBEaXJlY3RpdmU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBuYW1lcy5wdXNoKG5vZGUubmFtZS52YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIG5hbWVzO1xufVxudmFyIGhhc0FueURpcmVjdGl2ZXMgPSBmdW5jdGlvbiAobmFtZXMsIHJvb3QpIHsgcmV0dXJuIGhhc0RpcmVjdGl2ZXMobmFtZXMsIHJvb3QsIGZhbHNlKTsgfTtcbnZhciBoYXNBbGxEaXJlY3RpdmVzID0gZnVuY3Rpb24gKG5hbWVzLCByb290KSB7IHJldHVybiBoYXNEaXJlY3RpdmVzKG5hbWVzLCByb290LCB0cnVlKTsgfTtcbmZ1bmN0aW9uIGhhc0RpcmVjdGl2ZXMobmFtZXMsIHJvb3QsIGFsbCkge1xuICAgIHZhciBuYW1lU2V0ID0gbmV3IFNldChuYW1lcyk7XG4gICAgdmFyIHVuaXF1ZUNvdW50ID0gbmFtZVNldC5zaXplO1xuICAgIGdyYXBocWwudmlzaXQocm9vdCwge1xuICAgICAgICBEaXJlY3RpdmU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobmFtZVNldC5kZWxldGUobm9kZS5uYW1lLnZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICghYWxsIHx8ICFuYW1lU2V0LnNpemUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyYXBocWwuQlJFQUs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIGFsbCA/ICFuYW1lU2V0LnNpemUgOiBuYW1lU2V0LnNpemUgPCB1bmlxdWVDb3VudDtcbn1cbmZ1bmN0aW9uIGhhc0NsaWVudEV4cG9ydHMoZG9jdW1lbnQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQgJiYgaGFzRGlyZWN0aXZlcyhbJ2NsaWVudCcsICdleHBvcnQnXSwgZG9jdW1lbnQsIHRydWUpO1xufVxuZnVuY3Rpb24gaXNJbmNsdXNpb25EaXJlY3RpdmUoX2EpIHtcbiAgICB2YXIgdmFsdWUgPSBfYS5uYW1lLnZhbHVlO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gJ3NraXAnIHx8IHZhbHVlID09PSAnaW5jbHVkZSc7XG59XG5mdW5jdGlvbiBnZXRJbmNsdXNpb25EaXJlY3RpdmVzKGRpcmVjdGl2ZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgaWYgKGRpcmVjdGl2ZXMgJiYgZGlyZWN0aXZlcy5sZW5ndGgpIHtcbiAgICAgICAgZGlyZWN0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcbiAgICAgICAgICAgIGlmICghaXNJbmNsdXNpb25EaXJlY3RpdmUoZGlyZWN0aXZlKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgZGlyZWN0aXZlQXJndW1lbnRzID0gZGlyZWN0aXZlLmFyZ3VtZW50cztcbiAgICAgICAgICAgIHZhciBkaXJlY3RpdmVOYW1lID0gZGlyZWN0aXZlLm5hbWUudmFsdWU7XG4gICAgICAgICAgICBfX0RFVl9fID8gZ2xvYmFscy5pbnZhcmlhbnQoZGlyZWN0aXZlQXJndW1lbnRzICYmIGRpcmVjdGl2ZUFyZ3VtZW50cy5sZW5ndGggPT09IDEsIFwiSW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHMgZm9yIHRoZSBAXCIuY29uY2F0KGRpcmVjdGl2ZU5hbWUsIFwiIGRpcmVjdGl2ZS5cIikpIDogZ2xvYmFscy5pbnZhcmlhbnQoZGlyZWN0aXZlQXJndW1lbnRzICYmIGRpcmVjdGl2ZUFyZ3VtZW50cy5sZW5ndGggPT09IDEsIDQwKTtcbiAgICAgICAgICAgIHZhciBpZkFyZ3VtZW50ID0gZGlyZWN0aXZlQXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgX19ERVZfXyA/IGdsb2JhbHMuaW52YXJpYW50KGlmQXJndW1lbnQubmFtZSAmJiBpZkFyZ3VtZW50Lm5hbWUudmFsdWUgPT09ICdpZicsIFwiSW52YWxpZCBhcmd1bWVudCBmb3IgdGhlIEBcIi5jb25jYXQoZGlyZWN0aXZlTmFtZSwgXCIgZGlyZWN0aXZlLlwiKSkgOiBnbG9iYWxzLmludmFyaWFudChpZkFyZ3VtZW50Lm5hbWUgJiYgaWZBcmd1bWVudC5uYW1lLnZhbHVlID09PSAnaWYnLCA0MSk7XG4gICAgICAgICAgICB2YXIgaWZWYWx1ZSA9IGlmQXJndW1lbnQudmFsdWU7XG4gICAgICAgICAgICBfX0RFVl9fID8gZ2xvYmFscy5pbnZhcmlhbnQoaWZWYWx1ZSAmJlxuICAgICAgICAgICAgICAgIChpZlZhbHVlLmtpbmQgPT09ICdWYXJpYWJsZScgfHwgaWZWYWx1ZS5raW5kID09PSAnQm9vbGVhblZhbHVlJyksIFwiQXJndW1lbnQgZm9yIHRoZSBAXCIuY29uY2F0KGRpcmVjdGl2ZU5hbWUsIFwiIGRpcmVjdGl2ZSBtdXN0IGJlIGEgdmFyaWFibGUgb3IgYSBib29sZWFuIHZhbHVlLlwiKSkgOiBnbG9iYWxzLmludmFyaWFudChpZlZhbHVlICYmXG4gICAgICAgICAgICAgICAgKGlmVmFsdWUua2luZCA9PT0gJ1ZhcmlhYmxlJyB8fCBpZlZhbHVlLmtpbmQgPT09ICdCb29sZWFuVmFsdWUnKSwgNDIpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBkaXJlY3RpdmU6IGRpcmVjdGl2ZSwgaWZBcmd1bWVudDogaWZBcmd1bWVudCB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdldEZyYWdtZW50UXVlcnlEb2N1bWVudChkb2N1bWVudCwgZnJhZ21lbnROYW1lKSB7XG4gICAgdmFyIGFjdHVhbEZyYWdtZW50TmFtZSA9IGZyYWdtZW50TmFtZTtcbiAgICB2YXIgZnJhZ21lbnRzID0gW107XG4gICAgZG9jdW1lbnQuZGVmaW5pdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xuICAgICAgICBpZiAoZGVmaW5pdGlvbi5raW5kID09PSAnT3BlcmF0aW9uRGVmaW5pdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IF9fREVWX18gPyBuZXcgZ2xvYmFscy5JbnZhcmlhbnRFcnJvcihcIkZvdW5kIGEgXCIuY29uY2F0KGRlZmluaXRpb24ub3BlcmF0aW9uLCBcIiBvcGVyYXRpb25cIikuY29uY2F0KGRlZmluaXRpb24ubmFtZSA/IFwiIG5hbWVkICdcIi5jb25jYXQoZGVmaW5pdGlvbi5uYW1lLnZhbHVlLCBcIidcIikgOiAnJywgXCIuIFwiKSArXG4gICAgICAgICAgICAgICAgJ05vIG9wZXJhdGlvbnMgYXJlIGFsbG93ZWQgd2hlbiB1c2luZyBhIGZyYWdtZW50IGFzIGEgcXVlcnkuIE9ubHkgZnJhZ21lbnRzIGFyZSBhbGxvd2VkLicpIDogbmV3IGdsb2JhbHMuSW52YXJpYW50RXJyb3IoNDMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWZpbml0aW9uLmtpbmQgPT09ICdGcmFnbWVudERlZmluaXRpb24nKSB7XG4gICAgICAgICAgICBmcmFnbWVudHMucHVzaChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgYWN0dWFsRnJhZ21lbnROYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBfX0RFVl9fID8gZ2xvYmFscy5pbnZhcmlhbnQoZnJhZ21lbnRzLmxlbmd0aCA9PT0gMSwgXCJGb3VuZCBcIi5jb25jYXQoZnJhZ21lbnRzLmxlbmd0aCwgXCIgZnJhZ21lbnRzLiBgZnJhZ21lbnROYW1lYCBtdXN0IGJlIHByb3ZpZGVkIHdoZW4gdGhlcmUgaXMgbm90IGV4YWN0bHkgMSBmcmFnbWVudC5cIikpIDogZ2xvYmFscy5pbnZhcmlhbnQoZnJhZ21lbnRzLmxlbmd0aCA9PT0gMSwgNDQpO1xuICAgICAgICBhY3R1YWxGcmFnbWVudE5hbWUgPSBmcmFnbWVudHNbMF0ubmFtZS52YWx1ZTtcbiAgICB9XG4gICAgdmFyIHF1ZXJ5ID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGRvY3VtZW50KSwgeyBkZWZpbml0aW9uczogdHNsaWIuX19zcHJlYWRBcnJheShbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAga2luZDogJ09wZXJhdGlvbkRlZmluaXRpb24nLFxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogJ3F1ZXJ5JyxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25TZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogJ1NlbGVjdGlvblNldCcsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiAnRnJhZ21lbnRTcHJlYWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZDogJ05hbWUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYWN0dWFsRnJhZ21lbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sIGRvY3VtZW50LmRlZmluaXRpb25zLCB0cnVlKSB9KTtcbiAgICByZXR1cm4gcXVlcnk7XG59XG5mdW5jdGlvbiBjcmVhdGVGcmFnbWVudE1hcChmcmFnbWVudHMpIHtcbiAgICBpZiAoZnJhZ21lbnRzID09PSB2b2lkIDApIHsgZnJhZ21lbnRzID0gW107IH1cbiAgICB2YXIgc3ltVGFibGUgPSB7fTtcbiAgICBmcmFnbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZnJhZ21lbnQpIHtcbiAgICAgICAgc3ltVGFibGVbZnJhZ21lbnQubmFtZS52YWx1ZV0gPSBmcmFnbWVudDtcbiAgICB9KTtcbiAgICByZXR1cm4gc3ltVGFibGU7XG59XG5mdW5jdGlvbiBnZXRGcmFnbWVudEZyb21TZWxlY3Rpb24oc2VsZWN0aW9uLCBmcmFnbWVudE1hcCkge1xuICAgIHN3aXRjaCAoc2VsZWN0aW9uLmtpbmQpIHtcbiAgICAgICAgY2FzZSAnSW5saW5lRnJhZ21lbnQnOlxuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbjtcbiAgICAgICAgY2FzZSAnRnJhZ21lbnRTcHJlYWQnOiB7XG4gICAgICAgICAgICB2YXIgZnJhZ21lbnROYW1lID0gc2VsZWN0aW9uLm5hbWUudmFsdWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZyYWdtZW50TWFwID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRNYXAoZnJhZ21lbnROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IGZyYWdtZW50TWFwICYmIGZyYWdtZW50TWFwW2ZyYWdtZW50TmFtZV07XG4gICAgICAgICAgICBfX0RFVl9fID8gZ2xvYmFscy5pbnZhcmlhbnQoZnJhZ21lbnQsIFwiTm8gZnJhZ21lbnQgbmFtZWQgXCIuY29uY2F0KGZyYWdtZW50TmFtZSkpIDogZ2xvYmFscy5pbnZhcmlhbnQoZnJhZ21lbnQsIDQ1KTtcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudCB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzTm9uTnVsbE9iamVjdChvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnO1xufVxuXG5mdW5jdGlvbiBtYWtlUmVmZXJlbmNlKGlkKSB7XG4gICAgcmV0dXJuIHsgX19yZWY6IFN0cmluZyhpZCkgfTtcbn1cbmZ1bmN0aW9uIGlzUmVmZXJlbmNlKG9iaikge1xuICAgIHJldHVybiBCb29sZWFuKG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqLl9fcmVmID09PSAnc3RyaW5nJyk7XG59XG5mdW5jdGlvbiBpc0RvY3VtZW50Tm9kZSh2YWx1ZSkge1xuICAgIHJldHVybiAoaXNOb25OdWxsT2JqZWN0KHZhbHVlKSAmJlxuICAgICAgICB2YWx1ZS5raW5kID09PSBcIkRvY3VtZW50XCIgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZS5kZWZpbml0aW9ucykpO1xufVxuZnVuY3Rpb24gaXNTdHJpbmdWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5raW5kID09PSAnU3RyaW5nVmFsdWUnO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUua2luZCA9PT0gJ0Jvb2xlYW5WYWx1ZSc7XG59XG5mdW5jdGlvbiBpc0ludFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmtpbmQgPT09ICdJbnRWYWx1ZSc7XG59XG5mdW5jdGlvbiBpc0Zsb2F0VmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUua2luZCA9PT0gJ0Zsb2F0VmFsdWUnO1xufVxuZnVuY3Rpb24gaXNWYXJpYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5raW5kID09PSAnVmFyaWFibGUnO1xufVxuZnVuY3Rpb24gaXNPYmplY3RWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5raW5kID09PSAnT2JqZWN0VmFsdWUnO1xufVxuZnVuY3Rpb24gaXNMaXN0VmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUua2luZCA9PT0gJ0xpc3RWYWx1ZSc7XG59XG5mdW5jdGlvbiBpc0VudW1WYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5raW5kID09PSAnRW51bVZhbHVlJztcbn1cbmZ1bmN0aW9uIGlzTnVsbFZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmtpbmQgPT09ICdOdWxsVmFsdWUnO1xufVxuZnVuY3Rpb24gdmFsdWVUb09iamVjdFJlcHJlc2VudGF0aW9uKGFyZ09iaiwgbmFtZSwgdmFsdWUsIHZhcmlhYmxlcykge1xuICAgIGlmIChpc0ludFZhbHVlKHZhbHVlKSB8fCBpc0Zsb2F0VmFsdWUodmFsdWUpKSB7XG4gICAgICAgIGFyZ09ialtuYW1lLnZhbHVlXSA9IE51bWJlcih2YWx1ZS52YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQm9vbGVhblZhbHVlKHZhbHVlKSB8fCBpc1N0cmluZ1ZhbHVlKHZhbHVlKSkge1xuICAgICAgICBhcmdPYmpbbmFtZS52YWx1ZV0gPSB2YWx1ZS52YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPYmplY3RWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIG5lc3RlZEFyZ09ial8xID0ge307XG4gICAgICAgIHZhbHVlLmZpZWxkcy5tYXAoZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlVG9PYmplY3RSZXByZXNlbnRhdGlvbihuZXN0ZWRBcmdPYmpfMSwgb2JqLm5hbWUsIG9iai52YWx1ZSwgdmFyaWFibGVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFyZ09ialtuYW1lLnZhbHVlXSA9IG5lc3RlZEFyZ09ial8xO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1ZhcmlhYmxlKHZhbHVlKSkge1xuICAgICAgICB2YXIgdmFyaWFibGVWYWx1ZSA9ICh2YXJpYWJsZXMgfHwge30pW3ZhbHVlLm5hbWUudmFsdWVdO1xuICAgICAgICBhcmdPYmpbbmFtZS52YWx1ZV0gPSB2YXJpYWJsZVZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0xpc3RWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgYXJnT2JqW25hbWUudmFsdWVdID0gdmFsdWUudmFsdWVzLm1hcChmdW5jdGlvbiAobGlzdFZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgbmVzdGVkQXJnQXJyYXlPYmogPSB7fTtcbiAgICAgICAgICAgIHZhbHVlVG9PYmplY3RSZXByZXNlbnRhdGlvbihuZXN0ZWRBcmdBcnJheU9iaiwgbmFtZSwgbGlzdFZhbHVlLCB2YXJpYWJsZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5lc3RlZEFyZ0FycmF5T2JqW25hbWUudmFsdWVdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNFbnVtVmFsdWUodmFsdWUpKSB7XG4gICAgICAgIGFyZ09ialtuYW1lLnZhbHVlXSA9IHZhbHVlLnZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc051bGxWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgYXJnT2JqW25hbWUudmFsdWVdID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IF9fREVWX18gPyBuZXcgZ2xvYmFscy5JbnZhcmlhbnRFcnJvcihcIlRoZSBpbmxpbmUgYXJndW1lbnQgXFxcIlwiLmNvbmNhdChuYW1lLnZhbHVlLCBcIlxcXCIgb2Yga2luZCBcXFwiXCIpLmNvbmNhdCh2YWx1ZS5raW5kLCBcIlxcXCJcIikgK1xuICAgICAgICAgICAgJ2lzIG5vdCBzdXBwb3J0ZWQuIFVzZSB2YXJpYWJsZXMgaW5zdGVhZCBvZiBpbmxpbmUgYXJndW1lbnRzIHRvICcgK1xuICAgICAgICAgICAgJ292ZXJjb21lIHRoaXMgbGltaXRhdGlvbi4nKSA6IG5ldyBnbG9iYWxzLkludmFyaWFudEVycm9yKDU0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBzdG9yZUtleU5hbWVGcm9tRmllbGQoZmllbGQsIHZhcmlhYmxlcykge1xuICAgIHZhciBkaXJlY3RpdmVzT2JqID0gbnVsbDtcbiAgICBpZiAoZmllbGQuZGlyZWN0aXZlcykge1xuICAgICAgICBkaXJlY3RpdmVzT2JqID0ge307XG4gICAgICAgIGZpZWxkLmRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGlyZWN0aXZlKSB7XG4gICAgICAgICAgICBkaXJlY3RpdmVzT2JqW2RpcmVjdGl2ZS5uYW1lLnZhbHVlXSA9IHt9O1xuICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZS5hcmd1bWVudHMpIHtcbiAgICAgICAgICAgICAgICBkaXJlY3RpdmUuYXJndW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gX2EubmFtZSwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlVG9PYmplY3RSZXByZXNlbnRhdGlvbihkaXJlY3RpdmVzT2JqW2RpcmVjdGl2ZS5uYW1lLnZhbHVlXSwgbmFtZSwgdmFsdWUsIHZhcmlhYmxlcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgYXJnT2JqID0gbnVsbDtcbiAgICBpZiAoZmllbGQuYXJndW1lbnRzICYmIGZpZWxkLmFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgYXJnT2JqID0ge307XG4gICAgICAgIGZpZWxkLmFyZ3VtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBfYS5uYW1lLCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlVG9PYmplY3RSZXByZXNlbnRhdGlvbihhcmdPYmosIG5hbWUsIHZhbHVlLCB2YXJpYWJsZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldFN0b3JlS2V5TmFtZShmaWVsZC5uYW1lLnZhbHVlLCBhcmdPYmosIGRpcmVjdGl2ZXNPYmopO1xufVxudmFyIEtOT1dOX0RJUkVDVElWRVMgPSBbXG4gICAgJ2Nvbm5lY3Rpb24nLFxuICAgICdpbmNsdWRlJyxcbiAgICAnc2tpcCcsXG4gICAgJ2NsaWVudCcsXG4gICAgJ3Jlc3QnLFxuICAgICdleHBvcnQnLFxuXTtcbnZhciBnZXRTdG9yZUtleU5hbWUgPSBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIChmaWVsZE5hbWUsIGFyZ3MsIGRpcmVjdGl2ZXMpIHtcbiAgICBpZiAoYXJncyAmJlxuICAgICAgICBkaXJlY3RpdmVzICYmXG4gICAgICAgIGRpcmVjdGl2ZXNbJ2Nvbm5lY3Rpb24nXSAmJlxuICAgICAgICBkaXJlY3RpdmVzWydjb25uZWN0aW9uJ11bJ2tleSddKSB7XG4gICAgICAgIGlmIChkaXJlY3RpdmVzWydjb25uZWN0aW9uJ11bJ2ZpbHRlciddICYmXG4gICAgICAgICAgICBkaXJlY3RpdmVzWydjb25uZWN0aW9uJ11bJ2ZpbHRlciddLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJLZXlzID0gZGlyZWN0aXZlc1snY29ubmVjdGlvbiddWydmaWx0ZXInXVxuICAgICAgICAgICAgICAgID8gZGlyZWN0aXZlc1snY29ubmVjdGlvbiddWydmaWx0ZXInXVxuICAgICAgICAgICAgICAgIDogW107XG4gICAgICAgICAgICBmaWx0ZXJLZXlzLnNvcnQoKTtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZEFyZ3NfMSA9IHt9O1xuICAgICAgICAgICAgZmlsdGVyS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZEFyZ3NfMVtrZXldID0gYXJnc1trZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoZGlyZWN0aXZlc1snY29ubmVjdGlvbiddWydrZXknXSwgXCIoXCIpLmNvbmNhdChzdHJpbmdpZnkoZmlsdGVyZWRBcmdzXzEpLCBcIilcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGlyZWN0aXZlc1snY29ubmVjdGlvbiddWydrZXknXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgY29tcGxldGVGaWVsZE5hbWUgPSBmaWVsZE5hbWU7XG4gICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgdmFyIHN0cmluZ2lmaWVkQXJncyA9IHN0cmluZ2lmeShhcmdzKTtcbiAgICAgICAgY29tcGxldGVGaWVsZE5hbWUgKz0gXCIoXCIuY29uY2F0KHN0cmluZ2lmaWVkQXJncywgXCIpXCIpO1xuICAgIH1cbiAgICBpZiAoZGlyZWN0aXZlcykge1xuICAgICAgICBPYmplY3Qua2V5cyhkaXJlY3RpdmVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChLTk9XTl9ESVJFQ1RJVkVTLmluZGV4T2Yoa2V5KSAhPT0gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGl2ZXNba2V5XSAmJiBPYmplY3Qua2V5cyhkaXJlY3RpdmVzW2tleV0pLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlRmllbGROYW1lICs9IFwiQFwiLmNvbmNhdChrZXksIFwiKFwiKS5jb25jYXQoc3RyaW5naWZ5KGRpcmVjdGl2ZXNba2V5XSksIFwiKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlRmllbGROYW1lICs9IFwiQFwiLmNvbmNhdChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBsZXRlRmllbGROYW1lO1xufSwge1xuICAgIHNldFN0cmluZ2lmeTogZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzID0gc3RyaW5naWZ5O1xuICAgICAgICBzdHJpbmdpZnkgPSBzO1xuICAgICAgICByZXR1cm4gcHJldmlvdXM7XG4gICAgfSxcbn0pO1xudmFyIHN0cmluZ2lmeSA9IGZ1bmN0aW9uIGRlZmF1bHRTdHJpbmdpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIHN0cmluZ2lmeVJlcGxhY2VyKTtcbn07XG5mdW5jdGlvbiBzdHJpbmdpZnlSZXBsYWNlcihfa2V5LCB2YWx1ZSkge1xuICAgIGlmIChpc05vbk51bGxPYmplY3QodmFsdWUpICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IE9iamVjdC5rZXlzKHZhbHVlKS5zb3J0KCkucmVkdWNlKGZ1bmN0aW9uIChjb3B5LCBrZXkpIHtcbiAgICAgICAgICAgIGNvcHlba2V5XSA9IHZhbHVlW2tleV07XG4gICAgICAgICAgICByZXR1cm4gY29weTtcbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBhcmd1bWVudHNPYmplY3RGcm9tRmllbGQoZmllbGQsIHZhcmlhYmxlcykge1xuICAgIGlmIChmaWVsZC5hcmd1bWVudHMgJiYgZmllbGQuYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB2YXIgYXJnT2JqXzEgPSB7fTtcbiAgICAgICAgZmllbGQuYXJndW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IF9hLm5hbWUsIHZhbHVlID0gX2EudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVUb09iamVjdFJlcHJlc2VudGF0aW9uKGFyZ09ial8xLCBuYW1lLCB2YWx1ZSwgdmFyaWFibGVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhcmdPYmpfMTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiByZXN1bHRLZXlOYW1lRnJvbUZpZWxkKGZpZWxkKSB7XG4gICAgcmV0dXJuIGZpZWxkLmFsaWFzID8gZmllbGQuYWxpYXMudmFsdWUgOiBmaWVsZC5uYW1lLnZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0VHlwZW5hbWVGcm9tUmVzdWx0KHJlc3VsdCwgc2VsZWN0aW9uU2V0LCBmcmFnbWVudE1hcCkge1xuICAgIGlmICh0eXBlb2YgcmVzdWx0Ll9fdHlwZW5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuX190eXBlbmFtZTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHNlbGVjdGlvblNldC5zZWxlY3Rpb25zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gX2FbX2ldO1xuICAgICAgICBpZiAoaXNGaWVsZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLm5hbWUudmFsdWUgPT09ICdfX3R5cGVuYW1lJykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRbcmVzdWx0S2V5TmFtZUZyb21GaWVsZChzZWxlY3Rpb24pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0eXBlbmFtZSA9IGdldFR5cGVuYW1lRnJvbVJlc3VsdChyZXN1bHQsIGdldEZyYWdtZW50RnJvbVNlbGVjdGlvbihzZWxlY3Rpb24sIGZyYWdtZW50TWFwKS5zZWxlY3Rpb25TZXQsIGZyYWdtZW50TWFwKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHlwZW5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaXNGaWVsZChzZWxlY3Rpb24pIHtcbiAgICByZXR1cm4gc2VsZWN0aW9uLmtpbmQgPT09ICdGaWVsZCc7XG59XG5mdW5jdGlvbiBpc0lubGluZUZyYWdtZW50KHNlbGVjdGlvbikge1xuICAgIHJldHVybiBzZWxlY3Rpb24ua2luZCA9PT0gJ0lubGluZUZyYWdtZW50Jztcbn1cblxuZnVuY3Rpb24gY2hlY2tEb2N1bWVudChkb2MpIHtcbiAgICBfX0RFVl9fID8gZ2xvYmFscy5pbnZhcmlhbnQoZG9jICYmIGRvYy5raW5kID09PSAnRG9jdW1lbnQnLCBcIkV4cGVjdGluZyBhIHBhcnNlZCBHcmFwaFFMIGRvY3VtZW50LiBQZXJoYXBzIHlvdSBuZWVkIHRvIHdyYXAgdGhlIHF1ZXJ5IHN0cmluZyBpbiBhIFxcXCJncWxcXFwiIHRhZz8gaHR0cDovL2RvY3MuYXBvbGxvc3RhY2suY29tL2Fwb2xsby1jbGllbnQvY29yZS5odG1sI2dxbFwiKSA6IGdsb2JhbHMuaW52YXJpYW50KGRvYyAmJiBkb2Mua2luZCA9PT0gJ0RvY3VtZW50JywgNDYpO1xuICAgIHZhciBvcGVyYXRpb25zID0gZG9jLmRlZmluaXRpb25zXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQua2luZCAhPT0gJ0ZyYWdtZW50RGVmaW5pdGlvbic7IH0pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcbiAgICAgICAgaWYgKGRlZmluaXRpb24ua2luZCAhPT0gJ09wZXJhdGlvbkRlZmluaXRpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBfX0RFVl9fID8gbmV3IGdsb2JhbHMuSW52YXJpYW50RXJyb3IoXCJTY2hlbWEgdHlwZSBkZWZpbml0aW9ucyBub3QgYWxsb3dlZCBpbiBxdWVyaWVzLiBGb3VuZDogXFxcIlwiLmNvbmNhdChkZWZpbml0aW9uLmtpbmQsIFwiXFxcIlwiKSkgOiBuZXcgZ2xvYmFscy5JbnZhcmlhbnRFcnJvcig0Nyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgfSk7XG4gICAgX19ERVZfXyA/IGdsb2JhbHMuaW52YXJpYW50KG9wZXJhdGlvbnMubGVuZ3RoIDw9IDEsIFwiQW1iaWd1b3VzIEdyYXBoUUwgZG9jdW1lbnQ6IGNvbnRhaW5zIFwiLmNvbmNhdChvcGVyYXRpb25zLmxlbmd0aCwgXCIgb3BlcmF0aW9uc1wiKSkgOiBnbG9iYWxzLmludmFyaWFudChvcGVyYXRpb25zLmxlbmd0aCA8PSAxLCA0OCk7XG4gICAgcmV0dXJuIGRvYztcbn1cbmZ1bmN0aW9uIGdldE9wZXJhdGlvbkRlZmluaXRpb24oZG9jKSB7XG4gICAgY2hlY2tEb2N1bWVudChkb2MpO1xuICAgIHJldHVybiBkb2MuZGVmaW5pdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7IHJldHVybiBkZWZpbml0aW9uLmtpbmQgPT09ICdPcGVyYXRpb25EZWZpbml0aW9uJzsgfSlbMF07XG59XG5mdW5jdGlvbiBnZXRPcGVyYXRpb25OYW1lKGRvYykge1xuICAgIHJldHVybiAoZG9jLmRlZmluaXRpb25zXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb24ua2luZCA9PT0gJ09wZXJhdGlvbkRlZmluaXRpb24nICYmIGRlZmluaXRpb24ubmFtZTtcbiAgICB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Lm5hbWUudmFsdWU7IH0pWzBdIHx8IG51bGwpO1xufVxuZnVuY3Rpb24gZ2V0RnJhZ21lbnREZWZpbml0aW9ucyhkb2MpIHtcbiAgICByZXR1cm4gZG9jLmRlZmluaXRpb25zLmZpbHRlcihmdW5jdGlvbiAoZGVmaW5pdGlvbikgeyByZXR1cm4gZGVmaW5pdGlvbi5raW5kID09PSAnRnJhZ21lbnREZWZpbml0aW9uJzsgfSk7XG59XG5mdW5jdGlvbiBnZXRRdWVyeURlZmluaXRpb24oZG9jKSB7XG4gICAgdmFyIHF1ZXJ5RGVmID0gZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbihkb2MpO1xuICAgIF9fREVWX18gPyBnbG9iYWxzLmludmFyaWFudChxdWVyeURlZiAmJiBxdWVyeURlZi5vcGVyYXRpb24gPT09ICdxdWVyeScsICdNdXN0IGNvbnRhaW4gYSBxdWVyeSBkZWZpbml0aW9uLicpIDogZ2xvYmFscy5pbnZhcmlhbnQocXVlcnlEZWYgJiYgcXVlcnlEZWYub3BlcmF0aW9uID09PSAncXVlcnknLCA0OSk7XG4gICAgcmV0dXJuIHF1ZXJ5RGVmO1xufVxuZnVuY3Rpb24gZ2V0RnJhZ21lbnREZWZpbml0aW9uKGRvYykge1xuICAgIF9fREVWX18gPyBnbG9iYWxzLmludmFyaWFudChkb2Mua2luZCA9PT0gJ0RvY3VtZW50JywgXCJFeHBlY3RpbmcgYSBwYXJzZWQgR3JhcGhRTCBkb2N1bWVudC4gUGVyaGFwcyB5b3UgbmVlZCB0byB3cmFwIHRoZSBxdWVyeSBzdHJpbmcgaW4gYSBcXFwiZ3FsXFxcIiB0YWc/IGh0dHA6Ly9kb2NzLmFwb2xsb3N0YWNrLmNvbS9hcG9sbG8tY2xpZW50L2NvcmUuaHRtbCNncWxcIikgOiBnbG9iYWxzLmludmFyaWFudChkb2Mua2luZCA9PT0gJ0RvY3VtZW50JywgNTApO1xuICAgIF9fREVWX18gPyBnbG9iYWxzLmludmFyaWFudChkb2MuZGVmaW5pdGlvbnMubGVuZ3RoIDw9IDEsICdGcmFnbWVudCBtdXN0IGhhdmUgZXhhY3RseSBvbmUgZGVmaW5pdGlvbi4nKSA6IGdsb2JhbHMuaW52YXJpYW50KGRvYy5kZWZpbml0aW9ucy5sZW5ndGggPD0gMSwgNTEpO1xuICAgIHZhciBmcmFnbWVudERlZiA9IGRvYy5kZWZpbml0aW9uc1swXTtcbiAgICBfX0RFVl9fID8gZ2xvYmFscy5pbnZhcmlhbnQoZnJhZ21lbnREZWYua2luZCA9PT0gJ0ZyYWdtZW50RGVmaW5pdGlvbicsICdNdXN0IGJlIGEgZnJhZ21lbnQgZGVmaW5pdGlvbi4nKSA6IGdsb2JhbHMuaW52YXJpYW50KGZyYWdtZW50RGVmLmtpbmQgPT09ICdGcmFnbWVudERlZmluaXRpb24nLCA1Mik7XG4gICAgcmV0dXJuIGZyYWdtZW50RGVmO1xufVxuZnVuY3Rpb24gZ2V0TWFpbkRlZmluaXRpb24ocXVlcnlEb2MpIHtcbiAgICBjaGVja0RvY3VtZW50KHF1ZXJ5RG9jKTtcbiAgICB2YXIgZnJhZ21lbnREZWZpbml0aW9uO1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBxdWVyeURvYy5kZWZpbml0aW9uczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGRlZmluaXRpb24gPSBfYVtfaV07XG4gICAgICAgIGlmIChkZWZpbml0aW9uLmtpbmQgPT09ICdPcGVyYXRpb25EZWZpbml0aW9uJykge1xuICAgICAgICAgICAgdmFyIG9wZXJhdGlvbiA9IGRlZmluaXRpb24ub3BlcmF0aW9uO1xuICAgICAgICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJ3F1ZXJ5JyB8fFxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9PT0gJ211dGF0aW9uJyB8fFxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbiA9PT0gJ3N1YnNjcmlwdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmaW5pdGlvbi5raW5kID09PSAnRnJhZ21lbnREZWZpbml0aW9uJyAmJiAhZnJhZ21lbnREZWZpbml0aW9uKSB7XG4gICAgICAgICAgICBmcmFnbWVudERlZmluaXRpb24gPSBkZWZpbml0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChmcmFnbWVudERlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGZyYWdtZW50RGVmaW5pdGlvbjtcbiAgICB9XG4gICAgdGhyb3cgX19ERVZfXyA/IG5ldyBnbG9iYWxzLkludmFyaWFudEVycm9yKCdFeHBlY3RlZCBhIHBhcnNlZCBHcmFwaFFMIHF1ZXJ5IHdpdGggYSBxdWVyeSwgbXV0YXRpb24sIHN1YnNjcmlwdGlvbiwgb3IgYSBmcmFnbWVudC4nKSA6IG5ldyBnbG9iYWxzLkludmFyaWFudEVycm9yKDUzKTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRWYWx1ZXMoZGVmaW5pdGlvbikge1xuICAgIHZhciBkZWZhdWx0VmFsdWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgZGVmcyA9IGRlZmluaXRpb24gJiYgZGVmaW5pdGlvbi52YXJpYWJsZURlZmluaXRpb25zO1xuICAgIGlmIChkZWZzICYmIGRlZnMubGVuZ3RoKSB7XG4gICAgICAgIGRlZnMuZm9yRWFjaChmdW5jdGlvbiAoZGVmKSB7XG4gICAgICAgICAgICBpZiAoZGVmLmRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlVG9PYmplY3RSZXByZXNlbnRhdGlvbihkZWZhdWx0VmFsdWVzLCBkZWYudmFyaWFibGUubmFtZSwgZGVmLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlcztcbn1cblxuZnVuY3Rpb24gZmlsdGVySW5QbGFjZShhcnJheSwgdGVzdCwgY29udGV4dCkge1xuICAgIHZhciB0YXJnZXQgPSAwO1xuICAgIGFycmF5LmZvckVhY2goZnVuY3Rpb24gKGVsZW0sIGkpIHtcbiAgICAgICAgaWYgKHRlc3QuY2FsbCh0aGlzLCBlbGVtLCBpLCBhcnJheSkpIHtcbiAgICAgICAgICAgIGFycmF5W3RhcmdldCsrXSA9IGVsZW07XG4gICAgICAgIH1cbiAgICB9LCBjb250ZXh0KTtcbiAgICBhcnJheS5sZW5ndGggPSB0YXJnZXQ7XG4gICAgcmV0dXJuIGFycmF5O1xufVxuXG52YXIgVFlQRU5BTUVfRklFTEQgPSB7XG4gICAga2luZDogJ0ZpZWxkJyxcbiAgICBuYW1lOiB7XG4gICAgICAgIGtpbmQ6ICdOYW1lJyxcbiAgICAgICAgdmFsdWU6ICdfX3R5cGVuYW1lJyxcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGlzRW1wdHkob3AsIGZyYWdtZW50TWFwKSB7XG4gICAgcmV0dXJuICFvcCB8fCBvcC5zZWxlY3Rpb25TZXQuc2VsZWN0aW9ucy5ldmVyeShmdW5jdGlvbiAoc2VsZWN0aW9uKSB7IHJldHVybiBzZWxlY3Rpb24ua2luZCA9PT0gJ0ZyYWdtZW50U3ByZWFkJyAmJlxuICAgICAgICBpc0VtcHR5KGZyYWdtZW50TWFwW3NlbGVjdGlvbi5uYW1lLnZhbHVlXSwgZnJhZ21lbnRNYXApOyB9KTtcbn1cbmZ1bmN0aW9uIG51bGxJZkRvY0lzRW1wdHkoZG9jKSB7XG4gICAgcmV0dXJuIGlzRW1wdHkoZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbihkb2MpIHx8IGdldEZyYWdtZW50RGVmaW5pdGlvbihkb2MpLCBjcmVhdGVGcmFnbWVudE1hcChnZXRGcmFnbWVudERlZmluaXRpb25zKGRvYykpKVxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiBkb2M7XG59XG5mdW5jdGlvbiBnZXREaXJlY3RpdmVNYXRjaGVyKGRpcmVjdGl2ZXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGlyZWN0aXZlTWF0Y2hlcihkaXJlY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgICAgICByZXR1cm4gKGRpci5uYW1lICYmIGRpci5uYW1lID09PSBkaXJlY3RpdmUubmFtZS52YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAoZGlyLnRlc3QgJiYgZGlyLnRlc3QoZGlyZWN0aXZlKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiByZW1vdmVEaXJlY3RpdmVzRnJvbURvY3VtZW50KGRpcmVjdGl2ZXMsIGRvYykge1xuICAgIHZhciB2YXJpYWJsZXNJblVzZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIHZhcmlhYmxlc1RvUmVtb3ZlID0gW107XG4gICAgdmFyIGZyYWdtZW50U3ByZWFkc0luVXNlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgZnJhZ21lbnRTcHJlYWRzVG9SZW1vdmUgPSBbXTtcbiAgICB2YXIgbW9kaWZpZWREb2MgPSBudWxsSWZEb2NJc0VtcHR5KGdyYXBocWwudmlzaXQoZG9jLCB7XG4gICAgICAgIFZhcmlhYmxlOiB7XG4gICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUsIF9rZXksIHBhcmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQua2luZCAhPT0gJ1ZhcmlhYmxlRGVmaW5pdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzSW5Vc2Vbbm9kZS5uYW1lLnZhbHVlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgRmllbGQ6IHtcbiAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChkaXJlY3RpdmVzICYmIG5vZGUuZGlyZWN0aXZlcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2hvdWxkUmVtb3ZlRmllbGQgPSBkaXJlY3RpdmVzLnNvbWUoZnVuY3Rpb24gKGRpcmVjdGl2ZSkgeyByZXR1cm4gZGlyZWN0aXZlLnJlbW92ZTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRSZW1vdmVGaWVsZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5kaXJlY3RpdmVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmRpcmVjdGl2ZXMuc29tZShnZXREaXJlY3RpdmVNYXRjaGVyKGRpcmVjdGl2ZXMpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuYXJndW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hcmd1bWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmcudmFsdWUua2luZCA9PT0gJ1ZhcmlhYmxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVzVG9SZW1vdmUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogYXJnLnZhbHVlLm5hbWUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuc2VsZWN0aW9uU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QWxsRnJhZ21lbnRTcHJlYWRzRnJvbVNlbGVjdGlvblNldChub2RlLnNlbGVjdGlvblNldCkuZm9yRWFjaChmdW5jdGlvbiAoZnJhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudFNwcmVhZHNUb1JlbW92ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGZyYWcubmFtZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIEZyYWdtZW50U3ByZWFkOiB7XG4gICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudFNwcmVhZHNJblVzZVtub2RlLm5hbWUudmFsdWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIERpcmVjdGl2ZToge1xuICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdldERpcmVjdGl2ZU1hdGNoZXIoZGlyZWN0aXZlcykobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KSk7XG4gICAgaWYgKG1vZGlmaWVkRG9jICYmXG4gICAgICAgIGZpbHRlckluUGxhY2UodmFyaWFibGVzVG9SZW1vdmUsIGZ1bmN0aW9uICh2KSB7IHJldHVybiAhIXYubmFtZSAmJiAhdmFyaWFibGVzSW5Vc2Vbdi5uYW1lXTsgfSkubGVuZ3RoKSB7XG4gICAgICAgIG1vZGlmaWVkRG9jID0gcmVtb3ZlQXJndW1lbnRzRnJvbURvY3VtZW50KHZhcmlhYmxlc1RvUmVtb3ZlLCBtb2RpZmllZERvYyk7XG4gICAgfVxuICAgIGlmIChtb2RpZmllZERvYyAmJlxuICAgICAgICBmaWx0ZXJJblBsYWNlKGZyYWdtZW50U3ByZWFkc1RvUmVtb3ZlLCBmdW5jdGlvbiAoZnMpIHsgcmV0dXJuICEhZnMubmFtZSAmJiAhZnJhZ21lbnRTcHJlYWRzSW5Vc2VbZnMubmFtZV07IH0pXG4gICAgICAgICAgICAubGVuZ3RoKSB7XG4gICAgICAgIG1vZGlmaWVkRG9jID0gcmVtb3ZlRnJhZ21lbnRTcHJlYWRGcm9tRG9jdW1lbnQoZnJhZ21lbnRTcHJlYWRzVG9SZW1vdmUsIG1vZGlmaWVkRG9jKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGlmaWVkRG9jO1xufVxudmFyIGFkZFR5cGVuYW1lVG9Eb2N1bWVudCA9IE9iamVjdC5hc3NpZ24oZnVuY3Rpb24gKGRvYykge1xuICAgIHJldHVybiBncmFwaHFsLnZpc2l0KGRvYywge1xuICAgICAgICBTZWxlY3Rpb25TZXQ6IHtcbiAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgX2tleSwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudCAmJlxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQua2luZCA9PT0gJ09wZXJhdGlvbkRlZmluaXRpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGlvbnMgPSBub2RlLnNlbGVjdGlvbnM7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHNraXAgPSBzZWxlY3Rpb25zLnNvbWUoZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGlzRmllbGQoc2VsZWN0aW9uKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHNlbGVjdGlvbi5uYW1lLnZhbHVlID09PSAnX190eXBlbmFtZScgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24ubmFtZS52YWx1ZS5sYXN0SW5kZXhPZignX18nLCAwKSA9PT0gMCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChza2lwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gcGFyZW50O1xuICAgICAgICAgICAgICAgIGlmIChpc0ZpZWxkKGZpZWxkKSAmJlxuICAgICAgICAgICAgICAgICAgICBmaWVsZC5kaXJlY3RpdmVzICYmXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLmRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lLnZhbHVlID09PSAnZXhwb3J0JzsgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIG5vZGUpLCB7IHNlbGVjdGlvbnM6IHRzbGliLl9fc3ByZWFkQXJyYXkodHNsaWIuX19zcHJlYWRBcnJheShbXSwgc2VsZWN0aW9ucywgdHJ1ZSksIFtUWVBFTkFNRV9GSUVMRF0sIGZhbHNlKSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7XG59LCB7XG4gICAgYWRkZWQ6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICByZXR1cm4gZmllbGQgPT09IFRZUEVOQU1FX0ZJRUxEO1xuICAgIH0sXG59KTtcbnZhciBjb25uZWN0aW9uUmVtb3ZlQ29uZmlnID0ge1xuICAgIHRlc3Q6IGZ1bmN0aW9uIChkaXJlY3RpdmUpIHtcbiAgICAgICAgdmFyIHdpbGxSZW1vdmUgPSBkaXJlY3RpdmUubmFtZS52YWx1ZSA9PT0gJ2Nvbm5lY3Rpb24nO1xuICAgICAgICBpZiAod2lsbFJlbW92ZSkge1xuICAgICAgICAgICAgaWYgKCFkaXJlY3RpdmUuYXJndW1lbnRzIHx8XG4gICAgICAgICAgICAgICAgIWRpcmVjdGl2ZS5hcmd1bWVudHMuc29tZShmdW5jdGlvbiAoYXJnKSB7IHJldHVybiBhcmcubmFtZS52YWx1ZSA9PT0gJ2tleSc7IH0pKSB7XG4gICAgICAgICAgICAgICAgX19ERVZfXyAmJiBnbG9iYWxzLmludmFyaWFudC53YXJuKCdSZW1vdmluZyBhbiBAY29ubmVjdGlvbiBkaXJlY3RpdmUgZXZlbiB0aG91Z2ggaXQgZG9lcyBub3QgaGF2ZSBhIGtleS4gJyArXG4gICAgICAgICAgICAgICAgICAgICdZb3UgbWF5IHdhbnQgdG8gdXNlIHRoZSBrZXkgcGFyYW1ldGVyIHRvIHNwZWNpZnkgYSBzdG9yZSBrZXkuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdpbGxSZW1vdmU7XG4gICAgfSxcbn07XG5mdW5jdGlvbiByZW1vdmVDb25uZWN0aW9uRGlyZWN0aXZlRnJvbURvY3VtZW50KGRvYykge1xuICAgIHJldHVybiByZW1vdmVEaXJlY3RpdmVzRnJvbURvY3VtZW50KFtjb25uZWN0aW9uUmVtb3ZlQ29uZmlnXSwgY2hlY2tEb2N1bWVudChkb2MpKTtcbn1cbmZ1bmN0aW9uIGdldEFyZ3VtZW50TWF0Y2hlcihjb25maWcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYXJndW1lbnRNYXRjaGVyKGFyZ3VtZW50KSB7XG4gICAgICAgIHJldHVybiBjb25maWcuc29tZShmdW5jdGlvbiAoYUNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50LnZhbHVlICYmXG4gICAgICAgICAgICAgICAgYXJndW1lbnQudmFsdWUua2luZCA9PT0gJ1ZhcmlhYmxlJyAmJlxuICAgICAgICAgICAgICAgIGFyZ3VtZW50LnZhbHVlLm5hbWUgJiZcbiAgICAgICAgICAgICAgICAoYUNvbmZpZy5uYW1lID09PSBhcmd1bWVudC52YWx1ZS5uYW1lLnZhbHVlIHx8XG4gICAgICAgICAgICAgICAgICAgIChhQ29uZmlnLnRlc3QgJiYgYUNvbmZpZy50ZXN0KGFyZ3VtZW50KSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVtb3ZlQXJndW1lbnRzRnJvbURvY3VtZW50KGNvbmZpZywgZG9jKSB7XG4gICAgdmFyIGFyZ01hdGNoZXIgPSBnZXRBcmd1bWVudE1hdGNoZXIoY29uZmlnKTtcbiAgICByZXR1cm4gbnVsbElmRG9jSXNFbXB0eShncmFwaHFsLnZpc2l0KGRvYywge1xuICAgICAgICBPcGVyYXRpb25EZWZpbml0aW9uOiB7XG4gICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIG5vZGUpLCB7IHZhcmlhYmxlRGVmaW5pdGlvbnM6IG5vZGUudmFyaWFibGVEZWZpbml0aW9ucyA/IG5vZGUudmFyaWFibGVEZWZpbml0aW9ucy5maWx0ZXIoZnVuY3Rpb24gKHZhckRlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFjb25maWcuc29tZShmdW5jdGlvbiAoYXJnKSB7IHJldHVybiBhcmcubmFtZSA9PT0gdmFyRGVmLnZhcmlhYmxlLm5hbWUudmFsdWU7IH0pO1xuICAgICAgICAgICAgICAgICAgICB9KSA6IFtdIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgRmllbGQ6IHtcbiAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBzaG91bGRSZW1vdmVGaWVsZCA9IGNvbmZpZy5zb21lKGZ1bmN0aW9uIChhcmdDb25maWcpIHsgcmV0dXJuIGFyZ0NvbmZpZy5yZW1vdmU7IH0pO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRSZW1vdmVGaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJnTWF0Y2hDb3VudF8xID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuYXJndW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmFyZ3VtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJnTWF0Y2hlcihhcmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ01hdGNoQ291bnRfMSArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdNYXRjaENvdW50XzEgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgQXJndW1lbnQ6IHtcbiAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChhcmdNYXRjaGVyKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSkpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRnJhZ21lbnRTcHJlYWRGcm9tRG9jdW1lbnQoY29uZmlnLCBkb2MpIHtcbiAgICBmdW5jdGlvbiBlbnRlcihub2RlKSB7XG4gICAgICAgIGlmIChjb25maWcuc29tZShmdW5jdGlvbiAoZGVmKSB7IHJldHVybiBkZWYubmFtZSA9PT0gbm9kZS5uYW1lLnZhbHVlOyB9KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGxJZkRvY0lzRW1wdHkoZ3JhcGhxbC52aXNpdChkb2MsIHtcbiAgICAgICAgRnJhZ21lbnRTcHJlYWQ6IHsgZW50ZXI6IGVudGVyIH0sXG4gICAgICAgIEZyYWdtZW50RGVmaW5pdGlvbjogeyBlbnRlcjogZW50ZXIgfSxcbiAgICB9KSk7XG59XG5mdW5jdGlvbiBnZXRBbGxGcmFnbWVudFNwcmVhZHNGcm9tU2VsZWN0aW9uU2V0KHNlbGVjdGlvblNldCkge1xuICAgIHZhciBhbGxGcmFnbWVudHMgPSBbXTtcbiAgICBzZWxlY3Rpb25TZXQuc2VsZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKChpc0ZpZWxkKHNlbGVjdGlvbikgfHwgaXNJbmxpbmVGcmFnbWVudChzZWxlY3Rpb24pKSAmJlxuICAgICAgICAgICAgc2VsZWN0aW9uLnNlbGVjdGlvblNldCkge1xuICAgICAgICAgICAgZ2V0QWxsRnJhZ21lbnRTcHJlYWRzRnJvbVNlbGVjdGlvblNldChzZWxlY3Rpb24uc2VsZWN0aW9uU2V0KS5mb3JFYWNoKGZ1bmN0aW9uIChmcmFnKSB7IHJldHVybiBhbGxGcmFnbWVudHMucHVzaChmcmFnKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VsZWN0aW9uLmtpbmQgPT09ICdGcmFnbWVudFNwcmVhZCcpIHtcbiAgICAgICAgICAgIGFsbEZyYWdtZW50cy5wdXNoKHNlbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYWxsRnJhZ21lbnRzO1xufVxuZnVuY3Rpb24gYnVpbGRRdWVyeUZyb21TZWxlY3Rpb25TZXQoZG9jdW1lbnQpIHtcbiAgICB2YXIgZGVmaW5pdGlvbiA9IGdldE1haW5EZWZpbml0aW9uKGRvY3VtZW50KTtcbiAgICB2YXIgZGVmaW5pdGlvbk9wZXJhdGlvbiA9IGRlZmluaXRpb24ub3BlcmF0aW9uO1xuICAgIGlmIChkZWZpbml0aW9uT3BlcmF0aW9uID09PSAncXVlcnknKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICB9XG4gICAgdmFyIG1vZGlmaWVkRG9jID0gZ3JhcGhxbC52aXNpdChkb2N1bWVudCwge1xuICAgICAgICBPcGVyYXRpb25EZWZpbml0aW9uOiB7XG4gICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIG5vZGUpLCB7IG9wZXJhdGlvbjogJ3F1ZXJ5JyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIG1vZGlmaWVkRG9jO1xufVxuZnVuY3Rpb24gcmVtb3ZlQ2xpZW50U2V0c0Zyb21Eb2N1bWVudChkb2N1bWVudCkge1xuICAgIGNoZWNrRG9jdW1lbnQoZG9jdW1lbnQpO1xuICAgIHZhciBtb2RpZmllZERvYyA9IHJlbW92ZURpcmVjdGl2ZXNGcm9tRG9jdW1lbnQoW1xuICAgICAgICB7XG4gICAgICAgICAgICB0ZXN0OiBmdW5jdGlvbiAoZGlyZWN0aXZlKSB7IHJldHVybiBkaXJlY3RpdmUubmFtZS52YWx1ZSA9PT0gJ2NsaWVudCc7IH0sXG4gICAgICAgICAgICByZW1vdmU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgXSwgZG9jdW1lbnQpO1xuICAgIGlmIChtb2RpZmllZERvYykge1xuICAgICAgICBtb2RpZmllZERvYyA9IGdyYXBocWwudmlzaXQobW9kaWZpZWREb2MsIHtcbiAgICAgICAgICAgIEZyYWdtZW50RGVmaW5pdGlvbjoge1xuICAgICAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5zZWxlY3Rpb25TZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc1R5cGVuYW1lT25seSA9IG5vZGUuc2VsZWN0aW9uU2V0LnNlbGVjdGlvbnMuZXZlcnkoZnVuY3Rpb24gKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0ZpZWxkKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLm5hbWUudmFsdWUgPT09ICdfX3R5cGVuYW1lJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVHlwZW5hbWVPbmx5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtb2RpZmllZERvYztcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIG1lcmdlRGVlcCgpIHtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHNvdXJjZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRGVlcEFycmF5KHNvdXJjZXMpO1xufVxuZnVuY3Rpb24gbWVyZ2VEZWVwQXJyYXkoc291cmNlcykge1xuICAgIHZhciB0YXJnZXQgPSBzb3VyY2VzWzBdIHx8IHt9O1xuICAgIHZhciBjb3VudCA9IHNvdXJjZXMubGVuZ3RoO1xuICAgIGlmIChjb3VudCA+IDEpIHtcbiAgICAgICAgdmFyIG1lcmdlciA9IG5ldyBEZWVwTWVyZ2VyKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gbWVyZ2VyLm1lcmdlKHRhcmdldCwgc291cmNlc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbnZhciBkZWZhdWx0UmVjb25jaWxlciA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gdGhpcy5tZXJnZSh0YXJnZXRbcHJvcGVydHldLCBzb3VyY2VbcHJvcGVydHldKTtcbn07XG52YXIgRGVlcE1lcmdlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVlcE1lcmdlcihyZWNvbmNpbGVyKSB7XG4gICAgICAgIGlmIChyZWNvbmNpbGVyID09PSB2b2lkIDApIHsgcmVjb25jaWxlciA9IGRlZmF1bHRSZWNvbmNpbGVyOyB9XG4gICAgICAgIHRoaXMucmVjb25jaWxlciA9IHJlY29uY2lsZXI7XG4gICAgICAgIHRoaXMuaXNPYmplY3QgPSBpc05vbk51bGxPYmplY3Q7XG4gICAgICAgIHRoaXMucGFzdENvcGllcyA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgRGVlcE1lcmdlci5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNvbnRleHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNvbnRleHRbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTm9uTnVsbE9iamVjdChzb3VyY2UpICYmIGlzTm9uTnVsbE9iamVjdCh0YXJnZXQpKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUtleSkge1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwgc291cmNlS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0VmFsdWUgPSB0YXJnZXRbc291cmNlS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtzb3VyY2VLZXldICE9PSB0YXJnZXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF90aGlzLnJlY29uY2lsZXIuYXBwbHkoX3RoaXMsIHRzbGliLl9fc3ByZWFkQXJyYXkoW3RhcmdldCwgc291cmNlLCBzb3VyY2VLZXldLCBjb250ZXh0LCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdGFyZ2V0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBfdGhpcy5zaGFsbG93Q29weUZvck1lcmdlKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W3NvdXJjZUtleV0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IF90aGlzLnNoYWxsb3dDb3B5Rm9yTWVyZ2UodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W3NvdXJjZUtleV0gPSBzb3VyY2Vbc291cmNlS2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9O1xuICAgIERlZXBNZXJnZXIucHJvdG90eXBlLnNoYWxsb3dDb3B5Rm9yTWVyZ2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKGlzTm9uTnVsbE9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXN0Q29waWVzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdHNsaWIuX19hc3NpZ24oeyBfX3Byb3RvX186IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgfSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBhc3RDb3BpZXMuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICByZXR1cm4gRGVlcE1lcmdlcjtcbn0oKSk7XG5cbmZ1bmN0aW9uIGNvbmNhdFBhZ2luYXRpb24oa2V5QXJncykge1xuICAgIGlmIChrZXlBcmdzID09PSB2b2lkIDApIHsga2V5QXJncyA9IGZhbHNlOyB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5QXJnczoga2V5QXJncyxcbiAgICAgICAgbWVyZ2U6IGZ1bmN0aW9uIChleGlzdGluZywgaW5jb21pbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZyA/IHRzbGliLl9fc3ByZWFkQXJyYXkodHNsaWIuX19zcHJlYWRBcnJheShbXSwgZXhpc3RpbmcsIHRydWUpLCBpbmNvbWluZywgdHJ1ZSkgOiBpbmNvbWluZztcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gb2Zmc2V0TGltaXRQYWdpbmF0aW9uKGtleUFyZ3MpIHtcbiAgICBpZiAoa2V5QXJncyA9PT0gdm9pZCAwKSB7IGtleUFyZ3MgPSBmYWxzZTsgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGtleUFyZ3M6IGtleUFyZ3MsXG4gICAgICAgIG1lcmdlOiBmdW5jdGlvbiAoZXhpc3RpbmcsIGluY29taW5nLCBfYSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBfYS5hcmdzO1xuICAgICAgICAgICAgdmFyIG1lcmdlZCA9IGV4aXN0aW5nID8gZXhpc3Rpbmcuc2xpY2UoMCkgOiBbXTtcbiAgICAgICAgICAgIGlmIChpbmNvbWluZykge1xuICAgICAgICAgICAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYiA9IGFyZ3Mub2Zmc2V0LCBvZmZzZXQgPSBfYiA9PT0gdm9pZCAwID8gMCA6IF9iO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluY29taW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXJnZWRbb2Zmc2V0ICsgaV0gPSBpbmNvbWluZ1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkLnB1c2guYXBwbHkobWVyZ2VkLCBpbmNvbWluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVsYXlTdHlsZVBhZ2luYXRpb24oa2V5QXJncykge1xuICAgIGlmIChrZXlBcmdzID09PSB2b2lkIDApIHsga2V5QXJncyA9IGZhbHNlOyB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5QXJnczoga2V5QXJncyxcbiAgICAgICAgcmVhZDogZnVuY3Rpb24gKGV4aXN0aW5nLCBfYSkge1xuICAgICAgICAgICAgdmFyIGNhblJlYWQgPSBfYS5jYW5SZWFkLCByZWFkRmllbGQgPSBfYS5yZWFkRmllbGQ7XG4gICAgICAgICAgICBpZiAoIWV4aXN0aW5nKVxuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgICAgIHZhciBlZGdlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGZpcnN0RWRnZUN1cnNvciA9IFwiXCI7XG4gICAgICAgICAgICB2YXIgbGFzdEVkZ2VDdXJzb3IgPSBcIlwiO1xuICAgICAgICAgICAgZXhpc3RpbmcuZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgICAgICAgIGlmIChjYW5SZWFkKHJlYWRGaWVsZChcIm5vZGVcIiwgZWRnZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlZGdlLmN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RFZGdlQ3Vyc29yID0gZmlyc3RFZGdlQ3Vyc29yIHx8IGVkZ2UuY3Vyc29yIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0RWRnZUN1cnNvciA9IGVkZ2UuY3Vyc29yIHx8IGxhc3RFZGdlQ3Vyc29yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgX2IgPSBleGlzdGluZy5wYWdlSW5mbyB8fCB7fSwgc3RhcnRDdXJzb3IgPSBfYi5zdGFydEN1cnNvciwgZW5kQ3Vyc29yID0gX2IuZW5kQ3Vyc29yO1xuICAgICAgICAgICAgcmV0dXJuIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBnZXRFeHRyYXMoZXhpc3RpbmcpKSwgeyBlZGdlczogZWRnZXMsIHBhZ2VJbmZvOiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgZXhpc3RpbmcucGFnZUluZm8pLCB7IHN0YXJ0Q3Vyc29yOiBzdGFydEN1cnNvciB8fCBmaXJzdEVkZ2VDdXJzb3IsIGVuZEN1cnNvcjogZW5kQ3Vyc29yIHx8IGxhc3RFZGdlQ3Vyc29yIH0pIH0pO1xuICAgICAgICB9LFxuICAgICAgICBtZXJnZTogZnVuY3Rpb24gKGV4aXN0aW5nLCBpbmNvbWluZywgX2EpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gX2EuYXJncywgaXNSZWZlcmVuY2UgPSBfYS5pc1JlZmVyZW5jZSwgcmVhZEZpZWxkID0gX2EucmVhZEZpZWxkO1xuICAgICAgICAgICAgaWYgKCFleGlzdGluZykge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nID0gbWFrZUVtcHR5RGF0YSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpbmNvbWluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbmNvbWluZ0VkZ2VzID0gaW5jb21pbmcuZWRnZXMgPyBpbmNvbWluZy5lZGdlcy5tYXAoZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWZlcmVuY2UoZWRnZSA9IHRzbGliLl9fYXNzaWduKHt9LCBlZGdlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZWRnZS5jdXJzb3IgPSByZWFkRmllbGQoXCJjdXJzb3JcIiwgZWRnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlZGdlO1xuICAgICAgICAgICAgfSkgOiBbXTtcbiAgICAgICAgICAgIGlmIChpbmNvbWluZy5wYWdlSW5mbykge1xuICAgICAgICAgICAgICAgIHZhciBwYWdlSW5mb18xID0gaW5jb21pbmcucGFnZUluZm87XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0Q3Vyc29yID0gcGFnZUluZm9fMS5zdGFydEN1cnNvciwgZW5kQ3Vyc29yID0gcGFnZUluZm9fMS5lbmRDdXJzb3I7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0RWRnZSA9IGluY29taW5nRWRnZXNbMF07XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RFZGdlID0gaW5jb21pbmdFZGdlc1tpbmNvbWluZ0VkZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdEVkZ2UgJiYgc3RhcnRDdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RFZGdlLmN1cnNvciA9IHN0YXJ0Q3Vyc29yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGFzdEVkZ2UgJiYgZW5kQ3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RFZGdlLmN1cnNvciA9IGVuZEN1cnNvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0Q3Vyc29yID0gZmlyc3RFZGdlICYmIGZpcnN0RWRnZS5jdXJzb3I7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Q3Vyc29yICYmICFzdGFydEN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICBpbmNvbWluZyA9IG1lcmdlRGVlcChpbmNvbWluZywge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZUluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydEN1cnNvcjogZmlyc3RDdXJzb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RDdXJzb3IgPSBsYXN0RWRnZSAmJiBsYXN0RWRnZS5jdXJzb3I7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RDdXJzb3IgJiYgIWVuZEN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICBpbmNvbWluZyA9IG1lcmdlRGVlcChpbmNvbWluZywge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZUluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRDdXJzb3I6IGxhc3RDdXJzb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gZXhpc3RpbmcuZWRnZXM7XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gW107XG4gICAgICAgICAgICBpZiAoYXJncyAmJiBhcmdzLmFmdGVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcHJlZml4LmZpbmRJbmRleChmdW5jdGlvbiAoZWRnZSkgeyByZXR1cm4gZWRnZS5jdXJzb3IgPT09IGFyZ3MuYWZ0ZXI7IH0pO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWZpeCA9IHByZWZpeC5zbGljZSgwLCBpbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFyZ3MgJiYgYXJncy5iZWZvcmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwcmVmaXguZmluZEluZGV4KGZ1bmN0aW9uIChlZGdlKSB7IHJldHVybiBlZGdlLmN1cnNvciA9PT0gYXJncy5iZWZvcmU7IH0pO1xuICAgICAgICAgICAgICAgIHN1ZmZpeCA9IGluZGV4IDwgMCA/IHByZWZpeCA6IHByZWZpeC5zbGljZShpbmRleCk7XG4gICAgICAgICAgICAgICAgcHJlZml4ID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbmNvbWluZy5lZGdlcykge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVkZ2VzID0gdHNsaWIuX19zcHJlYWRBcnJheSh0c2xpYi5fX3NwcmVhZEFycmF5KHRzbGliLl9fc3ByZWFkQXJyYXkoW10sIHByZWZpeCwgdHJ1ZSksIGluY29taW5nRWRnZXMsIHRydWUpLCBzdWZmaXgsIHRydWUpO1xuICAgICAgICAgICAgdmFyIHBhZ2VJbmZvID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGluY29taW5nLnBhZ2VJbmZvKSwgZXhpc3RpbmcucGFnZUluZm8pO1xuICAgICAgICAgICAgaWYgKGluY29taW5nLnBhZ2VJbmZvKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gaW5jb21pbmcucGFnZUluZm8sIGhhc1ByZXZpb3VzUGFnZSA9IF9iLmhhc1ByZXZpb3VzUGFnZSwgaGFzTmV4dFBhZ2UgPSBfYi5oYXNOZXh0UGFnZSwgc3RhcnRDdXJzb3IgPSBfYi5zdGFydEN1cnNvciwgZW5kQ3Vyc29yID0gX2IuZW5kQ3Vyc29yLCBleHRyYXMgPSB0c2xpYi5fX3Jlc3QoX2IsIFtcImhhc1ByZXZpb3VzUGFnZVwiLCBcImhhc05leHRQYWdlXCIsIFwic3RhcnRDdXJzb3JcIiwgXCJlbmRDdXJzb3JcIl0pO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocGFnZUluZm8sIGV4dHJhcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmVmaXgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2b2lkIDAgIT09IGhhc1ByZXZpb3VzUGFnZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VJbmZvLmhhc1ByZXZpb3VzUGFnZSA9IGhhc1ByZXZpb3VzUGFnZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gc3RhcnRDdXJzb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlSW5mby5zdGFydEN1cnNvciA9IHN0YXJ0Q3Vyc29yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXN1ZmZpeC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gaGFzTmV4dFBhZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlSW5mby5oYXNOZXh0UGFnZSA9IGhhc05leHRQYWdlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodm9pZCAwICE9PSBlbmRDdXJzb3IpXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlSW5mby5lbmRDdXJzb3IgPSBlbmRDdXJzb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBnZXRFeHRyYXMoZXhpc3RpbmcpKSwgZ2V0RXh0cmFzKGluY29taW5nKSksIHsgZWRnZXM6IGVkZ2VzLCBwYWdlSW5mbzogcGFnZUluZm8gfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbnZhciBnZXRFeHRyYXMgPSBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0c2xpYi5fX3Jlc3Qob2JqLCBub3RFeHRyYXMpOyB9O1xudmFyIG5vdEV4dHJhcyA9IFtcImVkZ2VzXCIsIFwicGFnZUluZm9cIl07XG5mdW5jdGlvbiBtYWtlRW1wdHlEYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGVkZ2VzOiBbXSxcbiAgICAgICAgcGFnZUluZm86IHtcbiAgICAgICAgICAgIGhhc1ByZXZpb3VzUGFnZTogZmFsc2UsXG4gICAgICAgICAgICBoYXNOZXh0UGFnZTogdHJ1ZSxcbiAgICAgICAgICAgIHN0YXJ0Q3Vyc29yOiBcIlwiLFxuICAgICAgICAgICAgZW5kQ3Vyc29yOiBcIlwiLFxuICAgICAgICB9LFxuICAgIH07XG59XG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5mdW5jdGlvbiBjbG9uZURlZXAodmFsdWUpIHtcbiAgICByZXR1cm4gY2xvbmVEZWVwSGVscGVyKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGNsb25lRGVlcEhlbHBlcih2YWwsIHNlZW4pIHtcbiAgICBzd2l0Y2ggKHRvU3RyaW5nLmNhbGwodmFsKSkge1xuICAgICAgICBjYXNlIFwiW29iamVjdCBBcnJheV1cIjoge1xuICAgICAgICAgICAgc2VlbiA9IHNlZW4gfHwgbmV3IE1hcDtcbiAgICAgICAgICAgIGlmIChzZWVuLmhhcyh2YWwpKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWVuLmdldCh2YWwpO1xuICAgICAgICAgICAgdmFyIGNvcHlfMSA9IHZhbC5zbGljZSgwKTtcbiAgICAgICAgICAgIHNlZW4uc2V0KHZhbCwgY29weV8xKTtcbiAgICAgICAgICAgIGNvcHlfMS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCwgaSkge1xuICAgICAgICAgICAgICAgIGNvcHlfMVtpXSA9IGNsb25lRGVlcEhlbHBlcihjaGlsZCwgc2Vlbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb3B5XzE7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIltvYmplY3QgT2JqZWN0XVwiOiB7XG4gICAgICAgICAgICBzZWVuID0gc2VlbiB8fCBuZXcgTWFwO1xuICAgICAgICAgICAgaWYgKHNlZW4uaGFzKHZhbCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlZW4uZ2V0KHZhbCk7XG4gICAgICAgICAgICB2YXIgY29weV8yID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsKSk7XG4gICAgICAgICAgICBzZWVuLnNldCh2YWwsIGNvcHlfMik7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh2YWwpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGNvcHlfMltrZXldID0gY2xvbmVEZWVwSGVscGVyKHZhbFtrZXldLCBzZWVuKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvcHlfMjtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRlZXBGcmVlemUodmFsdWUpIHtcbiAgICB2YXIgd29ya1NldCA9IG5ldyBTZXQoW3ZhbHVlXSk7XG4gICAgd29ya1NldC5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgaWYgKGlzTm9uTnVsbE9iamVjdChvYmopICYmIHNoYWxsb3dGcmVlemUob2JqKSA9PT0gb2JqKSB7XG4gICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOb25OdWxsT2JqZWN0KG9ialtuYW1lXSkpXG4gICAgICAgICAgICAgICAgICAgIHdvcmtTZXQuYWRkKG9ialtuYW1lXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dGcmVlemUob2JqKSB7XG4gICAgaWYgKF9fREVWX18gJiYgIU9iamVjdC5pc0Zyb3plbihvYmopKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgVHlwZUVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gbWF5YmVEZWVwRnJlZXplKG9iaikge1xuICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgIGRlZXBGcmVlemUob2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gaXRlcmF0ZU9ic2VydmVyc1NhZmVseShvYnNlcnZlcnMsIG1ldGhvZCwgYXJndW1lbnQpIHtcbiAgICB2YXIgb2JzZXJ2ZXJzV2l0aE1ldGhvZCA9IFtdO1xuICAgIG9ic2VydmVycy5mb3JFYWNoKGZ1bmN0aW9uIChvYnMpIHsgcmV0dXJuIG9ic1ttZXRob2RdICYmIG9ic2VydmVyc1dpdGhNZXRob2QucHVzaChvYnMpOyB9KTtcbiAgICBvYnNlcnZlcnNXaXRoTWV0aG9kLmZvckVhY2goZnVuY3Rpb24gKG9icykgeyByZXR1cm4gb2JzW21ldGhvZF0oYXJndW1lbnQpOyB9KTtcbn1cblxuZnVuY3Rpb24gYXN5bmNNYXAob2JzZXJ2YWJsZSwgbWFwRm4sIGNhdGNoRm4pIHtcbiAgICByZXR1cm4gbmV3IHplbk9ic2VydmFibGVUcy5PYnNlcnZhYmxlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICB2YXIgbmV4dCA9IG9ic2VydmVyLm5leHQsIGVycm9yID0gb2JzZXJ2ZXIuZXJyb3IsIGNvbXBsZXRlID0gb2JzZXJ2ZXIuY29tcGxldGU7XG4gICAgICAgIHZhciBhY3RpdmVDYWxsYmFja0NvdW50ID0gMDtcbiAgICAgICAgdmFyIGNvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgcHJvbWlzZVF1ZXVlID0ge1xuICAgICAgICAgICAgdGhlbjogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJldHVybiByZXNvbHZlKGNhbGxiYWNrKCkpOyB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIG1ha2VDYWxsYmFjayhleGFtaW5lciwgZGVsZWdhdGUpIHtcbiAgICAgICAgICAgIGlmIChleGFtaW5lcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgICsrYWN0aXZlQ2FsbGJhY2tDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvdGggPSBmdW5jdGlvbiAoKSB7IHJldHVybiBleGFtaW5lcihhcmcpOyB9O1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlUXVldWUgPSBwcm9taXNlUXVldWUudGhlbihib3RoLCBib3RoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC0tYWN0aXZlQ2FsbGJhY2tDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgJiYgbmV4dC5jYWxsKG9ic2VydmVyLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAtLWFjdGl2ZUNhbGxiYWNrQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGNhdWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgJiYgZXJyb3IuY2FsbChvYnNlcnZlciwgY2F1Z2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiBkZWxlZ2F0ZSAmJiBkZWxlZ2F0ZS5jYWxsKG9ic2VydmVyLCBhcmcpOyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBoYW5kbGVyID0ge1xuICAgICAgICAgICAgbmV4dDogbWFrZUNhbGxiYWNrKG1hcEZuLCBuZXh0KSxcbiAgICAgICAgICAgIGVycm9yOiBtYWtlQ2FsbGJhY2soY2F0Y2hGbiwgZXJyb3IpLFxuICAgICAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICghYWN0aXZlQ2FsbGJhY2tDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZSAmJiBjb21wbGV0ZS5jYWxsKG9ic2VydmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICB2YXIgc3ViID0gb2JzZXJ2YWJsZS5zdWJzY3JpYmUoaGFuZGxlcik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdWIudW5zdWJzY3JpYmUoKTsgfTtcbiAgICB9KTtcbn1cblxudmFyIGNhblVzZVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIGdsb2JhbHMubWF5YmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmF2aWdhdG9yLnByb2R1Y3Q7IH0pICE9PSAnUmVhY3ROYXRpdmUnO1xudmFyIGNhblVzZVdlYWtTZXQgPSB0eXBlb2YgV2Vha1NldCA9PT0gJ2Z1bmN0aW9uJztcbnZhciBjYW5Vc2VTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIFN5bWJvbC5mb3IgPT09ICdmdW5jdGlvbic7XG52YXIgY2FuVXNlQXN5bmNJdGVyYXRvclN5bWJvbCA9IGNhblVzZVN5bWJvbCAmJiBTeW1ib2wuYXN5bmNJdGVyYXRvcjtcbnZhciBjYW5Vc2VET00gPSB0eXBlb2YgZ2xvYmFscy5tYXliZShmdW5jdGlvbiAoKSB7IHJldHVybiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudDsgfSkgPT09IFwiZnVuY3Rpb25cIjtcbnZhciB1c2luZ0pTRE9NID0gZ2xvYmFscy5tYXliZShmdW5jdGlvbiAoKSB7IHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJqc2RvbVwiKSA+PSAwOyB9KSB8fCBmYWxzZTtcbnZhciBjYW5Vc2VMYXlvdXRFZmZlY3QgPSBjYW5Vc2VET00gJiYgIXVzaW5nSlNET007XG5cbmZ1bmN0aW9uIGZpeE9ic2VydmFibGVTdWJjbGFzcyhzdWJjbGFzcykge1xuICAgIGZ1bmN0aW9uIHNldChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YmNsYXNzLCBrZXksIHsgdmFsdWU6IHplbk9ic2VydmFibGVUcy5PYnNlcnZhYmxlIH0pO1xuICAgIH1cbiAgICBpZiAoY2FuVXNlU3ltYm9sICYmIFN5bWJvbC5zcGVjaWVzKSB7XG4gICAgICAgIHNldChTeW1ib2wuc3BlY2llcyk7XG4gICAgfVxuICAgIHNldChcIkBAc3BlY2llc1wiKTtcbiAgICByZXR1cm4gc3ViY2xhc3M7XG59XG5cbmZ1bmN0aW9uIGlzUHJvbWlzZUxpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09IFwiZnVuY3Rpb25cIjtcbn1cbnZhciBDb25jYXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoQ29uY2FzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25jYXN0KHNvdXJjZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgICBfdGhpcy5hZGRPYnNlcnZlcihvYnNlcnZlcik7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMucmVtb3ZlT2JzZXJ2ZXIob2JzZXJ2ZXIpOyB9O1xuICAgICAgICB9KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vYnNlcnZlcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIF90aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBfdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIF90aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLmhhbmRsZXJzID0ge1xuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zdWIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubGF0ZXN0ID0gW1wibmV4dFwiLCByZXN1bHRdO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ub3RpZnkoXCJuZXh0XCIsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdGVPYnNlcnZlcnNTYWZlbHkoX3RoaXMub2JzZXJ2ZXJzLCBcIm5leHRcIiwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHZhciBzdWIgPSBfdGhpcy5zdWI7XG4gICAgICAgICAgICAgICAgaWYgKHN1YiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3ViKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBzdWIudW5zdWJzY3JpYmUoKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN1YiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxhdGVzdCA9IFtcImVycm9yXCIsIGVycm9yXTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubm90aWZ5KFwiZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRlT2JzZXJ2ZXJzU2FmZWx5KF90aGlzLm9ic2VydmVycywgXCJlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YiA9IF90aGlzLnN1YjtcbiAgICAgICAgICAgICAgICBpZiAoc3ViICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IF90aGlzLnNvdXJjZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1Yi51bnN1YnNjcmliZSgpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN1YiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMubGF0ZXN0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubGF0ZXN0WzBdID09PSBcIm5leHRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc29sdmUoX3RoaXMubGF0ZXN0WzFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm5vdGlmeShcImNvbXBsZXRlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZU9ic2VydmVyc1NhZmVseShfdGhpcy5vYnNlcnZlcnMsIFwiY29tcGxldGVcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNQcm9taXNlTGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnRoZW4oZnVuY3Rpb24gKG9icykgeyByZXR1cm4gX3RoaXMuc3ViID0gb2JzLnN1YnNjcmliZShfdGhpcy5oYW5kbGVycyk7IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3ViID0gdmFsdWUuc3Vic2NyaWJlKF90aGlzLmhhbmRsZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm5leHRSZXN1bHRMaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIF90aGlzLmNhbmNlbCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgIF90aGlzLnJlamVjdChyZWFzb24pO1xuICAgICAgICAgICAgX3RoaXMuc291cmNlcyA9IFtdO1xuICAgICAgICAgICAgX3RoaXMuaGFuZGxlcnMuY29tcGxldGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoXykgeyB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHNvdXJjZXMgPSBbbmV3IHplbk9ic2VydmFibGVUcy5PYnNlcnZhYmxlKHNvdXJjZXMpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcm9taXNlTGlrZShzb3VyY2VzKSkge1xuICAgICAgICAgICAgc291cmNlcy50aGVuKGZ1bmN0aW9uIChpdGVyYWJsZSkgeyByZXR1cm4gX3RoaXMuc3RhcnQoaXRlcmFibGUpOyB9LCBfdGhpcy5oYW5kbGVycy5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5zdGFydChzb3VyY2VzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbmNhc3QucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKHNvdXJjZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuc3ViICE9PSB2b2lkIDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuc291cmNlcyA9IEFycmF5LmZyb20oc291cmNlcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMuY29tcGxldGUoKTtcbiAgICB9O1xuICAgIENvbmNhc3QucHJvdG90eXBlLmRlbGl2ZXJMYXN0TWVzc2FnZSA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICBpZiAodGhpcy5sYXRlc3QpIHtcbiAgICAgICAgICAgIHZhciBuZXh0T3JFcnJvciA9IHRoaXMubGF0ZXN0WzBdO1xuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IG9ic2VydmVyW25leHRPckVycm9yXTtcbiAgICAgICAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QuY2FsbChvYnNlcnZlciwgdGhpcy5sYXRlc3RbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3ViID09PSBudWxsICYmXG4gICAgICAgICAgICAgICAgbmV4dE9yRXJyb3IgPT09IFwibmV4dFwiICYmXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25jYXN0LnByb3RvdHlwZS5hZGRPYnNlcnZlciA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICBpZiAoIXRoaXMub2JzZXJ2ZXJzLmhhcyhvYnNlcnZlcikpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsaXZlckxhc3RNZXNzYWdlKG9ic2VydmVyKTtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzLmFkZChvYnNlcnZlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbmNhc3QucHJvdG90eXBlLnJlbW92ZU9ic2VydmVyID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIGlmICh0aGlzLm9ic2VydmVycy5kZWxldGUob2JzZXJ2ZXIpICYmXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVycy5zaXplIDwgMSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVycy5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25jYXN0LnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHtcbiAgICAgICAgdmFyIG5leHRSZXN1bHRMaXN0ZW5lcnMgPSB0aGlzLm5leHRSZXN1bHRMaXN0ZW5lcnM7XG4gICAgICAgIGlmIChuZXh0UmVzdWx0TGlzdGVuZXJzLnNpemUpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dFJlc3VsdExpc3RlbmVycyA9IG5ldyBTZXQ7XG4gICAgICAgICAgICBuZXh0UmVzdWx0TGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7IHJldHVybiBsaXN0ZW5lcihtZXRob2QsIGFyZyk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25jYXN0LnByb3RvdHlwZS5iZWZvcmVOZXh0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uZXh0UmVzdWx0TGlzdGVuZXJzLmFkZChmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHtcbiAgICAgICAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhtZXRob2QsIGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIENvbmNhc3Q7XG59KHplbk9ic2VydmFibGVUcy5PYnNlcnZhYmxlKSk7XG5maXhPYnNlcnZhYmxlU3ViY2xhc3MoQ29uY2FzdCk7XG5cbmZ1bmN0aW9uIGlzTm9uRW1wdHlBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwO1xufVxuXG5mdW5jdGlvbiBncmFwaFFMUmVzdWx0SGFzRXJyb3IocmVzdWx0KSB7XG4gICAgcmV0dXJuIChyZXN1bHQuZXJyb3JzICYmIHJlc3VsdC5lcnJvcnMubGVuZ3RoID4gMCkgfHwgZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNvbXBhY3QoKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYmplY3RzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIG9iamVjdHMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmICghb2JqKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBwcmVmaXhDb3VudHMgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBtYWtlVW5pcXVlSWQocHJlZml4KSB7XG4gICAgdmFyIGNvdW50ID0gcHJlZml4Q291bnRzLmdldChwcmVmaXgpIHx8IDE7XG4gICAgcHJlZml4Q291bnRzLnNldChwcmVmaXgsIGNvdW50ICsgMSk7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHByZWZpeCwgXCI6XCIpLmNvbmNhdChjb3VudCwgXCI6XCIpLmNvbmNhdChNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKSk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUZvckRpc3BsYXkodmFsdWUpIHtcbiAgICB2YXIgdW5kZWZJZCA9IG1ha2VVbmlxdWVJZChcInN0cmluZ2lmeUZvckRpc3BsYXlcIik7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCA/IHVuZGVmSWQgOiB2YWx1ZTtcbiAgICB9KS5zcGxpdChKU09OLnN0cmluZ2lmeSh1bmRlZklkKSkuam9pbihcIjx1bmRlZmluZWQ+XCIpO1xufVxuXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMoZGVmYXVsdHMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gY29tcGFjdChkZWZhdWx0cywgb3B0aW9ucywgb3B0aW9ucy52YXJpYWJsZXMgJiYge1xuICAgICAgICB2YXJpYWJsZXM6IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCAoZGVmYXVsdHMgJiYgZGVmYXVsdHMudmFyaWFibGVzKSksIG9wdGlvbnMudmFyaWFibGVzKSxcbiAgICB9KTtcbn1cblxuZXhwb3J0cy5ERVYgPSBnbG9iYWxzLkRFVjtcbmV4cG9ydHMubWF5YmUgPSBnbG9iYWxzLm1heWJlO1xuZXhwb3J0cy5PYnNlcnZhYmxlID0gemVuT2JzZXJ2YWJsZVRzLk9ic2VydmFibGU7XG5leHBvcnRzLkNvbmNhc3QgPSBDb25jYXN0O1xuZXhwb3J0cy5EZWVwTWVyZ2VyID0gRGVlcE1lcmdlcjtcbmV4cG9ydHMuYWRkVHlwZW5hbWVUb0RvY3VtZW50ID0gYWRkVHlwZW5hbWVUb0RvY3VtZW50O1xuZXhwb3J0cy5hcmd1bWVudHNPYmplY3RGcm9tRmllbGQgPSBhcmd1bWVudHNPYmplY3RGcm9tRmllbGQ7XG5leHBvcnRzLmFzeW5jTWFwID0gYXN5bmNNYXA7XG5leHBvcnRzLmJ1aWxkUXVlcnlGcm9tU2VsZWN0aW9uU2V0ID0gYnVpbGRRdWVyeUZyb21TZWxlY3Rpb25TZXQ7XG5leHBvcnRzLmNhblVzZUFzeW5jSXRlcmF0b3JTeW1ib2wgPSBjYW5Vc2VBc3luY0l0ZXJhdG9yU3ltYm9sO1xuZXhwb3J0cy5jYW5Vc2VET00gPSBjYW5Vc2VET007XG5leHBvcnRzLmNhblVzZUxheW91dEVmZmVjdCA9IGNhblVzZUxheW91dEVmZmVjdDtcbmV4cG9ydHMuY2FuVXNlU3ltYm9sID0gY2FuVXNlU3ltYm9sO1xuZXhwb3J0cy5jYW5Vc2VXZWFrTWFwID0gY2FuVXNlV2Vha01hcDtcbmV4cG9ydHMuY2FuVXNlV2Vha1NldCA9IGNhblVzZVdlYWtTZXQ7XG5leHBvcnRzLmNoZWNrRG9jdW1lbnQgPSBjaGVja0RvY3VtZW50O1xuZXhwb3J0cy5jbG9uZURlZXAgPSBjbG9uZURlZXA7XG5leHBvcnRzLmNvbXBhY3QgPSBjb21wYWN0O1xuZXhwb3J0cy5jb25jYXRQYWdpbmF0aW9uID0gY29uY2F0UGFnaW5hdGlvbjtcbmV4cG9ydHMuY3JlYXRlRnJhZ21lbnRNYXAgPSBjcmVhdGVGcmFnbWVudE1hcDtcbmV4cG9ydHMuZml4T2JzZXJ2YWJsZVN1YmNsYXNzID0gZml4T2JzZXJ2YWJsZVN1YmNsYXNzO1xuZXhwb3J0cy5nZXREZWZhdWx0VmFsdWVzID0gZ2V0RGVmYXVsdFZhbHVlcztcbmV4cG9ydHMuZ2V0RGlyZWN0aXZlTmFtZXMgPSBnZXREaXJlY3RpdmVOYW1lcztcbmV4cG9ydHMuZ2V0RnJhZ21lbnREZWZpbml0aW9uID0gZ2V0RnJhZ21lbnREZWZpbml0aW9uO1xuZXhwb3J0cy5nZXRGcmFnbWVudERlZmluaXRpb25zID0gZ2V0RnJhZ21lbnREZWZpbml0aW9ucztcbmV4cG9ydHMuZ2V0RnJhZ21lbnRGcm9tU2VsZWN0aW9uID0gZ2V0RnJhZ21lbnRGcm9tU2VsZWN0aW9uO1xuZXhwb3J0cy5nZXRGcmFnbWVudFF1ZXJ5RG9jdW1lbnQgPSBnZXRGcmFnbWVudFF1ZXJ5RG9jdW1lbnQ7XG5leHBvcnRzLmdldEluY2x1c2lvbkRpcmVjdGl2ZXMgPSBnZXRJbmNsdXNpb25EaXJlY3RpdmVzO1xuZXhwb3J0cy5nZXRNYWluRGVmaW5pdGlvbiA9IGdldE1haW5EZWZpbml0aW9uO1xuZXhwb3J0cy5nZXRPcGVyYXRpb25EZWZpbml0aW9uID0gZ2V0T3BlcmF0aW9uRGVmaW5pdGlvbjtcbmV4cG9ydHMuZ2V0T3BlcmF0aW9uTmFtZSA9IGdldE9wZXJhdGlvbk5hbWU7XG5leHBvcnRzLmdldFF1ZXJ5RGVmaW5pdGlvbiA9IGdldFF1ZXJ5RGVmaW5pdGlvbjtcbmV4cG9ydHMuZ2V0U3RvcmVLZXlOYW1lID0gZ2V0U3RvcmVLZXlOYW1lO1xuZXhwb3J0cy5nZXRUeXBlbmFtZUZyb21SZXN1bHQgPSBnZXRUeXBlbmFtZUZyb21SZXN1bHQ7XG5leHBvcnRzLmdyYXBoUUxSZXN1bHRIYXNFcnJvciA9IGdyYXBoUUxSZXN1bHRIYXNFcnJvcjtcbmV4cG9ydHMuaGFzQWxsRGlyZWN0aXZlcyA9IGhhc0FsbERpcmVjdGl2ZXM7XG5leHBvcnRzLmhhc0FueURpcmVjdGl2ZXMgPSBoYXNBbnlEaXJlY3RpdmVzO1xuZXhwb3J0cy5oYXNDbGllbnRFeHBvcnRzID0gaGFzQ2xpZW50RXhwb3J0cztcbmV4cG9ydHMuaGFzRGlyZWN0aXZlcyA9IGhhc0RpcmVjdGl2ZXM7XG5leHBvcnRzLmlzRG9jdW1lbnROb2RlID0gaXNEb2N1bWVudE5vZGU7XG5leHBvcnRzLmlzRmllbGQgPSBpc0ZpZWxkO1xuZXhwb3J0cy5pc0lubGluZUZyYWdtZW50ID0gaXNJbmxpbmVGcmFnbWVudDtcbmV4cG9ydHMuaXNOb25FbXB0eUFycmF5ID0gaXNOb25FbXB0eUFycmF5O1xuZXhwb3J0cy5pc05vbk51bGxPYmplY3QgPSBpc05vbk51bGxPYmplY3Q7XG5leHBvcnRzLmlzUmVmZXJlbmNlID0gaXNSZWZlcmVuY2U7XG5leHBvcnRzLml0ZXJhdGVPYnNlcnZlcnNTYWZlbHkgPSBpdGVyYXRlT2JzZXJ2ZXJzU2FmZWx5O1xuZXhwb3J0cy5tYWtlUmVmZXJlbmNlID0gbWFrZVJlZmVyZW5jZTtcbmV4cG9ydHMubWFrZVVuaXF1ZUlkID0gbWFrZVVuaXF1ZUlkO1xuZXhwb3J0cy5tYXliZURlZXBGcmVlemUgPSBtYXliZURlZXBGcmVlemU7XG5leHBvcnRzLm1lcmdlRGVlcCA9IG1lcmdlRGVlcDtcbmV4cG9ydHMubWVyZ2VEZWVwQXJyYXkgPSBtZXJnZURlZXBBcnJheTtcbmV4cG9ydHMubWVyZ2VPcHRpb25zID0gbWVyZ2VPcHRpb25zO1xuZXhwb3J0cy5vZmZzZXRMaW1pdFBhZ2luYXRpb24gPSBvZmZzZXRMaW1pdFBhZ2luYXRpb247XG5leHBvcnRzLnJlbGF5U3R5bGVQYWdpbmF0aW9uID0gcmVsYXlTdHlsZVBhZ2luYXRpb247XG5leHBvcnRzLnJlbW92ZUFyZ3VtZW50c0Zyb21Eb2N1bWVudCA9IHJlbW92ZUFyZ3VtZW50c0Zyb21Eb2N1bWVudDtcbmV4cG9ydHMucmVtb3ZlQ2xpZW50U2V0c0Zyb21Eb2N1bWVudCA9IHJlbW92ZUNsaWVudFNldHNGcm9tRG9jdW1lbnQ7XG5leHBvcnRzLnJlbW92ZUNvbm5lY3Rpb25EaXJlY3RpdmVGcm9tRG9jdW1lbnQgPSByZW1vdmVDb25uZWN0aW9uRGlyZWN0aXZlRnJvbURvY3VtZW50O1xuZXhwb3J0cy5yZW1vdmVEaXJlY3RpdmVzRnJvbURvY3VtZW50ID0gcmVtb3ZlRGlyZWN0aXZlc0Zyb21Eb2N1bWVudDtcbmV4cG9ydHMucmVtb3ZlRnJhZ21lbnRTcHJlYWRGcm9tRG9jdW1lbnQgPSByZW1vdmVGcmFnbWVudFNwcmVhZEZyb21Eb2N1bWVudDtcbmV4cG9ydHMucmVzdWx0S2V5TmFtZUZyb21GaWVsZCA9IHJlc3VsdEtleU5hbWVGcm9tRmllbGQ7XG5leHBvcnRzLnNob3VsZEluY2x1ZGUgPSBzaG91bGRJbmNsdWRlO1xuZXhwb3J0cy5zdG9yZUtleU5hbWVGcm9tRmllbGQgPSBzdG9yZUtleU5hbWVGcm9tRmllbGQ7XG5leHBvcnRzLnN0cmluZ2lmeUZvckRpc3BsYXkgPSBzdHJpbmdpZnlGb3JEaXNwbGF5O1xuZXhwb3J0cy52YWx1ZVRvT2JqZWN0UmVwcmVzZW50YXRpb24gPSB2YWx1ZVRvT2JqZWN0UmVwcmVzZW50YXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsaXRpZXMuY2pzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@apollo/client/utilities/utilities.cjs\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nmodule.exports = _interopRequireDefault;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanM/NGVhNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICBcImRlZmF1bHRcIjogb2JqXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdDsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/interopRequireDefault.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireWildcard.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _typeof = __webpack_require__(/*! ../helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\");\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nmodule.exports = _interopRequireWildcard;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkLmpzP2RiY2UiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyxtQkFBTyxDQUFDLDBFQUFtQjs7QUFFekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHtcbiAgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsO1xuICB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuXG4gIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHtcbiAgICByZXR1cm4gY2FjaGU7XG4gIH07XG5cbiAgcmV0dXJuIGNhY2hlO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHtcbiAgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJkZWZhdWx0XCI6IG9ialxuICAgIH07XG4gIH1cblxuICB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTtcblxuICBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KG9iaik7XG4gIH1cblxuICB2YXIgbmV3T2JqID0ge307XG4gIHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsO1xuXG4gICAgICBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7XG5cbiAgaWYgKGNhY2hlKSB7XG4gICAgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTtcbiAgfVxuXG4gIHJldHVybiBuZXdPYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQ7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\n");

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanM/NzAzNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX3R5cGVvZihvYmopO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2Y7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/typeof.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\nexports.__esModule = true;\nexports.default = void 0;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"react\"));\nvar _router = __webpack_require__(/*! ../next-server/lib/router/router */ \"./node_modules/next/dist/next-server/lib/router/router.js\");\nvar _router2 = __webpack_require__(/*! ./router */ \"./node_modules/next/dist/client/router.js\");\nlet cachedObserver;\nconst listeners = new Map();\nconst IntersectionObserver = false ? undefined : null;\nconst prefetched = {};\nfunction getObserver() {\n  // Return shared instance of IntersectionObserver if already created\n  if (cachedObserver) {\n    return cachedObserver;\n  } // Only create shared IntersectionObserver if supported in browser\n  if (!IntersectionObserver) {\n    return undefined;\n  }\n  return cachedObserver = new IntersectionObserver(entries => {\n    entries.forEach(entry => {\n      if (!listeners.has(entry.target)) {\n        return;\n      }\n      const cb = listeners.get(entry.target);\n      if (entry.isIntersecting || entry.intersectionRatio > 0) {\n        cachedObserver.unobserve(entry.target);\n        listeners.delete(entry.target);\n        cb();\n      }\n    });\n  }, {\n    rootMargin: '200px'\n  });\n}\nconst listenToIntersections = (el, cb) => {\n  const observer = getObserver();\n  if (!observer) {\n    return () => {};\n  }\n  observer.observe(el);\n  listeners.set(el, cb);\n  return () => {\n    try {\n      observer.unobserve(el);\n    } catch (err) {\n      console.error(err);\n    }\n    listeners.delete(el);\n  };\n};\nfunction prefetch(router, href, as, options) {\n  if (true) return;\n  if (!(0, _router.isLocalURL)(href)) return; // Prefetch the JSON page if asked (only in the client)\n  // We need to handle a prefetch error here since we may be\n  // loading with priority which can reject but we don't\n  // want to force navigation since this is only a prefetch\n  router.prefetch(href, as, options).catch(err => {\n    if (true) {\n      // rethrow to show invalid URL errors\n      throw err;\n    }\n  }); // Join on an invalid URI character\n  prefetched[href + '%' + as] = true;\n}\nfunction isModifiedEvent(event) {\n  const {\n    target\n  } = event.currentTarget;\n  return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey ||\n  // triggers resource download\n  event.nativeEvent && event.nativeEvent.which === 2;\n}\nfunction linkClicked(e, router, href, as, replace, shallow, scroll) {\n  const {\n    nodeName\n  } = e.currentTarget;\n  if (nodeName === 'A' && (isModifiedEvent(e) || !(0, _router.isLocalURL)(href))) {\n    // ignore click for browser’s default behavior\n    return;\n  }\n  e.preventDefault(); //  avoid scroll for urls with anchor refs\n  if (scroll == null) {\n    scroll = as.indexOf('#') < 0;\n  } // replace state instead of push if prop is present\n  router[replace ? 'replace' : 'push'](href, as, {\n    shallow\n  }).then(success => {\n    if (!success) return;\n    if (scroll) {\n      window.scrollTo(0, 0);\n      document.body.focus();\n    }\n  });\n}\nfunction Link(props) {\n  if (true) {\n    function createPropError(args) {\n      return new Error(`Failed prop type: The prop \\`${args.key}\\` expects a ${args.expected} in \\`<Link>\\`, but got \\`${args.actual}\\` instead.` + (false ? undefined : ''));\n    } // TypeScript trick for type-guarding:\n    const requiredPropsGuard = {\n      href: true\n    };\n    const requiredProps = Object.keys(requiredPropsGuard);\n    requiredProps.forEach(key => {\n      if (key === 'href') {\n        if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {\n          throw createPropError({\n            key,\n            expected: '`string` or `object`',\n            actual: props[key] === null ? 'null' : typeof props[key]\n          });\n        }\n      } else {\n        // TypeScript trick for type-guarding:\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const _ = key;\n      }\n    }); // TypeScript trick for type-guarding:\n    const optionalPropsGuard = {\n      as: true,\n      replace: true,\n      scroll: true,\n      shallow: true,\n      passHref: true,\n      prefetch: true\n    };\n    const optionalProps = Object.keys(optionalPropsGuard);\n    optionalProps.forEach(key => {\n      if (key === 'as') {\n        if (props[key] && typeof props[key] !== 'string' && typeof props[key] !== 'object') {\n          throw createPropError({\n            key,\n            expected: '`string` or `object`',\n            actual: typeof props[key]\n          });\n        }\n      } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'prefetch') {\n        if (props[key] != null && typeof props[key] !== 'boolean') {\n          throw createPropError({\n            key,\n            expected: '`boolean`',\n            actual: typeof props[key]\n          });\n        }\n      } else {\n        // TypeScript trick for type-guarding:\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const _ = key;\n      }\n    }); // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const hasWarned = _react.default.useRef(false);\n    if (props.prefetch && !hasWarned.current) {\n      hasWarned.current = true;\n      console.warn('Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://err.sh/vercel/next.js/prefetch-true-deprecated');\n    }\n  }\n  const p = props.prefetch !== false;\n  const [childElm, setChildElm] = _react.default.useState();\n  const router = (0, _router2.useRouter)();\n  const pathname = router && router.pathname || '/';\n  const {\n    href,\n    as\n  } = _react.default.useMemo(() => {\n    const [resolvedHref, resolvedAs] = (0, _router.resolveHref)(pathname, props.href, true);\n    return {\n      href: resolvedHref,\n      as: props.as ? (0, _router.resolveHref)(pathname, props.as) : resolvedAs || resolvedHref\n    };\n  }, [pathname, props.href, props.as]);\n  _react.default.useEffect(() => {\n    if (p && IntersectionObserver && childElm && childElm.tagName && (0, _router.isLocalURL)(href)) {\n      // Join on an invalid URI character\n      const isPrefetched = prefetched[href + '%' + as];\n      if (!isPrefetched) {\n        return listenToIntersections(childElm, () => {\n          prefetch(router, href, as);\n        });\n      }\n    }\n  }, [p, childElm, href, as, router]);\n  let {\n    children,\n    replace,\n    shallow,\n    scroll\n  } = props; // Deprecated. Warning shown by propType check. If the children provided is a string (<Link>example</Link>) we wrap it in an <a> tag\n  if (typeof children === 'string') {\n    children = /*#__PURE__*/_react.default.createElement(\"a\", null, children);\n  } // This will return the first child, if multiple are provided it will throw an error\n  const child = _react.Children.only(children);\n  const childProps = {\n    ref: el => {\n      if (el) setChildElm(el);\n      if (child && typeof child === 'object' && child.ref) {\n        if (typeof child.ref === 'function') child.ref(el);else if (typeof child.ref === 'object') {\n          child.ref.current = el;\n        }\n      }\n    },\n    onClick: e => {\n      if (child.props && typeof child.props.onClick === 'function') {\n        child.props.onClick(e);\n      }\n      if (!e.defaultPrevented) {\n        linkClicked(e, router, href, as, replace, shallow, scroll);\n      }\n    }\n  };\n  if (p) {\n    childProps.onMouseEnter = e => {\n      if (!(0, _router.isLocalURL)(href)) return;\n      if (child.props && typeof child.props.onMouseEnter === 'function') {\n        child.props.onMouseEnter(e);\n      }\n      prefetch(router, href, as, {\n        priority: true\n      });\n    };\n  } // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n  // defined, we specify the current 'href', so that repetition is not needed by the user\n  if (props.passHref || child.type === 'a' && !('href' in child.props)) {\n    childProps.href = (0, _router.addBasePath)((0, _router.addLocale)(as, router && router.locale, router && router.defaultLocale));\n  }\n  return /*#__PURE__*/_react.default.cloneElement(child, childProps);\n}\nvar _default = Link;\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vY2xpZW50L2xpbmsudHN4PzVlNGIiXSwibmFtZXMiOlsiY2FjaGVkT2JzZXJ2ZXIiLCJsaXN0ZW5lcnMiLCJNYXAiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsIndpbmRvdyIsInByZWZldGNoZWQiLCJnZXRPYnNlcnZlciIsInVuZGVmaW5lZCIsImVudHJpZXMiLCJmb3JFYWNoIiwiZW50cnkiLCJoYXMiLCJ0YXJnZXQiLCJjYiIsImdldCIsImlzSW50ZXJzZWN0aW5nIiwiaW50ZXJzZWN0aW9uUmF0aW8iLCJ1bm9ic2VydmUiLCJkZWxldGUiLCJyb290TWFyZ2luIiwibGlzdGVuVG9JbnRlcnNlY3Rpb25zIiwiZWwiLCJvYnNlcnZlciIsIm9ic2VydmUiLCJzZXQiLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJwcmVmZXRjaCIsInJvdXRlciIsImhyZWYiLCJhcyIsIm9wdGlvbnMiLCJjYXRjaCIsImlzTW9kaWZpZWRFdmVudCIsImV2ZW50IiwiY3VycmVudFRhcmdldCIsIm1ldGFLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJhbHRLZXkiLCJuYXRpdmVFdmVudCIsIndoaWNoIiwibGlua0NsaWNrZWQiLCJlIiwicmVwbGFjZSIsInNoYWxsb3ciLCJzY3JvbGwiLCJub2RlTmFtZSIsInByZXZlbnREZWZhdWx0IiwiaW5kZXhPZiIsInRoZW4iLCJzdWNjZXNzIiwic2Nyb2xsVG8iLCJkb2N1bWVudCIsImJvZHkiLCJmb2N1cyIsIkxpbmsiLCJwcm9wcyIsImNyZWF0ZVByb3BFcnJvciIsImFyZ3MiLCJFcnJvciIsImtleSIsImV4cGVjdGVkIiwiYWN0dWFsIiwicmVxdWlyZWRQcm9wc0d1YXJkIiwicmVxdWlyZWRQcm9wcyIsIk9iamVjdCIsImtleXMiLCJfIiwib3B0aW9uYWxQcm9wc0d1YXJkIiwicGFzc0hyZWYiLCJvcHRpb25hbFByb3BzIiwiaGFzV2FybmVkIiwiUmVhY3QiLCJ1c2VSZWYiLCJjdXJyZW50Iiwid2FybiIsInAiLCJjaGlsZEVsbSIsInNldENoaWxkRWxtIiwidXNlU3RhdGUiLCJwYXRobmFtZSIsInVzZU1lbW8iLCJyZXNvbHZlZEhyZWYiLCJyZXNvbHZlZEFzIiwidXNlRWZmZWN0IiwidGFnTmFtZSIsImlzUHJlZmV0Y2hlZCIsImNoaWxkcmVuIiwiY2hpbGQiLCJDaGlsZHJlbiIsIm9ubHkiLCJjaGlsZFByb3BzIiwicmVmIiwib25DbGljayIsImRlZmF1bHRQcmV2ZW50ZWQiLCJvbk1vdXNlRW50ZXIiLCJwcmlvcml0eSIsInR5cGUiLCJsb2NhbGUiLCJkZWZhdWx0TG9jYWxlIiwiY2xvbmVFbGVtZW50Il0sIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBRUE7QUFRQTtBQXNCQSxJQUFJQSxjQUFKO0FBQ0EsTUFBTUMsU0FBUyxHQUFHLElBQUlDLEdBQUosRUFBbEI7QUFDQSxNQUFNQyxvQkFBb0IsR0FDeEIsUUFBZ0NDLFNBQWhDLEdBQThELElBRGhFO0FBRUEsTUFBTUMsVUFBMkMsR0FBRyxFQUFwRDtBQUVBLFNBQVNDLFdBQVQsR0FBeUQ7RUFDdkQ7RUFDQSxJQUFJTixjQUFKLEVBQW9CO0lBQ2xCLE9BQU9BLGNBQVA7RUFDRCxDQUVEO0VBQ0EsSUFBSSxDQUFDRyxvQkFBTCxFQUEyQjtJQUN6QixPQUFPSSxTQUFQO0VBQ0Q7RUFFRCxPQUFRUCxjQUFjLEdBQUcsSUFBSUcsb0JBQUosQ0FDdEJLLE9BQUQsSUFBYTtJQUNYQSxPQUFPLENBQUNDLE9BQVJELENBQWlCRSxLQUFELElBQVc7TUFDekIsSUFBSSxDQUFDVCxTQUFTLENBQUNVLEdBQVZWLENBQWNTLEtBQUssQ0FBQ0UsTUFBcEJYLENBQUwsRUFBa0M7UUFDaEM7TUFDRDtNQUVELE1BQU1ZLEVBQUUsR0FBR1osU0FBUyxDQUFDYSxHQUFWYixDQUFjUyxLQUFLLENBQUNFLE1BQXBCWCxDQUFYO01BQ0EsSUFBSVMsS0FBSyxDQUFDSyxjQUFOTCxJQUF3QkEsS0FBSyxDQUFDTSxpQkFBTk4sR0FBMEIsQ0FBdEQsRUFBeUQ7UUFDdkRWLGNBQWMs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bUJnQyxLQUFLLENBQUNTLElBQU5ULEtBQWUsR0FBZkEsSUFBc0IsRUFBRSxVQUFVQSxLQUFLLENBQUNoQyxLQUFsQixDQUE3QyxFQUF3RTtJQUN0RW1DLFVBQVUsQ0FBQy9ELElBQVgrRCxHQUFrQix5QkFDaEIsdUJBQVU5RCxFQUFWLEVBQWNGLE1BQU0sSUFBSUEsTUFBTSxDQUFDdUUsTUFBL0IsRUFBdUN2RSxNQUFNLElBQUlBLE1BQU0sQ0FBQ3dFLGFBQXhELENBRGdCLENBQWxCUjtFQUdEO0VBRUQsb0JBQU9uQixlQUFNNEIsWUFBTjVCLENBQW1CZ0IsS0FBbkJoQixFQUEwQm1CLFVBQTFCbkIsQ0FBUDtBQUNEO2VBRWNqQixJIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvbGluay5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgVXJsT2JqZWN0IH0gZnJvbSAndXJsJ1xuaW1wb3J0IHtcbiAgYWRkQmFzZVBhdGgsXG4gIGFkZExvY2FsZSxcbiAgaXNMb2NhbFVSTCxcbiAgTmV4dFJvdXRlcixcbiAgUHJlZmV0Y2hPcHRpb25zLFxuICByZXNvbHZlSHJlZixcbn0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci9yb3V0ZXInXG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tICcuL3JvdXRlcidcblxudHlwZSBVcmwgPSBzdHJpbmcgfCBVcmxPYmplY3RcbnR5cGUgUmVxdWlyZWRLZXlzPFQ+ID0ge1xuICBbSyBpbiBrZXlvZiBUXS0/OiB7fSBleHRlbmRzIFBpY2s8VCwgSz4gPyBuZXZlciA6IEtcbn1ba2V5b2YgVF1cbnR5cGUgT3B0aW9uYWxLZXlzPFQ+ID0ge1xuICBbSyBpbiBrZXlvZiBUXS0/OiB7fSBleHRlbmRzIFBpY2s8VCwgSz4gPyBLIDogbmV2ZXJcbn1ba2V5b2YgVF1cblxuZXhwb3J0IHR5cGUgTGlua1Byb3BzID0ge1xuICBocmVmOiBVcmxcbiAgYXM/OiBVcmxcbiAgcmVwbGFjZT86IGJvb2xlYW5cbiAgc2Nyb2xsPzogYm9vbGVhblxuICBzaGFsbG93PzogYm9vbGVhblxuICBwYXNzSHJlZj86IGJvb2xlYW5cbiAgcHJlZmV0Y2g/OiBib29sZWFuXG59XG50eXBlIExpbmtQcm9wc1JlcXVpcmVkID0gUmVxdWlyZWRLZXlzPExpbmtQcm9wcz5cbnR5cGUgTGlua1Byb3BzT3B0aW9uYWwgPSBPcHRpb25hbEtleXM8TGlua1Byb3BzPlxuXG5sZXQgY2FjaGVkT2JzZXJ2ZXI6IEludGVyc2VjdGlvbk9ic2VydmVyXG5jb25zdCBsaXN0ZW5lcnMgPSBuZXcgTWFwPEVsZW1lbnQsICgpID0+IHZvaWQ+KClcbmNvbnN0IEludGVyc2VjdGlvbk9ic2VydmVyID1cbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgOiBudWxsXG5jb25zdCBwcmVmZXRjaGVkOiB7IFtjYWNoZUtleTogc3RyaW5nXTogYm9vbGVhbiB9ID0ge31cblxuZnVuY3Rpb24gZ2V0T2JzZXJ2ZXIoKTogSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgfCB1bmRlZmluZWQge1xuICAvLyBSZXR1cm4gc2hhcmVkIGluc3RhbmNlIG9mIEludGVyc2VjdGlvbk9ic2VydmVyIGlmIGFscmVhZHkgY3JlYXRlZFxuICBpZiAoY2FjaGVkT2JzZXJ2ZXIpIHtcbiAgICByZXR1cm4gY2FjaGVkT2JzZXJ2ZXJcbiAgfVxuXG4gIC8vIE9ubHkgY3JlYXRlIHNoYXJlZCBJbnRlcnNlY3Rpb25PYnNlcnZlciBpZiBzdXBwb3J0ZWQgaW4gYnJvd3NlclxuICBpZiAoIUludGVyc2VjdGlvbk9ic2VydmVyKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgcmV0dXJuIChjYWNoZWRPYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihcbiAgICAoZW50cmllcykgPT4ge1xuICAgICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgICBpZiAoIWxpc3RlbmVycy5oYXMoZW50cnkudGFyZ2V0KSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2IgPSBsaXN0ZW5lcnMuZ2V0KGVudHJ5LnRhcmdldCkhXG4gICAgICAgIGlmIChlbnRyeS5pc0ludGVyc2VjdGluZyB8fCBlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyA+IDApIHtcbiAgICAgICAgICBjYWNoZWRPYnNlcnZlci51bm9ic2VydmUoZW50cnkudGFyZ2V0KVxuICAgICAgICAgIGxpc3RlbmVycy5kZWxldGUoZW50cnkudGFyZ2V0KVxuICAgICAgICAgIGNiKClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9LFxuICAgIHsgcm9vdE1hcmdpbjogJzIwMHB4JyB9XG4gICkpXG59XG5cbmNvbnN0IGxpc3RlblRvSW50ZXJzZWN0aW9ucyA9IChlbDogRWxlbWVudCwgY2I6ICgpID0+IHZvaWQpID0+IHtcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBnZXRPYnNlcnZlcigpXG4gIGlmICghb2JzZXJ2ZXIpIHtcbiAgICByZXR1cm4gKCkgPT4ge31cbiAgfVxuXG4gIG9ic2VydmVyLm9ic2VydmUoZWwpXG4gIGxpc3RlbmVycy5zZXQoZWwsIGNiKVxuICByZXR1cm4gKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBvYnNlcnZlci51bm9ic2VydmUoZWwpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICB9XG4gICAgbGlzdGVuZXJzLmRlbGV0ZShlbClcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVmZXRjaChcbiAgcm91dGVyOiBOZXh0Um91dGVyLFxuICBocmVmOiBzdHJpbmcsXG4gIGFzOiBzdHJpbmcsXG4gIG9wdGlvbnM/OiBQcmVmZXRjaE9wdGlvbnNcbik6IHZvaWQge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVyblxuICBpZiAoIWlzTG9jYWxVUkwoaHJlZikpIHJldHVyblxuICAvLyBQcmVmZXRjaCB0aGUgSlNPTiBwYWdlIGlmIGFza2VkIChvbmx5IGluIHRoZSBjbGllbnQpXG4gIC8vIFdlIG5lZWQgdG8gaGFuZGxlIGEgcHJlZmV0Y2ggZXJyb3IgaGVyZSBzaW5jZSB3ZSBtYXkgYmVcbiAgLy8gbG9hZGluZyB3aXRoIHByaW9yaXR5IHdoaWNoIGNhbiByZWplY3QgYnV0IHdlIGRvbid0XG4gIC8vIHdhbnQgdG8gZm9yY2UgbmF2aWdhdGlvbiBzaW5jZSB0aGlzIGlzIG9ubHkgYSBwcmVmZXRjaFxuICByb3V0ZXIucHJlZmV0Y2goaHJlZiwgYXMsIG9wdGlvbnMpLmNhdGNoKChlcnIpID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gcmV0aHJvdyB0byBzaG93IGludmFsaWQgVVJMIGVycm9yc1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9KVxuICAvLyBKb2luIG9uIGFuIGludmFsaWQgVVJJIGNoYXJhY3RlclxuICBwcmVmZXRjaGVkW2hyZWYgKyAnJScgKyBhc10gPSB0cnVlXG59XG5cbmZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudDogUmVhY3QuTW91c2VFdmVudCkge1xuICBjb25zdCB7IHRhcmdldCB9ID0gZXZlbnQuY3VycmVudFRhcmdldCBhcyBIVE1MQW5jaG9yRWxlbWVudFxuICByZXR1cm4gKFxuICAgICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSAnX3NlbGYnKSB8fFxuICAgIGV2ZW50Lm1ldGFLZXkgfHxcbiAgICBldmVudC5jdHJsS2V5IHx8XG4gICAgZXZlbnQuc2hpZnRLZXkgfHxcbiAgICBldmVudC5hbHRLZXkgfHwgLy8gdHJpZ2dlcnMgcmVzb3VyY2UgZG93bmxvYWRcbiAgICAoZXZlbnQubmF0aXZlRXZlbnQgJiYgZXZlbnQubmF0aXZlRXZlbnQud2hpY2ggPT09IDIpXG4gIClcbn1cblxuZnVuY3Rpb24gbGlua0NsaWNrZWQoXG4gIGU6IFJlYWN0Lk1vdXNlRXZlbnQsXG4gIHJvdXRlcjogTmV4dFJvdXRlcixcbiAgaHJlZjogc3RyaW5nLFxuICBhczogc3RyaW5nLFxuICByZXBsYWNlPzogYm9vbGVhbixcbiAgc2hhbGxvdz86IGJvb2xlYW4sXG4gIHNjcm9sbD86IGJvb2xlYW5cbik6IHZvaWQge1xuICBjb25zdCB7IG5vZGVOYW1lIH0gPSBlLmN1cnJlbnRUYXJnZXRcblxuICBpZiAobm9kZU5hbWUgPT09ICdBJyAmJiAoaXNNb2RpZmllZEV2ZW50KGUpIHx8ICFpc0xvY2FsVVJMKGhyZWYpKSkge1xuICAgIC8vIGlnbm9yZSBjbGljayBmb3IgYnJvd3NlcuKAmXMgZGVmYXVsdCBiZWhhdmlvclxuICAgIHJldHVyblxuICB9XG5cbiAgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgLy8gIGF2b2lkIHNjcm9sbCBmb3IgdXJscyB3aXRoIGFuY2hvciByZWZzXG4gIGlmIChzY3JvbGwgPT0gbnVsbCkge1xuICAgIHNjcm9sbCA9IGFzLmluZGV4T2YoJyMnKSA8IDBcbiAgfVxuXG4gIC8vIHJlcGxhY2Ugc3RhdGUgaW5zdGVhZCBvZiBwdXNoIGlmIHByb3AgaXMgcHJlc2VudFxuICByb3V0ZXJbcmVwbGFjZSA/ICdyZXBsYWNlJyA6ICdwdXNoJ10oaHJlZiwgYXMsIHsgc2hhbGxvdyB9KS50aGVuKFxuICAgIChzdWNjZXNzOiBib29sZWFuKSA9PiB7XG4gICAgICBpZiAoIXN1Y2Nlc3MpIHJldHVyblxuICAgICAgaWYgKHNjcm9sbCkge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMClcbiAgICAgICAgZG9jdW1lbnQuYm9keS5mb2N1cygpXG4gICAgICB9XG4gICAgfVxuICApXG59XG5cbmZ1bmN0aW9uIExpbmsocHJvcHM6IFJlYWN0LlByb3BzV2l0aENoaWxkcmVuPExpbmtQcm9wcz4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGVQcm9wRXJyb3IoYXJnczoge1xuICAgICAga2V5OiBzdHJpbmdcbiAgICAgIGV4cGVjdGVkOiBzdHJpbmdcbiAgICAgIGFjdHVhbDogc3RyaW5nXG4gICAgfSkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgYEZhaWxlZCBwcm9wIHR5cGU6IFRoZSBwcm9wIFxcYCR7YXJncy5rZXl9XFxgIGV4cGVjdHMgYSAke2FyZ3MuZXhwZWN0ZWR9IGluIFxcYDxMaW5rPlxcYCwgYnV0IGdvdCBcXGAke2FyZ3MuYWN0dWFsfVxcYCBpbnN0ZWFkLmAgK1xuICAgICAgICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBcIlxcbk9wZW4geW91ciBicm93c2VyJ3MgY29uc29sZSB0byB2aWV3IHRoZSBDb21wb25lbnQgc3RhY2sgdHJhY2UuXCJcbiAgICAgICAgICAgIDogJycpXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICBjb25zdCByZXF1aXJlZFByb3BzR3VhcmQ6IFJlY29yZDxMaW5rUHJvcHNSZXF1aXJlZCwgdHJ1ZT4gPSB7XG4gICAgICBocmVmOiB0cnVlLFxuICAgIH0gYXMgY29uc3RcbiAgICBjb25zdCByZXF1aXJlZFByb3BzOiBMaW5rUHJvcHNSZXF1aXJlZFtdID0gT2JqZWN0LmtleXMoXG4gICAgICByZXF1aXJlZFByb3BzR3VhcmRcbiAgICApIGFzIExpbmtQcm9wc1JlcXVpcmVkW11cbiAgICByZXF1aXJlZFByb3BzLmZvckVhY2goKGtleTogTGlua1Byb3BzUmVxdWlyZWQpID0+IHtcbiAgICAgIGlmIChrZXkgPT09ICdocmVmJykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJvcHNba2V5XSA9PSBudWxsIHx8XG4gICAgICAgICAgKHR5cGVvZiBwcm9wc1trZXldICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgcHJvcHNba2V5XSAhPT0gJ29iamVjdCcpXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgIG9yIGBvYmplY3RgJyxcbiAgICAgICAgICAgIGFjdHVhbDogcHJvcHNba2V5XSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBwcm9wc1trZXldLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgY29uc3QgXzogbmV2ZXIgPSBrZXlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICBjb25zdCBvcHRpb25hbFByb3BzR3VhcmQ6IFJlY29yZDxMaW5rUHJvcHNPcHRpb25hbCwgdHJ1ZT4gPSB7XG4gICAgICBhczogdHJ1ZSxcbiAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICBzY3JvbGw6IHRydWUsXG4gICAgICBzaGFsbG93OiB0cnVlLFxuICAgICAgcGFzc0hyZWY6IHRydWUsXG4gICAgICBwcmVmZXRjaDogdHJ1ZSxcbiAgICB9IGFzIGNvbnN0XG4gICAgY29uc3Qgb3B0aW9uYWxQcm9wczogTGlua1Byb3BzT3B0aW9uYWxbXSA9IE9iamVjdC5rZXlzKFxuICAgICAgb3B0aW9uYWxQcm9wc0d1YXJkXG4gICAgKSBhcyBMaW5rUHJvcHNPcHRpb25hbFtdXG4gICAgb3B0aW9uYWxQcm9wcy5mb3JFYWNoKChrZXk6IExpbmtQcm9wc09wdGlvbmFsKSA9PiB7XG4gICAgICBpZiAoa2V5ID09PSAnYXMnKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwcm9wc1trZXldICYmXG4gICAgICAgICAgdHlwZW9mIHByb3BzW2tleV0gIT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgdHlwZW9mIHByb3BzW2tleV0gIT09ICdvYmplY3QnXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgIG9yIGBvYmplY3RgJyxcbiAgICAgICAgICAgIGFjdHVhbDogdHlwZW9mIHByb3BzW2tleV0sXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAga2V5ID09PSAncmVwbGFjZScgfHxcbiAgICAgICAga2V5ID09PSAnc2Nyb2xsJyB8fFxuICAgICAgICBrZXkgPT09ICdzaGFsbG93JyB8fFxuICAgICAgICBrZXkgPT09ICdwYXNzSHJlZicgfHxcbiAgICAgICAga2V5ID09PSAncHJlZmV0Y2gnXG4gICAgICApIHtcbiAgICAgICAgaWYgKHByb3BzW2tleV0gIT0gbnVsbCAmJiB0eXBlb2YgcHJvcHNba2V5XSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiAnYGJvb2xlYW5gJyxcbiAgICAgICAgICAgIGFjdHVhbDogdHlwZW9mIHByb3BzW2tleV0sXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICBjb25zdCBfOiBuZXZlciA9IGtleVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBUaGlzIGhvb2sgaXMgaW4gYSBjb25kaXRpb25hbCBidXQgdGhhdCBpcyBvayBiZWNhdXNlIGBwcm9jZXNzLmVudi5OT0RFX0VOVmAgbmV2ZXIgY2hhbmdlc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIGNvbnN0IGhhc1dhcm5lZCA9IFJlYWN0LnVzZVJlZihmYWxzZSlcbiAgICBpZiAocHJvcHMucHJlZmV0Y2ggJiYgIWhhc1dhcm5lZC5jdXJyZW50KSB7XG4gICAgICBoYXNXYXJuZWQuY3VycmVudCA9IHRydWVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ05leHQuanMgYXV0by1wcmVmZXRjaGVzIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gdmlld3BvcnQuIFRoZSBwcmVmZXRjaCBhdHRyaWJ1dGUgaXMgbm8gbG9uZ2VyIG5lZWRlZC4gTW9yZTogaHR0cHM6Ly9lcnIuc2gvdmVyY2VsL25leHQuanMvcHJlZmV0Y2gtdHJ1ZS1kZXByZWNhdGVkJ1xuICAgICAgKVxuICAgIH1cbiAgfVxuICBjb25zdCBwID0gcHJvcHMucHJlZmV0Y2ggIT09IGZhbHNlXG5cbiAgY29uc3QgW2NoaWxkRWxtLCBzZXRDaGlsZEVsbV0gPSBSZWFjdC51c2VTdGF0ZTxFbGVtZW50PigpXG5cbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKClcbiAgY29uc3QgcGF0aG5hbWUgPSAocm91dGVyICYmIHJvdXRlci5wYXRobmFtZSkgfHwgJy8nXG5cbiAgY29uc3QgeyBocmVmLCBhcyB9ID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgW3Jlc29sdmVkSHJlZiwgcmVzb2x2ZWRBc10gPSByZXNvbHZlSHJlZihwYXRobmFtZSwgcHJvcHMuaHJlZiwgdHJ1ZSlcbiAgICByZXR1cm4ge1xuICAgICAgaHJlZjogcmVzb2x2ZWRIcmVmLFxuICAgICAgYXM6IHByb3BzLmFzXG4gICAgICAgID8gcmVzb2x2ZUhyZWYocGF0aG5hbWUsIHByb3BzLmFzKVxuICAgICAgICA6IHJlc29sdmVkQXMgfHwgcmVzb2x2ZWRIcmVmLFxuICAgIH1cbiAgfSwgW3BhdGhuYW1lLCBwcm9wcy5ocmVmLCBwcm9wcy5hc10pXG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoXG4gICAgICBwICYmXG4gICAgICBJbnRlcnNlY3Rpb25PYnNlcnZlciAmJlxuICAgICAgY2hpbGRFbG0gJiZcbiAgICAgIGNoaWxkRWxtLnRhZ05hbWUgJiZcbiAgICAgIGlzTG9jYWxVUkwoaHJlZilcbiAgICApIHtcbiAgICAgIC8vIEpvaW4gb24gYW4gaW52YWxpZCBVUkkgY2hhcmFjdGVyXG4gICAgICBjb25zdCBpc1ByZWZldGNoZWQgPSBwcmVmZXRjaGVkW2hyZWYgKyAnJScgKyBhc11cbiAgICAgIGlmICghaXNQcmVmZXRjaGVkKSB7XG4gICAgICAgIHJldHVybiBsaXN0ZW5Ub0ludGVyc2VjdGlvbnMoY2hpbGRFbG0sICgpID0+IHtcbiAgICAgICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfSwgW3AsIGNoaWxkRWxtLCBocmVmLCBhcywgcm91dGVyXSlcblxuICBsZXQgeyBjaGlsZHJlbiwgcmVwbGFjZSwgc2hhbGxvdywgc2Nyb2xsIH0gPSBwcm9wc1xuICAvLyBEZXByZWNhdGVkLiBXYXJuaW5nIHNob3duIGJ5IHByb3BUeXBlIGNoZWNrLiBJZiB0aGUgY2hpbGRyZW4gcHJvdmlkZWQgaXMgYSBzdHJpbmcgKDxMaW5rPmV4YW1wbGU8L0xpbms+KSB3ZSB3cmFwIGl0IGluIGFuIDxhPiB0YWdcbiAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZycpIHtcbiAgICBjaGlsZHJlbiA9IDxhPntjaGlsZHJlbn08L2E+XG4gIH1cblxuICAvLyBUaGlzIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBjaGlsZCwgaWYgbXVsdGlwbGUgYXJlIHByb3ZpZGVkIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3JcbiAgY29uc3QgY2hpbGQ6IGFueSA9IENoaWxkcmVuLm9ubHkoY2hpbGRyZW4pXG4gIGNvbnN0IGNoaWxkUHJvcHM6IHtcbiAgICBvbk1vdXNlRW50ZXI/OiBSZWFjdC5Nb3VzZUV2ZW50SGFuZGxlclxuICAgIG9uQ2xpY2s6IFJlYWN0Lk1vdXNlRXZlbnRIYW5kbGVyXG4gICAgaHJlZj86IHN0cmluZ1xuICAgIHJlZj86IGFueVxuICB9ID0ge1xuICAgIHJlZjogKGVsOiBhbnkpID0+IHtcbiAgICAgIGlmIChlbCkgc2V0Q2hpbGRFbG0oZWwpXG5cbiAgICAgIGlmIChjaGlsZCAmJiB0eXBlb2YgY2hpbGQgPT09ICdvYmplY3QnICYmIGNoaWxkLnJlZikge1xuICAgICAgICBpZiAodHlwZW9mIGNoaWxkLnJlZiA9PT0gJ2Z1bmN0aW9uJykgY2hpbGQucmVmKGVsKVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2hpbGQucmVmID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGNoaWxkLnJlZi5jdXJyZW50ID0gZWxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgb25DbGljazogKGU6IFJlYWN0Lk1vdXNlRXZlbnQpID0+IHtcbiAgICAgIGlmIChjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjaGlsZC5wcm9wcy5vbkNsaWNrKGUpXG4gICAgICB9XG4gICAgICBpZiAoIWUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICBsaW5rQ2xpY2tlZChlLCByb3V0ZXIsIGhyZWYsIGFzLCByZXBsYWNlLCBzaGFsbG93LCBzY3JvbGwpXG4gICAgICB9XG4gICAgfSxcbiAgfVxuXG4gIGlmIChwKSB7XG4gICAgY2hpbGRQcm9wcy5vbk1vdXNlRW50ZXIgPSAoZTogUmVhY3QuTW91c2VFdmVudCkgPT4ge1xuICAgICAgaWYgKCFpc0xvY2FsVVJMKGhyZWYpKSByZXR1cm5cbiAgICAgIGlmIChjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25Nb3VzZUVudGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNoaWxkLnByb3BzLm9uTW91c2VFbnRlcihlKVxuICAgICAgfVxuICAgICAgcHJlZmV0Y2gocm91dGVyLCBocmVmLCBhcywgeyBwcmlvcml0eTogdHJ1ZSB9KVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIGNoaWxkIGlzIGFuIDxhPiB0YWcgYW5kIGRvZXNuJ3QgaGF2ZSBhIGhyZWYgYXR0cmlidXRlLCBvciBpZiB0aGUgJ3Bhc3NIcmVmJyBwcm9wZXJ0eSBpc1xuICAvLyBkZWZpbmVkLCB3ZSBzcGVjaWZ5IHRoZSBjdXJyZW50ICdocmVmJywgc28gdGhhdCByZXBldGl0aW9uIGlzIG5vdCBuZWVkZWQgYnkgdGhlIHVzZXJcbiAgaWYgKHByb3BzLnBhc3NIcmVmIHx8IChjaGlsZC50eXBlID09PSAnYScgJiYgISgnaHJlZicgaW4gY2hpbGQucHJvcHMpKSkge1xuICAgIGNoaWxkUHJvcHMuaHJlZiA9IGFkZEJhc2VQYXRoKFxuICAgICAgYWRkTG9jYWxlKGFzLCByb3V0ZXIgJiYgcm91dGVyLmxvY2FsZSwgcm91dGVyICYmIHJvdXRlci5kZWZhdWx0TG9jYWxlKVxuICAgIClcbiAgfVxuXG4gIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIGNoaWxkUHJvcHMpXG59XG5cbmV4cG9ydCBkZWZhdWx0IExpbmtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/link.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/normalize-trailing-slash.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/normalize-trailing-slash.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.removePathTrailingSlash = removePathTrailingSlash;\nexports.normalizePathTrailingSlash = void 0; /**\n                                             * Removes the trailing slash of a path if there is one. Preserves the root path `/`.\n                                             */\nfunction removePathTrailingSlash(path) {\n  return path.endsWith('/') && path !== '/' ? path.slice(0, -1) : path;\n} /**\n  * Normalizes the trailing slash of a path according to the `trailingSlash` option\n  * in `next.config.js`.\n  */\nconst normalizePathTrailingSlash =  false ? undefined : removePathTrailingSlash;\nexports.normalizePathTrailingSlash = normalizePathTrailingSlash;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vY2xpZW50L25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaC50cz82MzIzIl0sIm5hbWVzIjpbInJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoIiwicGF0aCIsImVuZHNXaXRoIiwic2xpY2UiLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCIsInByb2Nlc3MiXSwibWFwcGluZ3MiOiI7Ozs7NENBQUE7OztBQUdPLFNBQVNBLHVCQUFULENBQWlDQyxJQUFqQyxFQUF1RDtFQUM1RCxPQUFPQSxJQUFJLENBQUNDLFFBQUxELENBQWMsR0FBZEEsS0FBc0JBLElBQUksS0FBSyxHQUEvQkEsR0FBcUNBLElBQUksQ0FBQ0UsS0FBTEYsQ0FBVyxDQUFYQSxFQUFjLENBQUMsQ0FBZkEsQ0FBckNBLEdBQXlEQSxJQUFoRTtBQUNELENBRUQ7Ozs7QUFJTyxNQUFNRywwQkFBMEIsR0FBR0MsU0FDckNKLFNBRHFDSSxHQVV0Q0wsdUJBVkciLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2guanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJlbW92ZXMgdGhlIHRyYWlsaW5nIHNsYXNoIG9mIGEgcGF0aCBpZiB0aGVyZSBpcyBvbmUuIFByZXNlcnZlcyB0aGUgcm9vdCBwYXRoIGAvYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBwYXRoLmVuZHNXaXRoKCcvJykgJiYgcGF0aCAhPT0gJy8nID8gcGF0aC5zbGljZSgwLCAtMSkgOiBwYXRoXG59XG5cbi8qKlxuICogTm9ybWFsaXplcyB0aGUgdHJhaWxpbmcgc2xhc2ggb2YgYSBwYXRoIGFjY29yZGluZyB0byB0aGUgYHRyYWlsaW5nU2xhc2hgIG9wdGlvblxuICogaW4gYG5leHQuY29uZmlnLmpzYC5cbiAqL1xuZXhwb3J0IGNvbnN0IG5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1RSQUlMSU5HX1NMQVNIXG4gID8gKHBhdGg6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgICBpZiAoL1xcLlteL10rXFwvPyQvLnRlc3QocGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGgpXG4gICAgICB9IGVsc2UgaWYgKHBhdGguZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICByZXR1cm4gcGF0aFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhdGggKyAnLydcbiAgICAgIH1cbiAgICB9XG4gIDogcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2hcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/normalize-trailing-slash.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/router.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/client/router.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"./node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nexports.__esModule = true;\nexports.useRouter = useRouter;\nexports.makePublicRouterInstance = makePublicRouterInstance;\nexports.createRouter = exports.withRouter = exports.default = void 0;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _router2 = _interopRequireWildcard(__webpack_require__(/*! ../next-server/lib/router/router */ \"./node_modules/next/dist/next-server/lib/router/router.js\"));\nexports.Router = _router2.default;\nexports.NextRouter = _router2.NextRouter;\nvar _routerContext = __webpack_require__(/*! ../next-server/lib/router-context */ \"../next-server/lib/router-context\");\nvar _withRouter = _interopRequireDefault(__webpack_require__(/*! ./with-router */ \"./node_modules/next/dist/client/with-router.js\"));\nexports.withRouter = _withRouter.default; /* global window */\nconst singletonRouter = {\n  router: null,\n  // holds the actual router instance\n  readyCallbacks: [],\n  ready(cb) {\n    if (this.router) return cb();\n    if (false) {}\n  }\n}; // Create public properties and methods of the router in the singletonRouter\nconst urlPropertyFields = ['pathname', 'route', 'query', 'asPath', 'components', 'isFallback', 'basePath', 'locale', 'locales', 'defaultLocale'];\nconst routerEvents = ['routeChangeStart', 'beforeHistoryChange', 'routeChangeComplete', 'routeChangeError', 'hashChangeStart', 'hashChangeComplete'];\nconst coreMethodFields = ['push', 'replace', 'reload', 'back', 'prefetch', 'beforePopState']; // Events is a static property on the router, the router doesn't have to be initialized to use it\nObject.defineProperty(singletonRouter, 'events', {\n  get() {\n    return _router2.default.events;\n  }\n});\nurlPropertyFields.forEach(field => {\n  // Here we need to use Object.defineProperty because, we need to return\n  // the property assigned to the actual router\n  // The value might get changed as we change routes and this is the\n  // proper way to access it\n  Object.defineProperty(singletonRouter, field, {\n    get() {\n      const router = getRouter();\n      return router[field];\n    }\n  });\n});\ncoreMethodFields.forEach(field => {\n  // We don't really know the types here, so we add them later instead\n  ;\n  singletonRouter[field] = (...args) => {\n    const router = getRouter();\n    return router[field](...args);\n  };\n});\nrouterEvents.forEach(event => {\n  singletonRouter.ready(() => {\n    _router2.default.events.on(event, (...args) => {\n      const eventField = `on${event.charAt(0).toUpperCase()}${event.substring(1)}`;\n      const _singletonRouter = singletonRouter;\n      if (_singletonRouter[eventField]) {\n        try {\n          _singletonRouter[eventField](...args);\n        } catch (err) {\n          console.error(`Error when running the Router event: ${eventField}`);\n          console.error(`${err.message}\\n${err.stack}`);\n        }\n      }\n    });\n  });\n});\nfunction getRouter() {\n  if (!singletonRouter.router) {\n    const message = 'No router instance found.\\n' + 'You should only use \"next/router\" inside the client side of your app.\\n';\n    throw new Error(message);\n  }\n  return singletonRouter.router;\n} // Export the singletonRouter and this is the public API.\nvar _default = singletonRouter; // Reexport the withRoute HOC\nexports.default = _default;\nfunction useRouter() {\n  return _react.default.useContext(_routerContext.RouterContext);\n} // INTERNAL APIS\n// -------------\n// (do not use following exports inside the app)\n// Create a router and assign it as the singleton instance.\n// This is used in client side when we are initilizing the app.\n// This should **not** use inside the server.\nconst createRouter = (...args) => {\n  singletonRouter.router = new _router2.default(...args);\n  singletonRouter.readyCallbacks.forEach(cb => cb());\n  singletonRouter.readyCallbacks = [];\n  return singletonRouter.router;\n}; // This function is used to create the `withRouter` router instance\nexports.createRouter = createRouter;\nfunction makePublicRouterInstance(router) {\n  const _router = router;\n  const instance = {};\n  for (const property of urlPropertyFields) {\n    if (typeof _router[property] === 'object') {\n      instance[property] = Object.assign(Array.isArray(_router[property]) ? [] : {}, _router[property]); // makes sure query is not stateful\n      continue;\n    }\n    instance[property] = _router[property];\n  } // Events is a static property on the router, the router doesn't have to be initialized to use it\n  instance.events = _router2.default.events;\n  coreMethodFields.forEach(field => {\n    instance[field] = (...args) => {\n      return _router[field](...args);\n    };\n  });\n  return instance;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vY2xpZW50L3JvdXRlci50cz8wNmZmIl0sIm5hbWVzIjpbInNpbmdsZXRvblJvdXRlciIsInJvdXRlciIsInJlYWR5Q2FsbGJhY2tzIiwicmVhZHkiLCJjYiIsInVybFByb3BlcnR5RmllbGRzIiwicm91dGVyRXZlbnRzIiwiY29yZU1ldGhvZEZpZWxkcyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiUm91dGVyIiwiZXZlbnRzIiwiZm9yRWFjaCIsImZpZWxkIiwiZ2V0Um91dGVyIiwiYXJncyIsImV2ZW50Iiwib24iLCJldmVudEZpZWxkIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJzdWJzdHJpbmciLCJfc2luZ2xldG9uUm91dGVyIiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwibWVzc2FnZSIsInN0YWNrIiwiRXJyb3IiLCJ1c2VSb3V0ZXIiLCJSZWFjdCIsInVzZUNvbnRleHQiLCJSb3V0ZXJDb250ZXh0IiwiY3JlYXRlUm91dGVyIiwibWFrZVB1YmxpY1JvdXRlckluc3RhbmNlIiwiX3JvdXRlciIsImluc3RhbmNlIiwicHJvcGVydHkiLCJhc3NpZ24iLCJBcnJheSIsImlzQXJyYXkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQ0E7QUFDQTs7O0FBQ0E7QUFzSEE7eUNBekhBO0FBbUJBLE1BQU1BLGVBQW9DLEdBQUc7RUFDM0NDLE1BQU0sRUFBRSxJQURtQztFQUM3QjtFQUNkQyxjQUFjLEVBQUUsRUFGMkI7RUFHM0NDLEtBQUssQ0FBQ0MsRUFBRCxFQUFpQjtJQUNwQixJQUFJLEtBQUtILE1BQVQsRUFBaUIsT0FBT0csRUFBRSxFQUFUO0lBQ2pCLFdBQW1DLEVBRWxDO0VBQ0Y7QUFSMEMsQ0FBN0MsQ0FXQTtBQUNBLE1BQU1DLGlCQUFpQixHQUFHLENBQ3hCLFVBRHdCLEVBRXhCLE9BRndCLEVBR3hCLE9BSHdCLEVBSXhCLFFBSndCLEVBS3hCLFlBTHdCLEVBTXhCLFlBTndCLEVBT3hCLFVBUHdCLEVB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b2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yb3V0ZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgUm91dGVyLCB7IE5leHRSb3V0ZXIgfSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3JvdXRlcidcbmltcG9ydCB7IFJvdXRlckNvbnRleHQgfSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyLWNvbnRleHQnXG5cbnR5cGUgQ2xhc3NBcmd1bWVudHM8VD4gPSBUIGV4dGVuZHMgbmV3ICguLi5hcmdzOiBpbmZlciBVKSA9PiBhbnkgPyBVIDogYW55XG5cbnR5cGUgUm91dGVyQXJncyA9IENsYXNzQXJndW1lbnRzPHR5cGVvZiBSb3V0ZXI+XG5cbnR5cGUgU2luZ2xldG9uUm91dGVyQmFzZSA9IHtcbiAgcm91dGVyOiBSb3V0ZXIgfCBudWxsXG4gIHJlYWR5Q2FsbGJhY2tzOiBBcnJheTwoKSA9PiBhbnk+XG4gIHJlYWR5KGNiOiAoKSA9PiBhbnkpOiB2b2lkXG59XG5cbmV4cG9ydCB7IFJvdXRlciwgTmV4dFJvdXRlciB9XG5cbmV4cG9ydCB0eXBlIFNpbmdsZXRvblJvdXRlciA9IFNpbmdsZXRvblJvdXRlckJhc2UgJiBOZXh0Um91dGVyXG5cbmNvbnN0IHNpbmdsZXRvblJvdXRlcjogU2luZ2xldG9uUm91dGVyQmFzZSA9IHtcbiAgcm91dGVyOiBudWxsLCAvLyBob2xkcyB0aGUgYWN0dWFsIHJvdXRlciBpbnN0YW5jZVxuICByZWFkeUNhbGxiYWNrczogW10sXG4gIHJlYWR5KGNiOiAoKSA9PiB2b2lkKSB7XG4gICAgaWYgKHRoaXMucm91dGVyKSByZXR1cm4gY2IoKVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5yZWFkeUNhbGxiYWNrcy5wdXNoKGNiKVxuICAgIH1cbiAgfSxcbn1cblxuLy8gQ3JlYXRlIHB1YmxpYyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIG9mIHRoZSByb3V0ZXIgaW4gdGhlIHNpbmdsZXRvblJvdXRlclxuY29uc3QgdXJsUHJvcGVydHlGaWVsZHMgPSBbXG4gICdwYXRobmFtZScsXG4gICdyb3V0ZScsXG4gICdxdWVyeScsXG4gICdhc1BhdGgnLFxuICAnY29tcG9uZW50cycsXG4gICdpc0ZhbGxiYWNrJyxcbiAgJ2Jhc2VQYXRoJyxcbiAgJ2xvY2FsZScsXG4gICdsb2NhbGVzJyxcbiAgJ2RlZmF1bHRMb2NhbGUnLFxuXVxuY29uc3Qgcm91dGVyRXZlbnRzID0gW1xuICAncm91dGVDaGFuZ2VTdGFydCcsXG4gICdiZWZvcmVIaXN0b3J5Q2hhbmdlJyxcbiAgJ3JvdXRlQ2hhbmdlQ29tcGxldGUnLFxuICAncm91dGVDaGFuZ2VFcnJvcicsXG4gICdoYXNoQ2hhbmdlU3RhcnQnLFxuICAnaGFzaENoYW5nZUNvbXBsZXRlJyxcbl1cbmNvbnN0IGNvcmVNZXRob2RGaWVsZHMgPSBbXG4gICdwdXNoJyxcbiAgJ3JlcGxhY2UnLFxuICAncmVsb2FkJyxcbiAgJ2JhY2snLFxuICAncHJlZmV0Y2gnLFxuICAnYmVmb3JlUG9wU3RhdGUnLFxuXVxuXG4vLyBFdmVudHMgaXMgYSBzdGF0aWMgcHJvcGVydHkgb24gdGhlIHJvdXRlciwgdGhlIHJvdXRlciBkb2Vzbid0IGhhdmUgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gdXNlIGl0XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc2luZ2xldG9uUm91dGVyLCAnZXZlbnRzJywge1xuICBnZXQoKSB7XG4gICAgcmV0dXJuIFJvdXRlci5ldmVudHNcbiAgfSxcbn0pXG5cbnVybFByb3BlcnR5RmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gIC8vIEhlcmUgd2UgbmVlZCB0byB1c2UgT2JqZWN0LmRlZmluZVByb3BlcnR5IGJlY2F1c2UsIHdlIG5lZWQgdG8gcmV0dXJuXG4gIC8vIHRoZSBwcm9wZXJ0eSBhc3NpZ25lZCB0byB0aGUgYWN0dWFsIHJvdXRlclxuICAvLyBUaGUgdmFsdWUgbWlnaHQgZ2V0IGNoYW5nZWQgYXMgd2UgY2hhbmdlIHJvdXRlcyBhbmQgdGhpcyBpcyB0aGVcbiAgLy8gcHJvcGVyIHdheSB0byBhY2Nlc3MgaXRcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNpbmdsZXRvblJvdXRlciwgZmllbGQsIHtcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCByb3V0ZXIgPSBnZXRSb3V0ZXIoKSBhcyBhbnlcbiAgICAgIHJldHVybiByb3V0ZXJbZmllbGRdIGFzIHN0cmluZ1xuICAgIH0sXG4gIH0pXG59KVxuXG5jb3JlTWV0aG9kRmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gIC8vIFdlIGRvbid0IHJlYWxseSBrbm93IHRoZSB0eXBlcyBoZXJlLCBzbyB3ZSBhZGQgdGhlbSBsYXRlciBpbnN0ZWFkXG4gIDsoc2luZ2xldG9uUm91dGVyIGFzIGFueSlbZmllbGRdID0gKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgY29uc3Qgcm91dGVyID0gZ2V0Um91dGVyKCkgYXMgYW55XG4gICAgcmV0dXJuIHJvdXRlcltmaWVsZF0oLi4uYXJncylcbiAgfVxufSlcblxucm91dGVyRXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gIHNpbmdsZXRvblJvdXRlci5yZWFkeSgoKSA9PiB7XG4gICAgUm91dGVyLmV2ZW50cy5vbihldmVudCwgKC4uLmFyZ3MpID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50RmllbGQgPSBgb24ke2V2ZW50LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpfSR7ZXZlbnQuc3Vic3RyaW5nKFxuICAgICAgICAxXG4gICAgICApfWBcbiAgICAgIGNvbnN0IF9zaW5nbGV0b25Sb3V0ZXIgPSBzaW5nbGV0b25Sb3V0ZXIgYXMgYW55XG4gICAgICBpZiAoX3NpbmdsZXRvblJvdXRlcltldmVudEZpZWxkXSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIF9zaW5nbGV0b25Sb3V0ZXJbZXZlbnRGaWVsZF0oLi4uYXJncylcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igd2hlbiBydW5uaW5nIHRoZSBSb3V0ZXIgZXZlbnQ6ICR7ZXZlbnRGaWVsZH1gKVxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYCR7ZXJyLm1lc3NhZ2V9XFxuJHtlcnIuc3RhY2t9YClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG59KVxuXG5mdW5jdGlvbiBnZXRSb3V0ZXIoKTogUm91dGVyIHtcbiAgaWYgKCFzaW5nbGV0b25Sb3V0ZXIucm91dGVyKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9XG4gICAgICAnTm8gcm91dGVyIGluc3RhbmNlIGZvdW5kLlxcbicgK1xuICAgICAgJ1lvdSBzaG91bGQgb25seSB1c2UgXCJuZXh0L3JvdXRlclwiIGluc2lkZSB0aGUgY2xpZW50IHNpZGUgb2YgeW91ciBhcHAuXFxuJ1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxuICB9XG4gIHJldHVybiBzaW5nbGV0b25Sb3V0ZXIucm91dGVyXG59XG5cbi8vIEV4cG9ydCB0aGUgc2luZ2xldG9uUm91dGVyIGFuZCB0aGlzIGlzIHRoZSBwdWJsaWMgQVBJLlxuZXhwb3J0IGRlZmF1bHQgc2luZ2xldG9uUm91dGVyIGFzIFNpbmdsZXRvblJvdXRlclxuXG4vLyBSZWV4cG9ydCB0aGUgd2l0aFJvdXRlIEhPQ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB3aXRoUm91dGVyIH0gZnJvbSAnLi93aXRoLXJvdXRlcidcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJvdXRlcigpOiBOZXh0Um91dGVyIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoUm91dGVyQ29udGV4dClcbn1cblxuLy8gSU5URVJOQUwgQVBJU1xuLy8gLS0tLS0tLS0tLS0tLVxuLy8gKGRvIG5vdCB1c2UgZm9sbG93aW5nIGV4cG9ydHMgaW5zaWRlIHRoZSBhcHApXG5cbi8vIENyZWF0ZSBhIHJvdXRlciBhbmQgYXNzaWduIGl0IGFzIHRoZSBzaW5nbGV0b24gaW5zdGFuY2UuXG4vLyBUaGlzIGlzIHVzZWQgaW4gY2xpZW50IHNpZGUgd2hlbiB3ZSBhcmUgaW5pdGlsaXppbmcgdGhlIGFwcC5cbi8vIFRoaXMgc2hvdWxkICoqbm90KiogdXNlIGluc2lkZSB0aGUgc2VydmVyLlxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJvdXRlciA9ICguLi5hcmdzOiBSb3V0ZXJBcmdzKTogUm91dGVyID0+IHtcbiAgc2luZ2xldG9uUm91dGVyLnJvdXRlciA9IG5ldyBSb3V0ZXIoLi4uYXJncylcbiAgc2luZ2xldG9uUm91dGVyLnJlYWR5Q2FsbGJhY2tzLmZvckVhY2goKGNiKSA9PiBjYigpKVxuICBzaW5nbGV0b25Sb3V0ZXIucmVhZHlDYWxsYmFja3MgPSBbXVxuXG4gIHJldHVybiBzaW5nbGV0b25Sb3V0ZXIucm91dGVyXG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBjcmVhdGUgdGhlIGB3aXRoUm91dGVyYCByb3V0ZXIgaW5zdGFuY2VcbmV4cG9ydCBmdW5jdGlvbiBtYWtlUHVibGljUm91dGVySW5zdGFuY2Uocm91dGVyOiBSb3V0ZXIpOiBOZXh0Um91dGVyIHtcbiAgY29uc3QgX3JvdXRlciA9IHJvdXRlciBhcyBhbnlcbiAgY29uc3QgaW5zdGFuY2UgPSB7fSBhcyBhbnlcblxuICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHVybFByb3BlcnR5RmllbGRzKSB7XG4gICAgaWYgKHR5cGVvZiBfcm91dGVyW3Byb3BlcnR5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGluc3RhbmNlW3Byb3BlcnR5XSA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgIEFycmF5LmlzQXJyYXkoX3JvdXRlcltwcm9wZXJ0eV0pID8gW10gOiB7fSxcbiAgICAgICAgX3JvdXRlcltwcm9wZXJ0eV1cbiAgICAgICkgLy8gbWFrZXMgc3VyZSBxdWVyeSBpcyBub3Qgc3RhdGVmdWxcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaW5zdGFuY2VbcHJvcGVydHldID0gX3JvdXRlcltwcm9wZXJ0eV1cbiAgfVxuXG4gIC8vIEV2ZW50cyBpcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiB0aGUgcm91dGVyLCB0aGUgcm91dGVyIGRvZXNuJ3QgaGF2ZSB0byBiZSBpbml0aWFsaXplZCB0byB1c2UgaXRcbiAgaW5zdGFuY2UuZXZlbnRzID0gUm91dGVyLmV2ZW50c1xuXG4gIGNvcmVNZXRob2RGaWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICBpbnN0YW5jZVtmaWVsZF0gPSAoLi4uYXJnczogYW55W10pID0+IHtcbiAgICAgIHJldHVybiBfcm91dGVyW2ZpZWxkXSguLi5hcmdzKVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gaW5zdGFuY2Vcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/router.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/with-router.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/with-router.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\nexports.__esModule = true;\nexports.default = withRouter;\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"react\"));\nvar _router = __webpack_require__(/*! ./router */ \"./node_modules/next/dist/client/router.js\");\nfunction withRouter(ComposedComponent) {\n  function WithRouterWrapper(props) {\n    return /*#__PURE__*/_react.default.createElement(ComposedComponent, Object.assign({\n      router: (0, _router.useRouter)()\n    }, props));\n  }\n  WithRouterWrapper.getInitialProps = ComposedComponent.getInitialProps // This is needed to allow checking for custom getInitialProps in _app\n  ;\n  WithRouterWrapper.origGetInitialProps = ComposedComponent.origGetInitialProps;\n  if (true) {\n    const name = ComposedComponent.displayName || ComposedComponent.name || 'Unknown';\n    WithRouterWrapper.displayName = `withRouter(${name})`;\n  }\n  return WithRouterWrapper;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vY2xpZW50L3dpdGgtcm91dGVyLnRzeD80ZmNiIl0sIm5hbWVzIjpbIndpdGhSb3V0ZXIiLCJDb21wb3NlZENvbXBvbmVudCIsIldpdGhSb3V0ZXJXcmFwcGVyIiwicHJvcHMiLCJnZXRJbml0aWFsUHJvcHMiLCJvcmlnR2V0SW5pdGlhbFByb3BzIiwibmFtZSIsImRpc3BsYXlOYW1lIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBRUE7QUFXZSxTQUFTQSxVQUFULENBSWJDLGlCQUphLEVBSytCO0VBQzVDLFNBQVNDLGlCQUFULENBQTJCQyxLQUEzQixFQUF1QztJQUNyQyxvQkFBTyw2QkFBQyxpQkFBRDtNQUFtQixNQUFNLEVBQUU7SUFBM0IsR0FBNENBLEtBQTVDLEVBQVA7RUFDRDtFQUVELGlCQUFpQixDQUFDQyxlQUFsQixHQUFvQ0gsaUJBQWlCLENBQUNHLGVBQ3REO0VBQUE7RUFDRUYsaUJBQUQsQ0FBMkJHLG1CQUEzQixHQUFrREosaUJBQUQsQ0FBMkJJLG1CQUE1RTtFQUNELFVBQTJDO0lBQ3pDLE1BQU1DLElBQUksR0FDUkwsaUJBQWlCLENBQUNNLFdBQWxCTixJQUFpQ0EsaUJBQWlCLENBQUNLLElBQW5ETCxJQUEyRCxTQUQ3RDtJQUVBQyxpQkFBaUIsQ0FBQ0ssV0FBbEJMLEdBQWlDLGNBQWFJLElBQUssR0FBbkRKO0VBQ0Q7RUFFRCxPQUFPQSxpQkFBUDtBQUNEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvd2l0aC1yb3V0ZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBOZXh0Q29tcG9uZW50VHlwZSwgTmV4dFBhZ2VDb250ZXh0IH0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3V0aWxzJ1xuaW1wb3J0IHsgTmV4dFJvdXRlciwgdXNlUm91dGVyIH0gZnJvbSAnLi9yb3V0ZXInXG5cbmV4cG9ydCB0eXBlIFdpdGhSb3V0ZXJQcm9wcyA9IHtcbiAgcm91dGVyOiBOZXh0Um91dGVyXG59XG5cbmV4cG9ydCB0eXBlIEV4Y2x1ZGVSb3V0ZXJQcm9wczxQPiA9IFBpY2s8XG4gIFAsXG4gIEV4Y2x1ZGU8a2V5b2YgUCwga2V5b2YgV2l0aFJvdXRlclByb3BzPlxuPlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB3aXRoUm91dGVyPFxuICBQIGV4dGVuZHMgV2l0aFJvdXRlclByb3BzLFxuICBDID0gTmV4dFBhZ2VDb250ZXh0XG4+KFxuICBDb21wb3NlZENvbXBvbmVudDogTmV4dENvbXBvbmVudFR5cGU8QywgYW55LCBQPlxuKTogUmVhY3QuQ29tcG9uZW50VHlwZTxFeGNsdWRlUm91dGVyUHJvcHM8UD4+IHtcbiAgZnVuY3Rpb24gV2l0aFJvdXRlcldyYXBwZXIocHJvcHM6IGFueSkge1xuICAgIHJldHVybiA8Q29tcG9zZWRDb21wb25lbnQgcm91dGVyPXt1c2VSb3V0ZXIoKX0gey4uLnByb3BzfSAvPlxuICB9XG5cbiAgV2l0aFJvdXRlcldyYXBwZXIuZ2V0SW5pdGlhbFByb3BzID0gQ29tcG9zZWRDb21wb25lbnQuZ2V0SW5pdGlhbFByb3BzXG4gIC8vIFRoaXMgaXMgbmVlZGVkIHRvIGFsbG93IGNoZWNraW5nIGZvciBjdXN0b20gZ2V0SW5pdGlhbFByb3BzIGluIF9hcHBcbiAgOyhXaXRoUm91dGVyV3JhcHBlciBhcyBhbnkpLm9yaWdHZXRJbml0aWFsUHJvcHMgPSAoQ29tcG9zZWRDb21wb25lbnQgYXMgYW55KS5vcmlnR2V0SW5pdGlhbFByb3BzXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3QgbmFtZSA9XG4gICAgICBDb21wb3NlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb3NlZENvbXBvbmVudC5uYW1lIHx8ICdVbmtub3duJ1xuICAgIFdpdGhSb3V0ZXJXcmFwcGVyLmRpc3BsYXlOYW1lID0gYHdpdGhSb3V0ZXIoJHtuYW1lfSlgXG4gIH1cblxuICByZXR1cm4gV2l0aFJvdXRlcldyYXBwZXJcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/with-router.js\n");

/***/ }),

/***/ "./node_modules/next/dist/compiled/path-to-regexp/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/compiled/path-to-regexp/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n    var tokens = [];\n    var i = 0;\n    while (i < str.length) {\n        var char = str[i];\n        if (char === \"*\" || char === \"+\" || char === \"?\") {\n            tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"\\\\\") {\n            tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n            continue;\n        }\n        if (char === \"{\") {\n            tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"}\") {\n            tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \":\") {\n            var name = \"\";\n            var j = i + 1;\n            while (j < str.length) {\n                var code = str.charCodeAt(j);\n                if (\n                // `0-9`\n                (code >= 48 && code <= 57) ||\n                    // `A-Z`\n                    (code >= 65 && code <= 90) ||\n                    // `a-z`\n                    (code >= 97 && code <= 122) ||\n                    // `_`\n                    code === 95) {\n                    name += str[j++];\n                    continue;\n                }\n                break;\n            }\n            if (!name)\n                throw new TypeError(\"Missing parameter name at \" + i);\n            tokens.push({ type: \"NAME\", index: i, value: name });\n            i = j;\n            continue;\n        }\n        if (char === \"(\") {\n            var count = 1;\n            var pattern = \"\";\n            var j = i + 1;\n            if (str[j] === \"?\") {\n                throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \" + j);\n            }\n            while (j < str.length) {\n                if (str[j] === \"\\\\\") {\n                    pattern += str[j++] + str[j++];\n                    continue;\n                }\n                if (str[j] === \")\") {\n                    count--;\n                    if (count === 0) {\n                        j++;\n                        break;\n                    }\n                }\n                else if (str[j] === \"(\") {\n                    count++;\n                    if (str[j + 1] !== \"?\") {\n                        throw new TypeError(\"Capturing groups are not allowed at \" + j);\n                    }\n                }\n                pattern += str[j++];\n            }\n            if (count)\n                throw new TypeError(\"Unbalanced pattern at \" + i);\n            if (!pattern)\n                throw new TypeError(\"Missing pattern at \" + i);\n            tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n            i = j;\n            continue;\n        }\n        tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n    }\n    tokens.push({ type: \"END\", index: i, value: \"\" });\n    return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\nfunction parse(str, options) {\n    if (options === void 0) { options = {}; }\n    var tokens = lexer(str);\n    var _a = options.prefixes, prefixes = _a === void 0 ? \"./\" : _a;\n    var defaultPattern = \"[^\" + escapeString(options.delimiter || \"/#?\") + \"]+?\";\n    var result = [];\n    var key = 0;\n    var i = 0;\n    var path = \"\";\n    var tryConsume = function (type) {\n        if (i < tokens.length && tokens[i].type === type)\n            return tokens[i++].value;\n    };\n    var mustConsume = function (type) {\n        var value = tryConsume(type);\n        if (value !== undefined)\n            return value;\n        var _a = tokens[i], nextType = _a.type, index = _a.index;\n        throw new TypeError(\"Unexpected \" + nextType + \" at \" + index + \", expected \" + type);\n    };\n    var consumeText = function () {\n        var result = \"\";\n        var value;\n        // tslint:disable-next-line\n        while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n            result += value;\n        }\n        return result;\n    };\n    while (i < tokens.length) {\n        var char = tryConsume(\"CHAR\");\n        var name = tryConsume(\"NAME\");\n        var pattern = tryConsume(\"PATTERN\");\n        if (name || pattern) {\n            var prefix = char || \"\";\n            if (prefixes.indexOf(prefix) === -1) {\n                path += prefix;\n                prefix = \"\";\n            }\n            if (path) {\n                result.push(path);\n                path = \"\";\n            }\n            result.push({\n                name: name || key++,\n                prefix: prefix,\n                suffix: \"\",\n                pattern: pattern || defaultPattern,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        var value = char || tryConsume(\"ESCAPED_CHAR\");\n        if (value) {\n            path += value;\n            continue;\n        }\n        if (path) {\n            result.push(path);\n            path = \"\";\n        }\n        var open = tryConsume(\"OPEN\");\n        if (open) {\n            var prefix = consumeText();\n            var name_1 = tryConsume(\"NAME\") || \"\";\n            var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n            var suffix = consumeText();\n            mustConsume(\"CLOSE\");\n            result.push({\n                name: name_1 || (pattern_1 ? key++ : \"\"),\n                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n                prefix: prefix,\n                suffix: suffix,\n                modifier: tryConsume(\"MODIFIER\") || \"\"\n            });\n            continue;\n        }\n        mustConsume(\"END\");\n    }\n    return result;\n}\nexports.parse = parse;\n/**\n * Compile a string to a template function for the path.\n */\nfunction compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\nexports.compile = compile;\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction(tokens, options) {\n    if (options === void 0) { options = {}; }\n    var reFlags = flags(options);\n    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;\n    // Compile all the tokens into regexps.\n    var matches = tokens.map(function (token) {\n        if (typeof token === \"object\") {\n            return new RegExp(\"^(?:\" + token.pattern + \")$\", reFlags);\n        }\n    });\n    return function (data) {\n        var path = \"\";\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (typeof token === \"string\") {\n                path += token;\n                continue;\n            }\n            var value = data ? data[token.name] : undefined;\n            var optional = token.modifier === \"?\" || token.modifier === \"*\";\n            var repeat = token.modifier === \"*\" || token.modifier === \"+\";\n            if (Array.isArray(value)) {\n                if (!repeat) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not repeat, but got an array\");\n                }\n                if (value.length === 0) {\n                    if (optional)\n                        continue;\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to not be empty\");\n                }\n                for (var j = 0; j < value.length; j++) {\n                    var segment = encode(value[j], token);\n                    if (validate && !matches[i].test(segment)) {\n                        throw new TypeError(\"Expected all \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                    }\n                    path += token.prefix + segment + token.suffix;\n                }\n                continue;\n            }\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                var segment = encode(String(value), token);\n                if (validate && !matches[i].test(segment)) {\n                    throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to match \\\"\" + token.pattern + \"\\\", but got \\\"\" + segment + \"\\\"\");\n                }\n                path += token.prefix + segment + token.suffix;\n                continue;\n            }\n            if (optional)\n                continue;\n            var typeOfMessage = repeat ? \"an array\" : \"a string\";\n            throw new TypeError(\"Expected \\\"\" + token.name + \"\\\" to be \" + typeOfMessage);\n        }\n        return path;\n    };\n}\nexports.tokensToFunction = tokensToFunction;\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nfunction match(str, options) {\n    var keys = [];\n    var re = pathToRegexp(str, keys, options);\n    return regexpToFunction(re, keys, options);\n}\nexports.match = match;\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nfunction regexpToFunction(re, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;\n    return function (pathname) {\n        var m = re.exec(pathname);\n        if (!m)\n            return false;\n        var path = m[0], index = m.index;\n        var params = Object.create(null);\n        var _loop_1 = function (i) {\n            // tslint:disable-next-line\n            if (m[i] === undefined)\n                return \"continue\";\n            var key = keys[i - 1];\n            if (key.modifier === \"*\" || key.modifier === \"+\") {\n                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n                    return decode(value, key);\n                });\n            }\n            else {\n                params[key.name] = decode(m[i], key);\n            }\n        };\n        for (var i = 1; i < m.length; i++) {\n            _loop_1(i);\n        }\n        return { path: path, index: index, params: params };\n    };\n}\nexports.regexpToFunction = regexpToFunction;\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n    return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n    if (!keys)\n        return path;\n    // Use a negative lookahead to match only capturing groups.\n    var groups = path.source.match(/\\((?!\\?)/g);\n    if (groups) {\n        for (var i = 0; i < groups.length; i++) {\n            keys.push({\n                name: i,\n                prefix: \"\",\n                suffix: \"\",\n                modifier: \"\",\n                pattern: \"\"\n            });\n        }\n    }\n    return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });\n    return new RegExp(\"(?:\" + parts.join(\"|\") + \")\", flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nfunction tokensToRegexp(tokens, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;\n    var endsWith = \"[\" + escapeString(options.endsWith || \"\") + \"]|$\";\n    var delimiter = \"[\" + escapeString(options.delimiter || \"/#?\") + \"]\";\n    var route = start ? \"^\" : \"\";\n    // Iterate over the tokens and create our regexp string.\n    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n        var token = tokens_1[_i];\n        if (typeof token === \"string\") {\n            route += escapeString(encode(token));\n        }\n        else {\n            var prefix = escapeString(encode(token.prefix));\n            var suffix = escapeString(encode(token.suffix));\n            if (token.pattern) {\n                if (keys)\n                    keys.push(token);\n                if (prefix || suffix) {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        var mod = token.modifier === \"*\" ? \"?\" : \"\";\n                        route += \"(?:\" + prefix + \"((?:\" + token.pattern + \")(?:\" + suffix + prefix + \"(?:\" + token.pattern + \"))*)\" + suffix + \")\" + mod;\n                    }\n                    else {\n                        route += \"(?:\" + prefix + \"(\" + token.pattern + \")\" + suffix + \")\" + token.modifier;\n                    }\n                }\n                else {\n                    route += \"(\" + token.pattern + \")\" + token.modifier;\n                }\n            }\n            else {\n                route += \"(?:\" + prefix + suffix + \")\" + token.modifier;\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += delimiter + \"?\";\n        route += !options.endsWith ? \"$\" : \"(?=\" + endsWith + \")\";\n    }\n    else {\n        var endToken = tokens[tokens.length - 1];\n        var isEndDelimited = typeof endToken === \"string\"\n            ? delimiter.indexOf(endToken[endToken.length - 1]) > -1\n            : // tslint:disable-next-line\n                endToken === undefined;\n        if (!strict) {\n            route += \"(?:\" + delimiter + \"(?=\" + endsWith + \"))?\";\n        }\n        if (!isEndDelimited) {\n            route += \"(?=\" + delimiter + \"|\" + endsWith + \")\";\n        }\n    }\n    return new RegExp(route, flags(options));\n}\nexports.tokensToRegexp = tokensToRegexp;\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nfunction pathToRegexp(path, keys, options) {\n    if (path instanceof RegExp)\n        return regexpToRegexp(path, keys);\n    if (Array.isArray(path))\n        return arrayToRegexp(path, keys, options);\n    return stringToRegexp(path, keys, options);\n}\nexports.pathToRegexp = pathToRegexp;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3BhdGgtdG8tcmVnZXhwL2luZGV4LmpzP2NjZWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsOENBQThDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvREFBb0Q7QUFDN0U7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix5QkFBeUIsMENBQTBDO0FBQ25FO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIseUJBQXlCLDJDQUEyQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNDQUFzQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0Q0FBNEM7QUFDckU7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBDQUEwQztBQUMvRDtBQUNBLGlCQUFpQixtQ0FBbUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQSxvRUFBb0UsVUFBVSxFQUFFO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDLG9FQUFvRSxVQUFVLEVBQUU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaURBQWlELEVBQUU7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0Msd09BQXdPLFVBQVUsRUFBRTtBQUNwUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxzQkFBc0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2REFBNkQ7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3BhdGgtdG8tcmVnZXhwL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFRva2VuaXplIGlucHV0IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gbGV4ZXIoc3RyKSB7XG4gICAgdmFyIHRva2VucyA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoYXIgPSBzdHJbaV07XG4gICAgICAgIGlmIChjaGFyID09PSBcIipcIiB8fCBjaGFyID09PSBcIitcIiB8fCBjaGFyID09PSBcIj9cIikge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goeyB0eXBlOiBcIk1PRElGSUVSXCIsIGluZGV4OiBpLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJFU0NBUEVEX0NIQVJcIiwgaW5kZXg6IGkrKywgdmFsdWU6IHN0cltpKytdIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IFwie1wiKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiT1BFTlwiLCBpbmRleDogaSwgdmFsdWU6IHN0cltpKytdIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IFwifVwiKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiQ0xPU0VcIiwgaW5kZXg6IGksIHZhbHVlOiBzdHJbaSsrXSB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSBcIjpcIikge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgdmFyIGogPSBpICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChqIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaik7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIC8vIGAwLTlgXG4gICAgICAgICAgICAgICAgKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gYEEtWmBcbiAgICAgICAgICAgICAgICAgICAgKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA5MCkgfHxcbiAgICAgICAgICAgICAgICAgICAgLy8gYGEtemBcbiAgICAgICAgICAgICAgICAgICAgKGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMjIpIHx8XG4gICAgICAgICAgICAgICAgICAgIC8vIGBfYFxuICAgICAgICAgICAgICAgICAgICBjb2RlID09PSA5NSkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lICs9IHN0cltqKytdO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5hbWUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk1pc3NpbmcgcGFyYW1ldGVyIG5hbWUgYXQgXCIgKyBpKTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJOQU1FXCIsIGluZGV4OiBpLCB2YWx1ZTogbmFtZSB9KTtcbiAgICAgICAgICAgIGkgPSBqO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09IFwiKFwiKSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSAxO1xuICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBcIlwiO1xuICAgICAgICAgICAgdmFyIGogPSBpICsgMTtcbiAgICAgICAgICAgIGlmIChzdHJbal0gPT09IFwiP1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhdHRlcm4gY2Fubm90IHN0YXJ0IHdpdGggXFxcIj9cXFwiIGF0IFwiICsgaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaiA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyW2pdID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IHN0cltqKytdICsgc3RyW2orK107XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RyW2pdID09PSBcIilcIikge1xuICAgICAgICAgICAgICAgICAgICBjb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0cltqXSA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cltqICsgMV0gIT09IFwiP1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2FwdHVyaW5nIGdyb3VwcyBhcmUgbm90IGFsbG93ZWQgYXQgXCIgKyBqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IHN0cltqKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvdW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmJhbGFuY2VkIHBhdHRlcm4gYXQgXCIgKyBpKTtcbiAgICAgICAgICAgIGlmICghcGF0dGVybilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWlzc2luZyBwYXR0ZXJuIGF0IFwiICsgaSk7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7IHR5cGU6IFwiUEFUVEVSTlwiLCBpbmRleDogaSwgdmFsdWU6IHBhdHRlcm4gfSk7XG4gICAgICAgICAgICBpID0gajtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJDSEFSXCIsIGluZGV4OiBpLCB2YWx1ZTogc3RyW2krK10gfSk7XG4gICAgfVxuICAgIHRva2Vucy5wdXNoKHsgdHlwZTogXCJFTkRcIiwgaW5kZXg6IGksIHZhbHVlOiBcIlwiIH0pO1xuICAgIHJldHVybiB0b2tlbnM7XG59XG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIGZvciB0aGUgcmF3IHRva2Vucy5cbiAqL1xuZnVuY3Rpb24gcGFyc2Uoc3RyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgdG9rZW5zID0gbGV4ZXIoc3RyKTtcbiAgICB2YXIgX2EgPSBvcHRpb25zLnByZWZpeGVzLCBwcmVmaXhlcyA9IF9hID09PSB2b2lkIDAgPyBcIi4vXCIgOiBfYTtcbiAgICB2YXIgZGVmYXVsdFBhdHRlcm4gPSBcIlteXCIgKyBlc2NhcGVTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIgfHwgXCIvIz9cIikgKyBcIl0rP1wiO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIga2V5ID0gMDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHBhdGggPSBcIlwiO1xuICAgIHZhciB0cnlDb25zdW1lID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgaWYgKGkgPCB0b2tlbnMubGVuZ3RoICYmIHRva2Vuc1tpXS50eXBlID09PSB0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRva2Vuc1tpKytdLnZhbHVlO1xuICAgIH07XG4gICAgdmFyIG11c3RDb25zdW1lID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdHJ5Q29uc3VtZSh0eXBlKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhciBfYSA9IHRva2Vuc1tpXSwgbmV4dFR5cGUgPSBfYS50eXBlLCBpbmRleCA9IF9hLmluZGV4O1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBcIiArIG5leHRUeXBlICsgXCIgYXQgXCIgKyBpbmRleCArIFwiLCBleHBlY3RlZCBcIiArIHR5cGUpO1xuICAgIH07XG4gICAgdmFyIGNvbnN1bWVUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgd2hpbGUgKCh2YWx1ZSA9IHRyeUNvbnN1bWUoXCJDSEFSXCIpIHx8IHRyeUNvbnN1bWUoXCJFU0NBUEVEX0NIQVJcIikpKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHdoaWxlIChpIDwgdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICB2YXIgY2hhciA9IHRyeUNvbnN1bWUoXCJDSEFSXCIpO1xuICAgICAgICB2YXIgbmFtZSA9IHRyeUNvbnN1bWUoXCJOQU1FXCIpO1xuICAgICAgICB2YXIgcGF0dGVybiA9IHRyeUNvbnN1bWUoXCJQQVRURVJOXCIpO1xuICAgICAgICBpZiAobmFtZSB8fCBwYXR0ZXJuKSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gY2hhciB8fCBcIlwiO1xuICAgICAgICAgICAgaWYgKHByZWZpeGVzLmluZGV4T2YocHJlZml4KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBwYXRoICs9IHByZWZpeDtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChwYXRoKTtcbiAgICAgICAgICAgICAgICBwYXRoID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lIHx8IGtleSsrLFxuICAgICAgICAgICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICAgICAgICAgIHN1ZmZpeDogXCJcIixcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBwYXR0ZXJuIHx8IGRlZmF1bHRQYXR0ZXJuLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVyOiB0cnlDb25zdW1lKFwiTU9ESUZJRVJcIikgfHwgXCJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSBjaGFyIHx8IHRyeUNvbnN1bWUoXCJFU0NBUEVEX0NIQVJcIik7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcGF0aCArPSB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXRoKTtcbiAgICAgICAgICAgIHBhdGggPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcGVuID0gdHJ5Q29uc3VtZShcIk9QRU5cIik7XG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gY29uc3VtZVRleHQoKTtcbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSB0cnlDb25zdW1lKFwiTkFNRVwiKSB8fCBcIlwiO1xuICAgICAgICAgICAgdmFyIHBhdHRlcm5fMSA9IHRyeUNvbnN1bWUoXCJQQVRURVJOXCIpIHx8IFwiXCI7XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gY29uc3VtZVRleHQoKTtcbiAgICAgICAgICAgIG11c3RDb25zdW1lKFwiQ0xPU0VcIik7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZV8xIHx8IChwYXR0ZXJuXzEgPyBrZXkrKyA6IFwiXCIpLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IG5hbWVfMSAmJiAhcGF0dGVybl8xID8gZGVmYXVsdFBhdHRlcm4gOiBwYXR0ZXJuXzEsXG4gICAgICAgICAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgICAgICAgICAgc3VmZml4OiBzdWZmaXgsXG4gICAgICAgICAgICAgICAgbW9kaWZpZXI6IHRyeUNvbnN1bWUoXCJNT0RJRklFUlwiKSB8fCBcIlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG11c3RDb25zdW1lKFwiRU5EXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuLyoqXG4gKiBDb21waWxlIGEgc3RyaW5nIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIHRoZSBwYXRoLlxuICovXG5mdW5jdGlvbiBjb21waWxlKHN0ciwgb3B0aW9ucykge1xuICAgIHJldHVybiB0b2tlbnNUb0Z1bmN0aW9uKHBhcnNlKHN0ciwgb3B0aW9ucyksIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5jb21waWxlID0gY29tcGlsZTtcbi8qKlxuICogRXhwb3NlIGEgbWV0aG9kIGZvciB0cmFuc2Zvcm1pbmcgdG9rZW5zIGludG8gdGhlIHBhdGggZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvRnVuY3Rpb24odG9rZW5zLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgcmVGbGFncyA9IGZsYWdzKG9wdGlvbnMpO1xuICAgIHZhciBfYSA9IG9wdGlvbnMuZW5jb2RlLCBlbmNvZGUgPSBfYSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0gOiBfYSwgX2IgPSBvcHRpb25zLnZhbGlkYXRlLCB2YWxpZGF0ZSA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2I7XG4gICAgLy8gQ29tcGlsZSBhbGwgdGhlIHRva2VucyBpbnRvIHJlZ2V4cHMuXG4gICAgdmFyIG1hdGNoZXMgPSB0b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIiArIHRva2VuLnBhdHRlcm4gKyBcIikkXCIsIHJlRmxhZ3MpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBwYXRoID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBwYXRoICs9IHRva2VuO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gZGF0YSA/IGRhdGFbdG9rZW4ubmFtZV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgb3B0aW9uYWwgPSB0b2tlbi5tb2RpZmllciA9PT0gXCI/XCIgfHwgdG9rZW4ubW9kaWZpZXIgPT09IFwiKlwiO1xuICAgICAgICAgICAgdmFyIHJlcGVhdCA9IHRva2VuLm1vZGlmaWVyID09PSBcIipcIiB8fCB0b2tlbi5tb2RpZmllciA9PT0gXCIrXCI7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcGVhdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgXFxcIlwiICsgdG9rZW4ubmFtZSArIFwiXFxcIiB0byBub3QgcmVwZWF0LCBidXQgZ290IGFuIGFycmF5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25hbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgXFxcIlwiICsgdG9rZW4ubmFtZSArIFwiXFxcIiB0byBub3QgYmUgZW1wdHlcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBlbmNvZGUodmFsdWVbal0sIHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlICYmICFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhbGwgXFxcIlwiICsgdG9rZW4ubmFtZSArIFwiXFxcIiB0byBtYXRjaCBcXFwiXCIgKyB0b2tlbi5wYXR0ZXJuICsgXCJcXFwiLCBidXQgZ290IFxcXCJcIiArIHNlZ21lbnQgKyBcIlxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50ICsgdG9rZW4uc3VmZml4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlZ21lbnQgPSBlbmNvZGUoU3RyaW5nKHZhbHVlKSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZSAmJiAhbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBcXFwiXCIgKyB0b2tlbi5uYW1lICsgXCJcXFwiIHRvIG1hdGNoIFxcXCJcIiArIHRva2VuLnBhdHRlcm4gKyBcIlxcXCIsIGJ1dCBnb3QgXFxcIlwiICsgc2VnbWVudCArIFwiXFxcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50ICsgdG9rZW4uc3VmZml4O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbmFsKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIHR5cGVPZk1lc3NhZ2UgPSByZXBlYXQgPyBcImFuIGFycmF5XCIgOiBcImEgc3RyaW5nXCI7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgXFxcIlwiICsgdG9rZW4ubmFtZSArIFwiXFxcIiB0byBiZSBcIiArIHR5cGVPZk1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH07XG59XG5leHBvcnRzLnRva2Vuc1RvRnVuY3Rpb24gPSB0b2tlbnNUb0Z1bmN0aW9uO1xuLyoqXG4gKiBDcmVhdGUgcGF0aCBtYXRjaCBmdW5jdGlvbiBmcm9tIGBwYXRoLXRvLXJlZ2V4cGAgc3BlYy5cbiAqL1xuZnVuY3Rpb24gbWF0Y2goc3RyLCBvcHRpb25zKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICB2YXIgcmUgPSBwYXRoVG9SZWdleHAoc3RyLCBrZXlzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gcmVnZXhwVG9GdW5jdGlvbihyZSwga2V5cywgb3B0aW9ucyk7XG59XG5leHBvcnRzLm1hdGNoID0gbWF0Y2g7XG4vKipcbiAqIENyZWF0ZSBhIHBhdGggbWF0Y2ggZnVuY3Rpb24gZnJvbSBgcGF0aC10by1yZWdleHBgIG91dHB1dC5cbiAqL1xuZnVuY3Rpb24gcmVnZXhwVG9GdW5jdGlvbihyZSwga2V5cywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIF9hID0gb3B0aW9ucy5kZWNvZGUsIGRlY29kZSA9IF9hID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSA6IF9hO1xuICAgIHJldHVybiBmdW5jdGlvbiAocGF0aG5hbWUpIHtcbiAgICAgICAgdmFyIG0gPSByZS5leGVjKHBhdGhuYW1lKTtcbiAgICAgICAgaWYgKCFtKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgcGF0aCA9IG1bMF0sIGluZGV4ID0gbS5pbmRleDtcbiAgICAgICAgdmFyIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgaWYgKG1baV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaSAtIDFdO1xuICAgICAgICAgICAgaWYgKGtleS5tb2RpZmllciA9PT0gXCIqXCIgfHwga2V5Lm1vZGlmaWVyID09PSBcIitcIikge1xuICAgICAgICAgICAgICAgIHBhcmFtc1trZXkubmFtZV0gPSBtW2ldLnNwbGl0KGtleS5wcmVmaXggKyBrZXkuc3VmZml4KS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGUodmFsdWUsIGtleSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNba2V5Lm5hbWVdID0gZGVjb2RlKG1baV0sIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgX2xvb3BfMShpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBwYXRoOiBwYXRoLCBpbmRleDogaW5kZXgsIHBhcmFtczogcGFyYW1zIH07XG4gICAgfTtcbn1cbmV4cG9ydHMucmVnZXhwVG9GdW5jdGlvbiA9IHJlZ2V4cFRvRnVuY3Rpb247XG4vKipcbiAqIEVzY2FwZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLisqPz1eIToke30oKVtcXF18L1xcXFxdKS9nLCBcIlxcXFwkMVwiKTtcbn1cbi8qKlxuICogR2V0IHRoZSBmbGFncyBmb3IgYSByZWdleHAgZnJvbSB0aGUgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gZmxhZ3Mob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMuc2Vuc2l0aXZlID8gXCJcIiA6IFwiaVwiO1xufVxuLyoqXG4gKiBQdWxsIG91dCBrZXlzIGZyb20gYSByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwKHBhdGgsIGtleXMpIHtcbiAgICBpZiAoIWtleXMpXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIC8vIFVzZSBhIG5lZ2F0aXZlIGxvb2thaGVhZCB0byBtYXRjaCBvbmx5IGNhcHR1cmluZyBncm91cHMuXG4gICAgdmFyIGdyb3VwcyA9IHBhdGguc291cmNlLm1hdGNoKC9cXCgoPyFcXD8pL2cpO1xuICAgIGlmIChncm91cHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGtleXMucHVzaCh7XG4gICAgICAgICAgICAgICAgbmFtZTogaSxcbiAgICAgICAgICAgICAgICBwcmVmaXg6IFwiXCIsXG4gICAgICAgICAgICAgICAgc3VmZml4OiBcIlwiLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVyOiBcIlwiLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IFwiXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufVxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gYXJyYXkgaW50byBhIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb1JlZ2V4cChwYXRocywga2V5cywgb3B0aW9ucykge1xuICAgIHZhciBwYXJ0cyA9IHBhdGhzLm1hcChmdW5jdGlvbiAocGF0aCkgeyByZXR1cm4gcGF0aFRvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpLnNvdXJjZTsgfSk7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCIoPzpcIiArIHBhcnRzLmpvaW4oXCJ8XCIpICsgXCIpXCIsIGZsYWdzKG9wdGlvbnMpKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgcGF0aCByZWdleHAgZnJvbSBzdHJpbmcgaW5wdXQuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdG9rZW5zVG9SZWdleHAocGFyc2UocGF0aCwgb3B0aW9ucyksIGtleXMsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBFeHBvc2UgYSBmdW5jdGlvbiBmb3IgdGFraW5nIHRva2VucyBhbmQgcmV0dXJuaW5nIGEgUmVnRXhwLlxuICovXG5mdW5jdGlvbiB0b2tlbnNUb1JlZ2V4cCh0b2tlbnMsIGtleXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBfYSA9IG9wdGlvbnMuc3RyaWN0LCBzdHJpY3QgPSBfYSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYSwgX2IgPSBvcHRpb25zLnN0YXJ0LCBzdGFydCA9IF9iID09PSB2b2lkIDAgPyB0cnVlIDogX2IsIF9jID0gb3B0aW9ucy5lbmQsIGVuZCA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2MsIF9kID0gb3B0aW9ucy5lbmNvZGUsIGVuY29kZSA9IF9kID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4geDsgfSA6IF9kO1xuICAgIHZhciBlbmRzV2l0aCA9IFwiW1wiICsgZXNjYXBlU3RyaW5nKG9wdGlvbnMuZW5kc1dpdGggfHwgXCJcIikgKyBcIl18JFwiO1xuICAgIHZhciBkZWxpbWl0ZXIgPSBcIltcIiArIGVzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlciB8fCBcIi8jP1wiKSArIFwiXVwiO1xuICAgIHZhciByb3V0ZSA9IHN0YXJ0ID8gXCJeXCIgOiBcIlwiO1xuICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdG9rZW5zIGFuZCBjcmVhdGUgb3VyIHJlZ2V4cCBzdHJpbmcuXG4gICAgZm9yICh2YXIgX2kgPSAwLCB0b2tlbnNfMSA9IHRva2VuczsgX2kgPCB0b2tlbnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zXzFbX2ldO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByb3V0ZSArPSBlc2NhcGVTdHJpbmcoZW5jb2RlKHRva2VuKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gZXNjYXBlU3RyaW5nKGVuY29kZSh0b2tlbi5wcmVmaXgpKTtcbiAgICAgICAgICAgIHZhciBzdWZmaXggPSBlc2NhcGVTdHJpbmcoZW5jb2RlKHRva2VuLnN1ZmZpeCkpO1xuICAgICAgICAgICAgaWYgKHRva2VuLnBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5cylcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZml4IHx8IHN1ZmZpeCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4ubW9kaWZpZXIgPT09IFwiK1wiIHx8IHRva2VuLm1vZGlmaWVyID09PSBcIipcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZCA9IHRva2VuLm1vZGlmaWVyID09PSBcIipcIiA/IFwiP1wiIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlICs9IFwiKD86XCIgKyBwcmVmaXggKyBcIigoPzpcIiArIHRva2VuLnBhdHRlcm4gKyBcIikoPzpcIiArIHN1ZmZpeCArIHByZWZpeCArIFwiKD86XCIgKyB0b2tlbi5wYXR0ZXJuICsgXCIpKSopXCIgKyBzdWZmaXggKyBcIilcIiArIG1vZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlICs9IFwiKD86XCIgKyBwcmVmaXggKyBcIihcIiArIHRva2VuLnBhdHRlcm4gKyBcIilcIiArIHN1ZmZpeCArIFwiKVwiICsgdG9rZW4ubW9kaWZpZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlICs9IFwiKFwiICsgdG9rZW4ucGF0dGVybiArIFwiKVwiICsgdG9rZW4ubW9kaWZpZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcm91dGUgKz0gXCIoPzpcIiArIHByZWZpeCArIHN1ZmZpeCArIFwiKVwiICsgdG9rZW4ubW9kaWZpZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuZCkge1xuICAgICAgICBpZiAoIXN0cmljdClcbiAgICAgICAgICAgIHJvdXRlICs9IGRlbGltaXRlciArIFwiP1wiO1xuICAgICAgICByb3V0ZSArPSAhb3B0aW9ucy5lbmRzV2l0aCA/IFwiJFwiIDogXCIoPz1cIiArIGVuZHNXaXRoICsgXCIpXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgZW5kVG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgaXNFbmREZWxpbWl0ZWQgPSB0eXBlb2YgZW5kVG9rZW4gPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8gZGVsaW1pdGVyLmluZGV4T2YoZW5kVG9rZW5bZW5kVG9rZW4ubGVuZ3RoIC0gMV0pID4gLTFcbiAgICAgICAgICAgIDogLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICAgICAgZW5kVG9rZW4gPT09IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgICAgIHJvdXRlICs9IFwiKD86XCIgKyBkZWxpbWl0ZXIgKyBcIig/PVwiICsgZW5kc1dpdGggKyBcIikpP1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNFbmREZWxpbWl0ZWQpIHtcbiAgICAgICAgICAgIHJvdXRlICs9IFwiKD89XCIgKyBkZWxpbWl0ZXIgKyBcInxcIiArIGVuZHNXaXRoICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocm91dGUsIGZsYWdzKG9wdGlvbnMpKTtcbn1cbmV4cG9ydHMudG9rZW5zVG9SZWdleHAgPSB0b2tlbnNUb1JlZ2V4cDtcbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG4gKiBwbGFjZWhvbGRlciBrZXkgZGVzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgdXNpbmcgYC91c2VyLzppZGAsIGBrZXlzYCB3aWxsXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cbiAqL1xuZnVuY3Rpb24gcGF0aFRvUmVnZXhwKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cClcbiAgICAgICAgcmV0dXJuIHJlZ2V4cFRvUmVnZXhwKHBhdGgsIGtleXMpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKVxuICAgICAgICByZXR1cm4gYXJyYXlUb1JlZ2V4cChwYXRoLCBrZXlzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gc3RyaW5nVG9SZWdleHAocGF0aCwga2V5cywgb3B0aW9ucyk7XG59XG5leHBvcnRzLnBhdGhUb1JlZ2V4cCA9IHBhdGhUb1JlZ2V4cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/path-to-regexp/index.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/mitt.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/mitt.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.default = mitt; /*\n                        MIT License\n                        Copyright (c) Jason Miller (https://jasonformat.com/)\n                        Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n                        The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n                        THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n                        */ // This file is based on https://github.com/developit/mitt/blob/v1.1.3/src/index.js\n// It's been edited for the needs of this script\n// See the LICENSE at the top of the file\nfunction mitt() {\n  const all = Object.create(null);\n  return {\n    on(type, handler) {\n      ;\n      (all[type] || (all[type] = [])).push(handler);\n    },\n    off(type, handler) {\n      if (all[type]) {\n        all[type].splice(all[type].indexOf(handler) >>> 0, 1);\n      }\n    },\n    emit(type, ...evts) {\n      // eslint-disable-next-line array-callback-return\n      ;\n      (all[type] || []).slice().map(handler => {\n        handler(...evts);\n      });\n    }\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL21pdHQudHM/ZjRlYyJdLCJuYW1lcyI6WyJtaXR0IiwiYWxsIiwiT2JqZWN0IiwiY3JlYXRlIiwib24iLCJ0eXBlIiwiaGFuZGxlciIsInB1c2giLCJvZmYiLCJzcGxpY2UiLCJpbmRleE9mIiwiZW1pdCIsImV2dHMiLCJzbGljZSIsIm1hcCJdLCJtYXBwaW5ncyI6Ijs7O3VCQUFBOzs7Ozs7MEJBQUEsQ0FZQTtBQUNBO0FBQ0E7QUFVZSxTQUFTQSxJQUFULEdBQTZCO0VBQzFDLE1BQU1DLEdBQStCLEdBQUdDLE1BQU0sQ0FBQ0MsTUFBUEQsQ0FBYyxJQUFkQSxDQUF4QztFQUVBLE9BQU87SUFDTEUsRUFBRSxDQUFDQyxJQUFELEVBQWVDLE9BQWYsRUFBaUM7TUFDakM7TUFBQyxDQUFDTCxHQUFHLENBQUNJLElBQUQsQ0FBSEosS0FBY0EsR0FBRyxDQUFDSSxJQUFELENBQUhKLEdBQVksRUFBMUJBLENBQUQsRUFBZ0NNLElBQWhDLENBQXFDRCxPQUFyQztJQUNGLENBSEk7SUFLTEUsR0FBRyxDQUFDSCxJQUFELEVBQWVDLE9BQWYsRUFBaUM7TUFDbEMsSUFBSUwsR0FBRyxDQUFDSSxJQUFELENBQVAsRUFBZTtRQUNiSixHQUFHLENBQUNJLElBQUQsQ0FBSEosQ0FBVVEsTUFBVlIsQ0FBaUJBLEdBQUcsQ0FBQ0ksSUFBRCxDQUFISixDQUFVUyxPQUFWVCxDQUFrQkssT0FBbEJMLE1BQStCLENBQWhEQSxFQUFtRCxDQUFuREE7TUFDRDtJQUNGLENBVEk7SUFXTFUsSUFBSSxDQUFDTixJQUFELEVBQWUsR0FBR08sSUFBbEIsRUFBK0I7TUFDakM7TUFDQTtNQUFDLENBQUNYLEdBQUcsQ0FBQ0ksSUFBRCxDQUFISixJQUFhLEVBQWQsRUFBa0JZLEtBQWxCLEdBQTBCQyxHQUExQixDQUErQlIsT0FBRCxJQUFzQjtRQUNuREEsT0FBTyxDQUFDLEdBQUdNLElBQUosQ0FBUE47TUFDRCxDQUZBO0lBR0Y7RUFoQkksQ0FBUDtBQWtCRCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL21pdHQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuTUlUIExpY2Vuc2VcblxuQ29weXJpZ2h0IChjKSBKYXNvbiBNaWxsZXIgKGh0dHBzOi8vamFzb25mb3JtYXQuY29tLylcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuKi9cblxuLy8gVGhpcyBmaWxlIGlzIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9kZXZlbG9waXQvbWl0dC9ibG9iL3YxLjEuMy9zcmMvaW5kZXguanNcbi8vIEl0J3MgYmVlbiBlZGl0ZWQgZm9yIHRoZSBuZWVkcyBvZiB0aGlzIHNjcmlwdFxuLy8gU2VlIHRoZSBMSUNFTlNFIGF0IHRoZSB0b3Agb2YgdGhlIGZpbGVcblxudHlwZSBIYW5kbGVyID0gKC4uLmV2dHM6IGFueVtdKSA9PiB2b2lkXG5cbmV4cG9ydCB0eXBlIE1pdHRFbWl0dGVyID0ge1xuICBvbih0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEhhbmRsZXIpOiB2b2lkXG4gIG9mZih0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEhhbmRsZXIpOiB2b2lkXG4gIGVtaXQodHlwZTogc3RyaW5nLCAuLi5ldnRzOiBhbnlbXSk6IHZvaWRcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWl0dCgpOiBNaXR0RW1pdHRlciB7XG4gIGNvbnN0IGFsbDogeyBbczogc3RyaW5nXTogSGFuZGxlcltdIH0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgcmV0dXJuIHtcbiAgICBvbih0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEhhbmRsZXIpIHtcbiAgICAgIDsoYWxsW3R5cGVdIHx8IChhbGxbdHlwZV0gPSBbXSkpLnB1c2goaGFuZGxlcilcbiAgICB9LFxuXG4gICAgb2ZmKHR5cGU6IHN0cmluZywgaGFuZGxlcjogSGFuZGxlcikge1xuICAgICAgaWYgKGFsbFt0eXBlXSkge1xuICAgICAgICBhbGxbdHlwZV0uc3BsaWNlKGFsbFt0eXBlXS5pbmRleE9mKGhhbmRsZXIpID4+PiAwLCAxKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbWl0KHR5cGU6IHN0cmluZywgLi4uZXZ0czogYW55W10pIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJheS1jYWxsYmFjay1yZXR1cm5cbiAgICAgIDsoYWxsW3R5cGVdIHx8IFtdKS5zbGljZSgpLm1hcCgoaGFuZGxlcjogSGFuZGxlcikgPT4ge1xuICAgICAgICBoYW5kbGVyKC4uLmV2dHMpXG4gICAgICB9KVxuICAgIH0sXG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/mitt.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/router.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/router.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.addLocale = addLocale;\nexports.delLocale = delLocale;\nexports.hasBasePath = hasBasePath;\nexports.addBasePath = addBasePath;\nexports.delBasePath = delBasePath;\nexports.isLocalURL = isLocalURL;\nexports.interpolateAs = interpolateAs;\nexports.resolveHref = resolveHref;\nexports.markLoadingError = markLoadingError;\nexports.default = void 0;\nvar _normalizeTrailingSlash = __webpack_require__(/*! ../../../client/normalize-trailing-slash */ \"./node_modules/next/dist/client/normalize-trailing-slash.js\");\nvar _denormalizePagePath = __webpack_require__(/*! ../../server/denormalize-page-path */ \"./node_modules/next/dist/next-server/server/denormalize-page-path.js\");\nvar _mitt = _interopRequireDefault(__webpack_require__(/*! ../mitt */ \"./node_modules/next/dist/next-server/lib/mitt.js\"));\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/next/dist/next-server/lib/utils.js\");\nvar _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js\");\nvar _parseRelativeUrl = __webpack_require__(/*! ./utils/parse-relative-url */ \"./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js\");\nvar _querystring = __webpack_require__(/*! ./utils/querystring */ \"./node_modules/next/dist/next-server/lib/router/utils/querystring.js\");\nvar _resolveRewrites = _interopRequireDefault(__webpack_require__(/*! ./utils/resolve-rewrites */ \"./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js\"));\nvar _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ \"./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js\");\nvar _routeRegex = __webpack_require__(/*! ./utils/route-regex */ \"./node_modules/next/dist/next-server/lib/router/utils/route-regex.js\");\nvar _escapePathDelimiters = _interopRequireDefault(__webpack_require__(/*! ./utils/escape-path-delimiters */ \"./node_modules/next/dist/next-server/lib/router/utils/escape-path-delimiters.js\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} /* global __NEXT_DATA__ */ // tslint:disable:no-console\nconst basePath =  false || '';\nfunction buildCancellationError() {\n  return Object.assign(new Error('Route Cancelled'), {\n    cancelled: true\n  });\n}\nfunction addPathPrefix(path, prefix) {\n  return prefix && path.startsWith('/') ? path === '/' ? (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(prefix) : `${prefix}${path}` : path;\n}\nfunction addLocale(path, locale, defaultLocale) {\n  if (false) {}\n  return path;\n}\nfunction delLocale(path, locale) {\n  if (false) {}\n  return path;\n}\nfunction hasBasePath(path) {\n  return path === basePath || path.startsWith(basePath + '/');\n}\nfunction addBasePath(path) {\n  // we only add the basepath on relative urls\n  return addPathPrefix(path, basePath);\n}\nfunction delBasePath(path) {\n  return path.slice(basePath.length) || '/';\n} /**\n  * Detects whether a given url is routable by the Next.js router (browser only).\n  */\nfunction isLocalURL(url) {\n  if (url.startsWith('/')) return true;\n  try {\n    // absolute urls can be local if they are on the same origin\n    const locationOrigin = (0, _utils.getLocationOrigin)();\n    const resolved = new URL(url, locationOrigin);\n    return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);\n  } catch (_) {\n    return false;\n  }\n}\nfunction interpolateAs(route, asPathname, query) {\n  let interpolatedRoute = '';\n  const dynamicRegex = (0, _routeRegex.getRouteRegex)(route);\n  const dynamicGroups = dynamicRegex.groups;\n  const dynamicMatches =\n  // Try to match the dynamic route against the asPath\n  (asPathname !== route ? (0, _routeMatcher.getRouteMatcher)(dynamicRegex)(asPathname) : '') ||\n  // Fall back to reading the values from the href\n  // TODO: should this take priority; also need to change in the router.\n  query;\n  interpolatedRoute = route;\n  const params = Object.keys(dynamicGroups);\n  if (!params.every(param => {\n    let value = dynamicMatches[param] || '';\n    const {\n      repeat,\n      optional\n    } = dynamicGroups[param]; // support single-level catch-all\n    // TODO: more robust handling for user-error (passing `/`)\n    let replaced = `[${repeat ? '...' : ''}${param}]`;\n    if (optional) {\n      replaced = `${!value ? '/' : ''}[${replaced}]`;\n    }\n    if (repeat && !Array.isArray(value)) value = [value];\n    return (optional || param in dynamicMatches) && (\n    // Interpolate group into data URL if present\n    interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(_escapePathDelimiters.default).join('/') : (0, _escapePathDelimiters.default)(value)) || '/');\n  })) {\n    interpolatedRoute = ''; // did not satisfy all requirements\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n  }\n  return {\n    params,\n    result: interpolatedRoute\n  };\n}\nfunction omitParmsFromQuery(query, params) {\n  const filteredQuery = {};\n  Object.keys(query).forEach(key => {\n    if (!params.includes(key)) {\n      filteredQuery[key] = query[key];\n    }\n  });\n  return filteredQuery;\n} /**\n  * Resolves a given hyperlink with a certain router state (basePath not included).\n  * Preserves absolute urls.\n  */\nfunction resolveHref(currentPath, href, resolveAs) {\n  // we use a dummy base url for relative urls\n  const base = new URL(currentPath, 'http://n');\n  const urlAsString = typeof href === 'string' ? href : (0, _utils.formatWithValidation)(href);\n  try {\n    const finalUrl = new URL(urlAsString, base);\n    finalUrl.pathname = (0, _normalizeTrailingSlash.normalizePathTrailingSlash)(finalUrl.pathname);\n    let interpolatedAs = '';\n    if ((0, _isDynamic.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n      const query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);\n      const {\n        result,\n        params\n      } = interpolateAs(finalUrl.pathname, finalUrl.pathname, query);\n      if (result) {\n        interpolatedAs = (0, _utils.formatWithValidation)({\n          pathname: result,\n          hash: finalUrl.hash,\n          query: omitParmsFromQuery(query, params)\n        });\n      }\n    } // if the origin didn't change, it means we received a relative href\n    const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n    return resolveAs ? [resolvedHref, interpolatedAs || resolvedHref] : resolvedHref;\n  } catch (_) {\n    return resolveAs ? [urlAsString] : urlAsString;\n  }\n}\nconst PAGE_LOAD_ERROR = Symbol('PAGE_LOAD_ERROR');\nfunction markLoadingError(err) {\n  return Object.defineProperty(err, PAGE_LOAD_ERROR, {});\n}\nfunction prepareUrlAs(router, url, as) {\n  // If url and as provided as an object representation,\n  // we'll format them into the string version here.\n  return {\n    url: addBasePath(resolveHref(router.pathname, url)),\n    as: as ? addBasePath(resolveHref(router.pathname, as)) : as\n  };\n}\nconst manualScrollRestoration =  false && false;\nfunction fetchRetry(url, attempts) {\n  return fetch(url, {\n    // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n    // Cookies may also be required for `getServerSideProps`.\n    //\n    // > `fetch` won’t send cookies, unless you set the credentials init\n    // > option.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n    //\n    // > For maximum browser compatibility when it comes to sending &\n    // > receiving cookies, always supply the `credentials: 'same-origin'`\n    // > option instead of relying on the default.\n    // https://github.com/github/fetch#caveats\n    credentials: 'same-origin'\n  }).then(res => {\n    if (!res.ok) {\n      if (attempts > 1 && res.status >= 500) {\n        return fetchRetry(url, attempts - 1);\n      }\n      throw new Error(`Failed to load static props`);\n    }\n    return res.json();\n  });\n}\nfunction fetchNextData(dataHref, isServerRender) {\n  return fetchRetry(dataHref, isServerRender ? 3 : 1).catch(err => {\n    // We should only trigger a server-side transition if this was caused\n    // on a client-side transition. Otherwise, we'd get into an infinite\n    // loop.\n    if (!isServerRender) {\n      markLoadingError(err);\n    }\n    throw err;\n  });\n}\nclass Router {\n  /**\n  * Map of all components loaded in `Router`\n  */ // Static Data Cache\n  constructor(_pathname, _query, _as, {\n    initialProps,\n    pageLoader,\n    App,\n    wrapApp,\n    Component,\n    initialStyleSheets,\n    err,\n    subscription,\n    isFallback,\n    locale,\n    locales,\n    defaultLocale\n  }) {\n    this.route = void 0;\n    this.pathname = void 0;\n    this.query = void 0;\n    this.asPath = void 0;\n    this.basePath = void 0;\n    this.components = void 0;\n    this.sdc = {};\n    this.sub = void 0;\n    this.clc = void 0;\n    this.pageLoader = void 0;\n    this._bps = void 0;\n    this.events = void 0;\n    this._wrapApp = void 0;\n    this.isSsr = void 0;\n    this.isFallback = void 0;\n    this._inFlightRoute = void 0;\n    this._shallow = void 0;\n    this.locale = void 0;\n    this.locales = void 0;\n    this.defaultLocale = void 0;\n    this.onPopState = e => {\n      const state = e.state;\n      if (!state) {\n        // We get state as undefined for two reasons.\n        //  1. With older safari (< 8) and older chrome (< 34)\n        //  2. When the URL changed with #\n        //\n        // In the both cases, we don't need to proceed and change the route.\n        // (as it's already changed)\n        // But we can simply replace the state with the new changes.\n        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n        // So, doing the following for (1) does no harm.\n        const {\n          pathname,\n          query\n        } = this;\n        this.changeState('replaceState', (0, _utils.formatWithValidation)({\n          pathname: addBasePath(pathname),\n          query\n        }), (0, _utils.getURL)());\n        return;\n      }\n      if (!state.__N) {\n        return;\n      }\n      const {\n        url,\n        as,\n        options\n      } = state;\n      const {\n        pathname\n      } = (0, _parseRelativeUrl.parseRelativeUrl)(url); // Make sure we don't re-render on initial load,\n      // can be caused by navigating back from an external site\n      if (this.isSsr && as === this.asPath && pathname === this.pathname) {\n        return;\n      } // If the downstream application returns falsy, return.\n      // They will then be responsible for handling the event.\n      if (this._bps && !this._bps(state)) {\n        return;\n      }\n      this.change('replaceState', url, as, Object.assign({}, options, {\n        shallow: options.shallow && this._shallow\n      }));\n    }; // represents the current component key\n    this.route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(_pathname); // set up the component cache (by route keys)\n    this.components = {}; // We should not keep the cache, if there's an error\n    // Otherwise, this cause issues when when going back and\n    // come again to the errored page.\n    if (_pathname !== '/_error') {\n      this.components[this.route] = {\n        Component,\n        styleSheets: initialStyleSheets,\n        props: initialProps,\n        err,\n        __N_SSG: initialProps && initialProps.__N_SSG,\n        __N_SSP: initialProps && initialProps.__N_SSP\n      };\n    }\n    this.components['/_app'] = {\n      Component: App,\n      styleSheets: [/* /_app does not need its stylesheets managed */]\n    }; // Backwards compat for Router.router.events\n    // TODO: Should be remove the following major version as it was never documented\n    this.events = Router.events;\n    this.pageLoader = pageLoader;\n    this.pathname = _pathname;\n    this.query = _query; // if auto prerendered and dynamic route wait to update asPath\n    // until after mount to prevent hydration mismatch\n    this.asPath =\n    // @ts-ignore this is temporarily global (attached to window)\n    (0, _isDynamic.isDynamicRoute)(_pathname) && __NEXT_DATA__.autoExport ? _pathname : _as;\n    this.basePath = basePath;\n    this.sub = subscription;\n    this.clc = null;\n    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating\n    // back from external site\n    this.isSsr = true;\n    this.isFallback = isFallback;\n    if (false) {}\n    if (false) {}\n  }\n  reload() {\n    window.location.reload();\n  } /**\n    * Go back in history\n    */\n  back() {\n    window.history.back();\n  } /**\n    * Performs a `pushState` with arguments\n    * @param url of the route\n    * @param as masks `url` for the browser\n    * @param options object you can define `shallow` and other options\n    */\n  push(url, as = url, options = {}) {\n    ;\n    ({\n      url,\n      as\n    } = prepareUrlAs(this, url, as));\n    return this.change('pushState', url, as, options);\n  } /**\n    * Performs a `replaceState` with arguments\n    * @param url of the route\n    * @param as masks `url` for the browser\n    * @param options object you can define `shallow` and other options\n    */\n  replace(url, as = url, options = {}) {\n    ;\n    ({\n      url,\n      as\n    } = prepareUrlAs(this, url, as));\n    return this.change('replaceState', url, as, options);\n  }\n  async change(method, url, as, options) {\n    if (!isLocalURL(url)) {\n      window.location.href = url;\n      return false;\n    }\n    if (!options._h) {\n      this.isSsr = false;\n    } // marking route changes as a navigation start entry\n    if (_utils.ST) {\n      performance.mark('routeChange');\n    }\n    if (this._inFlightRoute) {\n      this.abortComponentLoad(this._inFlightRoute);\n    }\n    as = addLocale(as, this.locale, this.defaultLocale);\n    const cleanedAs = delLocale(hasBasePath(as) ? delBasePath(as) : as, this.locale);\n    this._inFlightRoute = as; // If the url change is only related to a hash change\n    // We should not proceed. We should only change the state.\n    // WARNING: `_h` is an internal option for handing Next.js client-side\n    // hydration. Your app should _never_ use this property. It may change at\n    // any time without notice.\n    if (!options._h && this.onlyAHashChange(cleanedAs)) {\n      this.asPath = cleanedAs;\n      Router.events.emit('hashChangeStart', as); // TODO: do we need the resolved href when only a hash change?\n      this.changeState(method, url, as, options);\n      this.scrollToHash(cleanedAs);\n      this.notify(this.components[this.route]);\n      Router.events.emit('hashChangeComplete', as);\n      return true;\n    } // The build manifest needs to be loaded before auto-static dynamic pages\n    // get their query parameters to allow ensuring they can be parsed properly\n    // when rewritten to\n    const pages = await this.pageLoader.getPageList();\n    const {\n      __rewrites: rewrites\n    } = await this.pageLoader.promisedBuildManifest;\n    let parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);\n    let {\n      pathname,\n      query\n    } = parsed;\n    parsed = this._resolveHref(parsed, pages);\n    if (parsed.pathname !== pathname) {\n      pathname = parsed.pathname;\n      url = (0, _utils.formatWithValidation)(parsed);\n    } // url and as should always be prefixed with basePath by this\n    // point by either next/link or router.push/replace so strip the\n    // basePath from the pathname to match the pages dir 1-to-1\n    pathname = pathname ? (0, _normalizeTrailingSlash.removePathTrailingSlash)(delBasePath(pathname)) : pathname; // If asked to change the current URL we should reload the current page\n    // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n    // We also need to set the method = replaceState always\n    // as this should not go into the history (That's how browsers work)\n    // We should compare the new asPath to the current asPath, not the url\n    if (!this.urlIsNew(cleanedAs)) {\n      method = 'replaceState';\n    }\n    let route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname);\n    const {\n      shallow = false\n    } = options; // we need to resolve the as value using rewrites for dynamic SSG\n    // pages to allow building the data URL correctly\n    let resolvedAs = as;\n    if (true) {\n      resolvedAs = (0, _resolveRewrites.default)((0, _parseRelativeUrl.parseRelativeUrl)(as).pathname, pages, basePath, rewrites, query, p => this._resolveHref({\n        pathname: p\n      }, pages).pathname);\n      if (resolvedAs !== as) {\n        const potentialHref = (0, _normalizeTrailingSlash.removePathTrailingSlash)(this._resolveHref(Object.assign({}, parsed, {\n          pathname: resolvedAs\n        }), pages, false).pathname); // if this directly matches a page we need to update the href to\n        // allow the correct page chunk to be loaded\n        if (pages.includes(potentialHref)) {\n          route = potentialHref;\n          pathname = potentialHref;\n          parsed.pathname = pathname;\n          url = (0, _utils.formatWithValidation)(parsed);\n        }\n      }\n    }\n    resolvedAs = delLocale(delBasePath(resolvedAs), this.locale);\n    if ((0, _isDynamic.isDynamicRoute)(route)) {\n      const parsedAs = (0, _parseRelativeUrl.parseRelativeUrl)(resolvedAs);\n      const asPathname = parsedAs.pathname;\n      const routeRegex = (0, _routeRegex.getRouteRegex)(route);\n      const routeMatch = (0, _routeMatcher.getRouteMatcher)(routeRegex)(asPathname);\n      const shouldInterpolate = route === asPathname;\n      const interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {};\n      if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n        const missingParams = Object.keys(routeRegex.groups).filter(param => !query[param]);\n        if (missingParams.length > 0) {\n          if (true) {\n            console.warn(`${shouldInterpolate ? `Interpolating href` : `Mismatching \\`as\\` and \\`href\\``} failed to manually provide ` + `the params: ${missingParams.join(', ')} in the \\`href\\`'s \\`query\\``);\n          }\n          throw new Error((shouldInterpolate ? `The provided \\`href\\` (${url}) value is missing query values (${missingParams.join(', ')}) to be interpolated properly. ` : `The provided \\`as\\` value (${asPathname}) is incompatible with the \\`href\\` value (${route}). `) + `Read more: https://err.sh/vercel/next.js/${shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'}`);\n        }\n      } else if (shouldInterpolate) {\n        as = (0, _utils.formatWithValidation)(Object.assign({}, parsedAs, {\n          pathname: interpolatedAs.result,\n          query: omitParmsFromQuery(query, interpolatedAs.params)\n        }));\n      } else {\n        // Merge params into `query`, overwriting any specified in search\n        Object.assign(query, routeMatch);\n      }\n    }\n    Router.events.emit('routeChangeStart', as);\n    try {\n      const routeInfo = await this.getRouteInfo(route, pathname, query, as, shallow);\n      let {\n        error,\n        props,\n        __N_SSG,\n        __N_SSP\n      } = routeInfo; // handle redirect on client-transition\n      if ((__N_SSG || __N_SSP) && props && props.pageProps && props.pageProps.__N_REDIRECT) {\n        const destination = props.pageProps.__N_REDIRECT; // check if destination is internal (resolves to a page) and attempt\n        // client-navigation if it is falling back to hard navigation if\n        // it's not\n        if (destination.startsWith('/')) {\n          const parsedHref = (0, _parseRelativeUrl.parseRelativeUrl)(destination);\n          this._resolveHref(parsedHref, pages);\n          if (pages.includes(parsedHref.pathname)) {\n            return this.change('replaceState', destination, destination, options);\n          }\n        }\n        window.location.href = destination;\n        return new Promise(() => {});\n      }\n      Router.events.emit('beforeHistoryChange', as);\n      this.changeState(method, url, addLocale(as, this.locale, this.defaultLocale), options);\n      if (true) {\n        const appComp = this.components['/_app'].Component;\n        window.next.isPrerendered = appComp.getInitialProps === appComp.origGetInitialProps && !routeInfo.Component.getInitialProps;\n      }\n      await this.set(route, pathname, query, cleanedAs, routeInfo).catch(e => {\n        if (e.cancelled) error = error || e;else throw e;\n      });\n      if (error) {\n        Router.events.emit('routeChangeError', error, cleanedAs);\n        throw error;\n      }\n      if (false) {}\n      Router.events.emit('routeChangeComplete', as);\n      return true;\n    } catch (err) {\n      if (err.cancelled) {\n        return false;\n      }\n      throw err;\n    }\n  }\n  changeState(method, url, as, options = {}) {\n    if (true) {\n      if (typeof window.history === 'undefined') {\n        console.error(`Warning: window.history is not available.`);\n        return;\n      }\n      if (typeof window.history[method] === 'undefined') {\n        console.error(`Warning: window.history.${method} is not available`);\n        return;\n      }\n    }\n    if (method !== 'pushState' || (0, _utils.getURL)() !== as) {\n      this._shallow = options.shallow;\n      window.history[method]({\n        url,\n        as,\n        options,\n        __N: true\n      },\n      // Most browsers currently ignores this parameter, although they may use it in the future.\n      // Passing the empty string here should be safe against future changes to the method.\n      // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n      '', as);\n    }\n  }\n  async handleRouteInfoError(err, pathname, query, as, loadErrorFail) {\n    if (err.cancelled) {\n      // bubble up cancellation errors\n      throw err;\n    }\n    if (PAGE_LOAD_ERROR in err || loadErrorFail) {\n      Router.events.emit('routeChangeError', err, as); // If we can't load the page it could be one of following reasons\n      //  1. Page doesn't exists\n      //  2. Page does exist in a different zone\n      //  3. Internal error while loading the page\n      // So, doing a hard reload is the proper way to deal with this.\n      window.location.href = as; // Changing the URL doesn't block executing the current code path.\n      // So let's throw a cancellation error stop the routing logic.\n      throw buildCancellationError();\n    }\n    try {\n      const {\n        page: Component,\n        styleSheets\n      } = await this.fetchComponent('/_error');\n      const routeInfo = {\n        Component,\n        styleSheets,\n        err,\n        error: err\n      };\n      try {\n        routeInfo.props = await this.getInitialProps(Component, {\n          err,\n          pathname,\n          query\n        });\n      } catch (gipErr) {\n        console.error('Error in error page `getInitialProps`: ', gipErr);\n        routeInfo.props = {};\n      }\n      return routeInfo;\n    } catch (routeInfoErr) {\n      return this.handleRouteInfoError(routeInfoErr, pathname, query, as, true);\n    }\n  }\n  async getRouteInfo(route, pathname, query, as, shallow = false) {\n    try {\n      const cachedRouteInfo = this.components[route];\n      if (shallow && cachedRouteInfo && this.route === route) {\n        return cachedRouteInfo;\n      }\n      const routeInfo = cachedRouteInfo ? cachedRouteInfo : await this.fetchComponent(route).then(res => ({\n        Component: res.page,\n        styleSheets: res.styleSheets,\n        __N_SSG: res.mod.__N_SSG,\n        __N_SSP: res.mod.__N_SSP\n      }));\n      const {\n        Component,\n        __N_SSG,\n        __N_SSP\n      } = routeInfo;\n      if (true) {\n        const {\n          isValidElementType\n        } = __webpack_require__(/*! react-is */ \"react-is\");\n        if (!isValidElementType(Component)) {\n          throw new Error(`The default export is not a React Component in page: \"${pathname}\"`);\n        }\n      }\n      let dataHref;\n      if (__N_SSG || __N_SSP) {\n        dataHref = this.pageLoader.getDataHref((0, _utils.formatWithValidation)({\n          pathname,\n          query\n        }), delBasePath(as), __N_SSG, this.locale, this.defaultLocale);\n      }\n      const props = await this._getData(() => __N_SSG ? this._getStaticData(dataHref) : __N_SSP ? this._getServerData(dataHref) : this.getInitialProps(Component,\n      // we provide AppTree later so this needs to be `any`\n      {\n        pathname,\n        query,\n        asPath: as\n      }));\n      routeInfo.props = props;\n      this.components[route] = routeInfo;\n      return routeInfo;\n    } catch (err) {\n      return this.handleRouteInfoError(err, pathname, query, as);\n    }\n  }\n  set(route, pathname, query, as, data) {\n    this.isFallback = false;\n    this.route = route;\n    this.pathname = pathname;\n    this.query = query;\n    this.asPath = as;\n    return this.notify(data);\n  } /**\n    * Callback to execute before replacing router state\n    * @param cb callback to be executed\n    */\n  beforePopState(cb) {\n    this._bps = cb;\n  }\n  onlyAHashChange(as) {\n    if (!this.asPath) return false;\n    const [oldUrlNoHash, oldHash] = this.asPath.split('#');\n    const [newUrlNoHash, newHash] = as.split('#'); // Makes sure we scroll to the provided hash if the url/hash are the same\n    if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n      return true;\n    } // If the urls are change, there's more than a hash change\n    if (oldUrlNoHash !== newUrlNoHash) {\n      return false;\n    } // If the hash has changed, then it's a hash only change.\n    // This check is necessary to handle both the enter and\n    // leave hash === '' cases. The identity case falls through\n    // and is treated as a next reload.\n    return oldHash !== newHash;\n  }\n  scrollToHash(as) {\n    const [, hash] = as.split('#'); // Scroll to top if the hash is just `#` with no value\n    if (hash === '') {\n      window.scrollTo(0, 0);\n      return;\n    } // First we check if the element by id is found\n    const idEl = document.getElementById(hash);\n    if (idEl) {\n      idEl.scrollIntoView();\n      return;\n    } // If there's no element with the id, we check the `name` property\n    // To mirror browsers\n    const nameEl = document.getElementsByName(hash)[0];\n    if (nameEl) {\n      nameEl.scrollIntoView();\n    }\n  }\n  urlIsNew(asPath) {\n    return this.asPath !== asPath;\n  }\n  _resolveHref(parsedHref, pages, applyBasePath = true) {\n    const {\n      pathname\n    } = parsedHref;\n    const cleanPathname = (0, _normalizeTrailingSlash.removePathTrailingSlash)((0, _denormalizePagePath.denormalizePagePath)(applyBasePath ? delBasePath(pathname) : pathname));\n    if (cleanPathname === '/404' || cleanPathname === '/_error') {\n      return parsedHref;\n    } // handle resolving href for dynamic routes\n    if (!pages.includes(cleanPathname)) {\n      // eslint-disable-next-line array-callback-return\n      pages.some(page => {\n        if ((0, _isDynamic.isDynamicRoute)(page) && (0, _routeRegex.getRouteRegex)(page).re.test(cleanPathname)) {\n          parsedHref.pathname = applyBasePath ? addBasePath(page) : page;\n          return true;\n        }\n      });\n    }\n    return parsedHref;\n  } /**\n    * Prefetch page code, you may wait for the data during page rendering.\n    * This feature only works in production!\n    * @param url the href of prefetched page\n    * @param asPath the as path of the prefetched page\n    */\n  async prefetch(url, asPath = url, options = {}) {\n    let parsed = (0, _parseRelativeUrl.parseRelativeUrl)(url);\n    let {\n      pathname\n    } = parsed;\n    const pages = await this.pageLoader.getPageList();\n    parsed = this._resolveHref(parsed, pages);\n    if (parsed.pathname !== pathname) {\n      pathname = parsed.pathname;\n      url = (0, _utils.formatWithValidation)(parsed);\n    } // Prefetch is not supported in development mode because it would trigger on-demand-entries\n    if (true) {\n      return;\n    }\n    const route = (0, _normalizeTrailingSlash.removePathTrailingSlash)(pathname);\n    await Promise.all([this.pageLoader.prefetchData(url, asPath, this.locale, this.defaultLocale), this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]);\n  }\n  async fetchComponent(route) {\n    let cancelled = false;\n    const cancel = this.clc = () => {\n      cancelled = true;\n    };\n    const componentResult = await this.pageLoader.loadPage(route);\n    if (cancelled) {\n      const error = new Error(`Abort fetching component for route: \"${route}\"`);\n      error.cancelled = true;\n      throw error;\n    }\n    if (cancel === this.clc) {\n      this.clc = null;\n    }\n    return componentResult;\n  }\n  _getData(fn) {\n    let cancelled = false;\n    const cancel = () => {\n      cancelled = true;\n    };\n    this.clc = cancel;\n    return fn().then(data => {\n      if (cancel === this.clc) {\n        this.clc = null;\n      }\n      if (cancelled) {\n        const err = new Error('Loading initial props cancelled');\n        err.cancelled = true;\n        throw err;\n      }\n      return data;\n    });\n  }\n  _getStaticData(dataHref) {\n    const {\n      href: cacheKey\n    } = new URL(dataHref, window.location.href);\n    if (false) {}\n    return fetchNextData(dataHref, this.isSsr).then(data => {\n      this.sdc[cacheKey] = data;\n      return data;\n    });\n  }\n  _getServerData(dataHref) {\n    return fetchNextData(dataHref, this.isSsr);\n  }\n  getInitialProps(Component, ctx) {\n    const {\n      Component: App\n    } = this.components['/_app'];\n    const AppTree = this._wrapApp(App);\n    ctx.AppTree = AppTree;\n    return (0, _utils.loadGetInitialProps)(App, {\n      AppTree,\n      Component,\n      router: this,\n      ctx\n    });\n  }\n  abortComponentLoad(as) {\n    if (this.clc) {\n      Router.events.emit('routeChangeError', buildCancellationError(), as);\n      this.clc();\n      this.clc = null;\n    }\n  }\n  notify(data) {\n    return this.sub(data, this.components['/_app'].Component);\n  }\n}\nexports.default = Router;\nRouter.events = (0, _mitt.default)();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci9yb3V0ZXIudHM/MzViOCJdLCJuYW1lcyI6WyJiYXNlUGF0aCIsInByb2Nlc3MiLCJidWlsZENhbmNlbGxhdGlvbkVycm9yIiwiT2JqZWN0IiwiYXNzaWduIiwiRXJyb3IiLCJjYW5jZWxsZWQiLCJhZGRQYXRoUHJlZml4IiwicGF0aCIsInByZWZpeCIsInN0YXJ0c1dpdGgiLCJhZGRMb2NhbGUiLCJsb2NhbGUiLCJkZWZhdWx0TG9jYWxlIiwiZGVsTG9jYWxlIiwiaGFzQmFzZVBhdGgiLCJhZGRCYXNlUGF0aCIsImRlbEJhc2VQYXRoIiwic2xpY2UiLCJsZW5ndGgiLCJpc0xvY2FsVVJMIiwidXJsIiwibG9jYXRpb25PcmlnaW4iLCJyZXNvbHZlZCIsIlVSTCIsIm9yaWdpbiIsInBhdGhuYW1lIiwiXyIsImludGVycG9sYXRlQXMiLCJyb3V0ZSIsImFzUGF0aG5hbWUiLCJxdWVyeSIsImludGVycG9sYXRlZFJvdXRlIiwiZHluYW1pY1JlZ2V4IiwiZHluYW1pY0dyb3VwcyIsImdyb3VwcyIsImR5bmFtaWNNYXRjaGVzIiwicGFyYW1zIiwia2V5cyIsImV2ZXJ5IiwicGFyYW0iLCJ2YWx1ZSIsInJlcGVhdCIsIm9wdGlvbmFsIiwicmVwbGFjZWQiLCJBcnJheSIsImlzQXJyYXkiLCJyZXBsYWNlIiwibWFwIiwiZXNjYXBlUGF0aERlbGltaXRlcnMiLCJqb2luIiwicmVzdWx0Iiwib21pdFBhcm1zRnJvbVF1ZXJ5IiwiZmlsdGVyZWRRdWVyeSIsImZvckVhY2giLCJrZXkiLCJpbmNsdWRlcyIsInJlc29sdmVIcmVmIiwiY3VycmVudFBhdGgiLCJocmVmIiwicmVzb2x2ZUFzIiwiYmFzZSIsInVybEFzU3RyaW5nIiwiZmluYWxVcmwiLCJpbnRlcnBvbGF0ZWRBcyIsInNlYXJjaFBhcmFtcyIsImhhc2giLCJyZXNvbHZlZEhyZWYiLCJQQUdFX0xPQURfRVJST1IiLCJTeW1ib2wiLCJtYXJrTG9hZGluZ0Vycm9yIiwiZXJyIiwiZGVmaW5lUHJvcGVydHkiLCJwcmVwYXJlVXJsQXMiLCJyb3V0ZXIiLCJhcyIsIm1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uIiwiZmV0Y2hSZXRyeSIsImF0dGVtcHRzIiwiY3JlZGVudGlhbHMiLCJ0aGVuIiwicmVzIiwib2siLCJzdGF0dXMiLCJqc29uIiwiZmV0Y2hOZXh0RGF0YSIsImRhdGFIcmVmIiwiaXNTZXJ2ZXJSZW5kZXIiLCJjYXRjaCIsIlJvdXRlciIsImNvbnN0cnVjdG9yIiwiaW5pdGlhbFByb3BzIiwicGFnZUxvYWRlciIsIkFwcCIsIndyYXBBcHAiLCJDb21wb25lbnQiLCJpbml0aWFsU3R5bGVTaGVldHMiLCJzdWJzY3JpcHRpb24iLCJpc0ZhbGxiYWNrIiwibG9jYWxlcyIsImFzUGF0aCIsImNvbXBvbmVudHMiLCJzZGMiLCJzdWIiLCJjbGMiLCJfYnBzIiwiZXZlbnRzIiwiX3dyYXBBcHAiLCJpc1NzciIsIl9pbkZsaWdodFJvdXRlIiwiX3NoYWxsb3ciLCJvblBvcFN0YXRlIiwiZSIsInN0YXRlIiwiY2hhbmdlU3RhdGUiLCJfX04iLCJvcHRpb25zIiwiY2hhbmdlIiwic2hhbGxvdyIsInN0eWxlU2hlZXRzIiwicHJvcHMiLCJfX05fU1NHIiwiX19OX1NTUCIsIl9fTkVYVF9EQVRBX18iLCJhdXRvRXhwb3J0IiwicmVsb2FkIiwid2luZG93IiwibG9jYXRpb24iLCJiYWNrIiwiaGlzdG9yeSIsInB1c2giLCJtZXRob2QiLCJfaCIsIlNUIiwicGVyZm9ybWFuY2UiLCJtYXJrIiwiYWJvcnRDb21wb25lbnRMb2FkIiwiY2xlYW5lZEFzIiwib25seUFIYXNoQ2hhbmdlIiwiZW1pdCIsInNjcm9sbFRvSGFzaCIsIm5vdGlmeSIsInBhZ2VzIiwiZ2V0UGFnZUxpc3QiLCJfX3Jld3JpdGVzIiwicmV3cml0ZXMiLCJwcm9taXNlZEJ1aWxkTWFuaWZlc3QiLCJwYXJzZWQiLCJfcmVzb2x2ZUhyZWYiLCJ1cmxJc05ldyIsInJlc29sdmVkQXMiLCJwIiwicG90ZW50aWFsSHJlZiIsInBhcnNlZEFzIiwicm91dGVSZWdleCIsInJvdXRlTWF0Y2giLCJzaG91bGRJbnRlcnBvbGF0ZSIsIm1pc3NpbmdQYXJhbXMiLCJmaWx0ZXIiLCJjb25zb2xlIiwid2FybiIsInJvdXRlSW5mbyIsImdldFJvdXRlSW5mbyIsImVycm9yIiwicGFnZVByb3BzIiwiX19OX1JFRElSRUNUIiwiZGVzdGluYXRpb24iLCJwYXJzZWRIcmVmIiwiUHJvbWlzZSIsImFwcENvbXAiLCJuZXh0IiwiaXNQcmVyZW5kZXJlZCIsImdldEluaXRpYWxQcm9wcyIsIm9yaWdHZXRJbml0aWFsUHJvcHMiLCJzZXQiLCJoYW5kbGVSb3V0ZUluZm9FcnJvciIsImxvYWRFcnJvckZhaWwiLCJwYWdlIiwiZmV0Y2hDb21wb25lbnQiLCJnaXBFcnIiLCJyb3V0ZUluZm9FcnIiLCJjYWNoZWRSb3V0ZUluZm8iLCJtb2QiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJyZXF1aXJlIiwiZ2V0RGF0YUhyZWYiLCJfZ2V0RGF0YSIsIl9nZXRTdGF0aWNEYXRhIiwiX2dldFNlcnZlckRhdGEiLCJkYXRhIiwiYmVmb3JlUG9wU3RhdGUiLCJjYiIsIm9sZFVybE5vSGFzaCIsIm9sZEhhc2giLCJzcGxpdCIsIm5ld1VybE5vSGFzaCIsIm5ld0hhc2giLCJzY3JvbGxUbyIsImlkRWwiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwic2Nyb2xsSW50b1ZpZXciLCJuYW1lRWwiLCJnZXRFbGVtZW50c0J5TmFtZSIsImFwcGx5QmFzZVBhdGgiLCJjbGVhblBhdGhuYW1lIiwic29tZSIsInJlIiwidGVzdCIsInByZWZldGNoIiwiYWxsIiwicHJlZmV0Y2hEYXRhIiwicHJpb3JpdHkiLCJjYW5jZWwiLCJjb21wb25lbnRSZXN1bHQiLCJsb2FkUGFnZSIsImZuIiwiY2FjaGVLZXkiLCJjdHgiLCJBcHBUcmVlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBS0E7QUFLQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FB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T0EsSUFBUDtJQUNELENBSE14RyxDQUFQO0VBSUQ7RUFFRHVHLGNBQWMsQ0FBQ3RHLFFBQUQsRUFBb0M7SUFDaEQsT0FBT0QsYUFBYSxDQUFDQyxRQUFELEVBQVcsS0FBS3NCLEtBQWhCLENBQXBCO0VBQ0Q7RUFFRGdFLGVBQWUsQ0FDYjdFLFNBRGEsRUFFYjJILEdBRmEsRUFHQztJQUNkLE1BQU07TUFBRTNILFNBQVMsRUFBRUY7SUFBYixJQUFxQixLQUFLUSxVQUFMLENBQWdCLE9BQWhCLENBQTNCO0lBQ0EsTUFBTXNILE9BQU8sR0FBRyxLQUFLaEgsUUFBTCxDQUFjZCxHQUFkLENBQWhCO0lBQ0E2SCxHQUFHLENBQUNDLE9BQUpELEdBQWNDLE9BQWREO0lBQ0EsT0FBTyxnQ0FBNEM3SCxHQUE1QyxFQUFpRDtNQUN0RDhILE9BRHNEO01BRXRENUgsU0FGc0Q7TUFHdERyQixNQUFNLEVBQUUsSUFIOEM7TUFJdERnSjtJQUpzRCxDQUFqRCxDQUFQO0VBTUQ7RUFFRGxGLGtCQUFrQixDQUFDN0QsRUFBRCxFQUFtQjtJQUNuQyxJQUFJLEtBQUs2QixHQUFULEVBQWM7TUFDWmYsTUFBTSxDQUFDaUIsTUFBUGpCLENBQWNrRCxJQUFkbEQsQ0FBbUIsa0JBQW5CQSxFQUF1Q3ZGLHNCQUFzQixFQUE3RHVGLEVBQWlFZCxFQUFqRWM7TUFDQSxLQUFLZSxHQUFMO01BQ0EsS0FBS0EsR0FBTCxHQUFXLElBQVg7SUFDRDtFQUNGO0VBRURxQyxNQUFNLENBQUNnRCxJQUFELEVBQXdDO0lBQzVDLE9BQU8sS0FBS3RGLEdBQUwsQ0FBU3NGLElBQVQsRUFBZSxLQUFLeEYsVUFBTCxDQUFnQixPQUFoQixFQUF5Qk4sU0FBeEMsQ0FBUDtFQUNEO0FBMTNCK0M7O0FBQTdCTixNLENBMkJaaUIsTSxHQUFzQixvQiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci9yb3V0ZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgX19ORVhUX0RBVEFfXyAqL1xuLy8gdHNsaW50OmRpc2FibGU6bm8tY29uc29sZVxuaW1wb3J0IHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCB7IENvbXBvbmVudFR5cGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IFVybE9iamVjdCB9IGZyb20gJ3VybCdcbmltcG9ydCB7XG4gIG5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoLFxuICByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaCxcbn0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L25vcm1hbGl6ZS10cmFpbGluZy1zbGFzaCdcbmltcG9ydCB7IEdvb2RQYWdlQ2FjaGUsIFN0eWxlU2hlZXRUdXBsZSB9IGZyb20gJy4uLy4uLy4uL2NsaWVudC9wYWdlLWxvYWRlcidcbmltcG9ydCB7IGRlbm9ybWFsaXplUGFnZVBhdGggfSBmcm9tICcuLi8uLi9zZXJ2ZXIvZGVub3JtYWxpemUtcGFnZS1wYXRoJ1xuaW1wb3J0IG1pdHQsIHsgTWl0dEVtaXR0ZXIgfSBmcm9tICcuLi9taXR0J1xuaW1wb3J0IHtcbiAgQXBwQ29udGV4dFR5cGUsXG4gIGZvcm1hdFdpdGhWYWxpZGF0aW9uLFxuICBnZXRMb2NhdGlvbk9yaWdpbixcbiAgZ2V0VVJMLFxuICBsb2FkR2V0SW5pdGlhbFByb3BzLFxuICBOZXh0UGFnZUNvbnRleHQsXG4gIFNULFxufSBmcm9tICcuLi91dGlscydcbmltcG9ydCB7IGlzRHluYW1pY1JvdXRlIH0gZnJvbSAnLi91dGlscy9pcy1keW5hbWljJ1xuaW1wb3J0IHsgcGFyc2VSZWxhdGl2ZVVybCB9IGZyb20gJy4vdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsJ1xuaW1wb3J0IHsgc2VhcmNoUGFyYW1zVG9VcmxRdWVyeSB9IGZyb20gJy4vdXRpbHMvcXVlcnlzdHJpbmcnXG5pbXBvcnQgcmVzb2x2ZVJld3JpdGVzIGZyb20gJy4vdXRpbHMvcmVzb2x2ZS1yZXdyaXRlcydcbmltcG9ydCB7IGdldFJvdXRlTWF0Y2hlciB9IGZyb20gJy4vdXRpbHMvcm91dGUtbWF0Y2hlcidcbmltcG9ydCB7IGdldFJvdXRlUmVnZXggfSBmcm9tICcuL3V0aWxzL3JvdXRlLXJlZ2V4J1xuaW1wb3J0IGVzY2FwZVBhdGhEZWxpbWl0ZXJzIGZyb20gJy4vdXRpbHMvZXNjYXBlLXBhdGgtZGVsaW1pdGVycydcblxuaW50ZXJmYWNlIFRyYW5zaXRpb25PcHRpb25zIHtcbiAgc2hhbGxvdz86IGJvb2xlYW5cbn1cblxuaW50ZXJmYWNlIE5leHRIaXN0b3J5U3RhdGUge1xuICB1cmw6IHN0cmluZ1xuICBhczogc3RyaW5nXG4gIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zXG59XG5cbnR5cGUgSGlzdG9yeVN0YXRlID0gbnVsbCB8IHsgX19OOiBmYWxzZSB9IHwgKHsgX19OOiB0cnVlIH0gJiBOZXh0SGlzdG9yeVN0YXRlKVxuXG5jb25zdCBiYXNlUGF0aCA9IChwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIGFzIHN0cmluZykgfHwgJydcblxuZnVuY3Rpb24gYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IEVycm9yKCdSb3V0ZSBDYW5jZWxsZWQnKSwge1xuICAgIGNhbmNlbGxlZDogdHJ1ZSxcbiAgfSlcbn1cblxuZnVuY3Rpb24gYWRkUGF0aFByZWZpeChwYXRoOiBzdHJpbmcsIHByZWZpeD86IHN0cmluZykge1xuICByZXR1cm4gcHJlZml4ICYmIHBhdGguc3RhcnRzV2l0aCgnLycpXG4gICAgPyBwYXRoID09PSAnLydcbiAgICAgID8gbm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2gocHJlZml4KVxuICAgICAgOiBgJHtwcmVmaXh9JHtwYXRofWBcbiAgICA6IHBhdGhcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZExvY2FsZShcbiAgcGF0aDogc3RyaW5nLFxuICBsb2NhbGU/OiBzdHJpbmcsXG4gIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbikge1xuICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX2kxOG5fU1VQUE9SVCkge1xuICAgIHJldHVybiBsb2NhbGUgJiYgbG9jYWxlICE9PSBkZWZhdWx0TG9jYWxlICYmICFwYXRoLnN0YXJ0c1dpdGgoJy8nICsgbG9jYWxlKVxuICAgICAgPyBhZGRQYXRoUHJlZml4KHBhdGgsICcvJyArIGxvY2FsZSlcbiAgICAgIDogcGF0aFxuICB9XG4gIHJldHVybiBwYXRoXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWxMb2NhbGUocGF0aDogc3RyaW5nLCBsb2NhbGU/OiBzdHJpbmcpIHtcbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9pMThuX1NVUFBPUlQpIHtcbiAgICByZXR1cm4gbG9jYWxlICYmIHBhdGguc3RhcnRzV2l0aCgnLycgKyBsb2NhbGUpXG4gICAgICA/IHBhdGguc3Vic3RyKGxvY2FsZS5sZW5ndGggKyAxKSB8fCAnLydcbiAgICAgIDogcGF0aFxuICB9XG4gIHJldHVybiBwYXRoXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNCYXNlUGF0aChwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIHBhdGggPT09IGJhc2VQYXRoIHx8IHBhdGguc3RhcnRzV2l0aChiYXNlUGF0aCArICcvJylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEJhc2VQYXRoKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIHdlIG9ubHkgYWRkIHRoZSBiYXNlcGF0aCBvbiByZWxhdGl2ZSB1cmxzXG4gIHJldHVybiBhZGRQYXRoUHJlZml4KHBhdGgsIGJhc2VQYXRoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsQmFzZVBhdGgocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHBhdGguc2xpY2UoYmFzZVBhdGgubGVuZ3RoKSB8fCAnLydcbn1cblxuLyoqXG4gKiBEZXRlY3RzIHdoZXRoZXIgYSBnaXZlbiB1cmwgaXMgcm91dGFibGUgYnkgdGhlIE5leHQuanMgcm91dGVyIChicm93c2VyIG9ubHkpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNMb2NhbFVSTCh1cmw6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBpZiAodXJsLnN0YXJ0c1dpdGgoJy8nKSkgcmV0dXJuIHRydWVcbiAgdHJ5IHtcbiAgICAvLyBhYnNvbHV0ZSB1cmxzIGNhbiBiZSBsb2NhbCBpZiB0aGV5IGFyZSBvbiB0aGUgc2FtZSBvcmlnaW5cbiAgICBjb25zdCBsb2NhdGlvbk9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKClcbiAgICBjb25zdCByZXNvbHZlZCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbk9yaWdpbilcbiAgICByZXR1cm4gcmVzb2x2ZWQub3JpZ2luID09PSBsb2NhdGlvbk9yaWdpbiAmJiBoYXNCYXNlUGF0aChyZXNvbHZlZC5wYXRobmFtZSlcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbnR5cGUgVXJsID0gVXJsT2JqZWN0IHwgc3RyaW5nXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnBvbGF0ZUFzKFxuICByb3V0ZTogc3RyaW5nLFxuICBhc1BhdGhuYW1lOiBzdHJpbmcsXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuKSB7XG4gIGxldCBpbnRlcnBvbGF0ZWRSb3V0ZSA9ICcnXG5cbiAgY29uc3QgZHluYW1pY1JlZ2V4ID0gZ2V0Um91dGVSZWdleChyb3V0ZSlcbiAgY29uc3QgZHluYW1pY0dyb3VwcyA9IGR5bmFtaWNSZWdleC5ncm91cHNcbiAgY29uc3QgZHluYW1pY01hdGNoZXMgPVxuICAgIC8vIFRyeSB0byBtYXRjaCB0aGUgZHluYW1pYyByb3V0ZSBhZ2FpbnN0IHRoZSBhc1BhdGhcbiAgICAoYXNQYXRobmFtZSAhPT0gcm91dGUgPyBnZXRSb3V0ZU1hdGNoZXIoZHluYW1pY1JlZ2V4KShhc1BhdGhuYW1lKSA6ICcnKSB8fFxuICAgIC8vIEZhbGwgYmFjayB0byByZWFkaW5nIHRoZSB2YWx1ZXMgZnJvbSB0aGUgaHJlZlxuICAgIC8vIFRPRE86IHNob3VsZCB0aGlzIHRha2UgcHJpb3JpdHk7IGFsc28gbmVlZCB0byBjaGFuZ2UgaW4gdGhlIHJvdXRlci5cbiAgICBxdWVyeVxuXG4gIGludGVycG9sYXRlZFJvdXRlID0gcm91dGVcbiAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmtleXMoZHluYW1pY0dyb3VwcylcblxuICBpZiAoXG4gICAgIXBhcmFtcy5ldmVyeSgocGFyYW0pID0+IHtcbiAgICAgIGxldCB2YWx1ZSA9IGR5bmFtaWNNYXRjaGVzW3BhcmFtXSB8fCAnJ1xuICAgICAgY29uc3QgeyByZXBlYXQsIG9wdGlvbmFsIH0gPSBkeW5hbWljR3JvdXBzW3BhcmFtXVxuXG4gICAgICAvLyBzdXBwb3J0IHNpbmdsZS1sZXZlbCBjYXRjaC1hbGxcbiAgICAgIC8vIFRPRE86IG1vcmUgcm9idXN0IGhhbmRsaW5nIGZvciB1c2VyLWVycm9yIChwYXNzaW5nIGAvYClcbiAgICAgIGxldCByZXBsYWNlZCA9IGBbJHtyZXBlYXQgPyAnLi4uJyA6ICcnfSR7cGFyYW19XWBcbiAgICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICByZXBsYWNlZCA9IGAkeyF2YWx1ZSA/ICcvJyA6ICcnfVske3JlcGxhY2VkfV1gXG4gICAgICB9XG4gICAgICBpZiAocmVwZWF0ICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkgdmFsdWUgPSBbdmFsdWVdXG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIChvcHRpb25hbCB8fCBwYXJhbSBpbiBkeW5hbWljTWF0Y2hlcykgJiZcbiAgICAgICAgLy8gSW50ZXJwb2xhdGUgZ3JvdXAgaW50byBkYXRhIFVSTCBpZiBwcmVzZW50XG4gICAgICAgIChpbnRlcnBvbGF0ZWRSb3V0ZSA9XG4gICAgICAgICAgaW50ZXJwb2xhdGVkUm91dGUhLnJlcGxhY2UoXG4gICAgICAgICAgICByZXBsYWNlZCxcbiAgICAgICAgICAgIHJlcGVhdFxuICAgICAgICAgICAgICA/ICh2YWx1ZSBhcyBzdHJpbmdbXSkubWFwKGVzY2FwZVBhdGhEZWxpbWl0ZXJzKS5qb2luKCcvJylcbiAgICAgICAgICAgICAgOiBlc2NhcGVQYXRoRGVsaW1pdGVycyh2YWx1ZSBhcyBzdHJpbmcpXG4gICAgICAgICAgKSB8fCAnLycpXG4gICAgICApXG4gICAgfSlcbiAgKSB7XG4gICAgaW50ZXJwb2xhdGVkUm91dGUgPSAnJyAvLyBkaWQgbm90IHNhdGlzZnkgYWxsIHJlcXVpcmVtZW50c1xuXG4gICAgLy8gbi5iLiBXZSBpZ25vcmUgdGhpcyBlcnJvciBiZWNhdXNlIHdlIGhhbmRsZSB3YXJuaW5nIGZvciB0aGlzIGNhc2UgaW5cbiAgICAvLyBkZXZlbG9wbWVudCBpbiB0aGUgYDxMaW5rPmAgY29tcG9uZW50IGRpcmVjdGx5LlxuICB9XG4gIHJldHVybiB7XG4gICAgcGFyYW1zLFxuICAgIHJlc3VsdDogaW50ZXJwb2xhdGVkUm91dGUsXG4gIH1cbn1cblxuZnVuY3Rpb24gb21pdFBhcm1zRnJvbVF1ZXJ5KHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSwgcGFyYW1zOiBzdHJpbmdbXSkge1xuICBjb25zdCBmaWx0ZXJlZFF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSA9IHt9XG5cbiAgT2JqZWN0LmtleXMocXVlcnkpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmICghcGFyYW1zLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIGZpbHRlcmVkUXVlcnlba2V5XSA9IHF1ZXJ5W2tleV1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBmaWx0ZXJlZFF1ZXJ5XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgYSBnaXZlbiBoeXBlcmxpbmsgd2l0aCBhIGNlcnRhaW4gcm91dGVyIHN0YXRlIChiYXNlUGF0aCBub3QgaW5jbHVkZWQpLlxuICogUHJlc2VydmVzIGFic29sdXRlIHVybHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlSHJlZihcbiAgY3VycmVudFBhdGg6IHN0cmluZyxcbiAgaHJlZjogVXJsLFxuICByZXNvbHZlQXM/OiBib29sZWFuXG4pOiBzdHJpbmcge1xuICAvLyB3ZSB1c2UgYSBkdW1teSBiYXNlIHVybCBmb3IgcmVsYXRpdmUgdXJsc1xuICBjb25zdCBiYXNlID0gbmV3IFVSTChjdXJyZW50UGF0aCwgJ2h0dHA6Ly9uJylcbiAgY29uc3QgdXJsQXNTdHJpbmcgPVxuICAgIHR5cGVvZiBocmVmID09PSAnc3RyaW5nJyA/IGhyZWYgOiBmb3JtYXRXaXRoVmFsaWRhdGlvbihocmVmKVxuICB0cnkge1xuICAgIGNvbnN0IGZpbmFsVXJsID0gbmV3IFVSTCh1cmxBc1N0cmluZywgYmFzZSlcbiAgICBmaW5hbFVybC5wYXRobmFtZSA9IG5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKGZpbmFsVXJsLnBhdGhuYW1lKVxuICAgIGxldCBpbnRlcnBvbGF0ZWRBcyA9ICcnXG5cbiAgICBpZiAoXG4gICAgICBpc0R5bmFtaWNSb3V0ZShmaW5hbFVybC5wYXRobmFtZSkgJiZcbiAgICAgIGZpbmFsVXJsLnNlYXJjaFBhcmFtcyAmJlxuICAgICAgcmVzb2x2ZUFzXG4gICAgKSB7XG4gICAgICBjb25zdCBxdWVyeSA9IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoZmluYWxVcmwuc2VhcmNoUGFyYW1zKVxuXG4gICAgICBjb25zdCB7IHJlc3VsdCwgcGFyYW1zIH0gPSBpbnRlcnBvbGF0ZUFzKFxuICAgICAgICBmaW5hbFVybC5wYXRobmFtZSxcbiAgICAgICAgZmluYWxVcmwucGF0aG5hbWUsXG4gICAgICAgIHF1ZXJ5XG4gICAgICApXG5cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkQXMgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbih7XG4gICAgICAgICAgcGF0aG5hbWU6IHJlc3VsdCxcbiAgICAgICAgICBoYXNoOiBmaW5hbFVybC5oYXNoLFxuICAgICAgICAgIHF1ZXJ5OiBvbWl0UGFybXNGcm9tUXVlcnkocXVlcnksIHBhcmFtcyksXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIG9yaWdpbiBkaWRuJ3QgY2hhbmdlLCBpdCBtZWFucyB3ZSByZWNlaXZlZCBhIHJlbGF0aXZlIGhyZWZcbiAgICBjb25zdCByZXNvbHZlZEhyZWYgPVxuICAgICAgZmluYWxVcmwub3JpZ2luID09PSBiYXNlLm9yaWdpblxuICAgICAgICA/IGZpbmFsVXJsLmhyZWYuc2xpY2UoZmluYWxVcmwub3JpZ2luLmxlbmd0aClcbiAgICAgICAgOiBmaW5hbFVybC5ocmVmXG5cbiAgICByZXR1cm4gKHJlc29sdmVBc1xuICAgICAgPyBbcmVzb2x2ZWRIcmVmLCBpbnRlcnBvbGF0ZWRBcyB8fCByZXNvbHZlZEhyZWZdXG4gICAgICA6IHJlc29sdmVkSHJlZikgYXMgc3RyaW5nXG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gKHJlc29sdmVBcyA/IFt1cmxBc1N0cmluZ10gOiB1cmxBc1N0cmluZykgYXMgc3RyaW5nXG4gIH1cbn1cblxuY29uc3QgUEFHRV9MT0FEX0VSUk9SID0gU3ltYm9sKCdQQUdFX0xPQURfRVJST1InKVxuZXhwb3J0IGZ1bmN0aW9uIG1hcmtMb2FkaW5nRXJyb3IoZXJyOiBFcnJvcik6IEVycm9yIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnIsIFBBR0VfTE9BRF9FUlJPUiwge30pXG59XG5cbmZ1bmN0aW9uIHByZXBhcmVVcmxBcyhyb3V0ZXI6IE5leHRSb3V0ZXIsIHVybDogVXJsLCBhczogVXJsKSB7XG4gIC8vIElmIHVybCBhbmQgYXMgcHJvdmlkZWQgYXMgYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uLFxuICAvLyB3ZSdsbCBmb3JtYXQgdGhlbSBpbnRvIHRoZSBzdHJpbmcgdmVyc2lvbiBoZXJlLlxuICByZXR1cm4ge1xuICAgIHVybDogYWRkQmFzZVBhdGgocmVzb2x2ZUhyZWYocm91dGVyLnBhdGhuYW1lLCB1cmwpKSxcbiAgICBhczogYXMgPyBhZGRCYXNlUGF0aChyZXNvbHZlSHJlZihyb3V0ZXIucGF0aG5hbWUsIGFzKSkgOiBhcyxcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBCYXNlUm91dGVyID0ge1xuICByb3V0ZTogc3RyaW5nXG4gIHBhdGhuYW1lOiBzdHJpbmdcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIGFzUGF0aDogc3RyaW5nXG4gIGJhc2VQYXRoOiBzdHJpbmdcbiAgbG9jYWxlPzogc3RyaW5nXG4gIGxvY2FsZXM/OiBzdHJpbmdbXVxuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIE5leHRSb3V0ZXIgPSBCYXNlUm91dGVyICZcbiAgUGljazxcbiAgICBSb3V0ZXIsXG4gICAgfCAncHVzaCdcbiAgICB8ICdyZXBsYWNlJ1xuICAgIHwgJ3JlbG9hZCdcbiAgICB8ICdiYWNrJ1xuICAgIHwgJ3ByZWZldGNoJ1xuICAgIHwgJ2JlZm9yZVBvcFN0YXRlJ1xuICAgIHwgJ2V2ZW50cydcbiAgICB8ICdpc0ZhbGxiYWNrJ1xuICA+XG5cbmV4cG9ydCB0eXBlIFByZWZldGNoT3B0aW9ucyA9IHtcbiAgcHJpb3JpdHk/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIFByaXZhdGVSb3V0ZUluZm8gPSB7XG4gIENvbXBvbmVudDogQ29tcG9uZW50VHlwZVxuICBzdHlsZVNoZWV0czogU3R5bGVTaGVldFR1cGxlW11cbiAgX19OX1NTRz86IGJvb2xlYW5cbiAgX19OX1NTUD86IGJvb2xlYW5cbiAgcHJvcHM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gIGVycj86IEVycm9yXG4gIGVycm9yPzogYW55XG59XG5cbmV4cG9ydCB0eXBlIEFwcFByb3BzID0gUGljazxQcml2YXRlUm91dGVJbmZvLCAnQ29tcG9uZW50JyB8ICdlcnInPiAmIHtcbiAgcm91dGVyOiBSb3V0ZXJcbn0gJiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG5leHBvcnQgdHlwZSBBcHBDb21wb25lbnQgPSBDb21wb25lbnRUeXBlPEFwcFByb3BzPlxuXG50eXBlIFN1YnNjcmlwdGlvbiA9IChkYXRhOiBQcml2YXRlUm91dGVJbmZvLCBBcHA6IEFwcENvbXBvbmVudCkgPT4gUHJvbWlzZTx2b2lkPlxuXG50eXBlIEJlZm9yZVBvcFN0YXRlQ2FsbGJhY2sgPSAoc3RhdGU6IE5leHRIaXN0b3J5U3RhdGUpID0+IGJvb2xlYW5cblxudHlwZSBDb21wb25lbnRMb2FkQ2FuY2VsID0gKCgpID0+IHZvaWQpIHwgbnVsbFxuXG50eXBlIEhpc3RvcnlNZXRob2QgPSAncmVwbGFjZVN0YXRlJyB8ICdwdXNoU3RhdGUnXG5cbmNvbnN0IG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uID1cbiAgcHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTiAmJlxuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAnc2Nyb2xsUmVzdG9yYXRpb24nIGluIHdpbmRvdy5oaXN0b3J5XG5cbmZ1bmN0aW9uIGZldGNoUmV0cnkodXJsOiBzdHJpbmcsIGF0dGVtcHRzOiBudW1iZXIpOiBQcm9taXNlPGFueT4ge1xuICByZXR1cm4gZmV0Y2godXJsLCB7XG4gICAgLy8gQ29va2llcyBhcmUgcmVxdWlyZWQgdG8gYmUgcHJlc2VudCBmb3IgTmV4dC5qcycgU1NHIFwiUHJldmlldyBNb2RlXCIuXG4gICAgLy8gQ29va2llcyBtYXkgYWxzbyBiZSByZXF1aXJlZCBmb3IgYGdldFNlcnZlclNpZGVQcm9wc2AuXG4gICAgLy9cbiAgICAvLyA+IGBmZXRjaGAgd29u4oCZdCBzZW5kIGNvb2tpZXMsIHVubGVzcyB5b3Ugc2V0IHRoZSBjcmVkZW50aWFscyBpbml0XG4gICAgLy8gPiBvcHRpb24uXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSS9Vc2luZ19GZXRjaFxuICAgIC8vXG4gICAgLy8gPiBGb3IgbWF4aW11bSBicm93c2VyIGNvbXBhdGliaWxpdHkgd2hlbiBpdCBjb21lcyB0byBzZW5kaW5nICZcbiAgICAvLyA+IHJlY2VpdmluZyBjb29raWVzLCBhbHdheXMgc3VwcGx5IHRoZSBgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidgXG4gICAgLy8gPiBvcHRpb24gaW5zdGVhZCBvZiByZWx5aW5nIG9uIHRoZSBkZWZhdWx0LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gjY2F2ZWF0c1xuICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICB9KS50aGVuKChyZXMpID0+IHtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgaWYgKGF0dGVtcHRzID4gMSAmJiByZXMuc3RhdHVzID49IDUwMCkge1xuICAgICAgICByZXR1cm4gZmV0Y2hSZXRyeSh1cmwsIGF0dGVtcHRzIC0gMSlcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc3RhdGljIHByb3BzYClcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzLmpzb24oKVxuICB9KVxufVxuXG5mdW5jdGlvbiBmZXRjaE5leHREYXRhKGRhdGFIcmVmOiBzdHJpbmcsIGlzU2VydmVyUmVuZGVyOiBib29sZWFuKSB7XG4gIHJldHVybiBmZXRjaFJldHJ5KGRhdGFIcmVmLCBpc1NlcnZlclJlbmRlciA/IDMgOiAxKS5jYXRjaCgoZXJyOiBFcnJvcikgPT4ge1xuICAgIC8vIFdlIHNob3VsZCBvbmx5IHRyaWdnZXIgYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uIGlmIHRoaXMgd2FzIGNhdXNlZFxuICAgIC8vIG9uIGEgY2xpZW50LXNpZGUgdHJhbnNpdGlvbi4gT3RoZXJ3aXNlLCB3ZSdkIGdldCBpbnRvIGFuIGluZmluaXRlXG4gICAgLy8gbG9vcC5cbiAgICBpZiAoIWlzU2VydmVyUmVuZGVyKSB7XG4gICAgICBtYXJrTG9hZGluZ0Vycm9yKGVycilcbiAgICB9XG4gICAgdGhyb3cgZXJyXG4gIH0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJvdXRlciBpbXBsZW1lbnRzIEJhc2VSb3V0ZXIge1xuICByb3V0ZTogc3RyaW5nXG4gIHBhdGhuYW1lOiBzdHJpbmdcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIGFzUGF0aDogc3RyaW5nXG4gIGJhc2VQYXRoOiBzdHJpbmdcblxuICAvKipcbiAgICogTWFwIG9mIGFsbCBjb21wb25lbnRzIGxvYWRlZCBpbiBgUm91dGVyYFxuICAgKi9cbiAgY29tcG9uZW50czogeyBbcGF0aG5hbWU6IHN0cmluZ106IFByaXZhdGVSb3V0ZUluZm8gfVxuICAvLyBTdGF0aWMgRGF0YSBDYWNoZVxuICBzZGM6IHsgW2FzUGF0aDogc3RyaW5nXTogb2JqZWN0IH0gPSB7fVxuICBzdWI6IFN1YnNjcmlwdGlvblxuICBjbGM6IENvbXBvbmVudExvYWRDYW5jZWxcbiAgcGFnZUxvYWRlcjogYW55XG4gIF9icHM6IEJlZm9yZVBvcFN0YXRlQ2FsbGJhY2sgfCB1bmRlZmluZWRcbiAgZXZlbnRzOiBNaXR0RW1pdHRlclxuICBfd3JhcEFwcDogKEFwcDogQXBwQ29tcG9uZW50KSA9PiBhbnlcbiAgaXNTc3I6IGJvb2xlYW5cbiAgaXNGYWxsYmFjazogYm9vbGVhblxuICBfaW5GbGlnaHRSb3V0ZT86IHN0cmluZ1xuICBfc2hhbGxvdz86IGJvb2xlYW5cbiAgbG9jYWxlPzogc3RyaW5nXG4gIGxvY2FsZXM/OiBzdHJpbmdbXVxuICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG5cbiAgc3RhdGljIGV2ZW50czogTWl0dEVtaXR0ZXIgPSBtaXR0KClcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwYXRobmFtZTogc3RyaW5nLFxuICAgIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSxcbiAgICBhczogc3RyaW5nLFxuICAgIHtcbiAgICAgIGluaXRpYWxQcm9wcyxcbiAgICAgIHBhZ2VMb2FkZXIsXG4gICAgICBBcHAsXG4gICAgICB3cmFwQXBwLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgaW5pdGlhbFN0eWxlU2hlZXRzLFxuICAgICAgZXJyLFxuICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgaXNGYWxsYmFjayxcbiAgICAgIGxvY2FsZSxcbiAgICAgIGxvY2FsZXMsXG4gICAgICBkZWZhdWx0TG9jYWxlLFxuICAgIH06IHtcbiAgICAgIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uXG4gICAgICBpbml0aWFsUHJvcHM6IGFueVxuICAgICAgcGFnZUxvYWRlcjogYW55XG4gICAgICBDb21wb25lbnQ6IENvbXBvbmVudFR5cGVcbiAgICAgIGluaXRpYWxTdHlsZVNoZWV0czogU3R5bGVTaGVldFR1cGxlW11cbiAgICAgIEFwcDogQXBwQ29tcG9uZW50XG4gICAgICB3cmFwQXBwOiAoQXBwOiBBcHBDb21wb25lbnQpID0+IGFueVxuICAgICAgZXJyPzogRXJyb3JcbiAgICAgIGlzRmFsbGJhY2s6IGJvb2xlYW5cbiAgICAgIGxvY2FsZT86IHN0cmluZ1xuICAgICAgbG9jYWxlcz86IHN0cmluZ1tdXG4gICAgICBkZWZhdWx0TG9jYWxlPzogc3RyaW5nXG4gICAgfVxuICApIHtcbiAgICAvLyByZXByZXNlbnRzIHRoZSBjdXJyZW50IGNvbXBvbmVudCBrZXlcbiAgICB0aGlzLnJvdXRlID0gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2gocGF0aG5hbWUpXG5cbiAgICAvLyBzZXQgdXAgdGhlIGNvbXBvbmVudCBjYWNoZSAoYnkgcm91dGUga2V5cylcbiAgICB0aGlzLmNvbXBvbmVudHMgPSB7fVxuICAgIC8vIFdlIHNob3VsZCBub3Qga2VlcCB0aGUgY2FjaGUsIGlmIHRoZXJlJ3MgYW4gZXJyb3JcbiAgICAvLyBPdGhlcndpc2UsIHRoaXMgY2F1c2UgaXNzdWVzIHdoZW4gd2hlbiBnb2luZyBiYWNrIGFuZFxuICAgIC8vIGNvbWUgYWdhaW4gdG8gdGhlIGVycm9yZWQgcGFnZS5cbiAgICBpZiAocGF0aG5hbWUgIT09ICcvX2Vycm9yJykge1xuICAgICAgdGhpcy5jb21wb25lbnRzW3RoaXMucm91dGVdID0ge1xuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIHN0eWxlU2hlZXRzOiBpbml0aWFsU3R5bGVTaGVldHMsXG4gICAgICAgIHByb3BzOiBpbml0aWFsUHJvcHMsXG4gICAgICAgIGVycixcbiAgICAgICAgX19OX1NTRzogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NHLFxuICAgICAgICBfX05fU1NQOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU1AsXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jb21wb25lbnRzWycvX2FwcCddID0ge1xuICAgICAgQ29tcG9uZW50OiBBcHAgYXMgQ29tcG9uZW50VHlwZSxcbiAgICAgIHN0eWxlU2hlZXRzOiBbXG4gICAgICAgIC8qIC9fYXBwIGRvZXMgbm90IG5lZWQgaXRzIHN0eWxlc2hlZXRzIG1hbmFnZWQgKi9cbiAgICAgIF0sXG4gICAgfVxuXG4gICAgLy8gQmFja3dhcmRzIGNvbXBhdCBmb3IgUm91dGVyLnJvdXRlci5ldmVudHNcbiAgICAvLyBUT0RPOiBTaG91bGQgYmUgcmVtb3ZlIHRoZSBmb2xsb3dpbmcgbWFqb3IgdmVyc2lvbiBhcyBpdCB3YXMgbmV2ZXIgZG9jdW1lbnRlZFxuICAgIHRoaXMuZXZlbnRzID0gUm91dGVyLmV2ZW50c1xuXG4gICAgdGhpcy5wYWdlTG9hZGVyID0gcGFnZUxvYWRlclxuICAgIHRoaXMucGF0aG5hbWUgPSBwYXRobmFtZVxuICAgIHRoaXMucXVlcnkgPSBxdWVyeVxuICAgIC8vIGlmIGF1dG8gcHJlcmVuZGVyZWQgYW5kIGR5bmFtaWMgcm91dGUgd2FpdCB0byB1cGRhdGUgYXNQYXRoXG4gICAgLy8gdW50aWwgYWZ0ZXIgbW91bnQgdG8gcHJldmVudCBoeWRyYXRpb24gbWlzbWF0Y2hcbiAgICB0aGlzLmFzUGF0aCA9XG4gICAgICAvLyBAdHMtaWdub3JlIHRoaXMgaXMgdGVtcG9yYXJpbHkgZ2xvYmFsIChhdHRhY2hlZCB0byB3aW5kb3cpXG4gICAgICBpc0R5bmFtaWNSb3V0ZShwYXRobmFtZSkgJiYgX19ORVhUX0RBVEFfXy5hdXRvRXhwb3J0ID8gcGF0aG5hbWUgOiBhc1xuICAgIHRoaXMuYmFzZVBhdGggPSBiYXNlUGF0aFxuICAgIHRoaXMuc3ViID0gc3Vic2NyaXB0aW9uXG4gICAgdGhpcy5jbGMgPSBudWxsXG4gICAgdGhpcy5fd3JhcEFwcCA9IHdyYXBBcHBcbiAgICAvLyBtYWtlIHN1cmUgdG8gaWdub3JlIGV4dHJhIHBvcFN0YXRlIGluIHNhZmFyaSBvbiBuYXZpZ2F0aW5nXG4gICAgLy8gYmFjayBmcm9tIGV4dGVybmFsIHNpdGVcbiAgICB0aGlzLmlzU3NyID0gdHJ1ZVxuXG4gICAgdGhpcy5pc0ZhbGxiYWNrID0gaXNGYWxsYmFja1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9pMThuX1NVUFBPUlQpIHtcbiAgICAgIHRoaXMubG9jYWxlID0gbG9jYWxlXG4gICAgICB0aGlzLmxvY2FsZXMgPSBsb2NhbGVzXG4gICAgICB0aGlzLmRlZmF1bHRMb2NhbGUgPSBkZWZhdWx0TG9jYWxlXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgXCJhc1wiIGRvZXNuJ3Qgc3RhcnQgd2l0aCBkb3VibGUgc2xhc2hlcyBvciBlbHNlIGl0IGNhblxuICAgICAgLy8gdGhyb3cgYW4gZXJyb3IgYXMgaXQncyBjb25zaWRlcmVkIGludmFsaWRcbiAgICAgIGlmIChhcy5zdWJzdHIoMCwgMikgIT09ICcvLycpIHtcbiAgICAgICAgLy8gaW4gb3JkZXIgZm9yIGBlLnN0YXRlYCB0byB3b3JrIG9uIHRoZSBgb25wb3BzdGF0ZWAgZXZlbnRcbiAgICAgICAgLy8gd2UgaGF2ZSB0byByZWdpc3RlciB0aGUgaW5pdGlhbCByb3V0ZSB1cG9uIGluaXRpYWxpemF0aW9uXG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXG4gICAgICAgICAgJ3JlcGxhY2VTdGF0ZScsXG4gICAgICAgICAgZm9ybWF0V2l0aFZhbGlkYXRpb24oeyBwYXRobmFtZTogYWRkQmFzZVBhdGgocGF0aG5hbWUpLCBxdWVyeSB9KSxcbiAgICAgICAgICBnZXRVUkwoKVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMub25Qb3BTdGF0ZSlcblxuICAgICAgLy8gZW5hYmxlIGN1c3RvbSBzY3JvbGwgcmVzdG9yYXRpb24gaGFuZGxpbmcgd2hlbiBhdmFpbGFibGVcbiAgICAgIC8vIG90aGVyd2lzZSBmYWxsYmFjayB0byBicm93c2VyJ3MgZGVmYXVsdCBoYW5kbGluZ1xuICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSAnbWFudWFsJ1xuXG4gICAgICAgICAgbGV0IHNjcm9sbERlYm91bmNlVGltZW91dDogdW5kZWZpbmVkIHwgTm9kZUpTLlRpbWVvdXRcblxuICAgICAgICAgIGNvbnN0IGRlYm91bmNlZFNjcm9sbFNhdmUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsRGVib3VuY2VUaW1lb3V0KSBjbGVhclRpbWVvdXQoc2Nyb2xsRGVib3VuY2VUaW1lb3V0KVxuXG4gICAgICAgICAgICBzY3JvbGxEZWJvdW5jZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgeyB1cmwsIGFzOiBjdXJBcywgb3B0aW9ucyB9ID0gaGlzdG9yeS5zdGF0ZVxuICAgICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFxuICAgICAgICAgICAgICAgICdyZXBsYWNlU3RhdGUnLFxuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICBjdXJBcyxcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgICBfTl9YOiB3aW5kb3cuc2Nyb2xsWCxcbiAgICAgICAgICAgICAgICAgIF9OX1k6IHdpbmRvdy5zY3JvbGxZLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0sIDEwKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBkZWJvdW5jZWRTY3JvbGxTYXZlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25Qb3BTdGF0ZSA9IChlOiBQb3BTdGF0ZUV2ZW50KTogdm9pZCA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBlLnN0YXRlIGFzIEhpc3RvcnlTdGF0ZVxuXG4gICAgaWYgKCFzdGF0ZSkge1xuICAgICAgLy8gV2UgZ2V0IHN0YXRlIGFzIHVuZGVmaW5lZCBmb3IgdHdvIHJlYXNvbnMuXG4gICAgICAvLyAgMS4gV2l0aCBvbGRlciBzYWZhcmkgKDwgOCkgYW5kIG9sZGVyIGNocm9tZSAoPCAzNClcbiAgICAgIC8vICAyLiBXaGVuIHRoZSBVUkwgY2hhbmdlZCB3aXRoICNcbiAgICAgIC8vXG4gICAgICAvLyBJbiB0aGUgYm90aCBjYXNlcywgd2UgZG9uJ3QgbmVlZCB0byBwcm9jZWVkIGFuZCBjaGFuZ2UgdGhlIHJvdXRlLlxuICAgICAgLy8gKGFzIGl0J3MgYWxyZWFkeSBjaGFuZ2VkKVxuICAgICAgLy8gQnV0IHdlIGNhbiBzaW1wbHkgcmVwbGFjZSB0aGUgc3RhdGUgd2l0aCB0aGUgbmV3IGNoYW5nZXMuXG4gICAgICAvLyBBY3R1YWxseSwgZm9yICgxKSB3ZSBkb24ndCBuZWVkIHRvIG5vdGhpbmcuIEJ1dCBpdCdzIGhhcmQgdG8gZGV0ZWN0IHRoYXQgZXZlbnQuXG4gICAgICAvLyBTbywgZG9pbmcgdGhlIGZvbGxvd2luZyBmb3IgKDEpIGRvZXMgbm8gaGFybS5cbiAgICAgIGNvbnN0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSB0aGlzXG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKFxuICAgICAgICAncmVwbGFjZVN0YXRlJyxcbiAgICAgICAgZm9ybWF0V2l0aFZhbGlkYXRpb24oeyBwYXRobmFtZTogYWRkQmFzZVBhdGgocGF0aG5hbWUpLCBxdWVyeSB9KSxcbiAgICAgICAgZ2V0VVJMKClcbiAgICAgIClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghc3RhdGUuX19OKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB7IHVybCwgYXMsIG9wdGlvbnMgfSA9IHN0YXRlXG5cbiAgICBjb25zdCB7IHBhdGhuYW1lIH0gPSBwYXJzZVJlbGF0aXZlVXJsKHVybClcblxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCByZS1yZW5kZXIgb24gaW5pdGlhbCBsb2FkLFxuICAgIC8vIGNhbiBiZSBjYXVzZWQgYnkgbmF2aWdhdGluZyBiYWNrIGZyb20gYW4gZXh0ZXJuYWwgc2l0ZVxuICAgIGlmICh0aGlzLmlzU3NyICYmIGFzID09PSB0aGlzLmFzUGF0aCAmJiBwYXRobmFtZSA9PT0gdGhpcy5wYXRobmFtZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGRvd25zdHJlYW0gYXBwbGljYXRpb24gcmV0dXJucyBmYWxzeSwgcmV0dXJuLlxuICAgIC8vIFRoZXkgd2lsbCB0aGVuIGJlIHJlc3BvbnNpYmxlIGZvciBoYW5kbGluZyB0aGUgZXZlbnQuXG4gICAgaWYgKHRoaXMuX2JwcyAmJiAhdGhpcy5fYnBzKHN0YXRlKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5jaGFuZ2UoXG4gICAgICAncmVwbGFjZVN0YXRlJyxcbiAgICAgIHVybCxcbiAgICAgIGFzLFxuICAgICAgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICBzaGFsbG93OiBvcHRpb25zLnNoYWxsb3cgJiYgdGhpcy5fc2hhbGxvdyxcbiAgICAgIH0pXG4gICAgKVxuICB9XG5cbiAgcmVsb2FkKCk6IHZvaWQge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdvIGJhY2sgaW4gaGlzdG9yeVxuICAgKi9cbiAgYmFjaygpIHtcbiAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKClcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhIGBwdXNoU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi9cbiAgcHVzaCh1cmw6IFVybCwgYXM6IFVybCA9IHVybCwgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMgPSB7fSkge1xuICAgIDsoeyB1cmwsIGFzIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpXG4gICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdwdXNoU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHJlcGxhY2VTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqL1xuICByZXBsYWNlKHVybDogVXJsLCBhczogVXJsID0gdXJsLCBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucyA9IHt9KSB7XG4gICAgOyh7IHVybCwgYXMgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCB1cmwsIGFzKSlcbiAgICByZXR1cm4gdGhpcy5jaGFuZ2UoJ3JlcGxhY2VTdGF0ZScsIHVybCwgYXMsIG9wdGlvbnMpXG4gIH1cblxuICBhc3luYyBjaGFuZ2UoXG4gICAgbWV0aG9kOiBIaXN0b3J5TWV0aG9kLFxuICAgIHVybDogc3RyaW5nLFxuICAgIGFzOiBzdHJpbmcsXG4gICAgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnNcbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKCFpc0xvY2FsVVJMKHVybCkpIHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoIShvcHRpb25zIGFzIGFueSkuX2gpIHtcbiAgICAgIHRoaXMuaXNTc3IgPSBmYWxzZVxuICAgIH1cbiAgICAvLyBtYXJraW5nIHJvdXRlIGNoYW5nZXMgYXMgYSBuYXZpZ2F0aW9uIHN0YXJ0IGVudHJ5XG4gICAgaWYgKFNUKSB7XG4gICAgICBwZXJmb3JtYW5jZS5tYXJrKCdyb3V0ZUNoYW5nZScpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2luRmxpZ2h0Um91dGUpIHtcbiAgICAgIHRoaXMuYWJvcnRDb21wb25lbnRMb2FkKHRoaXMuX2luRmxpZ2h0Um91dGUpXG4gICAgfVxuXG4gICAgYXMgPSBhZGRMb2NhbGUoYXMsIHRoaXMubG9jYWxlLCB0aGlzLmRlZmF1bHRMb2NhbGUpXG4gICAgY29uc3QgY2xlYW5lZEFzID0gZGVsTG9jYWxlKFxuICAgICAgaGFzQmFzZVBhdGgoYXMpID8gZGVsQmFzZVBhdGgoYXMpIDogYXMsXG4gICAgICB0aGlzLmxvY2FsZVxuICAgIClcbiAgICB0aGlzLl9pbkZsaWdodFJvdXRlID0gYXNcblxuICAgIC8vIElmIHRoZSB1cmwgY2hhbmdlIGlzIG9ubHkgcmVsYXRlZCB0byBhIGhhc2ggY2hhbmdlXG4gICAgLy8gV2Ugc2hvdWxkIG5vdCBwcm9jZWVkLiBXZSBzaG91bGQgb25seSBjaGFuZ2UgdGhlIHN0YXRlLlxuXG4gICAgLy8gV0FSTklORzogYF9oYCBpcyBhbiBpbnRlcm5hbCBvcHRpb24gZm9yIGhhbmRpbmcgTmV4dC5qcyBjbGllbnQtc2lkZVxuICAgIC8vIGh5ZHJhdGlvbi4gWW91ciBhcHAgc2hvdWxkIF9uZXZlcl8gdXNlIHRoaXMgcHJvcGVydHkuIEl0IG1heSBjaGFuZ2UgYXRcbiAgICAvLyBhbnkgdGltZSB3aXRob3V0IG5vdGljZS5cbiAgICBpZiAoIShvcHRpb25zIGFzIGFueSkuX2ggJiYgdGhpcy5vbmx5QUhhc2hDaGFuZ2UoY2xlYW5lZEFzKSkge1xuICAgICAgdGhpcy5hc1BhdGggPSBjbGVhbmVkQXNcbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZVN0YXJ0JywgYXMpXG4gICAgICAvLyBUT0RPOiBkbyB3ZSBuZWVkIHRoZSByZXNvbHZlZCBocmVmIHdoZW4gb25seSBhIGhhc2ggY2hhbmdlP1xuICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMpXG4gICAgICB0aGlzLnNjcm9sbFRvSGFzaChjbGVhbmVkQXMpXG4gICAgICB0aGlzLm5vdGlmeSh0aGlzLmNvbXBvbmVudHNbdGhpcy5yb3V0ZV0pXG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2hhc2hDaGFuZ2VDb21wbGV0ZScsIGFzKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvLyBUaGUgYnVpbGQgbWFuaWZlc3QgbmVlZHMgdG8gYmUgbG9hZGVkIGJlZm9yZSBhdXRvLXN0YXRpYyBkeW5hbWljIHBhZ2VzXG4gICAgLy8gZ2V0IHRoZWlyIHF1ZXJ5IHBhcmFtZXRlcnMgdG8gYWxsb3cgZW5zdXJpbmcgdGhleSBjYW4gYmUgcGFyc2VkIHByb3Blcmx5XG4gICAgLy8gd2hlbiByZXdyaXR0ZW4gdG9cbiAgICBjb25zdCBwYWdlcyA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpXG4gICAgY29uc3QgeyBfX3Jld3JpdGVzOiByZXdyaXRlcyB9ID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLnByb21pc2VkQnVpbGRNYW5pZmVzdFxuXG4gICAgbGV0IHBhcnNlZCA9IHBhcnNlUmVsYXRpdmVVcmwodXJsKVxuXG4gICAgbGV0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSBwYXJzZWRcblxuICAgIHBhcnNlZCA9IHRoaXMuX3Jlc29sdmVIcmVmKHBhcnNlZCwgcGFnZXMpIGFzIHR5cGVvZiBwYXJzZWRcblxuICAgIGlmIChwYXJzZWQucGF0aG5hbWUgIT09IHBhdGhuYW1lKSB7XG4gICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZVxuICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuICAgIH1cblxuICAgIC8vIHVybCBhbmQgYXMgc2hvdWxkIGFsd2F5cyBiZSBwcmVmaXhlZCB3aXRoIGJhc2VQYXRoIGJ5IHRoaXNcbiAgICAvLyBwb2ludCBieSBlaXRoZXIgbmV4dC9saW5rIG9yIHJvdXRlci5wdXNoL3JlcGxhY2Ugc28gc3RyaXAgdGhlXG4gICAgLy8gYmFzZVBhdGggZnJvbSB0aGUgcGF0aG5hbWUgdG8gbWF0Y2ggdGhlIHBhZ2VzIGRpciAxLXRvLTFcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgICA/IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKGRlbEJhc2VQYXRoKHBhdGhuYW1lKSlcbiAgICAgIDogcGF0aG5hbWVcblxuICAgIC8vIElmIGFza2VkIHRvIGNoYW5nZSB0aGUgY3VycmVudCBVUkwgd2Ugc2hvdWxkIHJlbG9hZCB0aGUgY3VycmVudCBwYWdlXG4gICAgLy8gKG5vdCBsb2NhdGlvbi5yZWxvYWQoKSBidXQgcmVsb2FkIGdldEluaXRpYWxQcm9wcyBhbmQgb3RoZXIgTmV4dC5qcyBzdHVmZnMpXG4gICAgLy8gV2UgYWxzbyBuZWVkIHRvIHNldCB0aGUgbWV0aG9kID0gcmVwbGFjZVN0YXRlIGFsd2F5c1xuICAgIC8vIGFzIHRoaXMgc2hvdWxkIG5vdCBnbyBpbnRvIHRoZSBoaXN0b3J5IChUaGF0J3MgaG93IGJyb3dzZXJzIHdvcmspXG4gICAgLy8gV2Ugc2hvdWxkIGNvbXBhcmUgdGhlIG5ldyBhc1BhdGggdG8gdGhlIGN1cnJlbnQgYXNQYXRoLCBub3QgdGhlIHVybFxuICAgIGlmICghdGhpcy51cmxJc05ldyhjbGVhbmVkQXMpKSB7XG4gICAgICBtZXRob2QgPSAncmVwbGFjZVN0YXRlJ1xuICAgIH1cblxuICAgIGxldCByb3V0ZSA9IHJlbW92ZVBhdGhUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKVxuICAgIGNvbnN0IHsgc2hhbGxvdyA9IGZhbHNlIH0gPSBvcHRpb25zXG5cbiAgICAvLyB3ZSBuZWVkIHRvIHJlc29sdmUgdGhlIGFzIHZhbHVlIHVzaW5nIHJld3JpdGVzIGZvciBkeW5hbWljIFNTR1xuICAgIC8vIHBhZ2VzIHRvIGFsbG93IGJ1aWxkaW5nIHRoZSBkYXRhIFVSTCBjb3JyZWN0bHlcbiAgICBsZXQgcmVzb2x2ZWRBcyA9IGFzXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUykge1xuICAgICAgcmVzb2x2ZWRBcyA9IHJlc29sdmVSZXdyaXRlcyhcbiAgICAgICAgcGFyc2VSZWxhdGl2ZVVybChhcykucGF0aG5hbWUsXG4gICAgICAgIHBhZ2VzLFxuICAgICAgICBiYXNlUGF0aCxcbiAgICAgICAgcmV3cml0ZXMsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICAocDogc3RyaW5nKSA9PiB0aGlzLl9yZXNvbHZlSHJlZih7IHBhdGhuYW1lOiBwIH0sIHBhZ2VzKS5wYXRobmFtZSFcbiAgICAgIClcblxuICAgICAgaWYgKHJlc29sdmVkQXMgIT09IGFzKSB7XG4gICAgICAgIGNvbnN0IHBvdGVudGlhbEhyZWYgPSByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChcbiAgICAgICAgICB0aGlzLl9yZXNvbHZlSHJlZihcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIHBhcnNlZCwgeyBwYXRobmFtZTogcmVzb2x2ZWRBcyB9KSxcbiAgICAgICAgICAgIHBhZ2VzLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICApLnBhdGhuYW1lIVxuICAgICAgICApXG5cbiAgICAgICAgLy8gaWYgdGhpcyBkaXJlY3RseSBtYXRjaGVzIGEgcGFnZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaHJlZiB0b1xuICAgICAgICAvLyBhbGxvdyB0aGUgY29ycmVjdCBwYWdlIGNodW5rIHRvIGJlIGxvYWRlZFxuICAgICAgICBpZiAocGFnZXMuaW5jbHVkZXMocG90ZW50aWFsSHJlZikpIHtcbiAgICAgICAgICByb3V0ZSA9IHBvdGVudGlhbEhyZWZcbiAgICAgICAgICBwYXRobmFtZSA9IHBvdGVudGlhbEhyZWZcbiAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZVxuICAgICAgICAgIHVybCA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXNvbHZlZEFzID0gZGVsTG9jYWxlKGRlbEJhc2VQYXRoKHJlc29sdmVkQXMpLCB0aGlzLmxvY2FsZSlcblxuICAgIGlmIChpc0R5bmFtaWNSb3V0ZShyb3V0ZSkpIHtcbiAgICAgIGNvbnN0IHBhcnNlZEFzID0gcGFyc2VSZWxhdGl2ZVVybChyZXNvbHZlZEFzKVxuICAgICAgY29uc3QgYXNQYXRobmFtZSA9IHBhcnNlZEFzLnBhdGhuYW1lXG5cbiAgICAgIGNvbnN0IHJvdXRlUmVnZXggPSBnZXRSb3V0ZVJlZ2V4KHJvdXRlKVxuICAgICAgY29uc3Qgcm91dGVNYXRjaCA9IGdldFJvdXRlTWF0Y2hlcihyb3V0ZVJlZ2V4KShhc1BhdGhuYW1lKVxuICAgICAgY29uc3Qgc2hvdWxkSW50ZXJwb2xhdGUgPSByb3V0ZSA9PT0gYXNQYXRobmFtZVxuICAgICAgY29uc3QgaW50ZXJwb2xhdGVkQXMgPSBzaG91bGRJbnRlcnBvbGF0ZVxuICAgICAgICA/IGludGVycG9sYXRlQXMocm91dGUsIGFzUGF0aG5hbWUsIHF1ZXJ5KVxuICAgICAgICA6ICh7fSBhcyB7IHJlc3VsdDogdW5kZWZpbmVkOyBwYXJhbXM6IHVuZGVmaW5lZCB9KVxuXG4gICAgICBpZiAoIXJvdXRlTWF0Y2ggfHwgKHNob3VsZEludGVycG9sYXRlICYmICFpbnRlcnBvbGF0ZWRBcy5yZXN1bHQpKSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmdQYXJhbXMgPSBPYmplY3Qua2V5cyhyb3V0ZVJlZ2V4Lmdyb3VwcykuZmlsdGVyKFxuICAgICAgICAgIChwYXJhbSkgPT4gIXF1ZXJ5W3BhcmFtXVxuICAgICAgICApXG5cbiAgICAgICAgaWYgKG1pc3NpbmdQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIGAke1xuICAgICAgICAgICAgICAgIHNob3VsZEludGVycG9sYXRlXG4gICAgICAgICAgICAgICAgICA/IGBJbnRlcnBvbGF0aW5nIGhyZWZgXG4gICAgICAgICAgICAgICAgICA6IGBNaXNtYXRjaGluZyBcXGBhc1xcYCBhbmQgXFxgaHJlZlxcYGBcbiAgICAgICAgICAgICAgfSBmYWlsZWQgdG8gbWFudWFsbHkgcHJvdmlkZSBgICtcbiAgICAgICAgICAgICAgICBgdGhlIHBhcmFtczogJHttaXNzaW5nUGFyYW1zLmpvaW4oXG4gICAgICAgICAgICAgICAgICAnLCAnXG4gICAgICAgICAgICAgICAgKX0gaW4gdGhlIFxcYGhyZWZcXGAncyBcXGBxdWVyeVxcYGBcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAoc2hvdWxkSW50ZXJwb2xhdGVcbiAgICAgICAgICAgICAgPyBgVGhlIHByb3ZpZGVkIFxcYGhyZWZcXGAgKCR7dXJsfSkgdmFsdWUgaXMgbWlzc2luZyBxdWVyeSB2YWx1ZXMgKCR7bWlzc2luZ1BhcmFtcy5qb2luKFxuICAgICAgICAgICAgICAgICAgJywgJ1xuICAgICAgICAgICAgICAgICl9KSB0byBiZSBpbnRlcnBvbGF0ZWQgcHJvcGVybHkuIGBcbiAgICAgICAgICAgICAgOiBgVGhlIHByb3ZpZGVkIFxcYGFzXFxgIHZhbHVlICgke2FzUGF0aG5hbWV9KSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgXFxgaHJlZlxcYCB2YWx1ZSAoJHtyb3V0ZX0pLiBgKSArXG4gICAgICAgICAgICAgIGBSZWFkIG1vcmU6IGh0dHBzOi8vZXJyLnNoL3ZlcmNlbC9uZXh0LmpzLyR7XG4gICAgICAgICAgICAgICAgc2hvdWxkSW50ZXJwb2xhdGVcbiAgICAgICAgICAgICAgICAgID8gJ2hyZWYtaW50ZXJwb2xhdGlvbi1mYWlsZWQnXG4gICAgICAgICAgICAgICAgICA6ICdpbmNvbXBhdGlibGUtaHJlZi1hcydcbiAgICAgICAgICAgICAgfWBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSW50ZXJwb2xhdGUpIHtcbiAgICAgICAgYXMgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBwYXJzZWRBcywge1xuICAgICAgICAgICAgcGF0aG5hbWU6IGludGVycG9sYXRlZEFzLnJlc3VsdCxcbiAgICAgICAgICAgIHF1ZXJ5OiBvbWl0UGFybXNGcm9tUXVlcnkocXVlcnksIGludGVycG9sYXRlZEFzLnBhcmFtcyEpLFxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1lcmdlIHBhcmFtcyBpbnRvIGBxdWVyeWAsIG92ZXJ3cml0aW5nIGFueSBzcGVjaWZpZWQgaW4gc2VhcmNoXG4gICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksIHJvdXRlTWF0Y2gpXG4gICAgICB9XG4gICAgfVxuXG4gICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZVN0YXJ0JywgYXMpXG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oXG4gICAgICAgIHJvdXRlLFxuICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgcXVlcnksXG4gICAgICAgIGFzLFxuICAgICAgICBzaGFsbG93XG4gICAgICApXG4gICAgICBsZXQgeyBlcnJvciwgcHJvcHMsIF9fTl9TU0csIF9fTl9TU1AgfSA9IHJvdXRlSW5mb1xuXG4gICAgICAvLyBoYW5kbGUgcmVkaXJlY3Qgb24gY2xpZW50LXRyYW5zaXRpb25cbiAgICAgIGlmIChcbiAgICAgICAgKF9fTl9TU0cgfHwgX19OX1NTUCkgJiZcbiAgICAgICAgcHJvcHMgJiZcbiAgICAgICAgKHByb3BzIGFzIGFueSkucGFnZVByb3BzICYmXG4gICAgICAgIChwcm9wcyBhcyBhbnkpLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1RcbiAgICAgICkge1xuICAgICAgICBjb25zdCBkZXN0aW5hdGlvbiA9IChwcm9wcyBhcyBhbnkpLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1RcblxuICAgICAgICAvLyBjaGVjayBpZiBkZXN0aW5hdGlvbiBpcyBpbnRlcm5hbCAocmVzb2x2ZXMgdG8gYSBwYWdlKSBhbmQgYXR0ZW1wdFxuICAgICAgICAvLyBjbGllbnQtbmF2aWdhdGlvbiBpZiBpdCBpcyBmYWxsaW5nIGJhY2sgdG8gaGFyZCBuYXZpZ2F0aW9uIGlmXG4gICAgICAgIC8vIGl0J3Mgbm90XG4gICAgICAgIGlmIChkZXN0aW5hdGlvbi5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICBjb25zdCBwYXJzZWRIcmVmID0gcGFyc2VSZWxhdGl2ZVVybChkZXN0aW5hdGlvbilcbiAgICAgICAgICB0aGlzLl9yZXNvbHZlSHJlZihwYXJzZWRIcmVmLCBwYWdlcylcblxuICAgICAgICAgIGlmIChwYWdlcy5pbmNsdWRlcyhwYXJzZWRIcmVmLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKFxuICAgICAgICAgICAgICAncmVwbGFjZVN0YXRlJyxcbiAgICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBkZXN0aW5hdGlvblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCkgPT4ge30pXG4gICAgICB9XG5cbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnYmVmb3JlSGlzdG9yeUNoYW5nZScsIGFzKVxuICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICB1cmwsXG4gICAgICAgIGFkZExvY2FsZShhcywgdGhpcy5sb2NhbGUsIHRoaXMuZGVmYXVsdExvY2FsZSksXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIClcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc3QgYXBwQ29tcDogYW55ID0gdGhpcy5jb21wb25lbnRzWycvX2FwcCddLkNvbXBvbmVudFxuICAgICAgICA7KHdpbmRvdyBhcyBhbnkpLm5leHQuaXNQcmVyZW5kZXJlZCA9XG4gICAgICAgICAgYXBwQ29tcC5nZXRJbml0aWFsUHJvcHMgPT09IGFwcENvbXAub3JpZ0dldEluaXRpYWxQcm9wcyAmJlxuICAgICAgICAgICEocm91dGVJbmZvLkNvbXBvbmVudCBhcyBhbnkpLmdldEluaXRpYWxQcm9wc1xuICAgICAgfVxuXG4gICAgICBhd2FpdCB0aGlzLnNldChyb3V0ZSwgcGF0aG5hbWUhLCBxdWVyeSwgY2xlYW5lZEFzLCByb3V0ZUluZm8pLmNhdGNoKFxuICAgICAgICAoZSkgPT4ge1xuICAgICAgICAgIGlmIChlLmNhbmNlbGxlZCkgZXJyb3IgPSBlcnJvciB8fCBlXG4gICAgICAgICAgZWxzZSB0aHJvdyBlXG4gICAgICAgIH1cbiAgICAgIClcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGVycm9yLCBjbGVhbmVkQXMpXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiAmJiAnX05fWCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbygob3B0aW9ucyBhcyBhbnkpLl9OX1gsIChvcHRpb25zIGFzIGFueSkuX05fWSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUNvbXBsZXRlJywgYXMpXG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIGNoYW5nZVN0YXRlKFxuICAgIG1ldGhvZDogSGlzdG9yeU1ldGhvZCxcbiAgICB1cmw6IHN0cmluZyxcbiAgICBhczogc3RyaW5nLFxuICAgIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zID0ge31cbiAgKTogdm9pZCB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5IGlzIG5vdCBhdmFpbGFibGUuYClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnlbbWV0aG9kXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgV2FybmluZzogd2luZG93Lmhpc3RvcnkuJHttZXRob2R9IGlzIG5vdCBhdmFpbGFibGVgKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWV0aG9kICE9PSAncHVzaFN0YXRlJyB8fCBnZXRVUkwoKSAhPT0gYXMpIHtcbiAgICAgIHRoaXMuX3NoYWxsb3cgPSBvcHRpb25zLnNoYWxsb3dcbiAgICAgIHdpbmRvdy5oaXN0b3J5W21ldGhvZF0oXG4gICAgICAgIHtcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgYXMsXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBfX046IHRydWUsXG4gICAgICAgIH0gYXMgSGlzdG9yeVN0YXRlLFxuICAgICAgICAvLyBNb3N0IGJyb3dzZXJzIGN1cnJlbnRseSBpZ25vcmVzIHRoaXMgcGFyYW1ldGVyLCBhbHRob3VnaCB0aGV5IG1heSB1c2UgaXQgaW4gdGhlIGZ1dHVyZS5cbiAgICAgICAgLy8gUGFzc2luZyB0aGUgZW1wdHkgc3RyaW5nIGhlcmUgc2hvdWxkIGJlIHNhZmUgYWdhaW5zdCBmdXR1cmUgY2hhbmdlcyB0byB0aGUgbWV0aG9kLlxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSGlzdG9yeS9yZXBsYWNlU3RhdGVcbiAgICAgICAgJycsXG4gICAgICAgIGFzXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgaGFuZGxlUm91dGVJbmZvRXJyb3IoXG4gICAgZXJyOiBFcnJvciAmIHsgY29kZTogYW55OyBjYW5jZWxsZWQ6IGJvb2xlYW4gfSxcbiAgICBwYXRobmFtZTogc3RyaW5nLFxuICAgIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSxcbiAgICBhczogc3RyaW5nLFxuICAgIGxvYWRFcnJvckZhaWw/OiBib29sZWFuXG4gICk6IFByb21pc2U8UHJpdmF0ZVJvdXRlSW5mbz4ge1xuICAgIGlmIChlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAvLyBidWJibGUgdXAgY2FuY2VsbGF0aW9uIGVycm9yc1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgaWYgKFBBR0VfTE9BRF9FUlJPUiBpbiBlcnIgfHwgbG9hZEVycm9yRmFpbCkge1xuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgZXJyLCBhcylcblxuICAgICAgLy8gSWYgd2UgY2FuJ3QgbG9hZCB0aGUgcGFnZSBpdCBjb3VsZCBiZSBvbmUgb2YgZm9sbG93aW5nIHJlYXNvbnNcbiAgICAgIC8vICAxLiBQYWdlIGRvZXNuJ3QgZXhpc3RzXG4gICAgICAvLyAgMi4gUGFnZSBkb2VzIGV4aXN0IGluIGEgZGlmZmVyZW50IHpvbmVcbiAgICAgIC8vICAzLiBJbnRlcm5hbCBlcnJvciB3aGlsZSBsb2FkaW5nIHRoZSBwYWdlXG5cbiAgICAgIC8vIFNvLCBkb2luZyBhIGhhcmQgcmVsb2FkIGlzIHRoZSBwcm9wZXIgd2F5IHRvIGRlYWwgd2l0aCB0aGlzLlxuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBhc1xuXG4gICAgICAvLyBDaGFuZ2luZyB0aGUgVVJMIGRvZXNuJ3QgYmxvY2sgZXhlY3V0aW5nIHRoZSBjdXJyZW50IGNvZGUgcGF0aC5cbiAgICAgIC8vIFNvIGxldCdzIHRocm93IGEgY2FuY2VsbGF0aW9uIGVycm9yIHN0b3AgdGhlIHJvdXRpbmcgbG9naWMuXG4gICAgICB0aHJvdyBidWlsZENhbmNlbGxhdGlvbkVycm9yKClcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBwYWdlOiBDb21wb25lbnQsIHN0eWxlU2hlZXRzIH0gPSBhd2FpdCB0aGlzLmZldGNoQ29tcG9uZW50KFxuICAgICAgICAnL19lcnJvcidcbiAgICAgIClcbiAgICAgIGNvbnN0IHJvdXRlSW5mbzogUHJpdmF0ZVJvdXRlSW5mbyA9IHtcbiAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICBzdHlsZVNoZWV0cyxcbiAgICAgICAgZXJyLFxuICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSBhd2FpdCB0aGlzLmdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIHtcbiAgICAgICAgICBlcnIsXG4gICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgcXVlcnksXG4gICAgICAgIH0gYXMgYW55KVxuICAgICAgfSBjYXRjaCAoZ2lwRXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGVycm9yIHBhZ2UgYGdldEluaXRpYWxQcm9wc2A6ICcsIGdpcEVycilcbiAgICAgICAgcm91dGVJbmZvLnByb3BzID0ge31cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJvdXRlSW5mb1xuICAgIH0gY2F0Y2ggKHJvdXRlSW5mb0Vycikge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3Iocm91dGVJbmZvRXJyLCBwYXRobmFtZSwgcXVlcnksIGFzLCB0cnVlKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldFJvdXRlSW5mbyhcbiAgICByb3V0ZTogc3RyaW5nLFxuICAgIHBhdGhuYW1lOiBzdHJpbmcsXG4gICAgcXVlcnk6IGFueSxcbiAgICBhczogc3RyaW5nLFxuICAgIHNoYWxsb3c6IGJvb2xlYW4gPSBmYWxzZVxuICApOiBQcm9taXNlPFByaXZhdGVSb3V0ZUluZm8+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY2FjaGVkUm91dGVJbmZvID0gdGhpcy5jb21wb25lbnRzW3JvdXRlXVxuXG4gICAgICBpZiAoc2hhbGxvdyAmJiBjYWNoZWRSb3V0ZUluZm8gJiYgdGhpcy5yb3V0ZSA9PT0gcm91dGUpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZFJvdXRlSW5mb1xuICAgICAgfVxuXG4gICAgICBjb25zdCByb3V0ZUluZm86IFByaXZhdGVSb3V0ZUluZm8gPSBjYWNoZWRSb3V0ZUluZm9cbiAgICAgICAgPyBjYWNoZWRSb3V0ZUluZm9cbiAgICAgICAgOiBhd2FpdCB0aGlzLmZldGNoQ29tcG9uZW50KHJvdXRlKS50aGVuKChyZXMpID0+ICh7XG4gICAgICAgICAgICBDb21wb25lbnQ6IHJlcy5wYWdlLFxuICAgICAgICAgICAgc3R5bGVTaGVldHM6IHJlcy5zdHlsZVNoZWV0cyxcbiAgICAgICAgICAgIF9fTl9TU0c6IHJlcy5tb2QuX19OX1NTRyxcbiAgICAgICAgICAgIF9fTl9TU1A6IHJlcy5tb2QuX19OX1NTUCxcbiAgICAgICAgICB9KSlcblxuICAgICAgY29uc3QgeyBDb21wb25lbnQsIF9fTl9TU0csIF9fTl9TU1AgfSA9IHJvdXRlSW5mb1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zdCB7IGlzVmFsaWRFbGVtZW50VHlwZSB9ID0gcmVxdWlyZSgncmVhY3QtaXMnKVxuICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZShDb21wb25lbnQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFRoZSBkZWZhdWx0IGV4cG9ydCBpcyBub3QgYSBSZWFjdCBDb21wb25lbnQgaW4gcGFnZTogXCIke3BhdGhuYW1lfVwiYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgZGF0YUhyZWY6IHN0cmluZyB8IHVuZGVmaW5lZFxuXG4gICAgICBpZiAoX19OX1NTRyB8fCBfX05fU1NQKSB7XG4gICAgICAgIGRhdGFIcmVmID0gdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKFxuICAgICAgICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHsgcGF0aG5hbWUsIHF1ZXJ5IH0pLFxuICAgICAgICAgIGRlbEJhc2VQYXRoKGFzKSxcbiAgICAgICAgICBfX05fU1NHLFxuICAgICAgICAgIHRoaXMubG9jYWxlLFxuICAgICAgICAgIHRoaXMuZGVmYXVsdExvY2FsZVxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByb3BzID0gYXdhaXQgdGhpcy5fZ2V0RGF0YTxQcml2YXRlUm91dGVJbmZvPigoKSA9PlxuICAgICAgICBfX05fU1NHXG4gICAgICAgICAgPyB0aGlzLl9nZXRTdGF0aWNEYXRhKGRhdGFIcmVmISlcbiAgICAgICAgICA6IF9fTl9TU1BcbiAgICAgICAgICA/IHRoaXMuX2dldFNlcnZlckRhdGEoZGF0YUhyZWYhKVxuICAgICAgICAgIDogdGhpcy5nZXRJbml0aWFsUHJvcHMoXG4gICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgLy8gd2UgcHJvdmlkZSBBcHBUcmVlIGxhdGVyIHNvIHRoaXMgbmVlZHMgdG8gYmUgYGFueWBcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgIGFzUGF0aDogYXMsXG4gICAgICAgICAgICAgIH0gYXMgYW55XG4gICAgICAgICAgICApXG4gICAgICApXG5cbiAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHByb3BzXG4gICAgICB0aGlzLmNvbXBvbmVudHNbcm91dGVdID0gcm91dGVJbmZvXG4gICAgICByZXR1cm4gcm91dGVJbmZvXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVSb3V0ZUluZm9FcnJvcihlcnIsIHBhdGhuYW1lLCBxdWVyeSwgYXMpXG4gICAgfVxuICB9XG5cbiAgc2V0KFxuICAgIHJvdXRlOiBzdHJpbmcsXG4gICAgcGF0aG5hbWU6IHN0cmluZyxcbiAgICBxdWVyeTogUGFyc2VkVXJsUXVlcnksXG4gICAgYXM6IHN0cmluZyxcbiAgICBkYXRhOiBQcml2YXRlUm91dGVJbmZvXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuaXNGYWxsYmFjayA9IGZhbHNlXG5cbiAgICB0aGlzLnJvdXRlID0gcm91dGVcbiAgICB0aGlzLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlcbiAgICB0aGlzLmFzUGF0aCA9IGFzXG4gICAgcmV0dXJuIHRoaXMubm90aWZ5KGRhdGEpXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgdG8gZXhlY3V0ZSBiZWZvcmUgcmVwbGFjaW5nIHJvdXRlciBzdGF0ZVxuICAgKiBAcGFyYW0gY2IgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWRcbiAgICovXG4gIGJlZm9yZVBvcFN0YXRlKGNiOiBCZWZvcmVQb3BTdGF0ZUNhbGxiYWNrKSB7XG4gICAgdGhpcy5fYnBzID0gY2JcbiAgfVxuXG4gIG9ubHlBSGFzaENoYW5nZShhczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLmFzUGF0aCkgcmV0dXJuIGZhbHNlXG4gICAgY29uc3QgW29sZFVybE5vSGFzaCwgb2xkSGFzaF0gPSB0aGlzLmFzUGF0aC5zcGxpdCgnIycpXG4gICAgY29uc3QgW25ld1VybE5vSGFzaCwgbmV3SGFzaF0gPSBhcy5zcGxpdCgnIycpXG5cbiAgICAvLyBNYWtlcyBzdXJlIHdlIHNjcm9sbCB0byB0aGUgcHJvdmlkZWQgaGFzaCBpZiB0aGUgdXJsL2hhc2ggYXJlIHRoZSBzYW1lXG4gICAgaWYgKG5ld0hhc2ggJiYgb2xkVXJsTm9IYXNoID09PSBuZXdVcmxOb0hhc2ggJiYgb2xkSGFzaCA9PT0gbmV3SGFzaCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdXJscyBhcmUgY2hhbmdlLCB0aGVyZSdzIG1vcmUgdGhhbiBhIGhhc2ggY2hhbmdlXG4gICAgaWYgKG9sZFVybE5vSGFzaCAhPT0gbmV3VXJsTm9IYXNoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgaGFzaCBoYXMgY2hhbmdlZCwgdGhlbiBpdCdzIGEgaGFzaCBvbmx5IGNoYW5nZS5cbiAgICAvLyBUaGlzIGNoZWNrIGlzIG5lY2Vzc2FyeSB0byBoYW5kbGUgYm90aCB0aGUgZW50ZXIgYW5kXG4gICAgLy8gbGVhdmUgaGFzaCA9PT0gJycgY2FzZXMuIFRoZSBpZGVudGl0eSBjYXNlIGZhbGxzIHRocm91Z2hcbiAgICAvLyBhbmQgaXMgdHJlYXRlZCBhcyBhIG5leHQgcmVsb2FkLlxuICAgIHJldHVybiBvbGRIYXNoICE9PSBuZXdIYXNoXG4gIH1cblxuICBzY3JvbGxUb0hhc2goYXM6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IFssIGhhc2hdID0gYXMuc3BsaXQoJyMnKVxuICAgIC8vIFNjcm9sbCB0byB0b3AgaWYgdGhlIGhhc2ggaXMganVzdCBgI2Agd2l0aCBubyB2YWx1ZVxuICAgIGlmIChoYXNoID09PSAnJykge1xuICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBGaXJzdCB3ZSBjaGVjayBpZiB0aGUgZWxlbWVudCBieSBpZCBpcyBmb3VuZFxuICAgIGNvbnN0IGlkRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChoYXNoKVxuICAgIGlmIChpZEVsKSB7XG4gICAgICBpZEVsLnNjcm9sbEludG9WaWV3KClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBJZiB0aGVyZSdzIG5vIGVsZW1lbnQgd2l0aCB0aGUgaWQsIHdlIGNoZWNrIHRoZSBgbmFtZWAgcHJvcGVydHlcbiAgICAvLyBUbyBtaXJyb3IgYnJvd3NlcnNcbiAgICBjb25zdCBuYW1lRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShoYXNoKVswXVxuICAgIGlmIChuYW1lRWwpIHtcbiAgICAgIG5hbWVFbC5zY3JvbGxJbnRvVmlldygpXG4gICAgfVxuICB9XG5cbiAgdXJsSXNOZXcoYXNQYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5hc1BhdGggIT09IGFzUGF0aFxuICB9XG5cbiAgX3Jlc29sdmVIcmVmKHBhcnNlZEhyZWY6IFVybE9iamVjdCwgcGFnZXM6IHN0cmluZ1tdLCBhcHBseUJhc2VQYXRoID0gdHJ1ZSkge1xuICAgIGNvbnN0IHsgcGF0aG5hbWUgfSA9IHBhcnNlZEhyZWZcbiAgICBjb25zdCBjbGVhblBhdGhuYW1lID0gcmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2goXG4gICAgICBkZW5vcm1hbGl6ZVBhZ2VQYXRoKGFwcGx5QmFzZVBhdGggPyBkZWxCYXNlUGF0aChwYXRobmFtZSEpIDogcGF0aG5hbWUhKVxuICAgIClcblxuICAgIGlmIChjbGVhblBhdGhuYW1lID09PSAnLzQwNCcgfHwgY2xlYW5QYXRobmFtZSA9PT0gJy9fZXJyb3InKSB7XG4gICAgICByZXR1cm4gcGFyc2VkSHJlZlxuICAgIH1cblxuICAgIC8vIGhhbmRsZSByZXNvbHZpbmcgaHJlZiBmb3IgZHluYW1pYyByb3V0ZXNcbiAgICBpZiAoIXBhZ2VzLmluY2x1ZGVzKGNsZWFuUGF0aG5hbWUhKSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycmF5LWNhbGxiYWNrLXJldHVyblxuICAgICAgcGFnZXMuc29tZSgocGFnZSkgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgaXNEeW5hbWljUm91dGUocGFnZSkgJiZcbiAgICAgICAgICBnZXRSb3V0ZVJlZ2V4KHBhZ2UpLnJlLnRlc3QoY2xlYW5QYXRobmFtZSEpXG4gICAgICAgICkge1xuICAgICAgICAgIHBhcnNlZEhyZWYucGF0aG5hbWUgPSBhcHBseUJhc2VQYXRoID8gYWRkQmFzZVBhdGgocGFnZSkgOiBwYWdlXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZEhyZWZcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVmZXRjaCBwYWdlIGNvZGUsIHlvdSBtYXkgd2FpdCBmb3IgdGhlIGRhdGEgZHVyaW5nIHBhZ2UgcmVuZGVyaW5nLlxuICAgKiBUaGlzIGZlYXR1cmUgb25seSB3b3JrcyBpbiBwcm9kdWN0aW9uIVxuICAgKiBAcGFyYW0gdXJsIHRoZSBocmVmIG9mIHByZWZldGNoZWQgcGFnZVxuICAgKiBAcGFyYW0gYXNQYXRoIHRoZSBhcyBwYXRoIG9mIHRoZSBwcmVmZXRjaGVkIHBhZ2VcbiAgICovXG4gIGFzeW5jIHByZWZldGNoKFxuICAgIHVybDogc3RyaW5nLFxuICAgIGFzUGF0aDogc3RyaW5nID0gdXJsLFxuICAgIG9wdGlvbnM6IFByZWZldGNoT3B0aW9ucyA9IHt9XG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGxldCBwYXJzZWQgPSBwYXJzZVJlbGF0aXZlVXJsKHVybClcblxuICAgIGxldCB7IHBhdGhuYW1lIH0gPSBwYXJzZWRcblxuICAgIGNvbnN0IHBhZ2VzID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KClcblxuICAgIHBhcnNlZCA9IHRoaXMuX3Jlc29sdmVIcmVmKHBhcnNlZCwgcGFnZXMpIGFzIHR5cGVvZiBwYXJzZWRcblxuICAgIGlmIChwYXJzZWQucGF0aG5hbWUgIT09IHBhdGhuYW1lKSB7XG4gICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZVxuICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuICAgIH1cblxuICAgIC8vIFByZWZldGNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gZGV2ZWxvcG1lbnQgbW9kZSBiZWNhdXNlIGl0IHdvdWxkIHRyaWdnZXIgb24tZGVtYW5kLWVudHJpZXNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgcm91dGUgPSByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaChwYXRobmFtZSlcbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLnBhZ2VMb2FkZXIucHJlZmV0Y2hEYXRhKFxuICAgICAgICB1cmwsXG4gICAgICAgIGFzUGF0aCxcbiAgICAgICAgdGhpcy5sb2NhbGUsXG4gICAgICAgIHRoaXMuZGVmYXVsdExvY2FsZVxuICAgICAgKSxcbiAgICAgIHRoaXMucGFnZUxvYWRlcltvcHRpb25zLnByaW9yaXR5ID8gJ2xvYWRQYWdlJyA6ICdwcmVmZXRjaCddKHJvdXRlKSxcbiAgICBdKVxuICB9XG5cbiAgYXN5bmMgZmV0Y2hDb21wb25lbnQocm91dGU6IHN0cmluZyk6IFByb21pc2U8R29vZFBhZ2VDYWNoZT4ge1xuICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZVxuICAgIGNvbnN0IGNhbmNlbCA9ICh0aGlzLmNsYyA9ICgpID0+IHtcbiAgICAgIGNhbmNlbGxlZCA9IHRydWVcbiAgICB9KVxuXG4gICAgY29uc3QgY29tcG9uZW50UmVzdWx0ID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmxvYWRQYWdlKHJvdXRlKVxuXG4gICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgY29uc3QgZXJyb3I6IGFueSA9IG5ldyBFcnJvcihcbiAgICAgICAgYEFib3J0IGZldGNoaW5nIGNvbXBvbmVudCBmb3Igcm91dGU6IFwiJHtyb3V0ZX1cImBcbiAgICAgIClcbiAgICAgIGVycm9yLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuXG4gICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgIHRoaXMuY2xjID0gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiBjb21wb25lbnRSZXN1bHRcbiAgfVxuXG4gIF9nZXREYXRhPFQ+KGZuOiAoKSA9PiBQcm9taXNlPFQ+KTogUHJvbWlzZTxUPiB7XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlXG4gICAgY29uc3QgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgY2FuY2VsbGVkID0gdHJ1ZVxuICAgIH1cbiAgICB0aGlzLmNsYyA9IGNhbmNlbFxuICAgIHJldHVybiBmbigpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIGlmIChjYW5jZWwgPT09IHRoaXMuY2xjKSB7XG4gICAgICAgIHRoaXMuY2xjID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgIGNvbnN0IGVycjogYW55ID0gbmV3IEVycm9yKCdMb2FkaW5nIGluaXRpYWwgcHJvcHMgY2FuY2VsbGVkJylcbiAgICAgICAgZXJyLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhXG4gICAgfSlcbiAgfVxuXG4gIF9nZXRTdGF0aWNEYXRhKGRhdGFIcmVmOiBzdHJpbmcpOiBQcm9taXNlPG9iamVjdD4ge1xuICAgIGNvbnN0IHsgaHJlZjogY2FjaGVLZXkgfSA9IG5ldyBVUkwoZGF0YUhyZWYsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nICYmIHRoaXMuc2RjW2NhY2hlS2V5XSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnNkY1tjYWNoZUtleV0pXG4gICAgfVxuICAgIHJldHVybiBmZXRjaE5leHREYXRhKGRhdGFIcmVmLCB0aGlzLmlzU3NyKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICB0aGlzLnNkY1tjYWNoZUtleV0gPSBkYXRhXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0pXG4gIH1cblxuICBfZ2V0U2VydmVyRGF0YShkYXRhSHJlZjogc3RyaW5nKTogUHJvbWlzZTxvYmplY3Q+IHtcbiAgICByZXR1cm4gZmV0Y2hOZXh0RGF0YShkYXRhSHJlZiwgdGhpcy5pc1NzcilcbiAgfVxuXG4gIGdldEluaXRpYWxQcm9wcyhcbiAgICBDb21wb25lbnQ6IENvbXBvbmVudFR5cGUsXG4gICAgY3R4OiBOZXh0UGFnZUNvbnRleHRcbiAgKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCB7IENvbXBvbmVudDogQXBwIH0gPSB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ11cbiAgICBjb25zdCBBcHBUcmVlID0gdGhpcy5fd3JhcEFwcChBcHAgYXMgQXBwQ29tcG9uZW50KVxuICAgIGN0eC5BcHBUcmVlID0gQXBwVHJlZVxuICAgIHJldHVybiBsb2FkR2V0SW5pdGlhbFByb3BzPEFwcENvbnRleHRUeXBlPFJvdXRlcj4+KEFwcCwge1xuICAgICAgQXBwVHJlZSxcbiAgICAgIENvbXBvbmVudCxcbiAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgIGN0eCxcbiAgICB9KVxuICB9XG5cbiAgYWJvcnRDb21wb25lbnRMb2FkKGFzOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jbGMpIHtcbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSwgYXMpXG4gICAgICB0aGlzLmNsYygpXG4gICAgICB0aGlzLmNsYyA9IG51bGxcbiAgICB9XG4gIH1cblxuICBub3RpZnkoZGF0YTogUHJpdmF0ZVJvdXRlSW5mbyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLnN1YihkYXRhLCB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10uQ29tcG9uZW50IGFzIEFwcENvbXBvbmVudClcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/router/router.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/escape-path-delimiters.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/escape-path-delimiters.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.default = escapePathDelimiters; // escape delimiters used by path-to-regexp\nfunction escapePathDelimiters(segment) {\n  return segment.replace(/[/#?]/g, char => encodeURIComponent(char));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9lc2NhcGUtcGF0aC1kZWxpbWl0ZXJzLnRzPzc3MWYiXSwibmFtZXMiOlsiZXNjYXBlUGF0aERlbGltaXRlcnMiLCJzZWdtZW50IiwicmVwbGFjZSIsImNoYXIiLCJlbmNvZGVVUklDb21wb25lbnQiXSwibWFwcGluZ3MiOiI7Ozt1Q0FBQTtBQUNlLFNBQVNBLG9CQUFULENBQThCQyxPQUE5QixFQUF1RDtFQUNwRSxPQUFPQSxPQUFPLENBQUNDLE9BQVJELENBQWdCLFFBQWhCQSxFQUEyQkUsSUFBRCxJQUFrQkMsa0JBQWtCLENBQUNELElBQUQsQ0FBOURGLENBQVA7QUFDRCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9lc2NhcGUtcGF0aC1kZWxpbWl0ZXJzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXNjYXBlIGRlbGltaXRlcnMgdXNlZCBieSBwYXRoLXRvLXJlZ2V4cFxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXNjYXBlUGF0aERlbGltaXRlcnMoc2VnbWVudDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHNlZ21lbnQucmVwbGFjZSgvWy8jP10vZywgKGNoYXI6IHN0cmluZykgPT4gZW5jb2RlVVJJQ29tcG9uZW50KGNoYXIpKVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/router/utils/escape-path-delimiters.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/format-url.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/format-url.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.formatUrl = formatUrl;\nvar querystring = _interopRequireWildcard(__webpack_require__(/*! ./querystring */ \"./node_modules/next/dist/next-server/lib/router/utils/querystring.js\"));\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n  return cache;\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache();\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n} // Format function modified from nodejs\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\nconst slashedProtocols = /https?|ftp|gopher|file/;\nfunction formatUrl(urlObj) {\n  let {\n    auth,\n    hostname\n  } = urlObj;\n  let protocol = urlObj.protocol || '';\n  let pathname = urlObj.pathname || '';\n  let hash = urlObj.hash || '';\n  let query = urlObj.query || '';\n  let host = false;\n  auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';\n  if (urlObj.host) {\n    host = auth + urlObj.host;\n  } else if (hostname) {\n    host = auth + (~hostname.indexOf(':') ? `[${hostname}]` : hostname);\n    if (urlObj.port) {\n      host += ':' + urlObj.port;\n    }\n  }\n  if (query && typeof query === 'object') {\n    query = String(querystring.urlQueryToSearchParams(query));\n  }\n  let search = urlObj.search || query && `?${query}` || '';\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n  if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname[0] !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n  if (hash && hash[0] !== '#') hash = '#' + hash;\n  if (search && search[0] !== '?') search = '?' + search;\n  pathname = pathname.replace(/[?#]/g, encodeURIComponent);\n  search = search.replace('#', '%23');\n  return `${protocol}${host}${pathname}${search}${hash}`;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsLnRzPzEzYzciXSwibmFtZXMiOlsic2xhc2hlZFByb3RvY29scyIsImZvcm1hdFVybCIsInVybE9iaiIsImF1dGgiLCJob3N0bmFtZSIsInByb3RvY29sIiwicGF0aG5hbWUiLCJoYXNoIiwicXVlcnkiLCJob3N0IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVwbGFjZSIsImluZGV4T2YiLCJwb3J0IiwiU3RyaW5nIiwicXVlcnlzdHJpbmciLCJ1cmxRdWVyeVRvU2VhcmNoUGFyYW1zIiwic2VhcmNoIiwic3Vic3RyIiwic2xhc2hlcyIsInRlc3QiXSwibWFwcGluZ3MiOiI7Ozs7QUF3QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQSxNQUFNQSxnQkFBZ0IsR0FBRyx3QkFBekI7QUFFTyxTQUFTQyxTQUFULENBQW1CQyxNQUFuQixFQUFzQztFQUMzQyxJQUFJO0lBQUVDLElBQUY7SUFBUUM7RUFBUixJQUFxQkYsTUFBekI7RUFDQSxJQUFJRyxRQUFRLEdBQUdILE1BQU0sQ0FBQ0csUUFBUEgsSUFBbUIsRUFBbEM7RUFDQSxJQUFJSSxRQUFRLEdBQUdKLE1BQU0sQ0FBQ0ksUUFBUEosSUFBbUIsRUFBbEM7RUFDQSxJQUFJSyxJQUFJLEdBQUdMLE1BQU0sQ0FBQ0ssSUFBUEwsSUFBZSxFQUExQjtFQUNBLElBQUlNLEtBQUssR0FBR04sTUFBTSxDQUFDTSxLQUFQTixJQUFnQixFQUE1QjtFQUNBLElBQUlPLElBQW9CLEdBQUcsS0FBM0I7RUFFQU4sSUFBSSxHQUFHQSxJQUFJLEdBQUdPLGtCQUFrQixDQUFDUCxJQUFELENBQWxCTyxDQUF5QkMsT0FBekJELENBQWlDLE1BQWpDQSxFQUF5QyxHQUF6Q0EsSUFBZ0QsR0FBbkQsR0FBeUQsRUFBcEVQO0VBRUEsSUFBSUQsTUFBTSxDQUFDTyxJQUFYLEVBQWlCO0lBQ2ZBLElBQUksR0FBR04sSUFBSSxHQUFHRCxNQUFNLENBQUNPLElBQXJCQTtFQUNELENBRkQsTUFFTyxJQUFJTCxRQUFKLEVBQWM7SUFDbkJLLElBQUksR0FBR04sSUFBSSxJQUFJLENBQUNDLFFBQVEsQ0FBQ1EsT0FBVFIsQ0FBaUIsR0FBakJBLENBQUQsR0FBMEIsSUFBR0EsUUFBUyxHQUF0QyxHQUEyQ0EsUUFBL0MsQ0FBWEs7SUFDQSxJQUFJUCxNQUFNLENBQUNXLElBQVgsRUFBaUI7TUFDZkosSUFBSSxJQUFJLE1BQU1QLE1BQU0sQ0FBQ1csSUFBckJKO0lBQ0Q7RUFDRjtFQUVELElBQUlELEtBQUssSUFBSSxPQUFPQSxLQUFQLEtBQWlCLFFBQTlCLEVBQXdDO0lBQ3RDQSxLQUFLLEdBQUdNLE1BQU0sQ0FBQ0MsV0FBVyxDQUFDQyxzQkFBWkQsQ0FBbUNQLEtBQW5DTyxDQUFELENBQWRQO0VBQ0Q7RUFFRCxJQUFJUyxNQUFNLEdBQUdmLE1BQU0sQ0FBQ2UsTUFBUGYsSUFBa0JNLEtBQUssSUFBSyxJQUFHQSxLQUFNLEVBQXJDTixJQUEyQyxFQUF4RDtFQUVBLElBQUlHLFFBQVEsSUFBSUEsUUFBUSxDQUFDYSxNQUFUYixDQUFnQixDQUFDLENBQWpCQSxNQUF3QixHQUF4QyxFQUE2Q0EsUUFBUSxJQUFJLEdBQVpBO0VBRTdDLElBQ0VILE1BQU0sQ0FBQ2lCLE9BQVBqQixJQUNDLENBQUMsQ0FBQ0csUUFBRCxJQUFhTCxnQkFBZ0IsQ0FBQ29CLElBQWpCcEIsQ0FBc0JLLFFBQXRCTCxDQUFkLEtBQWtEUyxJQUFJLEtBQUssS0FGOUQsRUFHRTtJQUNBQSxJQUFJLEdBQUcsUUFBUUEsSUFBSSxJQUFJLEVBQWhCLENBQVBBO0lBQ0EsSUFBSUgsUUFBUSxJQUFJQSxRQUFRLENBQUMsQ0FBRCxDQUFSQSxLQUFnQixHQUFoQyxFQUFxQ0EsUUFBUSxHQUFHLE1BQU1BLFFBQWpCQTtFQUN0QyxDQU5ELE1BTU8sSUFBSSxDQUFDRyxJQUFMLEVBQVc7SUFDaEJBLElBQUksR0FBRyxFQUFQQTtFQUNEO0VBRUQsSUFBSUYsSUFBSSxJQUFJQSxJQUFJLENBQUMsQ0FBRCxDQUFKQSxLQUFZLEdBQXhCLEVBQTZCQSxJQUFJLEdBQUcsTUFBTUEsSUFBYkE7RUFDN0IsSUFBSVUsTUFBTSxJQUFJQSxNQUFNLENBQUMsQ0FBRCxDQUFOQSxLQUFjLEdBQTVCLEVBQWlDQSxNQUFNLEdBQUcsTUFBTUEsTUFBZkE7RUFFakNYLFFBQVEsR0FBR0EsUUFBUSxDQUFDSyxPQUFUTCxDQUFpQixPQUFqQkEsRUFBMEJJLGtCQUExQkosQ0FBWEE7RUFDQVcsTUFBTSxHQUFHQSxNQUFNLENBQUNOLE9BQVBNLENBQWUsR0FBZkEsRUFBb0IsS0FBcEJBLENBQVRBO0VBRUEsT0FBUSxHQUFFWixRQUFTLEdBQUVJLElBQUssR0FBRUgsUUFBUyxHQUFFVyxNQUFPLEdBQUVWLElBQUssRUFBckQ7QUFDRCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gRm9ybWF0IGZ1bmN0aW9uIG1vZGlmaWVkIGZyb20gbm9kZWpzXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHsgVXJsT2JqZWN0IH0gZnJvbSAndXJsJ1xuaW1wb3J0IHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCAqIGFzIHF1ZXJ5c3RyaW5nIGZyb20gJy4vcXVlcnlzdHJpbmcnXG5cbmNvbnN0IHNsYXNoZWRQcm90b2NvbHMgPSAvaHR0cHM/fGZ0cHxnb3BoZXJ8ZmlsZS9cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFVybCh1cmxPYmo6IFVybE9iamVjdCkge1xuICBsZXQgeyBhdXRoLCBob3N0bmFtZSB9ID0gdXJsT2JqXG4gIGxldCBwcm90b2NvbCA9IHVybE9iai5wcm90b2NvbCB8fCAnJ1xuICBsZXQgcGF0aG5hbWUgPSB1cmxPYmoucGF0aG5hbWUgfHwgJydcbiAgbGV0IGhhc2ggPSB1cmxPYmouaGFzaCB8fCAnJ1xuICBsZXQgcXVlcnkgPSB1cmxPYmoucXVlcnkgfHwgJydcbiAgbGV0IGhvc3Q6IHN0cmluZyB8IGZhbHNlID0gZmFsc2VcblxuICBhdXRoID0gYXV0aCA/IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKS5yZXBsYWNlKC8lM0EvaSwgJzonKSArICdAJyA6ICcnXG5cbiAgaWYgKHVybE9iai5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB1cmxPYmouaG9zdFxuICB9IGVsc2UgaWYgKGhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAofmhvc3RuYW1lLmluZGV4T2YoJzonKSA/IGBbJHtob3N0bmFtZX1dYCA6IGhvc3RuYW1lKVxuICAgIGlmICh1cmxPYmoucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB1cmxPYmoucG9ydFxuICAgIH1cbiAgfVxuXG4gIGlmIChxdWVyeSAmJiB0eXBlb2YgcXVlcnkgPT09ICdvYmplY3QnKSB7XG4gICAgcXVlcnkgPSBTdHJpbmcocXVlcnlzdHJpbmcudXJsUXVlcnlUb1NlYXJjaFBhcmFtcyhxdWVyeSBhcyBQYXJzZWRVcmxRdWVyeSkpXG4gIH1cblxuICBsZXQgc2VhcmNoID0gdXJsT2JqLnNlYXJjaCB8fCAocXVlcnkgJiYgYD8ke3F1ZXJ5fWApIHx8ICcnXG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonXG5cbiAgaWYgKFxuICAgIHVybE9iai5zbGFzaGVzIHx8XG4gICAgKCghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29scy50ZXN0KHByb3RvY29sKSkgJiYgaG9zdCAhPT0gZmFsc2UpXG4gICkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpXG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lWzBdICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWVcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJ1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaFswXSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaFxuICBpZiAoc2VhcmNoICYmIHNlYXJjaFswXSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2hcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZW5jb2RlVVJJQ29tcG9uZW50KVxuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKVxuXG4gIHJldHVybiBgJHtwcm90b2NvbH0ke2hvc3R9JHtwYXRobmFtZX0ke3NlYXJjaH0ke2hhc2h9YFxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/router/utils/format-url.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.isDynamicRoute = isDynamicRoute; // Identify /[param]/ in route string\nconst TEST_ROUTE = /\\/\\[[^/]+?\\](?=\\/|$)/;\nfunction isDynamicRoute(route) {\n  return TEST_ROUTE.test(route);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9pcy1keW5hbWljLnRzP2NkZTUiXSwibmFtZXMiOlsiVEVTVF9ST1VURSIsImlzRHluYW1pY1JvdXRlIiwicm91dGUiLCJ0ZXN0Il0sIm1hcHBpbmdzIjoiOzs7d0NBQUE7QUFDQSxNQUFNQSxVQUFVLEdBQUcsc0JBQW5CO0FBRU8sU0FBU0MsY0FBVCxDQUF3QkMsS0FBeEIsRUFBZ0Q7RUFDckQsT0FBT0YsVUFBVSxDQUFDRyxJQUFYSCxDQUFnQkUsS0FBaEJGLENBQVA7QUFDRCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9pcy1keW5hbWljLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSWRlbnRpZnkgL1twYXJhbV0vIGluIHJvdXRlIHN0cmluZ1xuY29uc3QgVEVTVF9ST1VURSA9IC9cXC9cXFtbXi9dKz9cXF0oPz1cXC98JCkvXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0R5bmFtaWNSb3V0ZShyb3V0ZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBURVNUX1JPVVRFLnRlc3Qocm91dGUpXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.parseRelativeUrl = parseRelativeUrl;\nvar _utils = __webpack_require__(/*! ../../utils */ \"./node_modules/next/dist/next-server/lib/utils.js\");\nvar _querystring = __webpack_require__(/*! ./querystring */ \"./node_modules/next/dist/next-server/lib/router/utils/querystring.js\");\nconst DUMMY_BASE = new URL(true ? 'http://n' : undefined); /**\n                                                                                 * Parses path-relative urls (e.g. `/hello/world?foo=bar`). If url isn't path-relative\n                                                                                 * (e.g. `./hello`) then at least base must be.\n                                                                                 * Absolute urls are rejected with one exception, in the browser, absolute urls that are on\n                                                                                 * the current origin will be parsed as relative\n                                                                                 */\nfunction parseRelativeUrl(url, base) {\n  const resolvedBase = base ? new URL(base, DUMMY_BASE) : DUMMY_BASE;\n  const {\n    pathname,\n    searchParams,\n    search,\n    hash,\n    href,\n    origin,\n    protocol\n  } = new URL(url, resolvedBase);\n  if (origin !== DUMMY_BASE.origin || protocol !== 'http:' && protocol !== 'https:') {\n    throw new Error('invariant: invalid relative URL');\n  }\n  return {\n    pathname,\n    query: (0, _querystring.searchParamsToUrlQuery)(searchParams),\n    search,\n    hash,\n    href: href.slice(DUMMY_BASE.origin.length)\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9wYXJzZS1yZWxhdGl2ZS11cmwudHM/OTQwZCJdLCJuYW1lcyI6WyJEVU1NWV9CQVNFIiwiVVJMIiwicGFyc2VSZWxhdGl2ZVVybCIsInVybCIsImJhc2UiLCJyZXNvbHZlZEJhc2UiLCJwYXRobmFtZSIsInNlYXJjaFBhcmFtcyIsInNlYXJjaCIsImhhc2giLCJocmVmIiwib3JpZ2luIiwicHJvdG9jb2wiLCJFcnJvciIsInF1ZXJ5Iiwic2xpY2UiLCJsZW5ndGgiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBRUEsTUFBTUEsVUFBVSxHQUFHLElBQUlDLEdBQUosQ0FDakIsT0FBZ0MsVUFBaEMsR0FBNkMsU0FENUIsQ0FBbkIsQ0FJQTs7Ozs7O0FBTU8sU0FBU0MsZ0JBQVQsQ0FBMEJDLEdBQTFCLEVBQXVDQyxJQUF2QyxFQUFzRDtFQUMzRCxNQUFNQyxZQUFZLEdBQUdELElBQUksR0FBRyxJQUFJSCxHQUFKLENBQVFHLElBQVIsRUFBY0osVUFBZCxDQUFILEdBQStCQSxVQUF4RDtFQUNBLE1BQU07SUFDSk0sUUFESTtJQUVKQyxZQUZJO0lBR0pDLE1BSEk7SUFJSkMsSUFKSTtJQUtKQyxJQUxJO0lBTUpDLE1BTkk7SUFPSkM7RUFQSSxJQVFGLElBQUlYLEdBQUosQ0FBUUUsR0FBUixFQUFhRSxZQUFiLENBUko7RUFTQSxJQUNFTSxNQUFNLEtBQUtYLFVBQVUsQ0FBQ1csTUFBdEJBLElBQ0NDLFFBQVEsS0FBSyxPQUFiQSxJQUF3QkEsUUFBUSxLQUFLLFFBRnhDLEVBR0U7SUFDQSxNQUFNLElBQUlDLEtBQUosQ0FBVSxpQ0FBVixDQUFOO0VBQ0Q7RUFDRCxPQUFPO0lBQ0xQLFFBREs7SUFFTFEsS0FBSyxFQUFFLHlDQUF1QlAsWUFBdkIsQ0FGRjtJQUdMQyxNQUhLO0lBSUxDLElBSks7SUFLTEMsSUFBSSxFQUFFQSxJQUFJLENBQUNLLEtBQUxMLENBQVdWLFVBQVUsQ0FBQ1csTUFBWFgsQ0FBa0JnQixNQUE3Qk47RUFMRCxDQUFQO0FBT0QiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0TG9jYXRpb25PcmlnaW4gfSBmcm9tICcuLi8uLi91dGlscydcbmltcG9ydCB7IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkgfSBmcm9tICcuL3F1ZXJ5c3RyaW5nJ1xuXG5jb25zdCBEVU1NWV9CQVNFID0gbmV3IFVSTChcbiAgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAnaHR0cDovL24nIDogZ2V0TG9jYXRpb25PcmlnaW4oKVxuKVxuXG4vKipcbiAqIFBhcnNlcyBwYXRoLXJlbGF0aXZlIHVybHMgKGUuZy4gYC9oZWxsby93b3JsZD9mb289YmFyYCkuIElmIHVybCBpc24ndCBwYXRoLXJlbGF0aXZlXG4gKiAoZS5nLiBgLi9oZWxsb2ApIHRoZW4gYXQgbGVhc3QgYmFzZSBtdXN0IGJlLlxuICogQWJzb2x1dGUgdXJscyBhcmUgcmVqZWN0ZWQgd2l0aCBvbmUgZXhjZXB0aW9uLCBpbiB0aGUgYnJvd3NlciwgYWJzb2x1dGUgdXJscyB0aGF0IGFyZSBvblxuICogdGhlIGN1cnJlbnQgb3JpZ2luIHdpbGwgYmUgcGFyc2VkIGFzIHJlbGF0aXZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJlbGF0aXZlVXJsKHVybDogc3RyaW5nLCBiYXNlPzogc3RyaW5nKSB7XG4gIGNvbnN0IHJlc29sdmVkQmFzZSA9IGJhc2UgPyBuZXcgVVJMKGJhc2UsIERVTU1ZX0JBU0UpIDogRFVNTVlfQkFTRVxuICBjb25zdCB7XG4gICAgcGF0aG5hbWUsXG4gICAgc2VhcmNoUGFyYW1zLFxuICAgIHNlYXJjaCxcbiAgICBoYXNoLFxuICAgIGhyZWYsXG4gICAgb3JpZ2luLFxuICAgIHByb3RvY29sLFxuICB9ID0gbmV3IFVSTCh1cmwsIHJlc29sdmVkQmFzZSlcbiAgaWYgKFxuICAgIG9yaWdpbiAhPT0gRFVNTVlfQkFTRS5vcmlnaW4gfHxcbiAgICAocHJvdG9jb2wgIT09ICdodHRwOicgJiYgcHJvdG9jb2wgIT09ICdodHRwczonKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudDogaW52YWxpZCByZWxhdGl2ZSBVUkwnKVxuICB9XG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWUsXG4gICAgcXVlcnk6IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoc2VhcmNoUGFyYW1zKSxcbiAgICBzZWFyY2gsXG4gICAgaGFzaCxcbiAgICBocmVmOiBocmVmLnNsaWNlKERVTU1ZX0JBU0Uub3JpZ2luLmxlbmd0aCksXG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/path-match.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/path-match.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nexports.__esModule = true;\nexports.pathToRegexp = exports.default = exports.customRouteMatcherOptions = exports.matcherOptions = void 0;\nvar pathToRegexp = _interopRequireWildcard(__webpack_require__(/*! next/dist/compiled/path-to-regexp */ \"./node_modules/next/dist/compiled/path-to-regexp/index.js\"));\nexports.pathToRegexp = pathToRegexp;\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n  return cache;\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache();\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nconst matcherOptions = {\n  sensitive: false,\n  delimiter: '/'\n};\nexports.matcherOptions = matcherOptions;\nconst customRouteMatcherOptions = _objectSpread(_objectSpread({}, matcherOptions), {}, {\n  strict: true\n});\nexports.customRouteMatcherOptions = customRouteMatcherOptions;\nvar _default = (customRoute = false) => {\n  return path => {\n    const keys = [];\n    const matcherRegex = pathToRegexp.pathToRegexp(path, keys, customRoute ? customRouteMatcherOptions : matcherOptions);\n    const matcher = pathToRegexp.regexpToFunction(matcherRegex, keys);\n    return (pathname, params) => {\n      const res = pathname == null ? false : matcher(pathname);\n      if (!res) {\n        return false;\n      }\n      if (customRoute) {\n        for (const key of keys) {\n          // unnamed params should be removed as they\n          // are not allowed to be used in the destination\n          if (typeof key.name === 'number') {\n            delete res.params[key.name];\n          }\n        }\n      }\n      return _objectSpread(_objectSpread({}, params), res.params);\n    };\n  };\n};\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9wYXRoLW1hdGNoLnRzP2YxMGEiXSwibmFtZXMiOlsibWF0Y2hlck9wdGlvbnMiLCJzZW5zaXRpdmUiLCJkZWxpbWl0ZXIiLCJjdXN0b21Sb3V0ZU1hdGNoZXJPcHRpb25zIiwic3RyaWN0IiwiY3VzdG9tUm91dGUiLCJwYXRoIiwia2V5cyIsIm1hdGNoZXJSZWdleCIsInBhdGhUb1JlZ2V4cCIsIm1hdGNoZXIiLCJyZWdleHBUb0Z1bmN0aW9uIiwicGF0aG5hbWUiLCJwYXJhbXMiLCJyZXMiLCJrZXkiLCJuYW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSU8sTUFBTUEsY0FDYyxHQUFHO0VBQzVCQyxTQUFTLEVBQUUsS0FEaUI7RUFFNUJDLFNBQVMsRUFBRTtBQUZpQixDQUR2Qjs7QUFNQSxNQUFNQyx5QkFDYyxtQ0FDdEJILGNBRHlCO0VBRTVCSSxNQUFNLEVBQUU7QUFGb0IsRUFEdkI7O2VBTVEsQ0FBQ0MsV0FBVyxHQUFHLEtBQWYsS0FBeUI7RUFDdEMsT0FBUUMsSUFBRCxJQUFrQjtJQUN2QixNQUFNQyxJQUF3QixHQUFHLEVBQWpDO0lBQ0EsTUFBTUMsWUFBWSxHQUFHQyxZQUFZLENBQUNBLFlBQWJBLENBQ25CSCxJQURtQkcsRUFFbkJGLElBRm1CRSxFQUduQkosV0FBVyxHQUFHRix5QkFBSCxHQUErQkgsY0FIdkJTLENBQXJCO0lBS0EsTUFBTUMsT0FBTyxHQUFHRCxZQUFZLENBQUNFLGdCQUFiRixDQUE4QkQsWUFBOUJDLEVBQTRDRixJQUE1Q0UsQ0FBaEI7SUFFQSxPQUFPLENBQUNHLFFBQUQsRUFBc0NDLE1BQXRDLEtBQXVEO01BQzVELE1BQU1DLEdBQUcsR0FBR0YsUUFBUSxJQUFJLElBQVpBLEdBQW1CLEtBQW5CQSxHQUEyQkYsT0FBTyxDQUFDRSxRQUFELENBQTlDO01BQ0EsSUFBSSxDQUFDRSxHQUFMLEVBQVU7UUFDUixPQUFPLEtBQVA7TUFDRDtNQUVELElBQUlULFdBQUosRUFBaUI7UUFDZixLQUFLLE1BQU1VLEdBQVgsSUFBa0JSLElBQWxCLEVBQXdCO1VBQ3RCO1VBQ0E7VUFDQSxJQUFJLE9BQU9RLEdBQUcsQ0FBQ0MsSUFBWCxLQUFvQixRQUF4QixFQUFrQztZQUNoQyxPQUFRRixHQUFHLENBQUNELE1BQUwsQ0FBb0JFLEdBQUcsQ0FBQ0MsSUFBeEIsQ0FBUDtVQUNEO1FBQ0Y7TUFDRjtNQUVELHVDQUFZSCxNQUFMLEdBQWdCQyxHQUFHLENBQUNELE1BQTNCO0lBQ0QsQ0FqQkQ7RUFrQkQsQ0EzQkQ7QUE0QkQsQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9wYXRoLW1hdGNoLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgcGF0aFRvUmVnZXhwIGZyb20gJ25leHQvZGlzdC9jb21waWxlZC9wYXRoLXRvLXJlZ2V4cCdcblxuZXhwb3J0IHsgcGF0aFRvUmVnZXhwIH1cblxuZXhwb3J0IGNvbnN0IG1hdGNoZXJPcHRpb25zOiBwYXRoVG9SZWdleHAuVG9rZW5zVG9SZWdleHBPcHRpb25zICZcbiAgcGF0aFRvUmVnZXhwLlBhcnNlT3B0aW9ucyA9IHtcbiAgc2Vuc2l0aXZlOiBmYWxzZSxcbiAgZGVsaW1pdGVyOiAnLycsXG59XG5cbmV4cG9ydCBjb25zdCBjdXN0b21Sb3V0ZU1hdGNoZXJPcHRpb25zOiBwYXRoVG9SZWdleHAuVG9rZW5zVG9SZWdleHBPcHRpb25zICZcbiAgcGF0aFRvUmVnZXhwLlBhcnNlT3B0aW9ucyA9IHtcbiAgLi4ubWF0Y2hlck9wdGlvbnMsXG4gIHN0cmljdDogdHJ1ZSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgKGN1c3RvbVJvdXRlID0gZmFsc2UpID0+IHtcbiAgcmV0dXJuIChwYXRoOiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCBrZXlzOiBwYXRoVG9SZWdleHAuS2V5W10gPSBbXVxuICAgIGNvbnN0IG1hdGNoZXJSZWdleCA9IHBhdGhUb1JlZ2V4cC5wYXRoVG9SZWdleHAoXG4gICAgICBwYXRoLFxuICAgICAga2V5cyxcbiAgICAgIGN1c3RvbVJvdXRlID8gY3VzdG9tUm91dGVNYXRjaGVyT3B0aW9ucyA6IG1hdGNoZXJPcHRpb25zXG4gICAgKVxuICAgIGNvbnN0IG1hdGNoZXIgPSBwYXRoVG9SZWdleHAucmVnZXhwVG9GdW5jdGlvbihtYXRjaGVyUmVnZXgsIGtleXMpXG5cbiAgICByZXR1cm4gKHBhdGhuYW1lOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkLCBwYXJhbXM/OiBhbnkpID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IHBhdGhuYW1lID09IG51bGwgPyBmYWxzZSA6IG1hdGNoZXIocGF0aG5hbWUpXG4gICAgICBpZiAoIXJlcykge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgaWYgKGN1c3RvbVJvdXRlKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAvLyB1bm5hbWVkIHBhcmFtcyBzaG91bGQgYmUgcmVtb3ZlZCBhcyB0aGV5XG4gICAgICAgICAgLy8gYXJlIG5vdCBhbGxvd2VkIHRvIGJlIHVzZWQgaW4gdGhlIGRlc3RpbmF0aW9uXG4gICAgICAgICAgaWYgKHR5cGVvZiBrZXkubmFtZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGRlbGV0ZSAocmVzLnBhcmFtcyBhcyBhbnkpW2tleS5uYW1lXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4geyAuLi5wYXJhbXMsIC4uLnJlcy5wYXJhbXMgfVxuICAgIH1cbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/router/utils/path-match.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nexports.__esModule = true;\nexports.default = prepareDestination;\nvar _querystring = __webpack_require__(/*! ./querystring */ \"./node_modules/next/dist/next-server/lib/router/utils/querystring.js\");\nvar _parseRelativeUrl = __webpack_require__(/*! ./parse-relative-url */ \"./node_modules/next/dist/next-server/lib/router/utils/parse-relative-url.js\");\nvar pathToRegexp = _interopRequireWildcard(__webpack_require__(/*! next/dist/compiled/path-to-regexp */ \"./node_modules/next/dist/compiled/path-to-regexp/index.js\"));\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n  return cache;\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache();\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nfunction prepareDestination(destination, params, query, appendParamsToQuery, basePath) {\n  let parsedDestination = {};\n  if (destination.startsWith('/')) {\n    parsedDestination = (0, _parseRelativeUrl.parseRelativeUrl)(destination);\n  } else {\n    const {\n      pathname,\n      searchParams,\n      hash,\n      hostname,\n      port,\n      protocol,\n      search,\n      href\n    } = new URL(destination);\n    parsedDestination = {\n      pathname,\n      query: (0, _querystring.searchParamsToUrlQuery)(searchParams),\n      hash,\n      protocol,\n      hostname,\n      port,\n      search,\n      href\n    };\n  }\n  const destQuery = parsedDestination.query;\n  const destPath = `${parsedDestination.pathname}${parsedDestination.hash || ''}`;\n  const destPathParamKeys = [];\n  pathToRegexp.pathToRegexp(destPath, destPathParamKeys);\n  const destPathParams = destPathParamKeys.map(key => key.name);\n  let destinationCompiler = pathToRegexp.compile(destPath,\n  // we don't validate while compiling the destination since we should\n  // have already validated before we got to this point and validating\n  // breaks compiling destinations with named pattern params from the source\n  // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n  // since compile validation is meant for reversing and not for inserting\n  // params from a separate path-regex into another\n  {\n    validate: false\n  });\n  let newUrl; // update any params in query values\n  for (const [key, strOrArray] of Object.entries(destQuery)) {\n    let value = Array.isArray(strOrArray) ? strOrArray[0] : strOrArray;\n    if (value) {\n      // the value needs to start with a forward-slash to be compiled\n      // correctly\n      value = `/${value}`;\n      const queryCompiler = pathToRegexp.compile(value, {\n        validate: false\n      });\n      value = queryCompiler(params).substr(1);\n    }\n    destQuery[key] = value;\n  } // add path params to query if it's not a redirect and not\n  // already defined in destination query or path\n  const paramKeys = Object.keys(params);\n  if (appendParamsToQuery && !paramKeys.some(key => destPathParams.includes(key))) {\n    for (const key of paramKeys) {\n      if (!(key in destQuery)) {\n        destQuery[key] = params[key];\n      }\n    }\n  }\n  const shouldAddBasePath = destination.startsWith('/') && basePath;\n  try {\n    newUrl = `${shouldAddBasePath ? basePath : ''}${destinationCompiler(params)}`;\n    const [pathname, hash] = newUrl.split('#');\n    parsedDestination.pathname = pathname;\n    parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`;\n    delete parsedDestination.search;\n  } catch (err) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw new Error(`To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://err.sh/vercel/next.js/invalid-multi-match`);\n    }\n    throw err;\n  } // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n  parsedDestination.query = _objectSpread(_objectSpread({}, query), parsedDestination.query);\n  return {\n    newUrl,\n    parsedDestination\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9wcmVwYXJlLWRlc3RpbmF0aW9uLnRzPzM1NjUiXSwibmFtZXMiOlsicHJlcGFyZURlc3RpbmF0aW9uIiwiZGVzdGluYXRpb24iLCJwYXJhbXMiLCJxdWVyeSIsImFwcGVuZFBhcmFtc1RvUXVlcnkiLCJiYXNlUGF0aCIsInBhcnNlZERlc3RpbmF0aW9uIiwic3RhcnRzV2l0aCIsInBhdGhuYW1lIiwic2VhcmNoUGFyYW1zIiwiaGFzaCIsImhvc3RuYW1lIiwicG9ydCIsInByb3RvY29sIiwic2VhcmNoIiwiaHJlZiIsIlVSTCIsImRlc3RRdWVyeSIsImRlc3RQYXRoIiwiZGVzdFBhdGhQYXJhbUtleXMiLCJwYXRoVG9SZWdleHAiLCJkZXN0UGF0aFBhcmFtcyIsIm1hcCIsImtleSIsIm5hbWUiLCJkZXN0aW5hdGlvbkNvbXBpbGVyIiwiY29tcGlsZSIsInZhbGlkYXRlIiwibmV3VXJsIiwic3RyT3JBcnJheSIsIk9iamVjdCIsImVudHJpZXMiLCJ2YWx1ZSIsIkFycmF5IiwiaXNBcnJheSIsInF1ZXJ5Q29tcGlsZXIiLCJzdWJzdHIiLCJwYXJhbUtleXMiLCJrZXlzIiwic29tZSIsImluY2x1ZGVzIiwic2hvdWxkQWRkQmFzZVBhdGgiLCJzcGxpdCIsImVyciIsIm1lc3NhZ2UiLCJtYXRjaCIsIkVycm9yIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSWUsU0FBU0Esa0JBQVQsQ0FDYkMsV0FEYSxFQUViQyxNQUZhLEVBR2JDLEtBSGEsRUFJYkMsbUJBSmEsRUFLYkMsUUFMYSxFQU1iO0VBQ0EsSUFBSUMsaUJBS21DLEdBQUcsRUFMMUM7RUFPQSxJQUFJTCxXQUFXLENBQUNNLFVBQVpOLENBQXVCLEdBQXZCQSxDQUFKLEVBQWlDO0lBQy9CSyxpQkFBaUIsR0FBRyx3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QVBkLENBQWEsR0FBYkEsQ0FBekI7SUFDQXRCLGlCQUFpQixDQUFDRSxRQUFsQkYsR0FBNkJFLFFBQTdCRjtJQUNBQSxpQkFBaUIsQ0FBQ0ksSUFBbEJKLEdBQTBCLEdBQUVJLElBQUksR0FBRyxHQUFILEdBQVMsRUFBRyxHQUFFQSxJQUFJLElBQUksRUFBRyxFQUF6REo7SUFDQSxPQUFPQSxpQkFBaUIsQ0FBQ1EsTUFBekI7RUFDRCxDQUFDLFFBQU82QixHQUFQLEVBQVk7SUFDWixJQUFJQSxHQUFHLENBQUNDLE9BQUpELENBQVlFLEtBQVpGLENBQWtCLDhDQUFsQkEsQ0FBSixFQUF1RTtNQUNyRSxNQUFNLElBQUlHLEtBQUosQ0FDSCx3S0FERyxDQUFOO0lBR0Q7SUFDRCxNQUFNSCxHQUFOO0VBQ0QsQ0FFRDtFQUNBO0VBQ0E7RUFDQTtFQUNBckMsaUJBQWlCLENBQUNILEtBQWxCRyxtQ0FDS0gsS0FEcUIsR0FFckJHLGlCQUFpQixDQUFDSCxLQUZHLENBQTFCRztFQUtBLE9BQU87SUFDTHNCLE1BREs7SUFFTHRCO0VBRkssQ0FBUDtBQUlEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3ByZXBhcmUtZGVzdGluYXRpb24uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHsgc2VhcmNoUGFyYW1zVG9VcmxRdWVyeSB9IGZyb20gJy4vcXVlcnlzdHJpbmcnXG5pbXBvcnQgeyBwYXJzZVJlbGF0aXZlVXJsIH0gZnJvbSAnLi9wYXJzZS1yZWxhdGl2ZS11cmwnXG5pbXBvcnQgKiBhcyBwYXRoVG9SZWdleHAgZnJvbSAnbmV4dC9kaXN0L2NvbXBpbGVkL3BhdGgtdG8tcmVnZXhwJ1xuXG50eXBlIFBhcmFtcyA9IHsgW3BhcmFtOiBzdHJpbmddOiBhbnkgfVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwcmVwYXJlRGVzdGluYXRpb24oXG4gIGRlc3RpbmF0aW9uOiBzdHJpbmcsXG4gIHBhcmFtczogUGFyYW1zLFxuICBxdWVyeTogUGFyc2VkVXJsUXVlcnksXG4gIGFwcGVuZFBhcmFtc1RvUXVlcnk6IGJvb2xlYW4sXG4gIGJhc2VQYXRoOiBzdHJpbmdcbikge1xuICBsZXQgcGFyc2VkRGVzdGluYXRpb246IHtcbiAgICBxdWVyeT86IFBhcnNlZFVybFF1ZXJ5XG4gICAgcHJvdG9jb2w/OiBzdHJpbmdcbiAgICBob3N0bmFtZT86IHN0cmluZ1xuICAgIHBvcnQ/OiBzdHJpbmdcbiAgfSAmIFJldHVyblR5cGU8dHlwZW9mIHBhcnNlUmVsYXRpdmVVcmw+ID0ge30gYXMgYW55XG5cbiAgaWYgKGRlc3RpbmF0aW9uLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgIHBhcnNlZERlc3RpbmF0aW9uID0gcGFyc2VSZWxhdGl2ZVVybChkZXN0aW5hdGlvbilcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXRobmFtZSxcbiAgICAgIHNlYXJjaFBhcmFtcyxcbiAgICAgIGhhc2gsXG4gICAgICBob3N0bmFtZSxcbiAgICAgIHBvcnQsXG4gICAgICBwcm90b2NvbCxcbiAgICAgIHNlYXJjaCxcbiAgICAgIGhyZWYsXG4gICAgfSA9IG5ldyBVUkwoZGVzdGluYXRpb24pXG5cbiAgICBwYXJzZWREZXN0aW5hdGlvbiA9IHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgcXVlcnk6IHNlYXJjaFBhcmFtc1RvVXJsUXVlcnkoc2VhcmNoUGFyYW1zKSxcbiAgICAgIGhhc2gsXG4gICAgICBwcm90b2NvbCxcbiAgICAgIGhvc3RuYW1lLFxuICAgICAgcG9ydCxcbiAgICAgIHNlYXJjaCxcbiAgICAgIGhyZWYsXG4gICAgfVxuICB9XG5cbiAgY29uc3QgZGVzdFF1ZXJ5ID0gcGFyc2VkRGVzdGluYXRpb24ucXVlcnlcbiAgY29uc3QgZGVzdFBhdGggPSBgJHtwYXJzZWREZXN0aW5hdGlvbi5wYXRobmFtZSF9JHtcbiAgICBwYXJzZWREZXN0aW5hdGlvbi5oYXNoIHx8ICcnXG4gIH1gXG4gIGNvbnN0IGRlc3RQYXRoUGFyYW1LZXlzOiBwYXRoVG9SZWdleHAuS2V5W10gPSBbXVxuICBwYXRoVG9SZWdleHAucGF0aFRvUmVnZXhwKGRlc3RQYXRoLCBkZXN0UGF0aFBhcmFtS2V5cylcblxuICBjb25zdCBkZXN0UGF0aFBhcmFtcyA9IGRlc3RQYXRoUGFyYW1LZXlzLm1hcCgoa2V5KSA9PiBrZXkubmFtZSlcblxuICBsZXQgZGVzdGluYXRpb25Db21waWxlciA9IHBhdGhUb1JlZ2V4cC5jb21waWxlKFxuICAgIGRlc3RQYXRoLFxuICAgIC8vIHdlIGRvbid0IHZhbGlkYXRlIHdoaWxlIGNvbXBpbGluZyB0aGUgZGVzdGluYXRpb24gc2luY2Ugd2Ugc2hvdWxkXG4gICAgLy8gaGF2ZSBhbHJlYWR5IHZhbGlkYXRlZCBiZWZvcmUgd2UgZ290IHRvIHRoaXMgcG9pbnQgYW5kIHZhbGlkYXRpbmdcbiAgICAvLyBicmVha3MgY29tcGlsaW5nIGRlc3RpbmF0aW9ucyB3aXRoIG5hbWVkIHBhdHRlcm4gcGFyYW1zIGZyb20gdGhlIHNvdXJjZVxuICAgIC8vIGUuZy4gL3NvbWV0aGluZzpoZWxsbyguKikgLT4gL2Fub3RoZXIvOmhlbGxvIGlzIGJyb2tlbiB3aXRoIHZhbGlkYXRpb25cbiAgICAvLyBzaW5jZSBjb21waWxlIHZhbGlkYXRpb24gaXMgbWVhbnQgZm9yIHJldmVyc2luZyBhbmQgbm90IGZvciBpbnNlcnRpbmdcbiAgICAvLyBwYXJhbXMgZnJvbSBhIHNlcGFyYXRlIHBhdGgtcmVnZXggaW50byBhbm90aGVyXG4gICAgeyB2YWxpZGF0ZTogZmFsc2UgfVxuICApXG4gIGxldCBuZXdVcmxcblxuICAvLyB1cGRhdGUgYW55IHBhcmFtcyBpbiBxdWVyeSB2YWx1ZXNcbiAgZm9yIChjb25zdCBba2V5LCBzdHJPckFycmF5XSBvZiBPYmplY3QuZW50cmllcyhkZXN0UXVlcnkpKSB7XG4gICAgbGV0IHZhbHVlID0gQXJyYXkuaXNBcnJheShzdHJPckFycmF5KSA/IHN0ck9yQXJyYXlbMF0gOiBzdHJPckFycmF5XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAvLyB0aGUgdmFsdWUgbmVlZHMgdG8gc3RhcnQgd2l0aCBhIGZvcndhcmQtc2xhc2ggdG8gYmUgY29tcGlsZWRcbiAgICAgIC8vIGNvcnJlY3RseVxuICAgICAgdmFsdWUgPSBgLyR7dmFsdWV9YFxuICAgICAgY29uc3QgcXVlcnlDb21waWxlciA9IHBhdGhUb1JlZ2V4cC5jb21waWxlKHZhbHVlLCB7IHZhbGlkYXRlOiBmYWxzZSB9KVxuICAgICAgdmFsdWUgPSBxdWVyeUNvbXBpbGVyKHBhcmFtcykuc3Vic3RyKDEpXG4gICAgfVxuICAgIGRlc3RRdWVyeVtrZXldID0gdmFsdWVcbiAgfVxuXG4gIC8vIGFkZCBwYXRoIHBhcmFtcyB0byBxdWVyeSBpZiBpdCdzIG5vdCBhIHJlZGlyZWN0IGFuZCBub3RcbiAgLy8gYWxyZWFkeSBkZWZpbmVkIGluIGRlc3RpbmF0aW9uIHF1ZXJ5IG9yIHBhdGhcbiAgY29uc3QgcGFyYW1LZXlzID0gT2JqZWN0LmtleXMocGFyYW1zKVxuXG4gIGlmIChcbiAgICBhcHBlbmRQYXJhbXNUb1F1ZXJ5ICYmXG4gICAgIXBhcmFtS2V5cy5zb21lKChrZXkpID0+IGRlc3RQYXRoUGFyYW1zLmluY2x1ZGVzKGtleSkpXG4gICkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHBhcmFtS2V5cykge1xuICAgICAgaWYgKCEoa2V5IGluIGRlc3RRdWVyeSkpIHtcbiAgICAgICAgZGVzdFF1ZXJ5W2tleV0gPSBwYXJhbXNba2V5XVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHNob3VsZEFkZEJhc2VQYXRoID0gZGVzdGluYXRpb24uc3RhcnRzV2l0aCgnLycpICYmIGJhc2VQYXRoXG5cbiAgdHJ5IHtcbiAgICBuZXdVcmwgPSBgJHtzaG91bGRBZGRCYXNlUGF0aCA/IGJhc2VQYXRoIDogJyd9JHtkZXN0aW5hdGlvbkNvbXBpbGVyKFxuICAgICAgcGFyYW1zXG4gICAgKX1gXG5cbiAgICBjb25zdCBbcGF0aG5hbWUsIGhhc2hdID0gbmV3VXJsLnNwbGl0KCcjJylcbiAgICBwYXJzZWREZXN0aW5hdGlvbi5wYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgcGFyc2VkRGVzdGluYXRpb24uaGFzaCA9IGAke2hhc2ggPyAnIycgOiAnJ30ke2hhc2ggfHwgJyd9YFxuICAgIGRlbGV0ZSBwYXJzZWREZXN0aW5hdGlvbi5zZWFyY2hcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyci5tZXNzYWdlLm1hdGNoKC9FeHBlY3RlZCAuKj8gdG8gbm90IHJlcGVhdCwgYnV0IGdvdCBhbiBhcnJheS8pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBUbyB1c2UgYSBtdWx0aS1tYXRjaCBpbiB0aGUgZGVzdGluYXRpb24geW91IG11c3QgYWRkIFxcYCpcXGAgYXQgdGhlIGVuZCBvZiB0aGUgcGFyYW0gbmFtZSB0byBzaWduaWZ5IGl0IHNob3VsZCByZXBlYXQuIGh0dHBzOi8vZXJyLnNoL3ZlcmNlbC9uZXh0LmpzL2ludmFsaWQtbXVsdGktbWF0Y2hgXG4gICAgICApXG4gICAgfVxuICAgIHRocm93IGVyclxuICB9XG5cbiAgLy8gUXVlcnkgbWVyZ2Ugb3JkZXIgbG93ZXN0IHByaW9yaXR5IHRvIGhpZ2hlc3RcbiAgLy8gMS4gaW5pdGlhbCBVUkwgcXVlcnkgdmFsdWVzXG4gIC8vIDIuIHBhdGggc2VnbWVudCB2YWx1ZXNcbiAgLy8gMy4gZGVzdGluYXRpb24gc3BlY2lmaWVkIHF1ZXJ5IHZhbHVlc1xuICBwYXJzZWREZXN0aW5hdGlvbi5xdWVyeSA9IHtcbiAgICAuLi5xdWVyeSxcbiAgICAuLi5wYXJzZWREZXN0aW5hdGlvbi5xdWVyeSxcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmV3VXJsLFxuICAgIHBhcnNlZERlc3RpbmF0aW9uLFxuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/querystring.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/querystring.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.searchParamsToUrlQuery = searchParamsToUrlQuery;\nexports.urlQueryToSearchParams = urlQueryToSearchParams;\nexports.assign = assign;\nfunction searchParamsToUrlQuery(searchParams) {\n  const query = {};\n  searchParams.forEach((value, key) => {\n    if (typeof query[key] === 'undefined') {\n      query[key] = value;\n    } else if (Array.isArray(query[key])) {\n      ;\n      query[key].push(value);\n    } else {\n      query[key] = [query[key], value];\n    }\n  });\n  return query;\n}\nfunction stringifyUrlQueryParam(param) {\n  if (typeof param === 'string' || typeof param === 'number' && !isNaN(param) || typeof param === 'boolean') {\n    return String(param);\n  } else {\n    return '';\n  }\n}\nfunction urlQueryToSearchParams(urlQuery) {\n  const result = new URLSearchParams();\n  Object.entries(urlQuery).forEach(([key, value]) => {\n    if (Array.isArray(value)) {\n      value.forEach(item => result.append(key, stringifyUrlQueryParam(item)));\n    } else {\n      result.set(key, stringifyUrlQueryParam(value));\n    }\n  });\n  return result;\n}\nfunction assign(target, ...searchParamsList) {\n  searchParamsList.forEach(searchParams => {\n    Array.from(searchParams.keys()).forEach(key => target.delete(key));\n    searchParams.forEach((value, key) => target.append(key, value));\n  });\n  return target;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9xdWVyeXN0cmluZy50cz8yZWJmIl0sIm5hbWVzIjpbInNlYXJjaFBhcmFtc1RvVXJsUXVlcnkiLCJzZWFyY2hQYXJhbXMiLCJxdWVyeSIsImZvckVhY2giLCJ2YWx1ZSIsImtleSIsIkFycmF5IiwiaXNBcnJheSIsInB1c2giLCJzdHJpbmdpZnlVcmxRdWVyeVBhcmFtIiwicGFyYW0iLCJpc05hTiIsIlN0cmluZyIsInVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMiLCJ1cmxRdWVyeSIsInJlc3VsdCIsIlVSTFNlYXJjaFBhcmFtcyIsIk9iamVjdCIsImVudHJpZXMiLCJpdGVtIiwiYXBwZW5kIiwic2V0IiwiYXNzaWduIiwidGFyZ2V0Iiwic2VhcmNoUGFyYW1zTGlzdCIsImZyb20iLCJrZXlzIiwiZGVsZXRlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFFTyxTQUFTQSxzQkFBVCxDQUNMQyxZQURLLEVBRVc7RUFDaEIsTUFBTUMsS0FBcUIsR0FBRyxFQUE5QjtFQUNBRCxZQUFZLENBQUNFLE9BQWJGLENBQXFCLENBQUNHLEtBQUQsRUFBUUMsR0FBUixLQUFnQjtJQUNuQyxJQUFJLE9BQU9ILEtBQUssQ0FBQ0csR0FBRCxDQUFaLEtBQXNCLFdBQTFCLEVBQXVDO01BQ3JDSCxLQUFLLENBQUNHLEdBQUQsQ0FBTEgsR0FBYUUsS0FBYkY7SUFDRCxDQUZELE1BRU8sSUFBSUksS0FBSyxDQUFDQyxPQUFORCxDQUFjSixLQUFLLENBQUNHLEdBQUQsQ0FBbkJDLENBQUosRUFBK0I7TUFDcEM7TUFBRUosS0FBSyxDQUFDRyxHQUFELENBQU4sQ0FBeUJHLElBQXpCLENBQThCSixLQUE5QjtJQUNGLENBRk0sTUFFQTtNQUNMRixLQUFLLENBQUNHLEdBQUQsQ0FBTEgsR0FBYSxDQUFDQSxLQUFLLENBQUNHLEdBQUQsQ0FBTixFQUF1QkQsS0FBdkIsQ0FBYkY7SUFDRDtFQUNGLENBUkREO0VBU0EsT0FBT0MsS0FBUDtBQUNEO0FBRUQsU0FBU08sc0JBQVQsQ0FBZ0NDLEtBQWhDLEVBQXVEO0VBQ3JELElBQ0UsT0FBT0EsS0FBUCxLQUFpQixRQUFqQixJQUNDLE9BQU9BLEtBQVAsS0FBaUIsUUFBakIsSUFBNkIsQ0FBQ0MsS0FBSyxDQUFDRCxLQUFELENBRHBDLElBRUEsT0FBT0EsS0FBUCxLQUFpQixTQUhuQixFQUlFO0lBQ0EsT0FBT0UsTUFBTSxDQUFDRixLQUFELENBQWI7RUFDRCxDQU5ELE1BTU87SUFDTCxPQUFPLEVBQVA7RUFDRDtBQUNGO0FBRU0sU0FBU0csc0JBQVQsQ0FDTEMsUUFESyxFQUVZO0VBQ2pCLE1BQU1DLE1BQU0sR0FBRyxJQUFJQyxlQUFKLEVBQWY7RUFDQUMsTUFBTSxDQUFDQyxPQUFQRCxDQUFlSCxRQUFmRyxFQUF5QmQsT0FBekJjLENBQWlDLENBQUMsQ0FBQ1osR0FBRCxFQUFNRCxLQUFOLENBQUQsS0FBa0I7SUFDakQsSUFBSUUsS0FBSyxDQUFDQyxPQUFORCxDQUFjRixLQUFkRSxDQUFKLEVBQTBCO01BQ3hCRixLQUFLLENBQUNELE9BQU5DLENBQWVlLElBQUQsSUFBVUosTUFBTSxDQUFDSyxNQUFQTCxDQUFjVixHQUFkVSxFQUFtQk4sc0JBQXNCLENBQUNVLElBQUQsQ0FBekNKLENBQXhCWDtJQUNELENBRkQsTUFFTztNQUNMVyxNQUFNLENBQUNNLEdBQVBOLENBQVdWLEdBQVhVLEVBQWdCTixzQkFBc0IsQ0FBQ0wsS0FBRCxDQUF0Q1c7SUFDRDtFQUNGLENBTkRFO0VBT0EsT0FBT0YsTUFBUDtBQUNEO0FBRU0sU0FBU08sTUFBVCxDQUNMQyxNQURLLEVBRUwsR0FBR0MsZ0JBRkUsRUFHWTtFQUNqQkEsZ0JBQWdCLENBQUNyQixPQUFqQnFCLENBQTBCdkIsWUFBRCxJQUFrQjtJQUN6Q0ssS0FBSyxDQUFDbUIsSUFBTm5CLENBQVdMLFlBQVksQ0FBQ3lCLElBQWJ6QixFQUFYSyxFQUFnQ0gsT0FBaENHLENBQXlDRCxHQUFELElBQVNrQixNQUFNLENBQUNJLE1BQVBKLENBQWNsQixHQUFka0IsQ0FBakRqQjtJQUNBTCxZQUFZLENBQUNFLE9BQWJGLENBQXFCLENBQUNHLEtBQUQsRUFBUUMsR0FBUixLQUFnQmtCLE1BQU0sQ0FBQ0gsTUFBUEcsQ0FBY2xCLEdBQWRrQixFQUFtQm5CLEtBQW5CbUIsQ0FBckN0QjtFQUNELENBSER1QjtFQUlBLE9BQU9ELE1BQVA7QUFDRCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9xdWVyeXN0cmluZy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5cbmV4cG9ydCBmdW5jdGlvbiBzZWFyY2hQYXJhbXNUb1VybFF1ZXJ5KFxuICBzZWFyY2hQYXJhbXM6IFVSTFNlYXJjaFBhcmFtc1xuKTogUGFyc2VkVXJsUXVlcnkge1xuICBjb25zdCBxdWVyeTogUGFyc2VkVXJsUXVlcnkgPSB7fVxuICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIGlmICh0eXBlb2YgcXVlcnlba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHF1ZXJ5W2tleV0gPSB2YWx1ZVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShxdWVyeVtrZXldKSkge1xuICAgICAgOyhxdWVyeVtrZXldIGFzIHN0cmluZ1tdKS5wdXNoKHZhbHVlKVxuICAgIH0gZWxzZSB7XG4gICAgICBxdWVyeVtrZXldID0gW3F1ZXJ5W2tleV0gYXMgc3RyaW5nLCB2YWx1ZV1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBxdWVyeVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlVcmxRdWVyeVBhcmFtKHBhcmFtOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoXG4gICAgdHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJyB8fFxuICAgICh0eXBlb2YgcGFyYW0gPT09ICdudW1iZXInICYmICFpc05hTihwYXJhbSkpIHx8XG4gICAgdHlwZW9mIHBhcmFtID09PSAnYm9vbGVhbidcbiAgKSB7XG4gICAgcmV0dXJuIFN0cmluZyhwYXJhbSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJydcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXJsUXVlcnlUb1NlYXJjaFBhcmFtcyhcbiAgdXJsUXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4pOiBVUkxTZWFyY2hQYXJhbXMge1xuICBjb25zdCByZXN1bHQgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKClcbiAgT2JqZWN0LmVudHJpZXModXJsUXVlcnkpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUuZm9yRWFjaCgoaXRlbSkgPT4gcmVzdWx0LmFwcGVuZChrZXksIHN0cmluZ2lmeVVybFF1ZXJ5UGFyYW0oaXRlbSkpKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgc3RyaW5naWZ5VXJsUXVlcnlQYXJhbSh2YWx1ZSkpXG4gICAgfVxuICB9KVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24oXG4gIHRhcmdldDogVVJMU2VhcmNoUGFyYW1zLFxuICAuLi5zZWFyY2hQYXJhbXNMaXN0OiBVUkxTZWFyY2hQYXJhbXNbXVxuKTogVVJMU2VhcmNoUGFyYW1zIHtcbiAgc2VhcmNoUGFyYW1zTGlzdC5mb3JFYWNoKChzZWFyY2hQYXJhbXMpID0+IHtcbiAgICBBcnJheS5mcm9tKHNlYXJjaFBhcmFtcy5rZXlzKCkpLmZvckVhY2goKGtleSkgPT4gdGFyZ2V0LmRlbGV0ZShrZXkpKVxuICAgIHNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB0YXJnZXQuYXBwZW5kKGtleSwgdmFsdWUpKVxuICB9KVxuICByZXR1cm4gdGFyZ2V0XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/router/utils/querystring.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.default = resolveRewrites;\nvar _pathMatch = _interopRequireDefault(__webpack_require__(/*! ./path-match */ \"./node_modules/next/dist/next-server/lib/router/utils/path-match.js\"));\nvar _prepareDestination = _interopRequireDefault(__webpack_require__(/*! ./prepare-destination */ \"./node_modules/next/dist/next-server/lib/router/utils/prepare-destination.js\"));\nvar _normalizeTrailingSlash = __webpack_require__(/*! ../../../../client/normalize-trailing-slash */ \"./node_modules/next/dist/client/normalize-trailing-slash.js\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nconst customRouteMatcher = (0, _pathMatch.default)(true);\nfunction resolveRewrites(asPath, pages, basePath, rewrites, query, resolveHref) {\n  if (!pages.includes(asPath)) {\n    for (const rewrite of rewrites) {\n      const matcher = customRouteMatcher(rewrite.source);\n      const params = matcher(asPath);\n      if (params) {\n        if (!rewrite.destination) {\n          // this is a proxied rewrite which isn't handled on the client\n          break;\n        }\n        const destRes = (0, _prepareDestination.default)(rewrite.destination, params, query, true, rewrite.basePath === false ? '' : basePath);\n        asPath = destRes.parsedDestination.pathname;\n        Object.assign(query, destRes.parsedDestination.query);\n        if (pages.includes((0, _normalizeTrailingSlash.removePathTrailingSlash)(asPath))) {\n          // check if we now match a page as this means we are done\n          // resolving the rewrites\n          break;\n        } // check if we match a dynamic-route, if so we break the rewrites chain\n        const resolvedHref = resolveHref(asPath);\n        if (resolvedHref !== asPath && pages.includes(resolvedHref)) {\n          break;\n        }\n      }\n    }\n  }\n  return asPath;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9yZXNvbHZlLXJld3JpdGVzLnRzPzY3ODciXSwibmFtZXMiOlsiY3VzdG9tUm91dGVNYXRjaGVyIiwicmVzb2x2ZVJld3JpdGVzIiwiYXNQYXRoIiwicGFnZXMiLCJiYXNlUGF0aCIsInJld3JpdGVzIiwicXVlcnkiLCJyZXNvbHZlSHJlZiIsImluY2x1ZGVzIiwicmV3cml0ZSIsIm1hdGNoZXIiLCJzb3VyY2UiLCJwYXJhbXMiLCJkZXN0aW5hdGlvbiIsImRlc3RSZXMiLCJwYXJzZWREZXN0aW5hdGlvbiIsInBhdGhuYW1lIiwiT2JqZWN0IiwiYXNzaWduIiwicmVzb2x2ZWRIcmVmIl0sIm1hcHBpbmdzIjoiOzs7O0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFFQSxNQUFNQSxrQkFBa0IsR0FBRyx3QkFBVSxJQUFWLENBQTNCO0FBRWUsU0FBU0MsZUFBVCxDQUNiQyxNQURhLEVBRWJDLEtBRmEsRUFHYkMsUUFIYSxFQUliQyxRQUphLEVBS2JDLEtBTGEsRUFNYkMsV0FOYSxFQU9iO0VBQ0EsSUFBSSxDQUFDSixLQUFLLENBQUNLLFFBQU5MLENBQWVELE1BQWZDLENBQUwsRUFBNkI7SUFDM0IsS0FBSyxNQUFNTSxPQUFYLElBQXNCSixRQUF0QixFQUFnQztNQUM5QixNQUFNSyxPQUFPLEdBQUdWLGtCQUFrQixDQUFDUyxPQUFPLENBQUNFLE1BQVQsQ0FBbEM7TUFDQSxNQUFNQyxNQUFNLEdBQUdGLE9BQU8sQ0FBQ1IsTUFBRCxDQUF0QjtNQUVBLElBQUlVLE1BQUosRUFBWTtRQUNWLElBQUksQ0FBQ0gsT0FBTyxDQUFDSSxXQUFiLEVBQTBCO1VBQ3hCO1VBQ0E7UUFDRDtRQUNELE1BQU1DLE9BQU8sR0FBRyxpQ0FDZEwsT0FBTyxDQUFDSSxXQURNLEVBRWRELE1BRmMsRUFHZE4sS0FIYyxFQUlkLElBSmMsRUFLZEcsT0FBTyxDQUFDTCxRQUFSSyxLQUFxQixLQUFyQkEsR0FBNkIsRUFBN0JBLEdBQWtDTCxRQUxwQixDQUFoQjtRQU9BRixNQUFNLEdBQUdZLE9BQU8sQ0FBQ0MsaUJBQVJELENBQTBCRSxRQUFuQ2Q7UUFDQWUsTUFBTSxDQUFDQyxNQUFQRCxDQUFjWCxLQUFkVyxFQUFxQkgsT0FBTyxDQUFDQyxpQkFBUkQsQ0FBMEJSLEtBQS9DVztRQUVBLElBQUlkLEtBQUssQ0FBQ0ssUUFBTkwsQ0FBZSxxREFBd0JELE1BQXhCLENBQWZDLENBQUosRUFBcUQ7VUFDbkQ7VUFDQTtVQUNBO1FBQ0QsQ0FFRDtRQUNBLE1BQU1nQixZQUFZLEdBQUdaLFdBQVcsQ0FBQ0wsTUFBRCxDQUFoQztRQUVBLElBQUlpQixZQUFZLEtBQUtqQixNQUFqQmlCLElBQTJCaEIsS0FBSyxDQUFDSyxRQUFOTCxDQUFlZ0IsWUFBZmhCLENBQS9CLEVBQTZEO1VBQzNEO1FBQ0Q7TUFDRjtJQUNGO0VBQ0Y7RUFDRCxPQUFPRCxNQUFQO0FBQ0QiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcmVzb2x2ZS1yZXdyaXRlcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgcGF0aE1hdGNoIGZyb20gJy4vcGF0aC1tYXRjaCdcbmltcG9ydCBwcmVwYXJlRGVzdGluYXRpb24gZnJvbSAnLi9wcmVwYXJlLWRlc3RpbmF0aW9uJ1xuaW1wb3J0IHsgUmV3cml0ZSB9IGZyb20gJy4uLy4uLy4uLy4uL2xpYi9sb2FkLWN1c3RvbS1yb3V0ZXMnXG5pbXBvcnQgeyByZW1vdmVQYXRoVHJhaWxpbmdTbGFzaCB9IGZyb20gJy4uLy4uLy4uLy4uL2NsaWVudC9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2gnXG5cbmNvbnN0IGN1c3RvbVJvdXRlTWF0Y2hlciA9IHBhdGhNYXRjaCh0cnVlKVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZXNvbHZlUmV3cml0ZXMoXG4gIGFzUGF0aDogc3RyaW5nLFxuICBwYWdlczogc3RyaW5nW10sXG4gIGJhc2VQYXRoOiBzdHJpbmcsXG4gIHJld3JpdGVzOiBSZXdyaXRlW10sXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSxcbiAgcmVzb2x2ZUhyZWY6IChwYXRoOiBzdHJpbmcpID0+IHN0cmluZ1xuKSB7XG4gIGlmICghcGFnZXMuaW5jbHVkZXMoYXNQYXRoKSkge1xuICAgIGZvciAoY29uc3QgcmV3cml0ZSBvZiByZXdyaXRlcykge1xuICAgICAgY29uc3QgbWF0Y2hlciA9IGN1c3RvbVJvdXRlTWF0Y2hlcihyZXdyaXRlLnNvdXJjZSlcbiAgICAgIGNvbnN0IHBhcmFtcyA9IG1hdGNoZXIoYXNQYXRoKVxuXG4gICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgIGlmICghcmV3cml0ZS5kZXN0aW5hdGlvbikge1xuICAgICAgICAgIC8vIHRoaXMgaXMgYSBwcm94aWVkIHJld3JpdGUgd2hpY2ggaXNuJ3QgaGFuZGxlZCBvbiB0aGUgY2xpZW50XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXN0UmVzID0gcHJlcGFyZURlc3RpbmF0aW9uKFxuICAgICAgICAgIHJld3JpdGUuZGVzdGluYXRpb24sXG4gICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgcmV3cml0ZS5iYXNlUGF0aCA9PT0gZmFsc2UgPyAnJyA6IGJhc2VQYXRoXG4gICAgICAgIClcbiAgICAgICAgYXNQYXRoID0gZGVzdFJlcy5wYXJzZWREZXN0aW5hdGlvbi5wYXRobmFtZSFcbiAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgZGVzdFJlcy5wYXJzZWREZXN0aW5hdGlvbi5xdWVyeSlcblxuICAgICAgICBpZiAocGFnZXMuaW5jbHVkZXMocmVtb3ZlUGF0aFRyYWlsaW5nU2xhc2goYXNQYXRoKSkpIHtcbiAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBub3cgbWF0Y2ggYSBwYWdlIGFzIHRoaXMgbWVhbnMgd2UgYXJlIGRvbmVcbiAgICAgICAgICAvLyByZXNvbHZpbmcgdGhlIHJld3JpdGVzXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIG1hdGNoIGEgZHluYW1pYy1yb3V0ZSwgaWYgc28gd2UgYnJlYWsgdGhlIHJld3JpdGVzIGNoYWluXG4gICAgICAgIGNvbnN0IHJlc29sdmVkSHJlZiA9IHJlc29sdmVIcmVmKGFzUGF0aClcblxuICAgICAgICBpZiAocmVzb2x2ZWRIcmVmICE9PSBhc1BhdGggJiYgcGFnZXMuaW5jbHVkZXMocmVzb2x2ZWRIcmVmKSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFzUGF0aFxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/router/utils/resolve-rewrites.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.getRouteMatcher = getRouteMatcher;\nfunction getRouteMatcher(routeRegex) {\n  const {\n    re,\n    groups\n  } = routeRegex;\n  return pathname => {\n    const routeMatch = re.exec(pathname);\n    if (!routeMatch) {\n      return false;\n    }\n    const decode = param => {\n      try {\n        return decodeURIComponent(param);\n      } catch (_) {\n        const err = new Error('failed to decode param');\n        err.code = 'DECODE_FAILED';\n        throw err;\n      }\n    };\n    const params = {};\n    Object.keys(groups).forEach(slugName => {\n      const g = groups[slugName];\n      const m = routeMatch[g.pos];\n      if (m !== undefined) {\n        params[slugName] = ~m.indexOf('/') ? m.split('/').map(entry => decode(entry)) : g.repeat ? [decode(m)] : decode(m);\n      }\n    });\n    return params;\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9yb3V0ZS1tYXRjaGVyLnRzP2E2NzIiXSwibmFtZXMiOlsiZ2V0Um91dGVNYXRjaGVyIiwicm91dGVSZWdleCIsInJlIiwiZ3JvdXBzIiwicGF0aG5hbWUiLCJyb3V0ZU1hdGNoIiwiZXhlYyIsImRlY29kZSIsInBhcmFtIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiXyIsImVyciIsIkVycm9yIiwiY29kZSIsInBhcmFtcyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwic2x1Z05hbWUiLCJnIiwibSIsInBvcyIsInVuZGVmaW5lZCIsImluZGV4T2YiLCJzcGxpdCIsIm1hcCIsImVudHJ5IiwicmVwZWF0Il0sIm1hcHBpbmdzIjoiOzs7O0FBRU8sU0FBU0EsZUFBVCxDQUF5QkMsVUFBekIsRUFBdUU7RUFDNUUsTUFBTTtJQUFFQyxFQUFGO0lBQU1DO0VBQU4sSUFBaUJGLFVBQXZCO0VBQ0EsT0FBUUcsUUFBRCxJQUF5QztJQUM5QyxNQUFNQyxVQUFVLEdBQUdILEVBQUUsQ0FBQ0ksSUFBSEosQ0FBUUUsUUFBUkYsQ0FBbkI7SUFDQSxJQUFJLENBQUNHLFVBQUwsRUFBaUI7TUFDZixPQUFPLEtBQVA7SUFDRDtJQUVELE1BQU1FLE1BQU0sR0FBSUMsS0FBRCxJQUFtQjtNQUNoQyxJQUFJO1FBQ0YsT0FBT0Msa0JBQWtCLENBQUNELEtBQUQsQ0FBekI7TUFDRCxDQUFDLFFBQU9FLENBQVAsRUFBVTtRQUNWLE1BQU1DLEdBQThCLEdBQUcsSUFBSUMsS0FBSixDQUNyQyx3QkFEcUMsQ0FBdkM7UUFHQUQsR0FBRyxDQUFDRSxJQUFKRixHQUFXLGVBQVhBO1FBQ0EsTUFBTUEsR0FBTjtNQUNEO0lBQ0YsQ0FWRDtJQVdBLE1BQU1HLE1BQWtELEdBQUcsRUFBM0Q7SUFFQUMsTUFBTSxDQUFDQyxJQUFQRCxDQUFZWixNQUFaWSxFQUFvQkUsT0FBcEJGLENBQTZCRyxRQUFELElBQXNCO01BQ2hELE1BQU1DLENBQUMsR0FBR2hCLE1BQU0sQ0FBQ2UsUUFBRCxDQUFoQjtNQUNBLE1BQU1FLENBQUMsR0FBR2YsVUFBVSxDQUFDYyxDQUFDLENBQUNFLEdBQUgsQ0FBcEI7TUFDQSxJQUFJRCxDQUFDLEtBQUtFLFNBQVYsRUFBcUI7UUFDbkJSLE1BQU0sQ0FBQ0ksUUFBRCxDQUFOSixHQUFtQixDQUFDTSxDQUFDLENBQUNHLE9BQUZILENBQVUsR0FBVkEsQ0FBRCxHQUNmQSxDQUFDLENBQUNJLEtBQUZKLENBQVEsR0FBUkEsRUFBYUssR0FBYkwsQ0FBa0JNLEtBQUQsSUFBV25CLE1BQU0sQ0FBQ21CLEtBQUQsQ0FBbENOLENBRGUsR0FFZkQsQ0FBQyxDQUFDUSxNQUFGUixHQUNBLENBQUNaLE1BQU0sQ0FBQ2EsQ0FBRCxDQUFQLENBREFELEdBRUFaLE1BQU0sQ0FBQ2EsQ0FBRCxDQUpWTjtNQUtEO0lBQ0YsQ0FWREM7SUFXQSxPQUFPRCxNQUFQO0VBQ0QsQ0EvQkQ7QUFnQ0QiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtbWF0Y2hlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldFJvdXRlUmVnZXggfSBmcm9tICcuL3JvdXRlLXJlZ2V4J1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um91dGVNYXRjaGVyKHJvdXRlUmVnZXg6IFJldHVyblR5cGU8dHlwZW9mIGdldFJvdXRlUmVnZXg+KSB7XG4gIGNvbnN0IHsgcmUsIGdyb3VwcyB9ID0gcm91dGVSZWdleFxuICByZXR1cm4gKHBhdGhuYW1lOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgY29uc3Qgcm91dGVNYXRjaCA9IHJlLmV4ZWMocGF0aG5hbWUhKVxuICAgIGlmICghcm91dGVNYXRjaCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgZGVjb2RlID0gKHBhcmFtOiBzdHJpbmcpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocGFyYW0pXG4gICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIGNvbnN0IGVycjogRXJyb3IgJiB7IGNvZGU/OiBzdHJpbmcgfSA9IG5ldyBFcnJvcihcbiAgICAgICAgICAnZmFpbGVkIHRvIGRlY29kZSBwYXJhbSdcbiAgICAgICAgKVxuICAgICAgICBlcnIuY29kZSA9ICdERUNPREVfRkFJTEVEJ1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGFyYW1zOiB7IFtwYXJhbU5hbWU6IHN0cmluZ106IHN0cmluZyB8IHN0cmluZ1tdIH0gPSB7fVxuXG4gICAgT2JqZWN0LmtleXMoZ3JvdXBzKS5mb3JFYWNoKChzbHVnTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCBnID0gZ3JvdXBzW3NsdWdOYW1lXVxuICAgICAgY29uc3QgbSA9IHJvdXRlTWF0Y2hbZy5wb3NdXG4gICAgICBpZiAobSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcmFtc1tzbHVnTmFtZV0gPSB+bS5pbmRleE9mKCcvJylcbiAgICAgICAgICA/IG0uc3BsaXQoJy8nKS5tYXAoKGVudHJ5KSA9PiBkZWNvZGUoZW50cnkpKVxuICAgICAgICAgIDogZy5yZXBlYXRcbiAgICAgICAgICA/IFtkZWNvZGUobSldXG4gICAgICAgICAgOiBkZWNvZGUobSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBwYXJhbXNcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-regex.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.getRouteRegex = getRouteRegex; // this isn't importing the escape-string-regex module\n// to reduce bytes\nfunction escapeRegex(str) {\n  return str.replace(/[|\\\\{}()[\\]^$+*?.-]/g, '\\\\$&');\n}\nfunction parseParameter(param) {\n  const optional = param.startsWith('[') && param.endsWith(']');\n  if (optional) {\n    param = param.slice(1, -1);\n  }\n  const repeat = param.startsWith('...');\n  if (repeat) {\n    param = param.slice(3);\n  }\n  return {\n    key: param,\n    repeat,\n    optional\n  };\n}\nfunction getRouteRegex(normalizedRoute) {\n  const segments = (normalizedRoute.replace(/\\/$/, '') || '/').slice(1).split('/');\n  const groups = {};\n  let groupIndex = 1;\n  const parameterizedRoute = segments.map(segment => {\n    if (segment.startsWith('[') && segment.endsWith(']')) {\n      const {\n        key,\n        optional,\n        repeat\n      } = parseParameter(segment.slice(1, -1));\n      groups[key] = {\n        pos: groupIndex++,\n        repeat,\n        optional\n      };\n      return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';\n    } else {\n      return `/${escapeRegex(segment)}`;\n    }\n  }).join(''); // dead code eliminate for browser since it's only needed\n  // while generating routes-manifest\n  if (true) {\n    let routeKeyCharCode = 97;\n    let routeKeyCharLength = 1; // builds a minimal routeKey using only a-z and minimal number of characters\n    const getSafeRouteKey = () => {\n      let routeKey = '';\n      for (let i = 0; i < routeKeyCharLength; i++) {\n        routeKey += String.fromCharCode(routeKeyCharCode);\n        routeKeyCharCode++;\n        if (routeKeyCharCode > 122) {\n          routeKeyCharLength++;\n          routeKeyCharCode = 97;\n        }\n      }\n      return routeKey;\n    };\n    const routeKeys = {};\n    let namedParameterizedRoute = segments.map(segment => {\n      if (segment.startsWith('[') && segment.endsWith(']')) {\n        const {\n          key,\n          optional,\n          repeat\n        } = parseParameter(segment.slice(1, -1)); // replace any non-word characters since they can break\n        // the named regex\n        let cleanedKey = key.replace(/\\W/g, '');\n        let invalidKey = false; // check if the key is still invalid and fallback to using a known\n        // safe key\n        if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n          invalidKey = true;\n        }\n        if (!isNaN(parseInt(cleanedKey.substr(0, 1)))) {\n          invalidKey = true;\n        }\n        if (invalidKey) {\n          cleanedKey = getSafeRouteKey();\n        }\n        routeKeys[cleanedKey] = key;\n        return repeat ? optional ? `(?:/(?<${cleanedKey}>.+?))?` : `/(?<${cleanedKey}>.+?)` : `/(?<${cleanedKey}>[^/]+?)`;\n      } else {\n        return `/${escapeRegex(segment)}`;\n      }\n    }).join('');\n    return {\n      re: new RegExp(`^${parameterizedRoute}(?:/)?$`),\n      groups,\n      routeKeys,\n      namedRegex: `^${namedParameterizedRoute}(?:/)?$`\n    };\n  }\n  return {\n    re: new RegExp(`^${parameterizedRoute}(?:/)?$`),\n    groups\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9yb3V0ZS1yZWdleC50cz85ZGJjIl0sIm5hbWVzIjpbImVzY2FwZVJlZ2V4Iiwic3RyIiwicmVwbGFjZSIsInBhcnNlUGFyYW1ldGVyIiwicGFyYW0iLCJvcHRpb25hbCIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsInNsaWNlIiwicmVwZWF0Iiwia2V5IiwiZ2V0Um91dGVSZWdleCIsIm5vcm1hbGl6ZWRSb3V0ZSIsInNlZ21lbnRzIiwic3BsaXQiLCJncm91cHMiLCJncm91cEluZGV4IiwicGFyYW1ldGVyaXplZFJvdXRlIiwibWFwIiwic2VnbWVudCIsInBvcyIsImpvaW4iLCJyb3V0ZUtleUNoYXJDb2RlIiwicm91dGVLZXlDaGFyTGVuZ3RoIiwiZ2V0U2FmZVJvdXRlS2V5Iiwicm91dGVLZXkiLCJpIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwicm91dGVLZXlzIiwibmFtZWRQYXJhbWV0ZXJpemVkUm91dGUiLCJjbGVhbmVkS2V5IiwiaW52YWxpZEtleSIsImxlbmd0aCIsImlzTmFOIiwicGFyc2VJbnQiLCJzdWJzdHIiLCJyZSIsIlJlZ0V4cCIsIm5hbWVkUmVnZXgiXSwibWFwcGluZ3MiOiI7OztzQ0FNQTtBQUNBO0FBQ0EsU0FBU0EsV0FBVCxDQUFxQkMsR0FBckIsRUFBa0M7RUFDaEMsT0FBT0EsR0FBRyxDQUFDQyxPQUFKRCxDQUFZLHNCQUFaQSxFQUFvQyxNQUFwQ0EsQ0FBUDtBQUNEO0FBRUQsU0FBU0UsY0FBVCxDQUF3QkMsS0FBeEIsRUFBdUM7RUFDckMsTUFBTUMsUUFBUSxHQUFHRCxLQUFLLENBQUNFLFVBQU5GLENBQWlCLEdBQWpCQSxLQUF5QkEsS0FBSyxDQUFDRyxRQUFOSCxDQUFlLEdBQWZBLENBQTFDO0VBQ0EsSUFBSUMsUUFBSixFQUFjO0lBQ1pELEtBQUssR0FBR0EsS0FBSyxDQUFDSSxLQUFOSixDQUFZLENBQVpBLEVBQWUsQ0FBQyxDQUFoQkEsQ0FBUkE7RUFDRDtFQUNELE1BQU1LLE1BQU0sR0FBR0wsS0FBSyxDQUFDRSxVQUFORixDQUFpQixLQUFqQkEsQ0FBZjtFQUNBLElBQUlLLE1BQUosRUFBWTtJQUNWTCxLQUFLLEdBQUdBLEtBQUssQ0FBQ0ksS0FBTkosQ0FBWSxDQUFaQSxDQUFSQTtFQUNEO0VBQ0QsT0FBTztJQUFFTSxHQUFHLEVBQUVOLEtBQVA7SUFBY0ssTUFBZDtJQUFzQko7RUFBdEIsQ0FBUDtBQUNEO0FBRU0sU0FBU00sYUFBVCxDQUNMQyxlQURLLEVBT0w7RUFDQSxNQUFNQyxRQUFRLEdBQUcsQ0FBQ0QsZUFBZSxDQUFDVixPQUFoQlUsQ0FBd0IsS0FBeEJBLEVBQStCLEVBQS9CQSxLQUFzQyxHQUF2QyxFQUNkSixLQURjLENBQ1IsQ0FEUSxFQUVkTSxLQUZjLENBRVIsR0FGUSxDQUFqQjtFQUlBLE1BQU1DLE1BQXNDLEdBQUcsRUFBL0M7RUFDQSxJQUFJQyxVQUFVLEdBQUcsQ0FBakI7RUFDQSxNQUFNQyxrQkFBa0IsR0FBR0osUUFBUSxDQUNoQ0ssR0FEd0JMLENBQ25CTSxPQUFELElBQWE7SUFDaEIsSUFBSUEsT0FBTyxDQUFDYixVQUFSYSxDQUFtQixHQUFuQkEsS0FBMkJBLE9BQU8sQ0FBQ1osUUFBUlksQ0FBaUIsR0FBakJBLENBQS9CLEVBQXNEO01BQ3BELE1BQU07UUFBRVQsR0FBRjtRQUFPTCxRQUFQO1FBQWlCSTtNQUFqQixJQUE0Qk4sY0FBYyxDQUFDZ0IsT0FBTyxDQUFDWCxLQUFSVyxDQUFjLENBQWRBLEVBQWlCLENBQUMsQ0FBbEJBLENBQUQsQ0FBaEQ7TUFDQUosTUFBTSxDQUFDTCxHQUFELENBQU5LLEdBQWM7UUFBRUssR0FBRyxFQUFFSixVQUFVLEVBQWpCO1FBQXFCUCxNQUFyQjtRQUE2Qko7TUFBN0IsQ0FBZFU7TUFDQSxPQUFPTixNQUFNLEdBQUlKLFFBQVEsR0FBRyxhQUFILEdBQW1CLFFBQS9CLEdBQTJDLFdBQXhEO0lBQ0QsQ0FKRCxNQUlPO01BQ0wsT0FBUSxJQUFHTCxXQUFXLENBQUNtQixPQUFELENBQVUsRUFBaEM7SUFDRDtFQUNGLENBVHdCTixFQVV4QlEsSUFWd0JSLENBVW5CLEVBVm1CQSxDQUEzQixDQVlBO0VBQ0E7RUFDQSxVQUFtQztJQUNqQyxJQUFJUyxnQkFBZ0IsR0FBRyxFQUF2QjtJQUNBLElBQUlDLGtCQUFrQixHQUFHLENBQXpCLENBRUE7SUFDQSxNQUFNQyxlQUFlLEdBQUcsTUFBTTtNQUM1QixJQUFJQyxRQUFRLEdBQUcsRUFBZjtNQUVBLEtBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0gsa0JBQXBCLEVBQXdDRyxDQUFDLEVBQXpDLEVBQTZDO1FBQzNDRCxRQUFRLElBQUlFLE1BQU0sQ0FBQ0MsWUFBUEQsQ0FBb0JMLGdCQUFwQkssQ0FBWkY7UUFDQUgsZ0JBQWdCO1FBRWhCLElBQUlBLGdCQUFnQixHQUFHLEdBQXZCLEVBQTRCO1VBQzFCQyxrQkFBa0I7VUFDbEJELGdCQUFnQixHQUFHLEVBQW5CQTtRQUNEO01BQ0Y7TUFDRCxPQUFPRyxRQUFQO0lBQ0QsQ0FiRDtJQWVBLE1BQU1JLFNBQXNDLEdBQUcsRUFBL0M7SUFFQSxJQUFJQyx1QkFBdUIsR0FBR2pCLFFBQVEsQ0FDbkNLLEdBRDJCTCxDQUN0Qk0sT0FBRCxJQUFhO01BQ2hCLElBQUlBLE9BQU8sQ0FBQ2IsVUFBUmEsQ0FBbUIsR0FBbkJBLEtBQTJCQSxPQUFPLENBQUNaLFFBQVJZLENBQWlCLEdBQWpCQSxDQUEvQixFQUFzRDtRQUNwRCxNQUFNO1VBQUVULEdBQUY7VUFBT0wsUUFBUDtVQUFpQkk7UUFBakIsSUFBNEJOLGNBQWMsQ0FBQ2dCLE9BQU8sQ0FBQ1gsS0FBUlcsQ0FBYyxDQUFkQSxFQUFpQixDQUFDLENBQWxCQSxDQUFELENBQWhELENBQ0E7UUFDQTtRQUNBLElBQUlZLFVBQVUsR0FBR3JCLEdBQUcsQ0FBQ1IsT0FBSlEsQ0FBWSxLQUFaQSxFQUFtQixFQUFuQkEsQ0FBakI7UUFDQSxJQUFJc0IsVUFBVSxHQUFHLEtBQWpCLENBRUE7UUFDQTtRQUNBLElBQUlELFVBQVUsQ0FBQ0UsTUFBWEYsS0FBc0IsQ0FBdEJBLElBQTJCQSxVQUFVLENBQUNFLE1BQVhGLEdBQW9CLEVBQW5ELEVBQXVEO1VBQ3JEQyxVQUFVLEdBQUcsSUFBYkE7UUFDRDtRQUNELElBQUksQ0FBQ0UsS0FBSyxDQUFDQyxRQUFRLENBQUNKLFVBQVUsQ0FBQ0ssTUFBWEwsQ0FBa0IsQ0FBbEJBLEVBQXFCLENBQXJCQSxDQUFELENBQVQsQ0FBVixFQUErQztVQUM3Q0MsVUFBVSxHQUFHLElBQWJBO1FBQ0Q7UUFFRCxJQUFJQSxVQUFKLEVBQWdCO1VBQ2RELFVBQVUsR0FBR1AsZUFBZSxFQUE1Qk87UUFDRDtRQUVERixTQUFTLENBQUNFLFVBQUQsQ0FBVEYsR0FBd0JuQixHQUF4Qm1CO1FBQ0EsT0FBT3BCLE1BQU0sR0FDVEosUUFBUSxHQUNMLFVBQVMwQixVQUFXLFNBRGYsR0FFTCxPQUFNQSxVQUFXLE9BSFgsR0FJUixPQUFNQSxVQUFXLFVBSnRCO01BS0QsQ0ExQkQsTUEwQk87UUFDTCxPQUFRLElBQUcvQixXQUFXLENBQUNtQixPQUFELENBQVUsRUFBaEM7TUFDRDtJQUNGLENBL0IyQk4sRUFnQzNCUSxJQWhDMkJSLENBZ0N0QixFQWhDc0JBLENBQTlCO0lBa0NBLE9BQU87TUFDTHdCLEVBQUUsRUFBRSxJQUFJQyxNQUFKLENBQVksSUFBR3JCLGtCQUFtQixTQUFsQyxDQURDO01BRUxGLE1BRks7TUFHTGMsU0FISztNQUlMVSxVQUFVLEVBQUcsSUFBR1QsdUJBQXdCO0lBSm5DLENBQVA7RUFNRDtFQUVELE9BQU87SUFDTE8sRUFBRSxFQUFFLElBQUlDLE1BQUosQ0FBWSxJQUFHckIsa0JBQW1CLFNBQWxDLENBREM7SUFFTEY7RUFGSyxDQUFQO0FBSUQiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtcmVnZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbnRlcmZhY2UgR3JvdXAge1xuICBwb3M6IG51bWJlclxuICByZXBlYXQ6IGJvb2xlYW5cbiAgb3B0aW9uYWw6IGJvb2xlYW5cbn1cblxuLy8gdGhpcyBpc24ndCBpbXBvcnRpbmcgdGhlIGVzY2FwZS1zdHJpbmctcmVnZXggbW9kdWxlXG4vLyB0byByZWR1Y2UgYnl0ZXNcbmZ1bmN0aW9uIGVzY2FwZVJlZ2V4KHN0cjogc3RyaW5nKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvW3xcXFxce30oKVtcXF1eJCsqPy4tXS9nLCAnXFxcXCQmJylcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXJhbWV0ZXIocGFyYW06IHN0cmluZykge1xuICBjb25zdCBvcHRpb25hbCA9IHBhcmFtLnN0YXJ0c1dpdGgoJ1snKSAmJiBwYXJhbS5lbmRzV2l0aCgnXScpXG4gIGlmIChvcHRpb25hbCkge1xuICAgIHBhcmFtID0gcGFyYW0uc2xpY2UoMSwgLTEpXG4gIH1cbiAgY29uc3QgcmVwZWF0ID0gcGFyYW0uc3RhcnRzV2l0aCgnLi4uJylcbiAgaWYgKHJlcGVhdCkge1xuICAgIHBhcmFtID0gcGFyYW0uc2xpY2UoMylcbiAgfVxuICByZXR1cm4geyBrZXk6IHBhcmFtLCByZXBlYXQsIG9wdGlvbmFsIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJvdXRlUmVnZXgoXG4gIG5vcm1hbGl6ZWRSb3V0ZTogc3RyaW5nXG4pOiB7XG4gIHJlOiBSZWdFeHBcbiAgbmFtZWRSZWdleD86IHN0cmluZ1xuICByb3V0ZUtleXM/OiB7IFtuYW1lZDogc3RyaW5nXTogc3RyaW5nIH1cbiAgZ3JvdXBzOiB7IFtncm91cE5hbWU6IHN0cmluZ106IEdyb3VwIH1cbn0ge1xuICBjb25zdCBzZWdtZW50cyA9IChub3JtYWxpemVkUm91dGUucmVwbGFjZSgvXFwvJC8sICcnKSB8fCAnLycpXG4gICAgLnNsaWNlKDEpXG4gICAgLnNwbGl0KCcvJylcblxuICBjb25zdCBncm91cHM6IHsgW2dyb3VwTmFtZTogc3RyaW5nXTogR3JvdXAgfSA9IHt9XG4gIGxldCBncm91cEluZGV4ID0gMVxuICBjb25zdCBwYXJhbWV0ZXJpemVkUm91dGUgPSBzZWdtZW50c1xuICAgIC5tYXAoKHNlZ21lbnQpID0+IHtcbiAgICAgIGlmIChzZWdtZW50LnN0YXJ0c1dpdGgoJ1snKSAmJiBzZWdtZW50LmVuZHNXaXRoKCddJykpIHtcbiAgICAgICAgY29uc3QgeyBrZXksIG9wdGlvbmFsLCByZXBlYXQgfSA9IHBhcnNlUGFyYW1ldGVyKHNlZ21lbnQuc2xpY2UoMSwgLTEpKVxuICAgICAgICBncm91cHNba2V5XSA9IHsgcG9zOiBncm91cEluZGV4KyssIHJlcGVhdCwgb3B0aW9uYWwgfVxuICAgICAgICByZXR1cm4gcmVwZWF0ID8gKG9wdGlvbmFsID8gJyg/Oi8oLis/KSk/JyA6ICcvKC4rPyknKSA6ICcvKFteL10rPyknXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYC8ke2VzY2FwZVJlZ2V4KHNlZ21lbnQpfWBcbiAgICAgIH1cbiAgICB9KVxuICAgIC5qb2luKCcnKVxuXG4gIC8vIGRlYWQgY29kZSBlbGltaW5hdGUgZm9yIGJyb3dzZXIgc2luY2UgaXQncyBvbmx5IG5lZWRlZFxuICAvLyB3aGlsZSBnZW5lcmF0aW5nIHJvdXRlcy1tYW5pZmVzdFxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsZXQgcm91dGVLZXlDaGFyQ29kZSA9IDk3XG4gICAgbGV0IHJvdXRlS2V5Q2hhckxlbmd0aCA9IDFcblxuICAgIC8vIGJ1aWxkcyBhIG1pbmltYWwgcm91dGVLZXkgdXNpbmcgb25seSBhLXogYW5kIG1pbmltYWwgbnVtYmVyIG9mIGNoYXJhY3RlcnNcbiAgICBjb25zdCBnZXRTYWZlUm91dGVLZXkgPSAoKSA9PiB7XG4gICAgICBsZXQgcm91dGVLZXkgPSAnJ1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdXRlS2V5Q2hhckxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJvdXRlS2V5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocm91dGVLZXlDaGFyQ29kZSlcbiAgICAgICAgcm91dGVLZXlDaGFyQ29kZSsrXG5cbiAgICAgICAgaWYgKHJvdXRlS2V5Q2hhckNvZGUgPiAxMjIpIHtcbiAgICAgICAgICByb3V0ZUtleUNoYXJMZW5ndGgrK1xuICAgICAgICAgIHJvdXRlS2V5Q2hhckNvZGUgPSA5N1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcm91dGVLZXlcbiAgICB9XG5cbiAgICBjb25zdCByb3V0ZUtleXM6IHsgW25hbWVkOiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9XG5cbiAgICBsZXQgbmFtZWRQYXJhbWV0ZXJpemVkUm91dGUgPSBzZWdtZW50c1xuICAgICAgLm1hcCgoc2VnbWVudCkgPT4ge1xuICAgICAgICBpZiAoc2VnbWVudC5zdGFydHNXaXRoKCdbJykgJiYgc2VnbWVudC5lbmRzV2l0aCgnXScpKSB7XG4gICAgICAgICAgY29uc3QgeyBrZXksIG9wdGlvbmFsLCByZXBlYXQgfSA9IHBhcnNlUGFyYW1ldGVyKHNlZ21lbnQuc2xpY2UoMSwgLTEpKVxuICAgICAgICAgIC8vIHJlcGxhY2UgYW55IG5vbi13b3JkIGNoYXJhY3RlcnMgc2luY2UgdGhleSBjYW4gYnJlYWtcbiAgICAgICAgICAvLyB0aGUgbmFtZWQgcmVnZXhcbiAgICAgICAgICBsZXQgY2xlYW5lZEtleSA9IGtleS5yZXBsYWNlKC9cXFcvZywgJycpXG4gICAgICAgICAgbGV0IGludmFsaWRLZXkgPSBmYWxzZVxuXG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGtleSBpcyBzdGlsbCBpbnZhbGlkIGFuZCBmYWxsYmFjayB0byB1c2luZyBhIGtub3duXG4gICAgICAgICAgLy8gc2FmZSBrZXlcbiAgICAgICAgICBpZiAoY2xlYW5lZEtleS5sZW5ndGggPT09IDAgfHwgY2xlYW5lZEtleS5sZW5ndGggPiAzMCkge1xuICAgICAgICAgICAgaW52YWxpZEtleSA9IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc05hTihwYXJzZUludChjbGVhbmVkS2V5LnN1YnN0cigwLCAxKSkpKSB7XG4gICAgICAgICAgICBpbnZhbGlkS2V5ID0gdHJ1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpbnZhbGlkS2V5KSB7XG4gICAgICAgICAgICBjbGVhbmVkS2V5ID0gZ2V0U2FmZVJvdXRlS2V5KClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3V0ZUtleXNbY2xlYW5lZEtleV0gPSBrZXlcbiAgICAgICAgICByZXR1cm4gcmVwZWF0XG4gICAgICAgICAgICA/IG9wdGlvbmFsXG4gICAgICAgICAgICAgID8gYCg/Oi8oPzwke2NsZWFuZWRLZXl9Pi4rPykpP2BcbiAgICAgICAgICAgICAgOiBgLyg/PCR7Y2xlYW5lZEtleX0+Lis/KWBcbiAgICAgICAgICAgIDogYC8oPzwke2NsZWFuZWRLZXl9PlteL10rPylgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGAvJHtlc2NhcGVSZWdleChzZWdtZW50KX1gXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuam9pbignJylcblxuICAgIHJldHVybiB7XG4gICAgICByZTogbmV3IFJlZ0V4cChgXiR7cGFyYW1ldGVyaXplZFJvdXRlfSg/Oi8pPyRgKSxcbiAgICAgIGdyb3VwcyxcbiAgICAgIHJvdXRlS2V5cyxcbiAgICAgIG5hbWVkUmVnZXg6IGBeJHtuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZX0oPzovKT8kYCxcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJlOiBuZXcgUmVnRXhwKGBeJHtwYXJhbWV0ZXJpemVkUm91dGV9KD86Lyk/JGApLFxuICAgIGdyb3VwcyxcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/router/utils/route-regex.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/utils.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.execOnce = execOnce;\nexports.getLocationOrigin = getLocationOrigin;\nexports.getURL = getURL;\nexports.getDisplayName = getDisplayName;\nexports.isResSent = isResSent;\nexports.loadGetInitialProps = loadGetInitialProps;\nexports.formatWithValidation = formatWithValidation;\nexports.ST = exports.SP = exports.urlObjectKeys = void 0;\nvar _formatUrl = __webpack_require__(/*! ./router/utils/format-url */ \"./node_modules/next/dist/next-server/lib/router/utils/format-url.js\"); /**\n                                                       * Utils\n                                                       */\nfunction execOnce(fn) {\n  let used = false;\n  let result;\n  return (...args) => {\n    if (!used) {\n      used = true;\n      result = fn(...args);\n    }\n    return result;\n  };\n}\nfunction getLocationOrigin() {\n  const {\n    protocol,\n    hostname,\n    port\n  } = window.location;\n  return `${protocol}//${hostname}${port ? ':' + port : ''}`;\n}\nfunction getURL() {\n  const {\n    href\n  } = window.location;\n  const origin = getLocationOrigin();\n  return href.substring(origin.length);\n}\nfunction getDisplayName(Component) {\n  return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';\n}\nfunction isResSent(res) {\n  return res.finished || res.headersSent;\n}\nasync function loadGetInitialProps(App, ctx) {\n  if (true) {\n    var _App$prototype;\n    if ((_App$prototype = App.prototype) == null ? void 0 : _App$prototype.getInitialProps) {\n      const message = `\"${getDisplayName(App)}.getInitialProps()\" is defined as an instance method - visit https://err.sh/vercel/next.js/get-initial-props-as-an-instance-method for more information.`;\n      throw new Error(message);\n    }\n  } // when called from _app `ctx` is nested in `ctx`\n  const res = ctx.res || ctx.ctx && ctx.ctx.res;\n  if (!App.getInitialProps) {\n    if (ctx.ctx && ctx.Component) {\n      // @ts-ignore pageProps default\n      return {\n        pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)\n      };\n    }\n    return {};\n  }\n  const props = await App.getInitialProps(ctx);\n  if (res && isResSent(res)) {\n    return props;\n  }\n  if (!props) {\n    const message = `\"${getDisplayName(App)}.getInitialProps()\" should resolve to an object. But found \"${props}\" instead.`;\n    throw new Error(message);\n  }\n  if (true) {\n    if (Object.keys(props).length === 0 && !ctx.ctx) {\n      console.warn(`${getDisplayName(App)} returned an empty object from \\`getInitialProps\\`. This de-optimizes and prevents automatic static optimization. https://err.sh/vercel/next.js/empty-object-getInitialProps`);\n    }\n  }\n  return props;\n}\nconst urlObjectKeys = ['auth', 'hash', 'host', 'hostname', 'href', 'path', 'pathname', 'port', 'protocol', 'query', 'search', 'slashes'];\nexports.urlObjectKeys = urlObjectKeys;\nfunction formatWithValidation(url) {\n  if (true) {\n    if (url !== null && typeof url === 'object') {\n      Object.keys(url).forEach(key => {\n        if (urlObjectKeys.indexOf(key) === -1) {\n          console.warn(`Unknown key passed via urlObject into url.format: ${key}`);\n        }\n      });\n    }\n  }\n  return (0, _formatUrl.formatUrl)(url);\n}\nconst SP = typeof performance !== 'undefined';\nexports.SP = SP;\nconst ST = SP && typeof performance.mark === 'function' && typeof performance.measure === 'function';\nexports.ST = ST;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3V0aWxzLnRzP2I2ZjkiXSwibmFtZXMiOlsiZXhlY09uY2UiLCJmbiIsInVzZWQiLCJyZXN1bHQiLCJhcmdzIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJwcm90b2NvbCIsImhvc3RuYW1lIiwicG9ydCIsIndpbmRvdyIsImxvY2F0aW9uIiwiZ2V0VVJMIiwiaHJlZiIsIm9yaWdpbiIsInN1YnN0cmluZyIsImxlbmd0aCIsImdldERpc3BsYXlOYW1lIiwiQ29tcG9uZW50IiwiZGlzcGxheU5hbWUiLCJuYW1lIiwiaXNSZXNTZW50IiwicmVzIiwiZmluaXNoZWQiLCJoZWFkZXJzU2VudCIsImxvYWRHZXRJbml0aWFsUHJvcHMiLCJBcHAiLCJjdHgiLCJwcm90b3R5cGUiLCJnZXRJbml0aWFsUHJvcHMiLCJtZXNzYWdlIiwiRXJyb3IiLCJwYWdlUHJvcHMiLCJwcm9wcyIsIk9iamVjdCIsImtleXMiLCJjb25zb2xlIiwid2FybiIsInVybE9iamVjdEtleXMiLCJmb3JtYXRXaXRoVmFsaWRhdGlvbiIsInVybCIsImZvckVhY2giLCJrZXkiLCJpbmRleE9mIiwiU1AiLCJwZXJmb3JtYW5jZSIsIlNUIiwibWFyayIsIm1lYXN1cmUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBSUEsNklBeVFBOzs7QUFHTyxTQUFTQSxRQUFULENBQ0xDLEVBREssRUFFRjtFQUNILElBQUlDLElBQUksR0FBRyxLQUFYO0VBQ0EsSUFBSUMsTUFBSjtFQUVBLE9BQVEsQ0FBQyxHQUFHQyxJQUFKLEtBQW9CO0lBQzFCLElBQUksQ0FBQ0YsSUFBTCxFQUFXO01BQ1RBLElBQUksR0FBRyxJQUFQQTtNQUNBQyxNQUFNLEdBQUdGLEVBQUUsQ0FBQyxHQUFHRyxJQUFKLENBQVhEO0lBQ0Q7SUFDRCxPQUFPQSxNQUFQO0VBQ0QsQ0FORDtBQU9EO0FBRU0sU0FBU0UsaUJBQVQsR0FBNkI7RUFDbEMsTUFBTTtJQUFFQyxRQUFGO0lB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QUFLLElBQVJBLElBQWdCLE9BQU9BLEdBQVAsS0FBZSxRQUFuQyxFQUE2QztNQUMzQ04sTUFBTSxDQUFDQyxJQUFQRCxDQUFZTSxHQUFaTixFQUFpQk8sT0FBakJQLENBQTBCUSxHQUFELElBQVM7UUFDaEMsSUFBSUosYUFBYSxDQUFDSyxPQUFkTCxDQUFzQkksR0FBdEJKLE1BQStCLENBQUMsQ0FBcEMsRUFBdUM7VUFDckNGLE9BQU8sQ0FBQ0MsSUFBUkQsQ0FDRyxxREFBb0RNLEdBQUksRUFEM0ROO1FBR0Q7TUFDRixDQU5ERjtJQU9EO0VBQ0Y7RUFFRCxPQUFPLDBCQUFVTSxHQUFWLENBQVA7QUFDRDtBQUVNLE1BQU1JLEVBQUUsR0FBRyxPQUFPQyxXQUFQLEtBQXVCLFdBQWxDOztBQUNBLE1BQU1DLEVBQUUsR0FDYkYsRUFBRSxJQUNGLE9BQU9DLFdBQVcsQ0FBQ0UsSUFBbkIsS0FBNEIsVUFENUJILElBRUEsT0FBT0MsV0FBVyxDQUFDRyxPQUFuQixLQUErQixVQUgxQiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL3V0aWxzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5jb21pbmdNZXNzYWdlLCBTZXJ2ZXJSZXNwb25zZSB9IGZyb20gJ2h0dHAnXG5pbXBvcnQgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHsgQ29tcG9uZW50VHlwZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgVXJsT2JqZWN0IH0gZnJvbSAndXJsJ1xuaW1wb3J0IHsgZm9ybWF0VXJsIH0gZnJvbSAnLi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybCdcbmltcG9ydCB7IE1hbmlmZXN0SXRlbSB9IGZyb20gJy4uL3NlcnZlci9sb2FkLWNvbXBvbmVudHMnXG5pbXBvcnQgeyBOZXh0Um91dGVyIH0gZnJvbSAnLi9yb3V0ZXIvcm91dGVyJ1xuaW1wb3J0IHsgRW52IH0gZnJvbSAnQG5leHQvZW52J1xuaW1wb3J0IHsgQnVpbGRNYW5pZmVzdCB9IGZyb20gJy4uL3NlcnZlci9nZXQtcGFnZS1maWxlcydcblxuLyoqXG4gKiBUeXBlcyB1c2VkIGJ5IGJvdGggbmV4dCBhbmQgbmV4dC1zZXJ2ZXJcbiAqL1xuXG5leHBvcnQgdHlwZSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgQyBleHRlbmRzIEJhc2VDb250ZXh0ID0gTmV4dFBhZ2VDb250ZXh0LFxuICBJUCA9IHt9LFxuICBQID0ge31cbj4gPSBDb21wb25lbnRUeXBlPFA+ICYge1xuICAvKipcbiAgICogVXNlZCBmb3IgaW5pdGlhbCBwYWdlIGxvYWQgZGF0YSBwb3B1bGF0aW9uLiBEYXRhIHJldHVybmVkIGZyb20gYGdldEluaXRpYWxQcm9wc2AgaXMgc2VyaWFsaXplZCB3aGVuIHNlcnZlciByZW5kZXJlZC5cbiAgICogTWFrZSBzdXJlIHRvIHJldHVybiBwbGFpbiBgT2JqZWN0YCB3aXRob3V0IHVzaW5nIGBEYXRlYCwgYE1hcGAsIGBTZXRgLlxuICAgKiBAcGFyYW0gY3R4IENvbnRleHQgb2YgYHBhZ2VgXG4gICAqL1xuICBnZXRJbml0aWFsUHJvcHM/KGNvbnRleHQ6IEMpOiBJUCB8IFByb21pc2U8SVA+XG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50VHlwZSA9IE5leHRDb21wb25lbnRUeXBlPFxuICBEb2N1bWVudENvbnRleHQsXG4gIERvY3VtZW50SW5pdGlhbFByb3BzLFxuICBEb2N1bWVudFByb3BzXG4+ICYge1xuICByZW5kZXJEb2N1bWVudChcbiAgICBEb2N1bWVudDogRG9jdW1lbnRUeXBlLFxuICAgIHByb3BzOiBEb2N1bWVudFByb3BzXG4gICk6IFJlYWN0LlJlYWN0RWxlbWVudFxufVxuXG5leHBvcnQgdHlwZSBBcHBUeXBlID0gTmV4dENvbXBvbmVudFR5cGU8XG4gIEFwcENvbnRleHRUeXBlLFxuICBBcHBJbml0aWFsUHJvcHMsXG4gIEFwcFByb3BzVHlwZVxuPlxuXG5leHBvcnQgdHlwZSBBcHBUcmVlVHlwZSA9IENvbXBvbmVudFR5cGU8XG4gIEFwcEluaXRpYWxQcm9wcyAmIHsgW25hbWU6IHN0cmluZ106IGFueSB9XG4+XG5cbi8qKlxuICogV2ViIHZpdGFscyBwcm92aWRlZCB0byBfYXBwLnJlcG9ydFdlYlZpdGFscyBieSBDb3JlIFdlYiBWaXRhbHMgcGx1Z2luIGRldmVsb3BlZCBieSBHb29nbGUgQ2hyb21lIHRlYW0uXG4gKiBodHRwczovL25leHRqcy5vcmcvYmxvZy9uZXh0LTktNCNpbnRlZ3JhdGVkLXdlYi12aXRhbHMtcmVwb3J0aW5nXG4gKi9cbmV4cG9ydCB0eXBlIE5leHRXZWJWaXRhbHNNZXRyaWMgPSB7XG4gIGlkOiBzdHJpbmdcbiAgbGFiZWw6IHN0cmluZ1xuICBuYW1lOiBzdHJpbmdcbiAgc3RhcnRUaW1lOiBudW1iZXJcbiAgdmFsdWU6IG51bWJlclxufVxuXG5leHBvcnQgdHlwZSBFbmhhbmNlcjxDPiA9IChDb21wb25lbnQ6IEMpID0+IENcblxuZXhwb3J0IHR5cGUgQ29tcG9uZW50c0VuaGFuY2VyID1cbiAgfCB7XG4gICAgICBlbmhhbmNlQXBwPzogRW5oYW5jZXI8QXBwVHlwZT5cbiAgICAgIGVuaGFuY2VDb21wb25lbnQ/OiBFbmhhbmNlcjxOZXh0Q29tcG9uZW50VHlwZT5cbiAgICB9XG4gIHwgRW5oYW5jZXI8TmV4dENvbXBvbmVudFR5cGU+XG5cbmV4cG9ydCB0eXBlIFJlbmRlclBhZ2VSZXN1bHQgPSB7XG4gIGh0bWw6IHN0cmluZ1xuICBoZWFkPzogQXJyYXk8SlNYLkVsZW1lbnQgfCBudWxsPlxufVxuXG5leHBvcnQgdHlwZSBSZW5kZXJQYWdlID0gKFxuICBvcHRpb25zPzogQ29tcG9uZW50c0VuaGFuY2VyXG4pID0+IFJlbmRlclBhZ2VSZXN1bHQgfCBQcm9taXNlPFJlbmRlclBhZ2VSZXN1bHQ+XG5cbmV4cG9ydCB0eXBlIEJhc2VDb250ZXh0ID0ge1xuICByZXM/OiBTZXJ2ZXJSZXNwb25zZVxuICBbazogc3RyaW5nXTogYW55XG59XG5cbmV4cG9ydCB0eXBlIEhlYWRFbnRyeSA9IFtzdHJpbmcsIHsgW2tleTogc3RyaW5nXTogYW55IH1dXG5cbmV4cG9ydCB0eXBlIE5FWFRfREFUQSA9IHtcbiAgcHJvcHM6IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgcGFnZTogc3RyaW5nXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICBidWlsZElkOiBzdHJpbmdcbiAgYXNzZXRQcmVmaXg/OiBzdHJpbmdcbiAgcnVudGltZUNvbmZpZz86IHsgW2tleTogc3RyaW5nXTogYW55IH1cbiAgbmV4dEV4cG9ydD86IGJvb2xlYW5cbiAgYXV0b0V4cG9ydD86IGJvb2xlYW5cbiAgaXNGYWxsYmFjaz86IGJvb2xlYW5cbiAgZHluYW1pY0lkcz86IHN0cmluZ1tdXG4gIGVycj86IEVycm9yICYgeyBzdGF0dXNDb2RlPzogbnVtYmVyIH1cbiAgZ3NwPzogYm9vbGVhblxuICBnc3NwPzogYm9vbGVhblxuICBjdXN0b21TZXJ2ZXI/OiBib29sZWFuXG4gIGdpcD86IGJvb2xlYW5cbiAgYXBwR2lwPzogYm9vbGVhblxuICBoZWFkOiBIZWFkRW50cnlbXVxuICBsb2NhbGU/OiBzdHJpbmdcbiAgbG9jYWxlcz86IHN0cmluZ1tdXG4gIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbn1cblxuLyoqXG4gKiBgTmV4dGAgY29udGV4dFxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5leHRQYWdlQ29udGV4dCB7XG4gIC8qKlxuICAgKiBFcnJvciBvYmplY3QgaWYgZW5jb3VudGVyZWQgZHVyaW5nIHJlbmRlcmluZ1xuICAgKi9cbiAgZXJyPzogKEVycm9yICYgeyBzdGF0dXNDb2RlPzogbnVtYmVyIH0pIHwgbnVsbFxuICAvKipcbiAgICogYEhUVFBgIHJlcXVlc3Qgb2JqZWN0LlxuICAgKi9cbiAgcmVxPzogSW5jb21pbmdNZXNzYWdlXG4gIC8qKlxuICAgKiBgSFRUUGAgcmVzcG9uc2Ugb2JqZWN0LlxuICAgKi9cbiAgcmVzPzogU2VydmVyUmVzcG9uc2VcbiAgLyoqXG4gICAqIFBhdGggc2VjdGlvbiBvZiBgVVJMYC5cbiAgICovXG4gIHBhdGhuYW1lOiBzdHJpbmdcbiAgLyoqXG4gICAqIFF1ZXJ5IHN0cmluZyBzZWN0aW9uIG9mIGBVUkxgIHBhcnNlZCBhcyBhbiBvYmplY3QuXG4gICAqL1xuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbiAgLyoqXG4gICAqIGBTdHJpbmdgIG9mIHRoZSBhY3R1YWwgcGF0aCBpbmNsdWRpbmcgcXVlcnkuXG4gICAqL1xuICBhc1BhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIGBDb21wb25lbnRgIHRoZSB0cmVlIG9mIHRoZSBBcHAgdG8gdXNlIGlmIG5lZWRpbmcgdG8gcmVuZGVyIHNlcGFyYXRlbHlcbiAgICovXG4gIEFwcFRyZWU6IEFwcFRyZWVUeXBlXG59XG5cbmV4cG9ydCB0eXBlIEFwcENvbnRleHRUeXBlPFIgZXh0ZW5kcyBOZXh0Um91dGVyID0gTmV4dFJvdXRlcj4gPSB7XG4gIENvbXBvbmVudDogTmV4dENvbXBvbmVudFR5cGU8TmV4dFBhZ2VDb250ZXh0PlxuICBBcHBUcmVlOiBBcHBUcmVlVHlwZVxuICBjdHg6IE5leHRQYWdlQ29udGV4dFxuICByb3V0ZXI6IFJcbn1cblxuZXhwb3J0IHR5cGUgQXBwSW5pdGlhbFByb3BzID0ge1xuICBwYWdlUHJvcHM6IGFueVxufVxuXG5leHBvcnQgdHlwZSBBcHBQcm9wc1R5cGU8XG4gIFIgZXh0ZW5kcyBOZXh0Um91dGVyID0gTmV4dFJvdXRlcixcbiAgUCA9IHt9XG4+ID0gQXBwSW5pdGlhbFByb3BzICYge1xuICBDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPE5leHRQYWdlQ29udGV4dCwgYW55LCBQPlxuICByb3V0ZXI6IFJcbiAgX19OX1NTRz86IGJvb2xlYW5cbiAgX19OX1NTUD86IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgRG9jdW1lbnRDb250ZXh0ID0gTmV4dFBhZ2VDb250ZXh0ICYge1xuICByZW5kZXJQYWdlOiBSZW5kZXJQYWdlXG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50SW5pdGlhbFByb3BzID0gUmVuZGVyUGFnZVJlc3VsdCAmIHtcbiAgc3R5bGVzPzogUmVhY3QuUmVhY3RFbGVtZW50W10gfCBSZWFjdC5SZWFjdEZyYWdtZW50XG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50UHJvcHMgPSBEb2N1bWVudEluaXRpYWxQcm9wcyAmIHtcbiAgX19ORVhUX0RBVEFfXzogTkVYVF9EQVRBXG4gIGRhbmdlcm91c0FzUGF0aDogc3RyaW5nXG4gIGRvY0NvbXBvbmVudHNSZW5kZXJlZDoge1xuICAgIEh0bWw/OiBib29sZWFuXG4gICAgTWFpbj86IGJvb2xlYW5cbiAgICBIZWFkPzogYm9vbGVhblxuICAgIE5leHRTY3JpcHQ/OiBib29sZWFuXG4gIH1cbiAgYnVpbGRNYW5pZmVzdDogQnVpbGRNYW5pZmVzdFxuICBhbXBQYXRoOiBzdHJpbmdcbiAgaW5BbXBNb2RlOiBib29sZWFuXG4gIGh5YnJpZEFtcDogYm9vbGVhblxuICBpc0RldmVsb3BtZW50OiBib29sZWFuXG4gIGR5bmFtaWNJbXBvcnRzOiBNYW5pZmVzdEl0ZW1bXVxuICBhc3NldFByZWZpeD86IHN0cmluZ1xuICBjYW5vbmljYWxCYXNlOiBzdHJpbmdcbiAgaGVhZFRhZ3M6IGFueVtdXG4gIHVuc3RhYmxlX3J1bnRpbWVKUz86IGZhbHNlXG4gIGRldk9ubHlDYWNoZUJ1c3RlclF1ZXJ5U3RyaW5nOiBzdHJpbmdcbiAgbG9jYWxlPzogc3RyaW5nXG59XG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSByZXF1ZXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmV4dEFwaVJlcXVlc3QgZXh0ZW5kcyBJbmNvbWluZ01lc3NhZ2Uge1xuICAvKipcbiAgICogT2JqZWN0IG9mIGBxdWVyeWAgdmFsdWVzIGZyb20gdXJsXG4gICAqL1xuICBxdWVyeToge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZyB8IHN0cmluZ1tdXG4gIH1cbiAgLyoqXG4gICAqIE9iamVjdCBvZiBgY29va2llc2AgZnJvbSBoZWFkZXJcbiAgICovXG4gIGNvb2tpZXM6IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmdcbiAgfVxuXG4gIGJvZHk6IGFueVxuXG4gIGVudjogRW52XG5cbiAgcHJldmlldz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFByZXZpZXcgZGF0YSBzZXQgb24gdGhlIHJlcXVlc3QsIGlmIGFueVxuICAgKiAqL1xuICBwcmV2aWV3RGF0YT86IGFueVxufVxuXG4vKipcbiAqIFNlbmQgYm9keSBvZiByZXNwb25zZVxuICovXG50eXBlIFNlbmQ8VD4gPSAoYm9keTogVCkgPT4gdm9pZFxuXG4vKipcbiAqIE5leHQgYEFQSWAgcm91dGUgcmVzcG9uc2VcbiAqL1xuZXhwb3J0IHR5cGUgTmV4dEFwaVJlc3BvbnNlPFQgPSBhbnk+ID0gU2VydmVyUmVzcG9uc2UgJiB7XG4gIC8qKlxuICAgKiBTZW5kIGRhdGEgYGFueWAgZGF0YSBpbiByZXNwb25zZVxuICAgKi9cbiAgc2VuZDogU2VuZDxUPlxuICAvKipcbiAgICogU2VuZCBkYXRhIGBqc29uYCBkYXRhIGluIHJlc3BvbnNlXG4gICAqL1xuICBqc29uOiBTZW5kPFQ+XG4gIHN0YXR1czogKHN0YXR1c0NvZGU6IG51bWJlcikgPT4gTmV4dEFwaVJlc3BvbnNlPFQ+XG4gIHJlZGlyZWN0KHVybDogc3RyaW5nKTogTmV4dEFwaVJlc3BvbnNlPFQ+XG4gIHJlZGlyZWN0KHN0YXR1czogbnVtYmVyLCB1cmw6IHN0cmluZyk6IE5leHRBcGlSZXNwb25zZTxUPlxuXG4gIC8qKlxuICAgKiBTZXQgcHJldmlldyBkYXRhIGZvciBOZXh0LmpzJyBwcmVyZW5kZXIgbW9kZVxuICAgKi9cbiAgc2V0UHJldmlld0RhdGE6IChcbiAgICBkYXRhOiBvYmplY3QgfCBzdHJpbmcsXG4gICAgb3B0aW9ucz86IHtcbiAgICAgIC8qKlxuICAgICAgICogU3BlY2lmaWVzIHRoZSBudW1iZXIgKGluIHNlY29uZHMpIGZvciB0aGUgcHJldmlldyBzZXNzaW9uIHRvIGxhc3QgZm9yLlxuICAgICAgICogVGhlIGdpdmVuIG51bWJlciB3aWxsIGJlIGNvbnZlcnRlZCB0byBhbiBpbnRlZ2VyIGJ5IHJvdW5kaW5nIGRvd24uXG4gICAgICAgKiBCeSBkZWZhdWx0LCBubyBtYXhpbXVtIGFnZSBpcyBzZXQgYW5kIHRoZSBwcmV2aWV3IHNlc3Npb24gZmluaXNoZXNcbiAgICAgICAqIHdoZW4gdGhlIGNsaWVudCBzaHV0cyBkb3duIChicm93c2VyIGlzIGNsb3NlZCkuXG4gICAgICAgKi9cbiAgICAgIG1heEFnZT86IG51bWJlclxuICAgIH1cbiAgKSA9PiBOZXh0QXBpUmVzcG9uc2U8VD5cbiAgY2xlYXJQcmV2aWV3RGF0YTogKCkgPT4gTmV4dEFwaVJlc3BvbnNlPFQ+XG59XG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSBoYW5kbGVyXG4gKi9cbmV4cG9ydCB0eXBlIE5leHRBcGlIYW5kbGVyPFQgPSBhbnk+ID0gKFxuICByZXE6IE5leHRBcGlSZXF1ZXN0LFxuICByZXM6IE5leHRBcGlSZXNwb25zZTxUPlxuKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPlxuXG4vKipcbiAqIFV0aWxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGVjT25jZTxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBSZXR1cm5UeXBlPFQ+PihcbiAgZm46IFRcbik6IFQge1xuICBsZXQgdXNlZCA9IGZhbHNlXG4gIGxldCByZXN1bHQ6IFJldHVyblR5cGU8VD5cblxuICByZXR1cm4gKCguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgIGlmICghdXNlZCkge1xuICAgICAgdXNlZCA9IHRydWVcbiAgICAgIHJlc3VsdCA9IGZuKC4uLmFyZ3MpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfSkgYXMgVFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9jYXRpb25PcmlnaW4oKSB7XG4gIGNvbnN0IHsgcHJvdG9jb2wsIGhvc3RuYW1lLCBwb3J0IH0gPSB3aW5kb3cubG9jYXRpb25cbiAgcmV0dXJuIGAke3Byb3RvY29sfS8vJHtob3N0bmFtZX0ke3BvcnQgPyAnOicgKyBwb3J0IDogJyd9YFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VVJMKCkge1xuICBjb25zdCB7IGhyZWYgfSA9IHdpbmRvdy5sb2NhdGlvblxuICBjb25zdCBvcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbigpXG4gIHJldHVybiBocmVmLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWU8UD4oQ29tcG9uZW50OiBDb21wb25lbnRUeXBlPFA+KSB7XG4gIHJldHVybiB0eXBlb2YgQ29tcG9uZW50ID09PSAnc3RyaW5nJ1xuICAgID8gQ29tcG9uZW50XG4gICAgOiBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ1Vua25vd24nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Jlc1NlbnQocmVzOiBTZXJ2ZXJSZXNwb25zZSkge1xuICByZXR1cm4gcmVzLmZpbmlzaGVkIHx8IHJlcy5oZWFkZXJzU2VudFxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZEdldEluaXRpYWxQcm9wczxcbiAgQyBleHRlbmRzIEJhc2VDb250ZXh0LFxuICBJUCA9IHt9LFxuICBQID0ge31cbj4oQXBwOiBOZXh0Q29tcG9uZW50VHlwZTxDLCBJUCwgUD4sIGN0eDogQyk6IFByb21pc2U8SVA+IHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoQXBwLnByb3RvdHlwZT8uZ2V0SW5pdGlhbFByb3BzKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYFwiJHtnZXREaXNwbGF5TmFtZShcbiAgICAgICAgQXBwXG4gICAgICApfS5nZXRJbml0aWFsUHJvcHMoKVwiIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIC0gdmlzaXQgaHR0cHM6Ly9lcnIuc2gvdmVyY2VsL25leHQuanMvZ2V0LWluaXRpYWwtcHJvcHMtYXMtYW4taW5zdGFuY2UtbWV0aG9kIGZvciBtb3JlIGluZm9ybWF0aW9uLmBcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxuICAgIH1cbiAgfVxuICAvLyB3aGVuIGNhbGxlZCBmcm9tIF9hcHAgYGN0eGAgaXMgbmVzdGVkIGluIGBjdHhgXG4gIGNvbnN0IHJlcyA9IGN0eC5yZXMgfHwgKGN0eC5jdHggJiYgY3R4LmN0eC5yZXMpXG5cbiAgaWYgKCFBcHAuZ2V0SW5pdGlhbFByb3BzKSB7XG4gICAgaWYgKGN0eC5jdHggJiYgY3R4LkNvbXBvbmVudCkge1xuICAgICAgLy8gQHRzLWlnbm9yZSBwYWdlUHJvcHMgZGVmYXVsdFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFnZVByb3BzOiBhd2FpdCBsb2FkR2V0SW5pdGlhbFByb3BzKGN0eC5Db21wb25lbnQsIGN0eC5jdHgpLFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge30gYXMgSVBcbiAgfVxuXG4gIGNvbnN0IHByb3BzID0gYXdhaXQgQXBwLmdldEluaXRpYWxQcm9wcyhjdHgpXG5cbiAgaWYgKHJlcyAmJiBpc1Jlc1NlbnQocmVzKSkge1xuICAgIHJldHVybiBwcm9wc1xuICB9XG5cbiAgaWYgKCFwcm9wcykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBgXCIke2dldERpc3BsYXlOYW1lKFxuICAgICAgQXBwXG4gICAgKX0uZ2V0SW5pdGlhbFByb3BzKClcIiBzaG91bGQgcmVzb2x2ZSB0byBhbiBvYmplY3QuIEJ1dCBmb3VuZCBcIiR7cHJvcHN9XCIgaW5zdGVhZC5gXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChPYmplY3Qua2V5cyhwcm9wcykubGVuZ3RoID09PSAwICYmICFjdHguY3R4KSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGAke2dldERpc3BsYXlOYW1lKFxuICAgICAgICAgIEFwcFxuICAgICAgICApfSByZXR1cm5lZCBhbiBlbXB0eSBvYmplY3QgZnJvbSBcXGBnZXRJbml0aWFsUHJvcHNcXGAuIFRoaXMgZGUtb3B0aW1pemVzIGFuZCBwcmV2ZW50cyBhdXRvbWF0aWMgc3RhdGljIG9wdGltaXphdGlvbi4gaHR0cHM6Ly9lcnIuc2gvdmVyY2VsL25leHQuanMvZW1wdHktb2JqZWN0LWdldEluaXRpYWxQcm9wc2BcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJvcHNcbn1cblxuZXhwb3J0IGNvbnN0IHVybE9iamVjdEtleXMgPSBbXG4gICdhdXRoJyxcbiAgJ2hhc2gnLFxuICAnaG9zdCcsXG4gICdob3N0bmFtZScsXG4gICdocmVmJyxcbiAgJ3BhdGgnLFxuICAncGF0aG5hbWUnLFxuICAncG9ydCcsXG4gICdwcm90b2NvbCcsXG4gICdxdWVyeScsXG4gICdzZWFyY2gnLFxuICAnc2xhc2hlcycsXG5dXG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRXaXRoVmFsaWRhdGlvbih1cmw6IFVybE9iamVjdCk6IHN0cmluZyB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgIGlmICh1cmwgIT09IG51bGwgJiYgdHlwZW9mIHVybCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIE9iamVjdC5rZXlzKHVybCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGlmICh1cmxPYmplY3RLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgVW5rbm93biBrZXkgcGFzc2VkIHZpYSB1cmxPYmplY3QgaW50byB1cmwuZm9ybWF0OiAke2tleX1gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmb3JtYXRVcmwodXJsKVxufVxuXG5leHBvcnQgY29uc3QgU1AgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnXG5leHBvcnQgY29uc3QgU1QgPVxuICBTUCAmJlxuICB0eXBlb2YgcGVyZm9ybWFuY2UubWFyayA9PT0gJ2Z1bmN0aW9uJyAmJlxuICB0eXBlb2YgcGVyZm9ybWFuY2UubWVhc3VyZSA9PT0gJ2Z1bmN0aW9uJ1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/lib/utils.js\n");

/***/ }),

/***/ "./node_modules/next/dist/next-server/server/denormalize-page-path.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/server/denormalize-page-path.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("exports.__esModule=true;exports.normalizePathSep=normalizePathSep;exports.denormalizePagePath=denormalizePagePath;function normalizePathSep(path){return path.replace(/\\\\/g,'/');}function denormalizePagePath(page){page=normalizePathSep(page);if(page.startsWith('/index/')){page=page.slice(6);}else if(page==='/index'){page='/';}return page;}\n//# sourceMappingURL=denormalize-page-path.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L25leHQtc2VydmVyL3NlcnZlci9kZW5vcm1hbGl6ZS1wYWdlLXBhdGguanM/YzI0MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYSx3QkFBd0IsMENBQTBDLGdEQUFnRCxnQ0FBZ0MsZ0NBQWdDLG1DQUFtQyw0QkFBNEIsK0JBQStCLG9CQUFvQix5QkFBeUIsVUFBVTtBQUNwViIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvc2VydmVyL2Rlbm9ybWFsaXplLXBhZ2UtcGF0aC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHMubm9ybWFsaXplUGF0aFNlcD1ub3JtYWxpemVQYXRoU2VwO2V4cG9ydHMuZGVub3JtYWxpemVQYWdlUGF0aD1kZW5vcm1hbGl6ZVBhZ2VQYXRoO2Z1bmN0aW9uIG5vcm1hbGl6ZVBhdGhTZXAocGF0aCl7cmV0dXJuIHBhdGgucmVwbGFjZSgvXFxcXC9nLCcvJyk7fWZ1bmN0aW9uIGRlbm9ybWFsaXplUGFnZVBhdGgocGFnZSl7cGFnZT1ub3JtYWxpemVQYXRoU2VwKHBhZ2UpO2lmKHBhZ2Uuc3RhcnRzV2l0aCgnL2luZGV4LycpKXtwYWdlPXBhZ2Uuc2xpY2UoNik7fWVsc2UgaWYocGFnZT09PScvaW5kZXgnKXtwYWdlPScvJzt9cmV0dXJuIHBhZ2U7fVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVub3JtYWxpemUtcGFnZS1wYXRoLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/next-server/server/denormalize-page-path.js\n");

/***/ }),

/***/ "./node_modules/next/link.js":
/*!***********************************!*\
  !*** ./node_modules/next/link.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./dist/client/link */ \"./node_modules/next/dist/client/link.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzPzYwNWEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLG1CQUFPLENBQUMsbUVBQW9CIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL25leHQvbGluay5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0L2NsaWVudC9saW5rJylcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/link.js\n");

/***/ }),

/***/ "./node_modules/reactstrap/dist/reactstrap.cjs":
/*!*****************************************************!*\
  !*** ./node_modules/reactstrap/dist/reactstrap.cjs ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var React = __webpack_require__(/*! react */ \"react\");\nvar PropTypes = __webpack_require__(/*! prop-types */ \"prop-types\");\nvar classNames = __webpack_require__(/*! classnames */ \"classnames\");\nvar reactPopper = __webpack_require__(/*! react-popper */ \"react-popper\");\nvar ReactDOM = __webpack_require__(/*! react-dom */ \"react-dom\");\nvar reactTransitionGroup = __webpack_require__(/*! react-transition-group */ \"react-transition-group\");\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar React__default = /*#__PURE__*/_interopDefaultLegacy(React);\nvar PropTypes__default = /*#__PURE__*/_interopDefaultLegacy(PropTypes);\nvar classNames__default = /*#__PURE__*/_interopDefaultLegacy(classNames);\nvar ReactDOM__default = /*#__PURE__*/_interopDefaultLegacy(ReactDOM);\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction getScrollbarWidth() {\n  var scrollDiv = document.createElement('div'); // .modal-scrollbar-measure styles // https://github.com/twbs/bootstrap/blob/v4.0.0-alpha.4/scss/_modal.scss#L106-L113\n\n  scrollDiv.style.position = 'absolute';\n  scrollDiv.style.top = '-9999px';\n  scrollDiv.style.width = '50px';\n  scrollDiv.style.height = '50px';\n  scrollDiv.style.overflow = 'scroll';\n  document.body.appendChild(scrollDiv);\n  var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n  document.body.removeChild(scrollDiv);\n  return scrollbarWidth;\n}\nfunction setScrollbarWidth(padding) {\n  document.body.style.paddingRight = padding > 0 ? padding + \"px\" : null;\n}\nfunction isBodyOverflowing() {\n  return document.body.clientWidth < window.innerWidth;\n}\nfunction getOriginalBodyPadding() {\n  var style = window.getComputedStyle(document.body, null);\n  return parseInt(style && style.getPropertyValue('padding-right') || 0, 10);\n}\nfunction conditionallyUpdateScrollbar() {\n  var scrollbarWidth = getScrollbarWidth(); // https://github.com/twbs/bootstrap/blob/v4.0.0-alpha.6/js/src/modal.js#L433\n\n  var fixedContent = document.querySelectorAll('.fixed-top, .fixed-bottom, .is-fixed, .sticky-top')[0];\n  var bodyPadding = fixedContent ? parseInt(fixedContent.style.paddingRight || 0, 10) : 0;\n\n  if (isBodyOverflowing()) {\n    setScrollbarWidth(bodyPadding + scrollbarWidth);\n  }\n}\nvar globalCssModule;\nfunction setGlobalCssModule(cssModule) {\n  globalCssModule = cssModule;\n}\nfunction mapToCssModules(className, cssModule) {\n  if (className === void 0) {\n    className = '';\n  }\n\n  if (cssModule === void 0) {\n    cssModule = globalCssModule;\n  }\n\n  if (!cssModule) return className;\n  return className.split(' ').map(function (c) {\n    return cssModule[c] || c;\n  }).join(' ');\n}\n/**\n * Returns a new object with the key/value pairs from `obj` that are not in the array `omitKeys`.\n */\n\nfunction omit(obj, omitKeys) {\n  var result = {};\n  Object.keys(obj).forEach(function (key) {\n    if (omitKeys.indexOf(key) === -1) {\n      result[key] = obj[key];\n    }\n  });\n  return result;\n}\n/**\n * Returns a filtered copy of an object with only the specified keys.\n */\n\nfunction pick(obj, keys) {\n  var pickKeys = Array.isArray(keys) ? keys : [keys];\n  var length = pickKeys.length;\n  var key;\n  var result = {};\n\n  while (length > 0) {\n    length -= 1;\n    key = pickKeys[length];\n    result[key] = obj[key];\n  }\n\n  return result;\n}\nvar warned = {};\nfunction warnOnce(message) {\n  if (!warned[message]) {\n    /* istanbul ignore else */\n    if (typeof console !== 'undefined') {\n      console.error(message); // eslint-disable-line no-console\n    }\n\n    warned[message] = true;\n  }\n}\nfunction deprecated(propType, explanation) {\n  return function validate(props, propName, componentName) {\n    if (props[propName] !== null && typeof props[propName] !== 'undefined') {\n      warnOnce(\"\\\"\" + propName + \"\\\" property of \\\"\" + componentName + \"\\\" has been deprecated.\\n\" + explanation);\n    }\n\n    return propType.apply(void 0, [props, propName, componentName].concat([].slice.call(arguments, 3)));\n  };\n} // Shim Element if needed (e.g. in Node environment)\n\nvar Element = typeof window === 'object' && window.Element || function () {};\n\nfunction DOMElement(props, propName, componentName) {\n  if (!(props[propName] instanceof Element)) {\n    return new Error('Invalid prop `' + propName + '` supplied to `' + componentName + '`. Expected prop to be an instance of Element. Validation failed.');\n  }\n}\nvar targetPropType = PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].func, DOMElement, PropTypes__default[\"default\"].shape({\n  current: PropTypes__default[\"default\"].any\n})]);\nvar tagPropType = PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].func, PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].shape({\n  $$typeof: PropTypes__default[\"default\"].symbol,\n  render: PropTypes__default[\"default\"].func\n}), PropTypes__default[\"default\"].arrayOf(PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].func, PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].shape({\n  $$typeof: PropTypes__default[\"default\"].symbol,\n  render: PropTypes__default[\"default\"].func\n})]))]); // These are all setup to match what is in the bootstrap _variables.scss\n// https://github.com/twbs/bootstrap/blob/v4-dev/scss/_variables.scss\n\nvar TransitionTimeouts = {\n  Fade: 150,\n  // $transition-fade\n  Collapse: 350,\n  // $transition-collapse\n  Modal: 300,\n  // $modal-transition\n  Carousel: 600,\n  // $carousel-transition\n  Offcanvas: 300 // $offcanvas-transition\n\n}; // Duplicated Transition.propType keys to ensure that Reactstrap builds\n// for distribution properly exclude these keys for nested child HTML attributes\n// since `react-transition-group` removes propTypes in production builds.\n\nvar TransitionPropTypeKeys = ['in', 'mountOnEnter', 'unmountOnExit', 'appear', 'enter', 'exit', 'timeout', 'onEnter', 'onEntering', 'onEntered', 'onExit', 'onExiting', 'onExited'];\nvar TransitionStatuses = {\n  ENTERING: 'entering',\n  ENTERED: 'entered',\n  EXITING: 'exiting',\n  EXITED: 'exited'\n};\nvar keyCodes = {\n  esc: 27,\n  space: 32,\n  enter: 13,\n  tab: 9,\n  up: 38,\n  down: 40,\n  home: 36,\n  end: 35,\n  n: 78,\n  p: 80\n};\nvar PopperPlacements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];\nvar canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\nfunction isReactRefObj(target) {\n  if (target && typeof target === 'object') {\n    return 'current' in target;\n  }\n\n  return false;\n}\n\nfunction getTag(value) {\n  if (value == null) {\n    return value === undefined ? '[object Undefined]' : '[object Null]';\n  }\n\n  return Object.prototype.toString.call(value);\n}\n\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type === 'object' || type === 'function');\n}\nfunction toNumber(value) {\n  var type = typeof value;\n  var NAN = 0 / 0;\n\n  if (type === 'number') {\n    return value;\n  }\n\n  if (type === 'symbol' || type === 'object' && getTag(value) === '[object Symbol]') {\n    return NAN;\n  }\n\n  if (isObject(value)) {\n    var other = typeof value.valueOf === 'function' ? value.valueOf() : value;\n    value = isObject(other) ? \"\" + other : other;\n  }\n\n  if (type !== 'string') {\n    return value === 0 ? value : +value;\n  }\n\n  value = value.replace(/^\\s+|\\s+$/g, '');\n  var isBinary = /^0b[01]+$/i.test(value);\n  return isBinary || /^0o[0-7]+$/i.test(value) ? parseInt(value.slice(2), isBinary ? 2 : 8) : /^[-+]0x[0-9a-f]+$/i.test(value) ? NAN : +value;\n}\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n\n  var tag = getTag(value);\n  return tag === '[object Function]' || tag === '[object AsyncFunction]' || tag === '[object GeneratorFunction]' || tag === '[object Proxy]';\n}\nfunction findDOMElements(target) {\n  if (isReactRefObj(target)) {\n    return target.current;\n  }\n\n  if (isFunction(target)) {\n    return target();\n  }\n\n  if (typeof target === 'string' && canUseDOM) {\n    var selection = document.querySelectorAll(target);\n\n    if (!selection.length) {\n      selection = document.querySelectorAll(\"#\" + target);\n    }\n\n    if (!selection.length) {\n      throw new Error(\"The target '\" + target + \"' could not be identified in the dom, tip: check spelling\");\n    }\n\n    return selection;\n  }\n\n  return target;\n}\nfunction isArrayOrNodeList(els) {\n  if (els === null) {\n    return false;\n  }\n\n  return Array.isArray(els) || canUseDOM && typeof els.length === 'number';\n}\nfunction getTarget(target, allElements) {\n  var els = findDOMElements(target);\n\n  if (allElements) {\n    if (isArrayOrNodeList(els)) {\n      return els;\n    }\n\n    if (els === null) {\n      return [];\n    }\n\n    return [els];\n  }\n\n  if (isArrayOrNodeList(els)) {\n    return els[0];\n  }\n\n  return els;\n}\nvar defaultToggleEvents = ['touchstart', 'click'];\nfunction addMultipleEventListeners(_els, handler, _events, useCapture) {\n  var els = _els;\n\n  if (!isArrayOrNodeList(els)) {\n    els = [els];\n  }\n\n  var events = _events;\n\n  if (typeof events === 'string') {\n    events = events.split(/\\s+/);\n  }\n\n  if (!isArrayOrNodeList(els) || typeof handler !== 'function' || !Array.isArray(events)) {\n    throw new Error(\"\\n      The first argument of this function must be DOM node or an array on DOM nodes or NodeList.\\n      The second must be a function.\\n      The third is a string or an array of strings that represents DOM events\\n    \");\n  }\n\n  Array.prototype.forEach.call(events, function (event) {\n    Array.prototype.forEach.call(els, function (el) {\n      el.addEventListener(event, handler, useCapture);\n    });\n  });\n  return function removeEvents() {\n    Array.prototype.forEach.call(events, function (event) {\n      Array.prototype.forEach.call(els, function (el) {\n        el.removeEventListener(event, handler, useCapture);\n      });\n    });\n  };\n}\nvar focusableElements = ['a[href]', 'area[href]', 'input:not([disabled]):not([type=hidden])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'object', 'embed', '[tabindex]:not(.modal):not(.offcanvas)', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable=\"false\"])'];\n\nvar utils = {\n  __proto__: null,\n  getScrollbarWidth: getScrollbarWidth,\n  setScrollbarWidth: setScrollbarWidth,\n  isBodyOverflowing: isBodyOverflowing,\n  getOriginalBodyPadding: getOriginalBodyPadding,\n  conditionallyUpdateScrollbar: conditionallyUpdateScrollbar,\n  setGlobalCssModule: setGlobalCssModule,\n  mapToCssModules: mapToCssModules,\n  omit: omit,\n  pick: pick,\n  warnOnce: warnOnce,\n  deprecated: deprecated,\n  DOMElement: DOMElement,\n  targetPropType: targetPropType,\n  tagPropType: tagPropType,\n  TransitionTimeouts: TransitionTimeouts,\n  TransitionPropTypeKeys: TransitionPropTypeKeys,\n  TransitionStatuses: TransitionStatuses,\n  keyCodes: keyCodes,\n  PopperPlacements: PopperPlacements,\n  canUseDOM: canUseDOM,\n  isReactRefObj: isReactRefObj,\n  isObject: isObject,\n  toNumber: toNumber,\n  isFunction: isFunction,\n  findDOMElements: findDOMElements,\n  isArrayOrNodeList: isArrayOrNodeList,\n  getTarget: getTarget,\n  defaultToggleEvents: defaultToggleEvents,\n  addMultipleEventListeners: addMultipleEventListeners,\n  focusableElements: focusableElements\n};\n\nvar _excluded$1h = [\"className\", \"cssModule\", \"fluid\", \"tag\"];\nvar propTypes$1m = {\n  tag: tagPropType,\n  fluid: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].bool, PropTypes__default[\"default\"].string]),\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object\n};\nvar defaultProps$1k = {\n  tag: 'div'\n};\n\nfunction Container(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      fluid = props.fluid,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$1h);\n\n  var containerClass = 'container';\n\n  if (fluid === true) {\n    containerClass = 'container-fluid';\n  } else if (fluid) {\n    containerClass = \"container-\" + fluid;\n  }\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, containerClass), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nContainer.propTypes = propTypes$1m;\nContainer.defaultProps = defaultProps$1k;\n\nvar _excluded$1g = [\"className\", \"cssModule\", \"noGutters\", \"tag\", \"widths\"];\nvar rowColWidths = ['xs', 'sm', 'md', 'lg', 'xl', 'xxl'];\nvar rowColsPropType = PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].number, PropTypes__default[\"default\"].string]);\nvar propTypes$1l = {\n  tag: tagPropType,\n  noGutters: deprecated(PropTypes__default[\"default\"].bool, 'Please use Bootstrap 5 gutter utility classes. https://getbootstrap.com/docs/5.0/layout/gutters/'),\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object,\n  xs: rowColsPropType,\n  sm: rowColsPropType,\n  md: rowColsPropType,\n  lg: rowColsPropType,\n  xl: rowColsPropType,\n  xxl: rowColsPropType,\n  widths: PropTypes__default[\"default\"].array\n};\nvar defaultProps$1j = {\n  tag: 'div',\n  widths: rowColWidths\n};\n\nfunction Row(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      noGutters = props.noGutters,\n      Tag = props.tag,\n      widths = props.widths,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$1g);\n\n  var colClasses = [];\n  widths.forEach(function (colWidth, i) {\n    var colSize = props[colWidth];\n    delete attributes[colWidth];\n\n    if (!colSize) {\n      return;\n    }\n\n    var isXs = !i;\n    colClasses.push(isXs ? \"row-cols-\" + colSize : \"row-cols-\" + colWidth + \"-\" + colSize);\n  });\n  var classes = mapToCssModules(classNames__default[\"default\"](className, noGutters ? 'gx-0' : null, 'row', colClasses), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nRow.propTypes = propTypes$1l;\nRow.defaultProps = defaultProps$1j;\n\nvar _excluded$1f = [\"className\", \"cssModule\", \"widths\", \"tag\"];\nvar colWidths$1 = ['xs', 'sm', 'md', 'lg', 'xl', 'xxl'];\nvar stringOrNumberProp$1 = PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].number, PropTypes__default[\"default\"].string]);\nvar columnProps$1 = PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].bool, PropTypes__default[\"default\"].number, PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].shape({\n  size: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].bool, PropTypes__default[\"default\"].number, PropTypes__default[\"default\"].string]),\n  order: stringOrNumberProp$1,\n  offset: stringOrNumberProp$1\n})]);\nvar propTypes$1k = {\n  tag: tagPropType,\n  xs: columnProps$1,\n  sm: columnProps$1,\n  md: columnProps$1,\n  lg: columnProps$1,\n  xl: columnProps$1,\n  xxl: columnProps$1,\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object,\n  widths: PropTypes__default[\"default\"].array\n};\nvar defaultProps$1i = {\n  tag: 'div',\n  widths: colWidths$1\n};\n\nvar getColumnSizeClass$1 = function getColumnSizeClass(isXs, colWidth, colSize) {\n  if (colSize === true || colSize === '') {\n    return isXs ? 'col' : \"col-\" + colWidth;\n  }\n\n  if (colSize === 'auto') {\n    return isXs ? 'col-auto' : \"col-\" + colWidth + \"-auto\";\n  }\n\n  return isXs ? \"col-\" + colSize : \"col-\" + colWidth + \"-\" + colSize;\n};\n\nvar getColumnClasses = function getColumnClasses(attributes, cssModule, widths) {\n  if (widths === void 0) {\n    widths = colWidths$1;\n  }\n\n  var modifiedAttributes = attributes;\n  var colClasses = [];\n  widths.forEach(function (colWidth, i) {\n    var columnProp = modifiedAttributes[colWidth];\n    delete modifiedAttributes[colWidth];\n\n    if (!columnProp && columnProp !== '') {\n      return;\n    }\n\n    var isXs = !i;\n\n    if (isObject(columnProp)) {\n      var _classNames;\n\n      var colSizeInterfix = isXs ? '-' : \"-\" + colWidth + \"-\";\n      var colClass = getColumnSizeClass$1(isXs, colWidth, columnProp.size);\n      colClasses.push(mapToCssModules(classNames__default[\"default\"]((_classNames = {}, _classNames[colClass] = columnProp.size || columnProp.size === '', _classNames[\"order\" + colSizeInterfix + columnProp.order] = columnProp.order || columnProp.order === 0, _classNames[\"offset\" + colSizeInterfix + columnProp.offset] = columnProp.offset || columnProp.offset === 0, _classNames)), cssModule));\n    } else {\n      var _colClass = getColumnSizeClass$1(isXs, colWidth, columnProp);\n\n      colClasses.push(_colClass);\n    }\n  });\n  return {\n    colClasses: colClasses,\n    modifiedAttributes: modifiedAttributes\n  };\n};\n\nfunction Col(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      widths = props.widths,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$1f);\n\n  var _getColumnClasses = getColumnClasses(attributes, cssModule, widths),\n      modifiedAttributes = _getColumnClasses.modifiedAttributes,\n      colClasses = _getColumnClasses.colClasses;\n\n  if (!colClasses.length) {\n    colClasses.push('col');\n  }\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, colClasses), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, modifiedAttributes, {\n    className: classes\n  }));\n}\n\nCol.propTypes = propTypes$1k;\nCol.defaultProps = defaultProps$1i;\n\nvar _excluded$1e = [\"expand\", \"className\", \"cssModule\", \"light\", \"dark\", \"fixed\", \"sticky\", \"color\", \"container\", \"tag\", \"children\"];\nvar propTypes$1j = {\n  children: PropTypes__default[\"default\"].node,\n\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Theme the navbar by adding a background color  */\n  color: PropTypes__default[\"default\"].string,\n\n  /** Use any of the responsive containers to change how wide the content in your navbar is presented. */\n  container: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].bool, PropTypes__default[\"default\"].string]),\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** This prop is passed if the background is dark, to make the text lighter */\n  dark: PropTypes__default[\"default\"].bool,\n\n  /** Determine if to show toggler button */\n  expand: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].bool, PropTypes__default[\"default\"].string]),\n\n  /** Make the navbar fixed at the top */\n  fixed: PropTypes__default[\"default\"].string,\n  full: PropTypes__default[\"default\"].bool,\n\n  /** Add `.navbar-light` class */\n  light: PropTypes__default[\"default\"].bool,\n  role: PropTypes__default[\"default\"].string,\n\n  /** Use `position: sticky` which isn't fully supported in every browser */\n  sticky: PropTypes__default[\"default\"].string,\n\n  /** Set a custom element for this component */\n  tag: tagPropType\n};\nvar defaultProps$1h = {\n  tag: 'nav',\n  expand: false,\n  container: 'fluid'\n};\n\nvar getExpandClass = function getExpandClass(expand) {\n  if (expand === false) {\n    return false;\n  }\n\n  if (expand === true || expand === 'xs') {\n    return 'navbar-expand';\n  }\n\n  return \"navbar-expand-\" + expand;\n};\n\nfunction Navbar(props) {\n  var _classNames;\n\n  var expand = props.expand,\n      className = props.className,\n      cssModule = props.cssModule,\n      light = props.light,\n      dark = props.dark,\n      fixed = props.fixed,\n      sticky = props.sticky,\n      color = props.color,\n      container = props.container,\n      Tag = props.tag,\n      children = props.children,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$1e);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'navbar', getExpandClass(expand), (_classNames = {\n    'navbar-light': light,\n    'navbar-dark': dark\n  }, _classNames[\"bg-\" + color] = color, _classNames[\"fixed-\" + fixed] = fixed, _classNames[\"sticky-\" + sticky] = sticky, _classNames)), cssModule);\n  var containerClass = container && container === true ? 'container' : \"container-\" + container;\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }), container ? /*#__PURE__*/React__default[\"default\"].createElement(\"div\", {\n    className: containerClass\n  }, children) : children);\n}\n\nNavbar.propTypes = propTypes$1j;\nNavbar.defaultProps = defaultProps$1h;\n\nvar _excluded$1d = [\"className\", \"cssModule\", \"tag\"];\nvar propTypes$1i = {\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Set a custom element for this component */\n  tag: tagPropType\n};\nvar defaultProps$1g = {\n  tag: 'a'\n};\n\nfunction NavbarBrand(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$1d);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'navbar-brand'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nNavbarBrand.propTypes = propTypes$1i;\nNavbarBrand.defaultProps = defaultProps$1g;\n\nvar _excluded$1c = [\"className\", \"cssModule\", \"active\", \"tag\"];\nvar propTypes$1h = {\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Set a custom element for this component */\n  tag: tagPropType,\n  active: PropTypes__default[\"default\"].bool\n};\nvar defaultProps$1f = {\n  tag: 'span'\n};\n\nfunction NavbarText(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$1c);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'navbar-text'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nNavbarText.propTypes = propTypes$1h;\nNavbarText.defaultProps = defaultProps$1f;\n\nvar _excluded$1b = [\"className\", \"cssModule\", \"children\", \"tag\"];\nvar propTypes$1g = {\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Set a custom element for this component */\n  tag: tagPropType,\n  type: PropTypes__default[\"default\"].string,\n\n  /** Pass children so this component can wrap the child elements */\n  children: PropTypes__default[\"default\"].node\n};\nvar defaultProps$1e = {\n  tag: 'button',\n  type: 'button'\n};\n\nfunction NavbarToggler(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      children = props.children,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$1b);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'navbar-toggler'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({\n    \"aria-label\": \"Toggle navigation\"\n  }, attributes, {\n    className: classes\n  }), children || /*#__PURE__*/React__default[\"default\"].createElement(\"span\", {\n    className: mapToCssModules('navbar-toggler-icon', cssModule)\n  }));\n}\n\nNavbarToggler.propTypes = propTypes$1g;\nNavbarToggler.defaultProps = defaultProps$1e;\n\nvar _excluded$1a = [\"className\", \"cssModule\", \"tabs\", \"pills\", \"vertical\", \"horizontal\", \"justified\", \"fill\", \"navbar\", \"card\", \"tag\"];\nvar propTypes$1f = {\n  /** Adding card prop adds `.card-header-tabs` or `.card-header-pills` class */\n  card: PropTypes__default[\"default\"].bool,\n\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** fills the nav to extend to full available width */\n  fill: PropTypes__default[\"default\"].bool,\n\n  /** Change the horizontal alignment of your nav */\n  horizontal: PropTypes__default[\"default\"].oneOf(['center', 'end']),\n\n  /**  All horizontal space will be occupied by nav links, but unlike the `fill` above, every nav item will be the same width. */\n  justified: PropTypes__default[\"default\"].bool,\n\n  /** Add navbar for a full-height and lightweight navigation */\n  navbar: PropTypes__default[\"default\"].bool,\n\n  /** Make NavItems look like pills */\n  pills: PropTypes__default[\"default\"].bool,\n\n  /** Make NavItems look like tabs */\n  tabs: PropTypes__default[\"default\"].bool,\n\n  /** Set a custom element for this component */\n  tag: tagPropType,\n\n  /** Stack your navigation by changing the flex item direction */\n  vertical: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].bool, PropTypes__default[\"default\"].string])\n};\nvar defaultProps$1d = {\n  tag: 'ul',\n  vertical: false\n};\n\nvar getVerticalClass = function getVerticalClass(vertical) {\n  if (vertical === false) {\n    return false;\n  }\n\n  if (vertical === true || vertical === 'xs') {\n    return 'flex-column';\n  }\n\n  return \"flex-\" + vertical + \"-column\";\n};\n\nfunction Nav(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      tabs = props.tabs,\n      pills = props.pills,\n      vertical = props.vertical,\n      horizontal = props.horizontal,\n      justified = props.justified,\n      fill = props.fill,\n      navbar = props.navbar,\n      card = props.card,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$1a);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, navbar ? 'navbar-nav' : 'nav', horizontal ? \"justify-content-\" + horizontal : false, getVerticalClass(vertical), {\n    'nav-tabs': tabs,\n    'card-header-tabs': card && tabs,\n    'nav-pills': pills,\n    'card-header-pills': card && pills,\n    'nav-justified': justified,\n    'nav-fill': fill\n  }), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nNav.propTypes = propTypes$1f;\nNav.defaultProps = defaultProps$1d;\n\nvar _excluded$19 = [\"className\", \"cssModule\", \"active\", \"tag\"];\nvar propTypes$1e = {\n  /** Add active class to element */\n  active: PropTypes__default[\"default\"].bool,\n\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Set a custom element for this component */\n  tag: tagPropType\n};\nvar defaultProps$1c = {\n  tag: 'li'\n};\n\nfunction NavItem(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      active = props.active,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$19);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'nav-item', active ? 'active' : false), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nNavItem.propTypes = propTypes$1e;\nNavItem.defaultProps = defaultProps$1c;\n\nvar _excluded$18 = [\"className\", \"cssModule\", \"active\", \"tag\", \"innerRef\"];\nvar propTypes$1d = {\n  /** Add active class to NavLink */\n  active: PropTypes__default[\"default\"].bool,\n\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Disable the link */\n  disabled: PropTypes__default[\"default\"].bool,\n  href: PropTypes__default[\"default\"].any,\n  innerRef: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].object, PropTypes__default[\"default\"].func, PropTypes__default[\"default\"].string]),\n\n  /** Function to be triggered on click */\n  onClick: PropTypes__default[\"default\"].func,\n\n  /** Set a custom element for this component */\n  tag: tagPropType\n};\nvar defaultProps$1b = {\n  tag: 'a'\n};\n\nvar NavLink = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(NavLink, _React$Component);\n\n  function NavLink(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    _this.onClick = _this.onClick.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  var _proto = NavLink.prototype;\n\n  _proto.onClick = function onClick(e) {\n    if (this.props.disabled) {\n      e.preventDefault();\n      return;\n    }\n\n    if (this.props.href === '#') {\n      e.preventDefault();\n    }\n\n    if (this.props.onClick) {\n      this.props.onClick(e);\n    }\n  };\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        className = _this$props.className,\n        cssModule = _this$props.cssModule,\n        active = _this$props.active,\n        Tag = _this$props.tag,\n        innerRef = _this$props.innerRef,\n        attributes = _objectWithoutPropertiesLoose(_this$props, _excluded$18);\n\n    var classes = mapToCssModules(classNames__default[\"default\"](className, 'nav-link', {\n      disabled: attributes.disabled,\n      active: active\n    }), cssModule);\n    return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n      ref: innerRef,\n      onClick: this.onClick,\n      className: classes\n    }));\n  };\n\n  return NavLink;\n}(React__default[\"default\"].Component);\n\nNavLink.propTypes = propTypes$1d;\nNavLink.defaultProps = defaultProps$1b;\nvar NavLink$1 = NavLink;\n\nvar _excluded$17 = [\"className\", \"listClassName\", \"cssModule\", \"children\", \"tag\", \"listTag\", \"aria-label\"];\nvar propTypes$1c = {\n  /** Aria label */\n  'aria-label': PropTypes__default[\"default\"].string,\n\n  /** Pass children so this component can wrap them */\n  children: PropTypes__default[\"default\"].node,\n\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change existing className with a new className */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Add custom class to list tag */\n  listClassName: PropTypes__default[\"default\"].string,\n\n  /** Set a custom element for list tag */\n  listTag: tagPropType,\n\n  /** Set a custom element for this component */\n  tag: tagPropType\n};\nvar defaultProps$1a = {\n  tag: 'nav',\n  listTag: 'ol',\n  'aria-label': 'breadcrumb'\n};\n\nfunction Breadcrumb(props) {\n  var className = props.className,\n      listClassName = props.listClassName,\n      cssModule = props.cssModule,\n      children = props.children,\n      Tag = props.tag,\n      ListTag = props.listTag,\n      label = props['aria-label'],\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$17);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className), cssModule);\n  var listClasses = mapToCssModules(classNames__default[\"default\"]('breadcrumb', listClassName), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes,\n    \"aria-label\": label\n  }), /*#__PURE__*/React__default[\"default\"].createElement(ListTag, {\n    className: listClasses\n  }, children));\n}\n\nBreadcrumb.propTypes = propTypes$1c;\nBreadcrumb.defaultProps = defaultProps$1a;\n\nvar _excluded$16 = [\"className\", \"cssModule\", \"active\", \"tag\"];\nvar propTypes$1b = {\n  /** Adds a visual \"active\" state to a Breadcrumb Item */\n  active: PropTypes__default[\"default\"].bool,\n\n  /** Add custom class to the element */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change existing className with a new className */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Set a custom element for this component */\n  tag: tagPropType\n};\nvar defaultProps$19 = {\n  tag: 'li'\n};\n\nfunction BreadcrumbItem(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      active = props.active,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$16);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, active ? 'active' : false, 'breadcrumb-item'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes,\n    \"aria-current\": active ? 'page' : undefined\n  }));\n}\n\nBreadcrumbItem.propTypes = propTypes$1b;\nBreadcrumbItem.defaultProps = defaultProps$19;\n\nvar _excluded$15 = [\"className\", \"cssModule\", \"variant\", \"innerRef\"];\nvar propTypes$1a = {\n  /** Disable the button if needed */\n  active: PropTypes__default[\"default\"].bool,\n\n  /** Aria label */\n  'aria-label': PropTypes__default[\"default\"].string,\n\n  /** Function to be triggered on click */\n  onClick: PropTypes__default[\"default\"].func,\n\n  /** Change the variant to white */\n  variant: PropTypes__default[\"default\"].oneOf(['white']),\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object,\n  innerRef: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].object, PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].func])\n};\nvar defaultProps$18 = {\n  'aria-label': 'close'\n};\n\nfunction CloseButton(props) {\n  var className = props.className,\n      variant = props.variant,\n      innerRef = props.innerRef,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$15);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'btn-close', variant && \"btn-close-\" + variant));\n  return /*#__PURE__*/React__default[\"default\"].createElement(\"button\", _extends({\n    ref: innerRef,\n    type: \"button\",\n    className: classes\n  }, attributes));\n}\n\nCloseButton.propTypes = propTypes$1a;\nCloseButton.defaultProps = defaultProps$18;\n\nvar _excluded$14 = [\"active\", \"aria-label\", \"block\", \"className\", \"close\", \"cssModule\", \"color\", \"outline\", \"size\", \"tag\", \"innerRef\"];\nvar propTypes$19 = {\n  /** Manually set the visual state of the button to active */\n  active: PropTypes__default[\"default\"].bool,\n\n  /** Aria label */\n  'aria-label': PropTypes__default[\"default\"].string,\n  block: PropTypes__default[\"default\"].bool,\n\n  /** Pass children so this component can wrap them */\n  children: PropTypes__default[\"default\"].node,\n\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change existing className with a new className */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Use the button as a close button */\n  close: PropTypes__default[\"default\"].bool,\n\n  /** Change color of Button to one of the available colors */\n  color: PropTypes__default[\"default\"].string,\n\n  /** Disables the button */\n  disabled: PropTypes__default[\"default\"].bool,\n  innerRef: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].object, PropTypes__default[\"default\"].func, PropTypes__default[\"default\"].string]),\n\n  /** Function to be triggered on click */\n  onClick: PropTypes__default[\"default\"].func,\n\n  /** Adds outline to the button */\n  outline: PropTypes__default[\"default\"].bool,\n\n  /** Make the button bigger or smaller */\n  size: PropTypes__default[\"default\"].string,\n\n  /** Set a custom element for this component */\n  tag: tagPropType\n};\nvar defaultProps$17 = {\n  color: 'secondary',\n  tag: 'button'\n};\n\nfunction Button(props) {\n  var onClick = React.useCallback(function (e) {\n    if (props.disabled) {\n      e.preventDefault();\n      return;\n    }\n\n    if (props.onClick) {\n      return props.onClick(e);\n    }\n  }, [props.onClick, props.disabled]);\n\n  var active = props.active,\n      ariaLabel = props['aria-label'],\n      block = props.block,\n      className = props.className,\n      close = props.close,\n      cssModule = props.cssModule,\n      color = props.color,\n      outline = props.outline,\n      size = props.size,\n      Tag = props.tag,\n      innerRef = props.innerRef,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$14);\n\n  if (close) {\n    return /*#__PURE__*/React__default[\"default\"].createElement(CloseButton, attributes);\n  }\n\n  var btnOutlineColor = \"btn\" + (outline ? '-outline' : '') + \"-\" + color;\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'btn', btnOutlineColor, size ? \"btn-\" + size : false, block ? 'd-block w-100' : false, {\n    active: active,\n    disabled: props.disabled\n  }), cssModule);\n\n  if (attributes.href && Tag === 'button') {\n    Tag = 'a';\n  }\n\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({\n    type: Tag === 'button' && attributes.onClick ? 'button' : undefined\n  }, attributes, {\n    className: classes,\n    ref: innerRef,\n    onClick: onClick,\n    \"aria-label\": ariaLabel\n  }));\n}\n\nButton.propTypes = propTypes$19;\nButton.defaultProps = defaultProps$17;\n\nvar _excluded$13 = [\"className\"];\nvar propTypes$18 = {\n  onClick: PropTypes__default[\"default\"].func,\n  onBlur: PropTypes__default[\"default\"].func,\n  onFocus: PropTypes__default[\"default\"].func,\n  defaultValue: PropTypes__default[\"default\"].bool,\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object\n};\nvar defaultProps$16 = {\n  defaultValue: false\n};\n\nfunction ButtonToggle(props) {\n  var _useState = React.useState(props.defaultValue),\n      toggled = _useState[0],\n      setToggled = _useState[1];\n\n  var _useState2 = React.useState(false),\n      focus = _useState2[0],\n      setFocus = _useState2[1];\n\n  var onBlur = React.useCallback(function (e) {\n    if (props.onBlur) {\n      props.onBlur(e);\n    }\n\n    setFocus(false);\n  }, [props.onBlur]);\n  var onFocus = React.useCallback(function (e) {\n    if (props.onFocus) {\n      props.onFocus(e);\n    }\n\n    setFocus(true);\n  }, [props.onFocus]);\n  var onClick = React.useCallback(function (e) {\n    if (props.onClick) {\n      props.onClick(e);\n    }\n\n    setToggled(!toggled);\n  }, [props.onClick]);\n\n  var className = props.className,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$13);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, {\n    focus: focus\n  }), props.cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Button, _extends({\n    active: toggled,\n    onBlur: onBlur,\n    onFocus: onFocus,\n    onClick: onClick,\n    className: classes\n  }, attributes));\n}\n\nButtonToggle.propTypes = propTypes$18;\nButtonToggle.defaultProps = defaultProps$16;\n\n/**\n * DropdownContext\n * {\n *  toggle: PropTypes.func.isRequired,\n *  isOpen: PropTypes.bool.isRequired,\n *  direction: PropTypes.oneOf(['up', 'down', 'start', 'end']).isRequired,\n *  inNavbar: PropTypes.bool.isRequired,\n *  disabled: PropTypes.bool\n * }\n */\n\nvar DropdownContext = React__default[\"default\"].createContext({});\n\nvar InputGroupContext = React__default[\"default\"].createContext({});\n\nvar _excluded$12 = [\"className\", \"cssModule\", \"direction\", \"isOpen\", \"group\", \"size\", \"nav\", \"setActiveFromChild\", \"active\", \"tag\", \"menuRole\"];\nvar propTypes$17 = {\n  a11y: PropTypes__default[\"default\"].bool,\n  disabled: PropTypes__default[\"default\"].bool,\n  direction: PropTypes__default[\"default\"].oneOf(['up', 'down', 'start', 'end', 'left', 'right']),\n  group: PropTypes__default[\"default\"].bool,\n  isOpen: PropTypes__default[\"default\"].bool,\n  nav: PropTypes__default[\"default\"].bool,\n  active: PropTypes__default[\"default\"].bool,\n  size: PropTypes__default[\"default\"].string,\n  tag: tagPropType,\n  toggle: PropTypes__default[\"default\"].func,\n  children: PropTypes__default[\"default\"].node,\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object,\n  dropup: PropTypes__default[\"default\"].bool,\n  inNavbar: PropTypes__default[\"default\"].bool,\n  setActiveFromChild: PropTypes__default[\"default\"].bool,\n  menuRole: PropTypes__default[\"default\"].oneOf(['listbox', 'menu'])\n};\nvar defaultProps$15 = {\n  a11y: true,\n  isOpen: false,\n  direction: 'down',\n  nav: false,\n  active: false,\n  inNavbar: false,\n  setActiveFromChild: false\n};\nvar preventDefaultKeys = [keyCodes.space, keyCodes.enter, keyCodes.up, keyCodes.down, keyCodes.end, keyCodes.home];\n\nvar Dropdown = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Dropdown, _React$Component);\n\n  function Dropdown(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    _this.addEvents = _this.addEvents.bind(_assertThisInitialized(_this));\n    _this.handleDocumentClick = _this.handleDocumentClick.bind(_assertThisInitialized(_this));\n    _this.handleKeyDown = _this.handleKeyDown.bind(_assertThisInitialized(_this));\n    _this.removeEvents = _this.removeEvents.bind(_assertThisInitialized(_this));\n    _this.toggle = _this.toggle.bind(_assertThisInitialized(_this));\n    _this.handleMenuRef = _this.handleMenuRef.bind(_assertThisInitialized(_this));\n    _this.handleToggleRef = _this.handleToggleRef.bind(_assertThisInitialized(_this));\n    _this.containerRef = React__default[\"default\"].createRef();\n    _this.menuRef = React__default[\"default\"].createRef();\n    _this.toggleRef = React__default[\"default\"].createRef(); // ref for DropdownToggle\n\n    return _this;\n  }\n\n  var _proto = Dropdown.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.handleProps();\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    if (this.props.isOpen !== prevProps.isOpen) {\n      this.handleProps();\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.removeEvents();\n  };\n\n  _proto.handleMenuRef = function handleMenuRef(menuRef) {\n    this.menuRef.current = menuRef;\n  };\n\n  _proto.handleToggleRef = function handleToggleRef(toggleRef) {\n    this.toggleRef.current = toggleRef;\n  };\n\n  _proto.handleDocumentClick = function handleDocumentClick(e) {\n    if (e && (e.which === 3 || e.type === 'keyup' && e.which !== keyCodes.tab)) return;\n    var container = this.getContainer();\n    var menu = this.getMenu();\n    var toggle = this.getToggle();\n    var targetIsToggle = e.target === toggle;\n    var clickIsInMenu = menu && menu.contains(e.target) && menu !== e.target;\n    var clickIsInInput = false;\n\n    if (container) {\n      // this is only for InputGroup with type dropdown\n      clickIsInInput = container.classList.contains('input-group') && container.classList.contains('dropdown') && e.target.tagName === 'INPUT';\n    }\n\n    if ((targetIsToggle && !clickIsInInput || clickIsInMenu) && (e.type !== 'keyup' || e.which === keyCodes.tab)) {\n      return;\n    }\n\n    this.toggle(e);\n  };\n\n  _proto.handleKeyDown = function handleKeyDown(e) {\n    var _this2 = this;\n\n    var isTargetMenuItem = e.target.getAttribute('role') === 'menuitem' || e.target.getAttribute('role') === 'option';\n    var isTargetMenuCtrl = this.getMenuCtrl() === e.target;\n    var isTab = keyCodes.tab === e.which;\n\n    if (/input|textarea/i.test(e.target.tagName) || isTab && !this.props.a11y || isTab && !(isTargetMenuItem || isTargetMenuCtrl)) {\n      return;\n    }\n\n    if (preventDefaultKeys.indexOf(e.which) !== -1 || e.which >= 48 && e.which <= 90) {\n      e.preventDefault();\n    }\n\n    if (this.props.disabled) return;\n\n    if (isTargetMenuCtrl) {\n      if ([keyCodes.space, keyCodes.enter, keyCodes.up, keyCodes.down].indexOf(e.which) > -1) {\n        // Open the menu (if not open) and focus the first menu item\n        if (!this.props.isOpen) {\n          this.toggle(e);\n        }\n\n        setTimeout(function () {\n          return _this2.getMenuItems()[0].focus();\n        });\n      } else if (this.props.isOpen && isTab) {\n        // Focus the first menu item if tabbing from an open menu. We need this\n        // for cases where the DropdownMenu sets a custom container, which may\n        // not be the natural next item to tab to from the DropdownToggle.\n        e.preventDefault();\n        this.getMenuItems()[0].focus();\n      } else if (this.props.isOpen && e.which === keyCodes.esc) {\n        this.toggle(e);\n      }\n    }\n\n    if (this.props.isOpen && isTargetMenuItem) {\n      if ([keyCodes.tab, keyCodes.esc].indexOf(e.which) > -1) {\n        this.toggle(e);\n        this.getMenuCtrl().focus();\n      } else if ([keyCodes.space, keyCodes.enter].indexOf(e.which) > -1) {\n        e.target.click();\n        this.getMenuCtrl().focus();\n      } else if ([keyCodes.down, keyCodes.up].indexOf(e.which) > -1 || [keyCodes.n, keyCodes.p].indexOf(e.which) > -1 && e.ctrlKey) {\n        var $menuitems = this.getMenuItems();\n        var index = $menuitems.indexOf(e.target);\n\n        if (keyCodes.up === e.which || keyCodes.p === e.which && e.ctrlKey) {\n          index = index !== 0 ? index - 1 : $menuitems.length - 1;\n        } else if (keyCodes.down === e.which || keyCodes.n === e.which && e.ctrlKey) {\n          index = index === $menuitems.length - 1 ? 0 : index + 1;\n        }\n\n        $menuitems[index].focus();\n      } else if (keyCodes.end === e.which) {\n        var _$menuitems = this.getMenuItems();\n\n        _$menuitems[_$menuitems.length - 1].focus();\n      } else if (keyCodes.home === e.which) {\n        var _$menuitems2 = this.getMenuItems();\n\n        _$menuitems2[0].focus();\n      } else if (e.which >= 48 && e.which <= 90) {\n        var _$menuitems3 = this.getMenuItems();\n\n        var charPressed = String.fromCharCode(e.which).toLowerCase();\n\n        for (var i = 0; i < _$menuitems3.length; i += 1) {\n          var firstLetter = _$menuitems3[i].textContent && _$menuitems3[i].textContent[0].toLowerCase();\n\n          if (firstLetter === charPressed) {\n            _$menuitems3[i].focus();\n\n            break;\n          }\n        }\n      }\n    }\n  };\n\n  _proto.handleProps = function handleProps() {\n    if (this.props.isOpen) {\n      this.addEvents();\n    } else {\n      this.removeEvents();\n    }\n  };\n\n  _proto.getContextValue = function getContextValue() {\n    return {\n      toggle: this.toggle,\n      isOpen: this.props.isOpen,\n      direction: this.props.direction === 'down' && this.props.dropup ? 'up' : this.props.direction,\n      inNavbar: this.props.inNavbar,\n      disabled: this.props.disabled,\n      // Callback that should be called by DropdownMenu to provide a ref to\n      // a HTML tag that's used for the DropdownMenu\n      onMenuRef: this.handleMenuRef,\n      onToggleRef: this.handleToggleRef,\n      menuRole: this.props.menuRole\n    };\n  };\n\n  _proto.getContainer = function getContainer() {\n    return this.containerRef.current;\n  };\n\n  _proto.getMenu = function getMenu() {\n    return this.menuRef.current;\n  };\n\n  _proto.getToggle = function getToggle() {\n    return this.toggleRef.current;\n  };\n\n  _proto.getMenuCtrl = function getMenuCtrl() {\n    if (this._$menuCtrl) return this._$menuCtrl;\n    this._$menuCtrl = this.getToggle();\n    return this._$menuCtrl;\n  };\n\n  _proto.getItemType = function getItemType() {\n    if (this.props.menuRole === 'listbox') {\n      return 'option';\n    }\n\n    return 'menuitem';\n  };\n\n  _proto.getMenuItems = function getMenuItems() {\n    // In a real menu with a child DropdownMenu, `this.getMenu()` should never\n    // be null, but it is sometimes null in tests. To mitigate that, we just\n    // use `this.getContainer()` as the fallback `menuContainer`.\n    var menuContainer = this.getMenu() || this.getContainer();\n    return [].slice.call(menuContainer.querySelectorAll(\"[role=\\\"\" + this.getItemType() + \"\\\"]\"));\n  };\n\n  _proto.addEvents = function addEvents() {\n    var _this3 = this;\n\n    ['click', 'touchstart', 'keyup'].forEach(function (event) {\n      return document.addEventListener(event, _this3.handleDocumentClick, true);\n    });\n  };\n\n  _proto.removeEvents = function removeEvents() {\n    var _this4 = this;\n\n    ['click', 'touchstart', 'keyup'].forEach(function (event) {\n      return document.removeEventListener(event, _this4.handleDocumentClick, true);\n    });\n  };\n\n  _proto.toggle = function toggle(e) {\n    if (this.props.disabled) {\n      return e && e.preventDefault();\n    }\n\n    return this.props.toggle(e);\n  };\n\n  _proto.render = function render() {\n    var _classNames,\n        _this5 = this,\n        _ref;\n\n    var _omit = omit(this.props, ['toggle', 'disabled', 'inNavbar', 'a11y']),\n        className = _omit.className,\n        cssModule = _omit.cssModule,\n        direction = _omit.direction,\n        isOpen = _omit.isOpen,\n        group = _omit.group,\n        size = _omit.size,\n        nav = _omit.nav,\n        setActiveFromChild = _omit.setActiveFromChild,\n        active = _omit.active,\n        tag = _omit.tag,\n        attrs = _objectWithoutPropertiesLoose(_omit, _excluded$12);\n\n    var Tag = tag || (nav ? 'li' : 'div');\n    var subItemIsActive = false;\n\n    if (setActiveFromChild) {\n      React__default[\"default\"].Children.map(this.props.children[1].props.children, function (dropdownItem) {\n        if (dropdownItem && dropdownItem.props.active) subItemIsActive = true;\n      });\n    }\n\n    var classes = mapToCssModules(classNames__default[\"default\"](className, nav && active ? 'active' : false, setActiveFromChild && subItemIsActive ? 'active' : false, (_classNames = {\n      'btn-group': group\n    }, _classNames[\"btn-group-\" + size] = !!size, _classNames.dropdown = !group, _classNames.dropup = direction === 'up', _classNames.dropstart = direction === 'start' || direction === 'left', _classNames.dropend = direction === 'end' || direction === 'right', _classNames.show = isOpen, _classNames['nav-item'] = nav, _classNames)), cssModule);\n\n    if (this.context.insideInputGroup) {\n      return /*#__PURE__*/React__default[\"default\"].createElement(DropdownContext.Provider, {\n        value: this.getContextValue()\n      }, /*#__PURE__*/React__default[\"default\"].createElement(reactPopper.Manager, null, React__default[\"default\"].Children.map(this.props.children, function (child) {\n        return React__default[\"default\"].cloneElement(child, {\n          onKeyDown: _this5.handleKeyDown\n        });\n      })));\n    }\n\n    return /*#__PURE__*/React__default[\"default\"].createElement(DropdownContext.Provider, {\n      value: this.getContextValue()\n    }, /*#__PURE__*/React__default[\"default\"].createElement(reactPopper.Manager, null, /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attrs, (_ref = {}, _ref[typeof Tag === 'string' ? 'ref' : 'innerRef'] = this.containerRef, _ref), {\n      onKeyDown: this.handleKeyDown,\n      className: classes\n    }))));\n  };\n\n  return Dropdown;\n}(React__default[\"default\"].Component);\n\nDropdown.propTypes = propTypes$17;\nDropdown.defaultProps = defaultProps$15;\nDropdown.contextType = InputGroupContext;\nvar Dropdown$1 = Dropdown;\n\nvar propTypes$16 = {\n  children: PropTypes__default[\"default\"].node\n};\n\nfunction ButtonDropdown(props) {\n  return /*#__PURE__*/React__default[\"default\"].createElement(Dropdown$1, _extends({\n    group: true\n  }, props));\n}\n\nButtonDropdown.propTypes = propTypes$16;\n\nvar _excluded$11 = [\"className\", \"cssModule\", \"size\", \"vertical\", \"tag\"];\nvar propTypes$15 = {\n  /** Aria label */\n  'aria-label': PropTypes__default[\"default\"].string,\n\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** In order for assistive technologies (such as screen readers) to convey that a series of buttons is grouped, an appropriate role attribute needs to be provided. For button groups, this would be role=\"group\", while toolbars should have a role=\"toolbar\". */\n  role: PropTypes__default[\"default\"].string,\n\n  /** Make the button bigger or smaller */\n  size: PropTypes__default[\"default\"].string,\n\n  /** Set a custom element for this component */\n  tag: tagPropType,\n\n  /** Make button group vertical */\n  vertical: PropTypes__default[\"default\"].bool\n};\nvar defaultProps$14 = {\n  tag: 'div',\n  role: 'group'\n};\n\nfunction ButtonGroup(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      size = props.size,\n      vertical = props.vertical,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$11);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, size ? 'btn-group-' + size : false, vertical ? 'btn-group-vertical' : 'btn-group'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nButtonGroup.propTypes = propTypes$15;\nButtonGroup.defaultProps = defaultProps$14;\n\nvar _excluded$10 = [\"className\", \"cssModule\", \"tag\"];\nvar propTypes$14 = {\n  /** Aria label */\n  'aria-label': PropTypes__default[\"default\"].string,\n\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change existing className with a new className */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** In order for assistive technologies (such as screen readers) to convey that a series of buttons is grouped, an appropriate role attribute needs to be provided. For button groups, this would be role=\"group\", while toolbars should have a role=\"toolbar\". */\n  role: PropTypes__default[\"default\"].string,\n\n  /** Set a custom element for this component */\n  tag: tagPropType\n};\nvar defaultProps$13 = {\n  tag: 'div',\n  role: 'toolbar'\n};\n\nfunction ButtonToolbar(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$10);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'btn-toolbar'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nButtonToolbar.propTypes = propTypes$14;\nButtonToolbar.defaultProps = defaultProps$13;\n\nvar _excluded$$ = [\"className\", \"cssModule\", \"divider\", \"tag\", \"header\", \"active\", \"text\"];\nvar propTypes$13 = {\n  children: PropTypes__default[\"default\"].node,\n  active: PropTypes__default[\"default\"].bool,\n  disabled: PropTypes__default[\"default\"].bool,\n  divider: PropTypes__default[\"default\"].bool,\n  tag: tagPropType,\n  header: PropTypes__default[\"default\"].bool,\n  onClick: PropTypes__default[\"default\"].func,\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object,\n  toggle: PropTypes__default[\"default\"].bool,\n  text: PropTypes__default[\"default\"].bool\n};\nvar defaultProps$12 = {\n  tag: 'button',\n  toggle: true\n};\n\nvar DropdownItem = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(DropdownItem, _React$Component);\n\n  function DropdownItem(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    _this.onClick = _this.onClick.bind(_assertThisInitialized(_this));\n    _this.getTabIndex = _this.getTabIndex.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  var _proto = DropdownItem.prototype;\n\n  _proto.onClick = function onClick(e) {\n    var _this$props = this.props,\n        disabled = _this$props.disabled,\n        header = _this$props.header,\n        divider = _this$props.divider,\n        text = _this$props.text;\n\n    if (disabled || header || divider || text) {\n      e.preventDefault();\n      return;\n    }\n\n    if (this.props.onClick) {\n      this.props.onClick(e);\n    }\n\n    if (this.props.toggle) {\n      this.context.toggle(e);\n    }\n  };\n\n  _proto.getRole = function getRole() {\n    if (this.context.menuRole === 'listbox') {\n      return 'option';\n    }\n\n    return 'menuitem';\n  };\n\n  _proto.getTabIndex = function getTabIndex() {\n    var _this$props2 = this.props,\n        disabled = _this$props2.disabled,\n        header = _this$props2.header,\n        divider = _this$props2.divider,\n        text = _this$props2.text;\n\n    if (disabled || header || divider || text) {\n      return '-1';\n    }\n\n    return '0';\n  };\n\n  _proto.render = function render() {\n    var tabIndex = this.getTabIndex();\n    var role = tabIndex > -1 ? this.getRole() : undefined;\n\n    var _omit = omit(this.props, ['toggle']),\n        className = _omit.className,\n        cssModule = _omit.cssModule,\n        divider = _omit.divider,\n        Tag = _omit.tag,\n        header = _omit.header,\n        active = _omit.active,\n        text = _omit.text,\n        props = _objectWithoutPropertiesLoose(_omit, _excluded$$);\n\n    var classes = mapToCssModules(classNames__default[\"default\"](className, {\n      disabled: props.disabled,\n      'dropdown-item': !divider && !header && !text,\n      active: active,\n      'dropdown-header': header,\n      'dropdown-divider': divider,\n      'dropdown-item-text': text\n    }), cssModule);\n\n    if (Tag === 'button') {\n      if (header) {\n        Tag = 'h6';\n      } else if (divider) {\n        Tag = 'div';\n      } else if (props.href) {\n        Tag = 'a';\n      } else if (text) {\n        Tag = 'span';\n      }\n    }\n\n    return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({\n      type: Tag === 'button' && (props.onClick || this.props.toggle) ? 'button' : undefined\n    }, props, {\n      tabIndex: tabIndex,\n      role: role,\n      className: classes,\n      onClick: this.onClick\n    }));\n  };\n\n  return DropdownItem;\n}(React__default[\"default\"].Component);\n\nDropdownItem.propTypes = propTypes$13;\nDropdownItem.defaultProps = defaultProps$12;\nDropdownItem.contextType = DropdownContext;\nvar DropdownItem$1 = DropdownItem;\n\nvar _excluded$_ = [\"className\", \"cssModule\", \"dark\", \"end\", \"right\", \"tag\", \"flip\", \"modifiers\", \"persist\", \"strategy\", \"container\", \"updateOnSelect\"];\nvar propTypes$12 = {\n  tag: tagPropType,\n  children: PropTypes__default[\"default\"].node.isRequired,\n  dark: PropTypes__default[\"default\"].bool,\n  end: PropTypes__default[\"default\"].bool,\n\n  /** Flips the menu to the opposite side if there is not enough space to fit */\n  flip: PropTypes__default[\"default\"].bool,\n  modifiers: PropTypes__default[\"default\"].array,\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object,\n  style: PropTypes__default[\"default\"].object,\n  persist: PropTypes__default[\"default\"].bool,\n  strategy: PropTypes__default[\"default\"].string,\n  container: targetPropType,\n\n  /** Update popper layout when a click event comes up. This leverages event bubbling. */\n  updateOnSelect: PropTypes__default[\"default\"].bool,\n  right: deprecated(PropTypes__default[\"default\"].bool, 'Please use \"end\" instead.')\n};\nvar defaultProps$11 = {\n  tag: 'div',\n  flip: true,\n  modifiers: []\n};\nvar directionPositionMap = {\n  up: 'top',\n  left: 'left',\n  right: 'right',\n  start: 'left',\n  end: 'right',\n  down: 'bottom'\n};\n\nvar DropdownMenu = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(DropdownMenu, _React$Component);\n\n  function DropdownMenu() {\n    return _React$Component.apply(this, arguments) || this;\n  }\n\n  var _proto = DropdownMenu.prototype;\n\n  _proto.getRole = function getRole() {\n    if (this.context.menuRole === 'listbox') {\n      return 'listbox';\n    }\n\n    return 'menu';\n  };\n\n  _proto.render = function render() {\n    var _this = this;\n\n    var _this$props = this.props,\n        className = _this$props.className,\n        cssModule = _this$props.cssModule,\n        dark = _this$props.dark,\n        end = _this$props.end,\n        right = _this$props.right,\n        tag = _this$props.tag,\n        flip = _this$props.flip,\n        modifiers = _this$props.modifiers,\n        persist = _this$props.persist,\n        strategy = _this$props.strategy,\n        container = _this$props.container,\n        updateOnSelect = _this$props.updateOnSelect,\n        attrs = _objectWithoutPropertiesLoose(_this$props, _excluded$_);\n\n    var classes = mapToCssModules(classNames__default[\"default\"](className, 'dropdown-menu', {\n      'dropdown-menu-dark': dark,\n      'dropdown-menu-end': end || right,\n      show: this.context.isOpen\n    }), cssModule);\n    var Tag = tag;\n\n    if (persist || this.context.isOpen && !this.context.inNavbar) {\n      var position1 = directionPositionMap[this.context.direction] || 'bottom';\n      var position2 = end || right ? 'end' : 'start';\n      var poperPlacement = position1 + \"-\" + position2;\n      var poperModifiers = [].concat(modifiers, [{\n        name: 'flip',\n        enabled: !!flip\n      }]);\n      var popper = /*#__PURE__*/React__default[\"default\"].createElement(reactPopper.Popper, {\n        placement: poperPlacement,\n        modifiers: poperModifiers,\n        strategy: strategy\n      }, function (_ref) {\n        var ref = _ref.ref,\n            style = _ref.style,\n            placement = _ref.placement,\n            update = _ref.update;\n\n        var combinedStyle = _objectSpread2(_objectSpread2({}, _this.props.style), style);\n\n        var handleRef = function handleRef(tagRef) {\n          // Send the ref to `react-popper`\n          ref(tagRef); // Send the ref to the parent Dropdown so that clicks outside\n          // it will cause it to close\n\n          var onMenuRef = _this.context.onMenuRef;\n          if (onMenuRef) onMenuRef(tagRef);\n        };\n\n        return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({\n          tabIndex: \"-1\",\n          role: _this.getRole(),\n          ref: handleRef\n        }, attrs, {\n          style: combinedStyle,\n          \"aria-hidden\": !_this.context.isOpen,\n          className: classes,\n          \"data-popper-placement\": placement,\n          onClick: function onClick() {\n            return updateOnSelect && update();\n          }\n        }));\n      });\n\n      if (container) {\n        return ReactDOM__default[\"default\"].createPortal(popper, getTarget(container));\n      }\n\n      return popper;\n    }\n\n    var onMenuRef = this.context.onMenuRef;\n    return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({\n      tabIndex: \"-1\",\n      role: this.getRole()\n    }, attrs, {\n      ref: onMenuRef,\n      \"aria-hidden\": !this.context.isOpen,\n      className: classes,\n      \"data-popper-placement\": attrs.placement\n    }));\n  };\n\n  return DropdownMenu;\n}(React__default[\"default\"].Component);\n\nDropdownMenu.propTypes = propTypes$12;\nDropdownMenu.defaultProps = defaultProps$11;\nDropdownMenu.contextType = DropdownContext;\nvar DropdownMenu$1 = DropdownMenu;\n\nvar _excluded$Z = [\"className\", \"color\", \"cssModule\", \"caret\", \"split\", \"nav\", \"tag\", \"innerRef\"];\nvar propTypes$11 = {\n  caret: PropTypes__default[\"default\"].bool,\n  color: PropTypes__default[\"default\"].string,\n  children: PropTypes__default[\"default\"].node,\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object,\n  disabled: PropTypes__default[\"default\"].bool,\n  onClick: PropTypes__default[\"default\"].func,\n  'aria-haspopup': PropTypes__default[\"default\"].bool,\n  split: PropTypes__default[\"default\"].bool,\n  tag: tagPropType,\n  nav: PropTypes__default[\"default\"].bool,\n  innerRef: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].object, PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].func])\n};\nvar defaultProps$10 = {\n  color: 'secondary',\n  'aria-haspopup': true\n};\n\nvar DropdownToggle = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(DropdownToggle, _React$Component);\n\n  function DropdownToggle(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    _this.onClick = _this.onClick.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  var _proto = DropdownToggle.prototype;\n\n  _proto.onClick = function onClick(e) {\n    if (this.props.disabled || this.context.disabled) {\n      e.preventDefault();\n      return;\n    }\n\n    if (this.props.nav && !this.props.tag) {\n      e.preventDefault();\n    }\n\n    if (this.props.onClick) {\n      this.props.onClick(e);\n    }\n\n    this.context.toggle(e);\n  };\n\n  _proto.getRole = function getRole() {\n    return this.context.menuRole || this.props['aria-haspopup'];\n  };\n\n  _proto.render = function render() {\n    var _this2 = this;\n\n    var _this$props = this.props,\n        className = _this$props.className,\n        color = _this$props.color,\n        cssModule = _this$props.cssModule,\n        caret = _this$props.caret,\n        split = _this$props.split,\n        nav = _this$props.nav,\n        tag = _this$props.tag,\n        innerRef = _this$props.innerRef,\n        props = _objectWithoutPropertiesLoose(_this$props, _excluded$Z);\n\n    var ariaLabel = props['aria-label'] || 'Toggle Dropdown';\n    var classes = mapToCssModules(classNames__default[\"default\"](className, {\n      'dropdown-toggle': caret || split,\n      'dropdown-toggle-split': split,\n      'nav-link': nav\n    }), cssModule);\n    var children = typeof props.children !== 'undefined' ? props.children : /*#__PURE__*/React__default[\"default\"].createElement(\"span\", {\n      className: \"visually-hidden\"\n    }, ariaLabel);\n    var Tag;\n\n    if (nav && !tag) {\n      Tag = 'a';\n      props.href = '#';\n    } else if (!tag) {\n      Tag = Button;\n      props.color = color;\n      props.cssModule = cssModule;\n    } else {\n      Tag = tag;\n    }\n\n    if (this.context.inNavbar) {\n      return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, props, {\n        className: classes,\n        onClick: this.onClick,\n        ref: this.context.onToggleRef,\n        \"aria-expanded\": this.context.isOpen,\n        \"aria-haspopup\": this.getRole(),\n        children: children\n      }));\n    }\n\n    return /*#__PURE__*/React__default[\"default\"].createElement(reactPopper.Reference, {\n      innerRef: innerRef\n    }, function (_ref) {\n      var _ref2;\n\n      var ref = _ref.ref;\n\n      var handleRef = function handleRef(tagRef) {\n        ref(tagRef);\n        var onToggleRef = _this2.context.onToggleRef;\n        if (onToggleRef) onToggleRef(tagRef);\n      };\n\n      return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, props, (_ref2 = {}, _ref2[typeof Tag === 'string' ? 'ref' : 'innerRef'] = handleRef, _ref2), {\n        className: classes,\n        onClick: _this2.onClick,\n        \"aria-expanded\": _this2.context.isOpen,\n        \"aria-haspopup\": _this2.getRole(),\n        children: children\n      }));\n    });\n  };\n\n  return DropdownToggle;\n}(React__default[\"default\"].Component);\n\nDropdownToggle.propTypes = propTypes$11;\nDropdownToggle.defaultProps = defaultProps$10;\nDropdownToggle.contextType = DropdownContext;\nvar DropdownToggle$1 = DropdownToggle;\n\nvar _excluded$Y = [\"tag\", \"baseClass\", \"baseClassActive\", \"className\", \"cssModule\", \"children\", \"innerRef\"];\n\nvar propTypes$10 = _objectSpread2(_objectSpread2({}, reactTransitionGroup.Transition.propTypes), {}, {\n  children: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].arrayOf(PropTypes__default[\"default\"].node), PropTypes__default[\"default\"].node]),\n  tag: tagPropType,\n  baseClass: PropTypes__default[\"default\"].string,\n  baseClassActive: PropTypes__default[\"default\"].string,\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object,\n  innerRef: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].object, PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].func])\n});\n\nvar defaultProps$$ = _objectSpread2(_objectSpread2({}, reactTransitionGroup.Transition.defaultProps), {}, {\n  tag: 'div',\n  baseClass: 'fade',\n  baseClassActive: 'show',\n  timeout: TransitionTimeouts.Fade,\n  appear: true,\n  enter: true,\n  exit: true,\n  \"in\": true\n});\n\nfunction Fade(props) {\n  var Tag = props.tag,\n      baseClass = props.baseClass,\n      baseClassActive = props.baseClassActive,\n      className = props.className,\n      cssModule = props.cssModule,\n      children = props.children,\n      innerRef = props.innerRef,\n      otherProps = _objectWithoutPropertiesLoose(props, _excluded$Y);\n\n  var transitionProps = pick(otherProps, TransitionPropTypeKeys);\n  var childProps = omit(otherProps, TransitionPropTypeKeys);\n  return /*#__PURE__*/React__default[\"default\"].createElement(reactTransitionGroup.Transition, transitionProps, function (status) {\n    var isActive = status === 'entered';\n    var classes = mapToCssModules(classNames__default[\"default\"](className, baseClass, isActive && baseClassActive), cssModule);\n    return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({\n      className: classes\n    }, childProps, {\n      ref: innerRef\n    }), children);\n  });\n}\n\nFade.propTypes = propTypes$10;\nFade.defaultProps = defaultProps$$;\n\n/**\n * AccordionContext\n * {\n *  toggle: PropTypes.func.isRequired,\n *  openId: PropTypes.string,\n * }\n */\n\nvar AccordionContext = React__default[\"default\"].createContext({});\n\nvar _excluded$X = [\"flush\", \"open\", \"toggle\", \"className\", \"cssModule\", \"tag\", \"innerRef\"];\nvar propTypes$$ = {\n  children: PropTypes__default[\"default\"].node,\n\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change existing className with a new className */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Render accordions edge-to-edge with their parent container */\n  flush: PropTypes__default[\"default\"].bool,\n  innerRef: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].object, PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].func]),\n\n  /** The current active key that corresponds to the currently expanded card */\n  open: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].array, PropTypes__default[\"default\"].string]).isRequired,\n\n  /** Set a custom element for this component */\n  tag: tagPropType,\n\n  /** Function that's triggered on clicking `AccordionHeader` */\n  toggle: PropTypes__default[\"default\"].func.isRequired\n};\nvar defaultProps$_ = {\n  tag: 'div'\n};\n\nfunction Accordion(props) {\n  var flush = props.flush,\n      open = props.open,\n      toggle = props.toggle,\n      className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      innerRef = props.innerRef,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$X);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'accordion', {\n    'accordion-flush': flush\n  }), cssModule);\n  var accordionContext = React.useMemo(function () {\n    return {\n      open: open,\n      toggle: toggle\n    };\n  });\n  return /*#__PURE__*/React__default[\"default\"].createElement(AccordionContext.Provider, {\n    value: accordionContext\n  }, /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes,\n    ref: innerRef\n  })));\n}\n\nAccordion.propTypes = propTypes$$;\nAccordion.defaultProps = defaultProps$_;\n\nvar _excluded$W = [\"defaultOpen\", \"stayOpen\"];\nvar propTypes$_ = {\n  tag: tagPropType,\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object,\n  innerRef: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].object, PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].func]),\n  children: PropTypes__default[\"default\"].node,\n  defaultOpen: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].array, PropTypes__default[\"default\"].string]),\n  stayOpen: PropTypes__default[\"default\"].bool\n};\nvar defaultProps$Z = {\n  tag: 'div'\n};\n\nfunction UncontrolledAccordion(_ref) {\n  var defaultOpen = _ref.defaultOpen,\n      stayOpen = _ref.stayOpen,\n      props = _objectWithoutPropertiesLoose(_ref, _excluded$W);\n\n  var _useState = React.useState(defaultOpen || (stayOpen ? [] : undefined)),\n      open = _useState[0],\n      setOpen = _useState[1];\n\n  var toggle = function toggle(id) {\n    if (stayOpen) {\n      if (open.includes(id)) {\n        setOpen(open.filter(function (accordionId) {\n          return accordionId !== id;\n        }));\n      } else {\n        setOpen([].concat(open, [id]));\n      }\n    } else if (open === id) {\n      setOpen(undefined);\n    } else {\n      setOpen(id);\n    }\n  };\n\n  return /*#__PURE__*/React__default[\"default\"].createElement(Accordion, _extends({}, props, {\n    open: open,\n    toggle: toggle\n  }));\n}\n\nUncontrolledAccordion.propTypes = propTypes$_;\nUncontrolledAccordion.defaultProps = defaultProps$Z;\n\nvar _excluded$V = [\"className\", \"cssModule\", \"tag\", \"innerRef\", \"children\", \"targetId\"];\nvar propTypes$Z = {\n  children: PropTypes__default[\"default\"].node,\n\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change existing base class name with a new class name */\n  cssModule: PropTypes__default[\"default\"].object,\n  innerRef: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].object, PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].func]),\n\n  /** Set a custom element for this component */\n  tag: tagPropType,\n\n  /** Unique key used to control item's collapse/expand */\n  targetId: PropTypes__default[\"default\"].string.isRequired\n};\nvar defaultProps$Y = {\n  tag: 'h2'\n};\n\nfunction AccordionHeader(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      innerRef = props.innerRef,\n      children = props.children,\n      targetId = props.targetId,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$V);\n\n  var _useContext = React.useContext(AccordionContext),\n      open = _useContext.open,\n      toggle = _useContext.toggle;\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'accordion-header'), cssModule);\n  var buttonClasses = mapToCssModules(classNames__default[\"default\"]('accordion-button', {\n    collapsed: !(Array.isArray(open) ? open.includes(targetId) : open === targetId)\n  }), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes,\n    ref: innerRef\n  }), /*#__PURE__*/React__default[\"default\"].createElement(\"button\", {\n    type: \"button\",\n    className: buttonClasses,\n    onClick: function onClick() {\n      return toggle(targetId);\n    }\n  }, children));\n}\n\nAccordionHeader.propTypes = propTypes$Z;\nAccordionHeader.defaultProps = defaultProps$Y;\n\nvar _excluded$U = [\"className\", \"cssModule\", \"tag\", \"innerRef\"];\nvar propTypes$Y = {\n  children: PropTypes__default[\"default\"].node,\n\n  /** To add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change existing base class name with a new class name */\n  cssModule: PropTypes__default[\"default\"].object,\n  innerRef: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].object, PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].func]),\n\n  /** Set a custom element for this component */\n  tag: tagPropType\n};\nvar defaultProps$X = {\n  tag: 'div'\n};\n\nfunction AccordionItem(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      innerRef = props.innerRef,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$U);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'accordion-item'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes,\n    ref: innerRef\n  }));\n}\n\nAccordionItem.propTypes = propTypes$Y;\nAccordionItem.defaultProps = defaultProps$X;\n\nvar _excluded$T = [\"tag\", \"horizontal\", \"isOpen\", \"className\", \"navbar\", \"cssModule\", \"children\", \"innerRef\"];\n\nvar _transitionStatusToCl;\n\nvar propTypes$X = _objectSpread2(_objectSpread2({}, reactTransitionGroup.Transition.propTypes), {}, {\n  /** Make content animation appear horizontally */\n  horizontal: PropTypes__default[\"default\"].bool,\n\n  /** Set if Collapse is open or closed */\n  isOpen: PropTypes__default[\"default\"].bool,\n  children: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].arrayOf(PropTypes__default[\"default\"].node), PropTypes__default[\"default\"].node]),\n\n  /** Set a custom element for this component */\n  tag: tagPropType,\n\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].node,\n  navbar: PropTypes__default[\"default\"].bool,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n  innerRef: PropTypes__default[\"default\"].shape({\n    current: PropTypes__default[\"default\"].object\n  })\n});\n\nvar defaultProps$W = _objectSpread2(_objectSpread2({}, reactTransitionGroup.Transition.defaultProps), {}, {\n  horizontal: false,\n  isOpen: false,\n  appear: false,\n  enter: true,\n  exit: true,\n  tag: 'div',\n  timeout: TransitionTimeouts.Collapse\n});\n\nvar transitionStatusToClassHash = (_transitionStatusToCl = {}, _transitionStatusToCl[TransitionStatuses.ENTERING] = 'collapsing', _transitionStatusToCl[TransitionStatuses.ENTERED] = 'collapse show', _transitionStatusToCl[TransitionStatuses.EXITING] = 'collapsing', _transitionStatusToCl[TransitionStatuses.EXITED] = 'collapse', _transitionStatusToCl);\n\nfunction getTransitionClass(status) {\n  return transitionStatusToClassHash[status] || 'collapse';\n}\n\nvar Collapse = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(Collapse, _Component);\n\n  function Collapse(props) {\n    var _this;\n\n    _this = _Component.call(this, props) || this;\n    _this.state = {\n      dimension: null\n    };\n    _this.nodeRef = props.innerRef || React__default[\"default\"].createRef();\n    ['onEntering', 'onEntered', 'onExit', 'onExiting', 'onExited'].forEach(function (name) {\n      _this[name] = _this[name].bind(_assertThisInitialized(_this));\n    });\n    return _this;\n  }\n\n  var _proto = Collapse.prototype;\n\n  _proto.onEntering = function onEntering(_, isAppearing) {\n    var node = this.getNode();\n    this.setState({\n      dimension: this.getDimension(node)\n    });\n    this.props.onEntering(node, isAppearing);\n  };\n\n  _proto.onEntered = function onEntered(_, isAppearing) {\n    var node = this.getNode();\n    this.setState({\n      dimension: null\n    });\n    this.props.onEntered(node, isAppearing);\n  };\n\n  _proto.onExit = function onExit() {\n    var node = this.getNode();\n    this.setState({\n      dimension: this.getDimension(node)\n    });\n    this.props.onExit(node);\n  };\n\n  _proto.onExiting = function onExiting() {\n    var node = this.getNode(); // getting this variable triggers a reflow\n\n    this.getDimension(node); // eslint-disable-line no-unused-vars\n\n\n    this.setState({\n      dimension: 0\n    });\n    this.props.onExiting(node);\n  };\n\n  _proto.onExited = function onExited() {\n    var node = this.getNode();\n    this.setState({\n      dimension: null\n    });\n    this.props.onExited(node);\n  };\n\n  _proto.getNode = function getNode() {\n    return this.nodeRef.current;\n  };\n\n  _proto.getDimension = function getDimension(node) {\n    return this.props.horizontal ? node.scrollWidth : node.scrollHeight;\n  };\n\n  _proto.render = function render() {\n    var _this2 = this;\n\n    var _this$props = this.props,\n        Tag = _this$props.tag,\n        horizontal = _this$props.horizontal,\n        isOpen = _this$props.isOpen,\n        className = _this$props.className,\n        navbar = _this$props.navbar,\n        cssModule = _this$props.cssModule,\n        children = _this$props.children,\n        otherProps = _objectWithoutPropertiesLoose(_this$props, _excluded$T);\n\n    var dimension = this.state.dimension;\n    var transitionProps = pick(otherProps, TransitionPropTypeKeys);\n    var childProps = omit(otherProps, TransitionPropTypeKeys);\n    return /*#__PURE__*/React__default[\"default\"].createElement(reactTransitionGroup.Transition, _extends({}, transitionProps, {\n      \"in\": isOpen,\n      nodeRef: this.nodeRef,\n      onEntering: this.onEntering,\n      onEntered: this.onEntered,\n      onExit: this.onExit,\n      onExiting: this.onExiting,\n      onExited: this.onExited\n    }), function (status) {\n      var _ref;\n\n      var collapseClass = getTransitionClass(status);\n      var classes = mapToCssModules(classNames__default[\"default\"](className, horizontal && 'collapse-horizontal', collapseClass, navbar && 'navbar-collapse'), cssModule);\n      var style = dimension === null ? null : (_ref = {}, _ref[horizontal ? 'width' : 'height'] = dimension, _ref);\n      return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, childProps, {\n        style: _objectSpread2(_objectSpread2({}, childProps.style), style),\n        className: classes,\n        ref: _this2.nodeRef\n      }), children);\n    });\n  };\n\n  return Collapse;\n}(React.Component);\n\nCollapse.propTypes = propTypes$X;\nCollapse.defaultProps = defaultProps$W;\nvar Collapse$1 = Collapse;\n\nvar _excluded$S = [\"className\", \"cssModule\", \"tag\", \"innerRef\", \"children\", \"accordionId\"];\nvar propTypes$W = {\n  /** Unique key used to control item's collapse/expand */\n  accordionId: PropTypes__default[\"default\"].string.isRequired,\n\n  /** To add custom class */\n  className: PropTypes__default[\"default\"].string,\n  children: PropTypes__default[\"default\"].node,\n\n  /** Change existing base class name with a new class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Pass ref to the component */\n  innerRef: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].object, PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].func]),\n\n  /** Set a custom element for this component */\n  tag: tagPropType\n};\nvar defaultProps$V = {\n  tag: 'div'\n};\n\nfunction AccordionBody(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      innerRef = props.innerRef,\n      children = props.children,\n      accordionId = props.accordionId,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$S);\n\n  var _useContext = React.useContext(AccordionContext),\n      open = _useContext.open;\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'accordion-collapse'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Collapse$1, _extends({}, attributes, {\n    className: classes,\n    ref: innerRef,\n    isOpen: Array.isArray(open) ? open.includes(accordionId) : open === accordionId\n  }), /*#__PURE__*/React__default[\"default\"].createElement(Tag, {\n    className: \"accordion-body\"\n  }, children));\n}\n\nAccordionBody.propTypes = propTypes$W;\nAccordionBody.defaultProps = defaultProps$V;\n\nvar _excluded$R = [\"className\", \"cssModule\", \"color\", \"innerRef\", \"pill\", \"tag\"];\nvar propTypes$V = {\n  /** Pass children so this component can wrap the child elements */\n  children: PropTypes__default[\"default\"].node,\n\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change background color of Badge */\n  color: PropTypes__default[\"default\"].string,\n\n  /** Change existing className with a new className */\n  cssModule: PropTypes__default[\"default\"].object,\n  innerRef: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].object, PropTypes__default[\"default\"].func, PropTypes__default[\"default\"].string]),\n\n  /** Add rounded corners to the Badge */\n  pill: PropTypes__default[\"default\"].bool,\n\n  /** Set a custom element for this component */\n  tag: tagPropType\n};\nvar defaultProps$U = {\n  color: 'secondary',\n  pill: false,\n  tag: 'span'\n};\n\nfunction Badge(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      color = props.color,\n      innerRef = props.innerRef,\n      pill = props.pill,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$R);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'badge', 'bg-' + color, pill ? 'rounded-pill' : false), cssModule);\n\n  if (attributes.href && Tag === 'span') {\n    Tag = 'a';\n  }\n\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes,\n    ref: innerRef\n  }));\n}\n\nBadge.propTypes = propTypes$V;\nBadge.defaultProps = defaultProps$U;\n\nvar _excluded$Q = [\"className\", \"cssModule\", \"color\", \"body\", \"inverse\", \"outline\", \"tag\", \"innerRef\"];\nvar propTypes$U = {\n  /** Toggles card padding using `.card-body` */\n  body: PropTypes__default[\"default\"].bool,\n\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change background color of component */\n  color: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n  innerRef: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].object, PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].func]),\n\n  /** Inverts the color */\n  inverse: PropTypes__default[\"default\"].bool,\n\n  /** Changes the card to have only outline */\n  outline: PropTypes__default[\"default\"].bool,\n\n  /** Set a custom element for this component */\n  tag: tagPropType\n};\nvar defaultProps$T = {\n  tag: 'div'\n};\n\nfunction Card(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      color = props.color,\n      body = props.body,\n      inverse = props.inverse,\n      outline = props.outline,\n      Tag = props.tag,\n      innerRef = props.innerRef,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$Q);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'card', inverse ? 'text-white' : false, body ? 'card-body' : false, color ? (outline ? 'border' : 'bg') + \"-\" + color : false), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes,\n    ref: innerRef\n  }));\n}\n\nCard.propTypes = propTypes$U;\nCard.defaultProps = defaultProps$T;\n\nvar _excluded$P = [\"className\", \"cssModule\", \"tag\"];\nvar propTypes$T = {\n  tag: tagPropType,\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object\n};\nvar defaultProps$S = {\n  tag: 'div'\n};\n\nfunction CardGroup(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$P);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'card-group'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nCardGroup.propTypes = propTypes$T;\nCardGroup.defaultProps = defaultProps$S;\n\nvar _excluded$O = [\"className\", \"cssModule\", \"tag\"];\nvar propTypes$S = {\n  tag: tagPropType,\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object\n};\nvar defaultProps$R = {\n  tag: 'div'\n};\n\nfunction CardDeck(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$O);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'card-deck'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nCardDeck.propTypes = propTypes$S;\nCardDeck.defaultProps = defaultProps$R;\n\nvar _excluded$N = [\"className\", \"cssModule\", \"tag\"];\nvar propTypes$R = {\n  tag: tagPropType,\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object\n};\nvar defaultProps$Q = {\n  tag: 'div'\n};\n\nfunction CardColumns(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$N);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'card-columns'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nCardColumns.propTypes = propTypes$R;\nCardColumns.defaultProps = defaultProps$Q;\n\nvar _excluded$M = [\"className\", \"cssModule\", \"innerRef\", \"tag\"];\nvar propTypes$Q = {\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n  innerRef: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].object, PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].func]),\n\n  /** Set a custom element for this component */\n  tag: tagPropType\n};\nvar defaultProps$P = {\n  tag: 'div'\n};\n\nfunction CardBody(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      innerRef = props.innerRef,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$M);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'card-body'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes,\n    ref: innerRef\n  }));\n}\n\nCardBody.propTypes = propTypes$Q;\nCardBody.defaultProps = defaultProps$P;\n\nvar _excluded$L = [\"className\", \"cssModule\", \"tag\", \"innerRef\"];\nvar propTypes$P = {\n  tag: tagPropType,\n  innerRef: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].object, PropTypes__default[\"default\"].func, PropTypes__default[\"default\"].string]),\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object\n};\nvar defaultProps$O = {\n  tag: 'a'\n};\n\nfunction CardLink(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      innerRef = props.innerRef,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$L);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'card-link'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    ref: innerRef,\n    className: classes\n  }));\n}\n\nCardLink.propTypes = propTypes$P;\nCardLink.defaultProps = defaultProps$O;\n\nvar _excluded$K = [\"className\", \"cssModule\", \"tag\"];\nvar propTypes$O = {\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Set a custom element for this component */\n  tag: tagPropType\n};\nvar defaultProps$N = {\n  tag: 'div'\n};\n\nfunction CardFooter(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$K);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'card-footer'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nCardFooter.propTypes = propTypes$O;\nCardFooter.defaultProps = defaultProps$N;\n\nvar _excluded$J = [\"className\", \"cssModule\", \"tag\"];\nvar propTypes$N = {\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Set a custom element for this component */\n  tag: tagPropType\n};\nvar defaultProps$M = {\n  tag: 'div'\n};\n\nfunction CardHeader(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$J);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'card-header'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nCardHeader.propTypes = propTypes$N;\nCardHeader.defaultProps = defaultProps$M;\n\nvar _excluded$I = [\"className\", \"cssModule\", \"top\", \"bottom\", \"tag\"];\nvar propTypes$M = {\n  /** Add `bottom` prop if image is at bottom of card */\n  bottom: PropTypes__default[\"default\"].bool,\n\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change existing className with a new className */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Set a custom element for this component */\n  tag: tagPropType,\n\n  /** Add `top` prop if image is at top of card */\n  top: PropTypes__default[\"default\"].bool\n};\nvar defaultProps$L = {\n  tag: 'img'\n};\n\nfunction CardImg(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      top = props.top,\n      bottom = props.bottom,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$I);\n\n  var cardImgClassName = 'card-img';\n\n  if (top) {\n    cardImgClassName = 'card-img-top';\n  }\n\n  if (bottom) {\n    cardImgClassName = 'card-img-bottom';\n  }\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, cardImgClassName), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nCardImg.propTypes = propTypes$M;\nCardImg.defaultProps = defaultProps$L;\n\nvar _excluded$H = [\"className\", \"cssModule\", \"tag\"];\nvar propTypes$L = {\n  tag: tagPropType,\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object\n};\nvar defaultProps$K = {\n  tag: 'div'\n};\n\nfunction CardImgOverlay(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$H);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'card-img-overlay'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nCardImgOverlay.propTypes = propTypes$L;\nCardImgOverlay.defaultProps = defaultProps$K;\n\n/**\n * CarouselContext\n * {\n *  direction: PropTypes.oneOf(['start', 'end']).isRequired,\n * }\n */\n\nvar CarouselContext = React__default[\"default\"].createContext({});\n\nvar _excluded$G = [\"in\", \"children\", \"cssModule\", \"slide\", \"tag\", \"className\"];\n\nvar CarouselItem = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(CarouselItem, _React$Component);\n\n  function CarouselItem(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    _this.state = {\n      startAnimation: false\n    };\n    _this.onEnter = _this.onEnter.bind(_assertThisInitialized(_this));\n    _this.onEntering = _this.onEntering.bind(_assertThisInitialized(_this));\n    _this.onExit = _this.onExit.bind(_assertThisInitialized(_this));\n    _this.onExiting = _this.onExiting.bind(_assertThisInitialized(_this));\n    _this.onExited = _this.onExited.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  var _proto = CarouselItem.prototype;\n\n  _proto.onEnter = function onEnter(node, isAppearing) {\n    this.setState({\n      startAnimation: false\n    });\n    this.props.onEnter(node, isAppearing);\n  };\n\n  _proto.onEntering = function onEntering(node, isAppearing) {\n    // getting this variable triggers a reflow\n    var offsetHeight = node.offsetHeight;\n    this.setState({\n      startAnimation: true\n    });\n    this.props.onEntering(node, isAppearing);\n    return offsetHeight;\n  };\n\n  _proto.onExit = function onExit(node) {\n    this.setState({\n      startAnimation: false\n    });\n    this.props.onExit(node);\n  };\n\n  _proto.onExiting = function onExiting(node) {\n    this.setState({\n      startAnimation: true\n    });\n    node.dispatchEvent(new CustomEvent('slide.bs.carousel'));\n    this.props.onExiting(node);\n  };\n\n  _proto.onExited = function onExited(node) {\n    node.dispatchEvent(new CustomEvent('slid.bs.carousel'));\n    this.props.onExited(node);\n  };\n\n  _proto.render = function render() {\n    var _this2 = this;\n\n    var _this$props = this.props,\n        isIn = _this$props[\"in\"],\n        children = _this$props.children,\n        cssModule = _this$props.cssModule,\n        slide = _this$props.slide,\n        Tag = _this$props.tag,\n        className = _this$props.className,\n        transitionProps = _objectWithoutPropertiesLoose(_this$props, _excluded$G);\n\n    return /*#__PURE__*/React__default[\"default\"].createElement(reactTransitionGroup.Transition, _extends({}, transitionProps, {\n      enter: slide,\n      exit: slide,\n      \"in\": isIn,\n      onEnter: this.onEnter,\n      onEntering: this.onEntering,\n      onExit: this.onExit,\n      onExiting: this.onExiting,\n      onExited: this.onExited\n    }), function (status) {\n      var direction = _this2.context.direction;\n      var isActive = status === TransitionStatuses.ENTERED || status === TransitionStatuses.EXITING;\n      var directionClassName = (status === TransitionStatuses.ENTERING || status === TransitionStatuses.EXITING) && _this2.state.startAnimation && (direction === 'end' ? 'carousel-item-start' : 'carousel-item-end');\n      var orderClassName = status === TransitionStatuses.ENTERING && (direction === 'end' ? 'carousel-item-next' : 'carousel-item-prev');\n      var itemClasses = mapToCssModules(classNames__default[\"default\"](className, 'carousel-item', isActive && 'active', directionClassName, orderClassName), cssModule);\n      return /*#__PURE__*/React__default[\"default\"].createElement(Tag, {\n        className: itemClasses\n      }, children);\n    });\n  };\n\n  return CarouselItem;\n}(React__default[\"default\"].Component);\n\nCarouselItem.propTypes = _objectSpread2(_objectSpread2({}, reactTransitionGroup.Transition.propTypes), {}, {\n  /** Set a custom element for this component */\n  tag: tagPropType,\n  \"in\": PropTypes__default[\"default\"].bool,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n  children: PropTypes__default[\"default\"].node,\n\n  /** Enable/disable animation */\n  slide: PropTypes__default[\"default\"].bool,\n\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string\n});\nCarouselItem.defaultProps = _objectSpread2(_objectSpread2({}, reactTransitionGroup.Transition.defaultProps), {}, {\n  tag: 'div',\n  timeout: TransitionTimeouts.Carousel,\n  slide: true\n});\nCarouselItem.contextType = CarouselContext;\nvar CarouselItem$1 = CarouselItem;\n\nvar SWIPE_THRESHOLD = 40;\nvar propTypes$K = {\n  /** the current active slide of the carousel */\n  activeIndex: PropTypes__default[\"default\"].number,\n\n  /** a function which should advance the carousel to the next slide (via activeIndex) */\n  next: PropTypes__default[\"default\"].func.isRequired,\n\n  /** a function which should advance the carousel to the previous slide (via activeIndex) */\n  previous: PropTypes__default[\"default\"].func.isRequired,\n\n  /** controls if the left and right arrow keys should control the carousel */\n  keyboard: PropTypes__default[\"default\"].bool,\n\n  /** If set to \"hover\", pauses the cycling of the carousel on mouseenter and resumes the cycling of the carousel on\n   * mouseleave. If set to false, hovering over the carousel won't pause it.\n   */\n  pause: PropTypes__default[\"default\"].oneOf(['hover', false]),\n\n  /** Autoplays the carousel after the user manually cycles the first item. If \"carousel\", autoplays the carousel on load. */\n  ride: PropTypes__default[\"default\"].oneOf(['carousel']),\n\n  /** the interval at which the carousel automatically cycles */\n  interval: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].number, PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].bool]),\n  children: PropTypes__default[\"default\"].array,\n\n  /** called when the mouse enters the Carousel */\n  mouseEnter: PropTypes__default[\"default\"].func,\n\n  /** called when the mouse exits the Carousel */\n  mouseLeave: PropTypes__default[\"default\"].func,\n\n  /** controls whether the slide animation on the Carousel works or not */\n  slide: PropTypes__default[\"default\"].bool,\n\n  /** make the controls, indicators and captions dark on the Carousel */\n  dark: PropTypes__default[\"default\"].bool,\n  fade: PropTypes__default[\"default\"].bool,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Enable touch support */\n  enableTouch: PropTypes__default[\"default\"].bool\n};\nvar propsToOmit$2 = Object.keys(propTypes$K);\nvar defaultProps$J = {\n  interval: 5000,\n  pause: 'hover',\n  keyboard: true,\n  slide: true,\n  enableTouch: true,\n  fade: false\n};\n\nvar Carousel = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Carousel, _React$Component);\n\n  function Carousel(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    _this.handleKeyPress = _this.handleKeyPress.bind(_assertThisInitialized(_this));\n    _this.renderItems = _this.renderItems.bind(_assertThisInitialized(_this));\n    _this.hoverStart = _this.hoverStart.bind(_assertThisInitialized(_this));\n    _this.hoverEnd = _this.hoverEnd.bind(_assertThisInitialized(_this));\n    _this.handleTouchStart = _this.handleTouchStart.bind(_assertThisInitialized(_this));\n    _this.handleTouchEnd = _this.handleTouchEnd.bind(_assertThisInitialized(_this));\n    _this.touchStartX = 0;\n    _this.touchStartY = 0;\n    _this.state = {\n      activeIndex: _this.props.activeIndex,\n      direction: 'end',\n      indicatorClicked: false\n    };\n    return _this;\n  }\n\n  var _proto = Carousel.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    // Set up the cycle\n    if (this.props.ride === 'carousel') {\n      this.setInterval();\n    } // TODO: move this to the specific carousel like bootstrap. Currently it will trigger ALL carousels on the page.\n\n\n    document.addEventListener('keyup', this.handleKeyPress);\n  };\n\n  Carousel.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n    var newState = null;\n    var activeIndex = prevState.activeIndex,\n        direction = prevState.direction,\n        indicatorClicked = prevState.indicatorClicked;\n\n    if (nextProps.activeIndex !== activeIndex) {\n      // Calculate the direction to turn\n      if (nextProps.activeIndex === activeIndex + 1) {\n        direction = 'end';\n      } else if (nextProps.activeIndex === activeIndex - 1) {\n        direction = 'start';\n      } else if (nextProps.activeIndex < activeIndex) {\n        direction = indicatorClicked ? 'start' : 'end';\n      } else if (nextProps.activeIndex !== activeIndex) {\n        direction = indicatorClicked ? 'end' : 'start';\n      }\n\n      newState = {\n        activeIndex: nextProps.activeIndex,\n        direction: direction,\n        indicatorClicked: false\n      };\n    }\n\n    return newState;\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    if (prevState.activeIndex === this.state.activeIndex) return;\n    this.setInterval();\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.clearInterval();\n    document.removeEventListener('keyup', this.handleKeyPress);\n  };\n\n  _proto.handleKeyPress = function handleKeyPress(evt) {\n    if (this.props.keyboard) {\n      if (evt.keyCode === 37) {\n        this.props.previous();\n      } else if (evt.keyCode === 39) {\n        this.props.next();\n      }\n    }\n  };\n\n  _proto.handleTouchStart = function handleTouchStart(e) {\n    if (!this.props.enableTouch) {\n      return;\n    }\n\n    this.touchStartX = e.changedTouches[0].screenX;\n    this.touchStartY = e.changedTouches[0].screenY;\n  };\n\n  _proto.handleTouchEnd = function handleTouchEnd(e) {\n    if (!this.props.enableTouch) {\n      return;\n    }\n\n    var currentX = e.changedTouches[0].screenX;\n    var currentY = e.changedTouches[0].screenY;\n    var diffX = Math.abs(this.touchStartX - currentX);\n    var diffY = Math.abs(this.touchStartY - currentY); // Don't swipe if Y-movement is bigger than X-movement\n\n    if (diffX < diffY) {\n      return;\n    }\n\n    if (diffX < SWIPE_THRESHOLD) {\n      return;\n    }\n\n    if (currentX < this.touchStartX) {\n      this.props.next();\n    } else {\n      this.props.previous();\n    }\n  };\n\n  _proto.getContextValue = function getContextValue() {\n    return {\n      direction: this.state.direction\n    };\n  };\n\n  _proto.setInterval = function (_setInterval) {\n    function setInterval() {\n      return _setInterval.apply(this, arguments);\n    }\n\n    setInterval.toString = function () {\n      return _setInterval.toString();\n    };\n\n    return setInterval;\n  }(function () {\n    var _this2 = this;\n\n    // make sure not to have multiple intervals going...\n    this.clearInterval();\n\n    if (this.props.interval) {\n      this.cycleInterval = setInterval(function () {\n        _this2.props.next();\n      }, parseInt(this.props.interval, 10));\n    }\n  });\n\n  _proto.clearInterval = function (_clearInterval) {\n    function clearInterval() {\n      return _clearInterval.apply(this, arguments);\n    }\n\n    clearInterval.toString = function () {\n      return _clearInterval.toString();\n    };\n\n    return clearInterval;\n  }(function () {\n    clearInterval(this.cycleInterval);\n  });\n\n  _proto.hoverStart = function hoverStart() {\n    if (this.props.pause === 'hover') {\n      this.clearInterval();\n    }\n\n    if (this.props.mouseEnter) {\n      var _this$props;\n\n      (_this$props = this.props).mouseEnter.apply(_this$props, [].slice.call(arguments));\n    }\n  };\n\n  _proto.hoverEnd = function hoverEnd() {\n    if (this.props.pause === 'hover') {\n      this.setInterval();\n    }\n\n    if (this.props.mouseLeave) {\n      var _this$props2;\n\n      (_this$props2 = this.props).mouseLeave.apply(_this$props2, [].slice.call(arguments));\n    }\n  };\n\n  _proto.renderItems = function renderItems(carouselItems, className) {\n    var _this3 = this;\n\n    var slide = this.props.slide;\n    return /*#__PURE__*/React__default[\"default\"].createElement(\"div\", {\n      className: className\n    }, carouselItems.map(function (item, index) {\n      var isIn = index === _this3.state.activeIndex;\n      return React__default[\"default\"].cloneElement(item, {\n        \"in\": isIn,\n        slide: slide\n      });\n    }));\n  };\n\n  _proto.render = function render() {\n    var _this4 = this;\n\n    var _this$props3 = this.props,\n        cssModule = _this$props3.cssModule,\n        slide = _this$props3.slide,\n        className = _this$props3.className,\n        dark = _this$props3.dark,\n        fade = _this$props3.fade;\n    var attributes = omit(this.props, propsToOmit$2);\n    var outerClasses = mapToCssModules(classNames__default[\"default\"](className, 'carousel', fade && 'carousel-fade', slide && 'slide', dark && 'carousel-dark'), cssModule);\n    var innerClasses = mapToCssModules(classNames__default[\"default\"]('carousel-inner'), cssModule); // filter out booleans, null, or undefined\n\n    var children = this.props.children.filter(function (child) {\n      return child !== null && child !== undefined && typeof child !== 'boolean';\n    });\n    var slidesOnly = children.every(function (child) {\n      return child.type === CarouselItem$1;\n    }); // Rendering only slides\n\n    if (slidesOnly) {\n      return /*#__PURE__*/React__default[\"default\"].createElement(\"div\", _extends({}, attributes, {\n        className: outerClasses,\n        onMouseEnter: this.hoverStart,\n        onMouseLeave: this.hoverEnd\n      }), /*#__PURE__*/React__default[\"default\"].createElement(CarouselContext.Provider, {\n        value: this.getContextValue()\n      }, this.renderItems(children, innerClasses)));\n    } // Rendering slides and controls\n\n\n    if (children[0] instanceof Array) {\n      var _carouselItems = children[0];\n      var _controlLeft = children[1];\n      var _controlRight = children[2];\n      return /*#__PURE__*/React__default[\"default\"].createElement(\"div\", _extends({}, attributes, {\n        className: outerClasses,\n        onMouseEnter: this.hoverStart,\n        onMouseLeave: this.hoverEnd\n      }), /*#__PURE__*/React__default[\"default\"].createElement(CarouselContext.Provider, {\n        value: this.getContextValue()\n      }, this.renderItems(_carouselItems, innerClasses), _controlLeft, _controlRight));\n    } // Rendering indicators, slides and controls\n\n\n    var indicators = children[0];\n\n    var wrappedOnClick = function wrappedOnClick(e) {\n      if (typeof indicators.props.onClickHandler === 'function') {\n        _this4.setState({\n          indicatorClicked: true\n        }, function () {\n          return indicators.props.onClickHandler(e);\n        });\n      }\n    };\n\n    var wrappedIndicators = React__default[\"default\"].cloneElement(indicators, {\n      onClickHandler: wrappedOnClick\n    });\n    var carouselItems = children[1];\n    var controlLeft = children[2];\n    var controlRight = children[3];\n    return /*#__PURE__*/React__default[\"default\"].createElement(\"div\", _extends({}, attributes, {\n      className: outerClasses,\n      onMouseEnter: this.hoverStart,\n      onMouseLeave: this.hoverEnd,\n      onTouchStart: this.handleTouchStart,\n      onTouchEnd: this.handleTouchEnd\n    }), /*#__PURE__*/React__default[\"default\"].createElement(CarouselContext.Provider, {\n      value: this.getContextValue()\n    }, wrappedIndicators, this.renderItems(carouselItems, innerClasses), controlLeft, controlRight));\n  };\n\n  return Carousel;\n}(React__default[\"default\"].Component);\n\nCarousel.propTypes = propTypes$K;\nCarousel.defaultProps = defaultProps$J;\nvar Carousel$1 = Carousel;\n\nvar _excluded$F = [\"direction\", \"onClickHandler\", \"cssModule\", \"directionText\", \"className\"];\n\nfunction CarouselControl(props) {\n  var direction = props.direction,\n      onClickHandler = props.onClickHandler,\n      cssModule = props.cssModule,\n      directionText = props.directionText,\n      className = props.className,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$F);\n\n  var anchorClasses = mapToCssModules(classNames__default[\"default\"](className, \"carousel-control-\" + direction), cssModule);\n  var iconClasses = mapToCssModules(classNames__default[\"default\"](\"carousel-control-\" + direction + \"-icon\"), cssModule);\n  var screenReaderClasses = mapToCssModules(classNames__default[\"default\"]('visually-hidden'), cssModule);\n  return (\n    /*#__PURE__*/\n    // We need to disable this linting rule to use an `<a>` instead of\n    // `<button>` because that's what the Bootstrap examples require:\n    // https://getbootstrap.com/docs/4.5/components/carousel/#with-controls\n    // eslint-disable-next-line jsx-a11y/anchor-is-valid\n    React__default[\"default\"].createElement(\"a\", _extends({}, attributes, {\n      className: anchorClasses,\n      style: {\n        cursor: 'pointer'\n      },\n      role: \"button\",\n      tabIndex: \"0\",\n      onClick: function onClick(e) {\n        e.preventDefault();\n        onClickHandler();\n      }\n    }), /*#__PURE__*/React__default[\"default\"].createElement(\"span\", {\n      className: iconClasses,\n      \"aria-hidden\": \"true\"\n    }), /*#__PURE__*/React__default[\"default\"].createElement(\"span\", {\n      className: screenReaderClasses\n    }, directionText || direction))\n  );\n}\n\nCarouselControl.propTypes = {\n  /** Set the direction of control button */\n  direction: PropTypes__default[\"default\"].oneOf(['prev', 'next']).isRequired,\n\n  /** Function to be triggered on click */\n  onClickHandler: PropTypes__default[\"default\"].func.isRequired,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Screen reader text */\n  directionText: PropTypes__default[\"default\"].string,\n\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string\n};\n\nvar _excluded$E = [\"items\", \"activeIndex\", \"cssModule\", \"onClickHandler\", \"className\"];\n\nfunction CarouselIndicators(props) {\n  var items = props.items,\n      activeIndex = props.activeIndex,\n      cssModule = props.cssModule,\n      onClickHandler = props.onClickHandler,\n      className = props.className,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$E);\n\n  var listClasses = mapToCssModules(classNames__default[\"default\"](className, 'carousel-indicators'), cssModule);\n  var indicators = items.map(function (item, idx) {\n    var indicatorClasses = mapToCssModules(classNames__default[\"default\"]({\n      active: activeIndex === idx\n    }), cssModule);\n    return /*#__PURE__*/React__default[\"default\"].createElement(\"button\", {\n      \"aria-label\": item.caption,\n      \"data-bs-target\": true,\n      type: \"button\",\n      key: \"\" + (item.key || Object.values(item).join('')),\n      onClick: function onClick(e) {\n        e.preventDefault();\n        onClickHandler(idx);\n      },\n      className: indicatorClasses\n    });\n  });\n  return /*#__PURE__*/React__default[\"default\"].createElement(\"div\", _extends({\n    className: listClasses\n  }, attributes), indicators);\n}\n\nCarouselIndicators.propTypes = {\n  /** The current active index */\n  activeIndex: PropTypes__default[\"default\"].number.isRequired,\n\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Array of items to show */\n  items: PropTypes__default[\"default\"].array.isRequired,\n\n  /** Function to be triggered on click */\n  onClickHandler: PropTypes__default[\"default\"].func.isRequired\n};\n\nfunction CarouselCaption(props) {\n  var captionHeader = props.captionHeader,\n      captionText = props.captionText,\n      cssModule = props.cssModule,\n      className = props.className;\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'carousel-caption', 'd-none', 'd-md-block'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(\"div\", {\n    className: classes\n  }, /*#__PURE__*/React__default[\"default\"].createElement(\"h3\", null, captionHeader), /*#__PURE__*/React__default[\"default\"].createElement(\"p\", null, captionText));\n}\n\nCarouselCaption.propTypes = {\n  /** Heading for the caption */\n  captionHeader: PropTypes__default[\"default\"].node,\n\n  /** Text for caption */\n  captionText: PropTypes__default[\"default\"].node.isRequired,\n\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object\n};\n\nvar _excluded$D = [\"defaultActiveIndex\", \"autoPlay\", \"indicators\", \"controls\", \"items\", \"goToIndex\"];\nvar propTypes$J = {\n  items: PropTypes__default[\"default\"].array.isRequired,\n  indicators: PropTypes__default[\"default\"].bool,\n  controls: PropTypes__default[\"default\"].bool,\n  autoPlay: PropTypes__default[\"default\"].bool,\n  defaultActiveIndex: PropTypes__default[\"default\"].number,\n  activeIndex: PropTypes__default[\"default\"].number,\n  next: PropTypes__default[\"default\"].func,\n  previous: PropTypes__default[\"default\"].func,\n  goToIndex: PropTypes__default[\"default\"].func\n};\n\nvar UncontrolledCarousel = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(UncontrolledCarousel, _Component);\n\n  function UncontrolledCarousel(props) {\n    var _this;\n\n    _this = _Component.call(this, props) || this;\n    _this.animating = false;\n    _this.state = {\n      activeIndex: props.defaultActiveIndex || 0\n    };\n    _this.next = _this.next.bind(_assertThisInitialized(_this));\n    _this.previous = _this.previous.bind(_assertThisInitialized(_this));\n    _this.goToIndex = _this.goToIndex.bind(_assertThisInitialized(_this));\n    _this.onExiting = _this.onExiting.bind(_assertThisInitialized(_this));\n    _this.onExited = _this.onExited.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  var _proto = UncontrolledCarousel.prototype;\n\n  _proto.onExiting = function onExiting() {\n    this.animating = true;\n  };\n\n  _proto.onExited = function onExited() {\n    this.animating = false;\n  };\n\n  _proto.next = function next() {\n    var _this2 = this;\n\n    if (this.animating) return;\n    this.setState(function (prevState) {\n      var nextIndex = prevState.activeIndex === _this2.props.items.length - 1 ? 0 : prevState.activeIndex + 1;\n      return {\n        activeIndex: nextIndex\n      };\n    });\n  };\n\n  _proto.previous = function previous() {\n    var _this3 = this;\n\n    if (this.animating) return;\n    this.setState(function (prevState) {\n      var nextIndex = prevState.activeIndex === 0 ? _this3.props.items.length - 1 : prevState.activeIndex - 1;\n      return {\n        activeIndex: nextIndex\n      };\n    });\n  };\n\n  _proto.goToIndex = function goToIndex(newIndex) {\n    if (this.animating) return;\n    this.setState({\n      activeIndex: newIndex\n    });\n  };\n\n  _proto.render = function render() {\n    var _this4 = this;\n\n    var _this$props = this.props,\n        autoPlay = _this$props.autoPlay,\n        indicators = _this$props.indicators,\n        controls = _this$props.controls,\n        items = _this$props.items,\n        goToIndex = _this$props.goToIndex,\n        props = _objectWithoutPropertiesLoose(_this$props, _excluded$D);\n\n    var activeIndex = this.state.activeIndex;\n    var slides = items.map(function (item) {\n      var key = item.key || item.src;\n      return /*#__PURE__*/React__default[\"default\"].createElement(CarouselItem$1, {\n        onExiting: _this4.onExiting,\n        onExited: _this4.onExited,\n        key: key\n      }, /*#__PURE__*/React__default[\"default\"].createElement(\"img\", {\n        className: \"d-block w-100\",\n        src: item.src,\n        alt: item.altText\n      }), /*#__PURE__*/React__default[\"default\"].createElement(CarouselCaption, {\n        captionText: item.caption,\n        captionHeader: item.header || item.caption\n      }));\n    });\n    return /*#__PURE__*/React__default[\"default\"].createElement(Carousel$1, _extends({\n      activeIndex: activeIndex,\n      next: this.next,\n      previous: this.previous,\n      ride: autoPlay ? 'carousel' : undefined\n    }, props), indicators && /*#__PURE__*/React__default[\"default\"].createElement(CarouselIndicators, {\n      items: items,\n      activeIndex: props.activeIndex || activeIndex,\n      onClickHandler: goToIndex || this.goToIndex\n    }), slides, controls && /*#__PURE__*/React__default[\"default\"].createElement(CarouselControl, {\n      direction: \"prev\",\n      directionText: \"Previous\",\n      onClickHandler: props.previous || this.previous\n    }), controls && /*#__PURE__*/React__default[\"default\"].createElement(CarouselControl, {\n      direction: \"next\",\n      directionText: \"Next\",\n      onClickHandler: props.next || this.next\n    }));\n  };\n\n  return UncontrolledCarousel;\n}(React.Component);\n\nUncontrolledCarousel.propTypes = propTypes$J;\nUncontrolledCarousel.defaultProps = {\n  controls: true,\n  indicators: true,\n  autoPlay: true\n};\nvar UncontrolledCarousel$1 = UncontrolledCarousel;\n\nvar _excluded$C = [\"className\", \"cssModule\", \"tag\"];\nvar propTypes$I = {\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Set a custom element for this component */\n  tag: tagPropType\n};\nvar defaultProps$I = {\n  tag: 'div'\n};\n\nfunction CardSubtitle(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$C);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'card-subtitle'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nCardSubtitle.propTypes = propTypes$I;\nCardSubtitle.defaultProps = defaultProps$I;\n\nvar _excluded$B = [\"className\", \"cssModule\", \"tag\"];\nvar propTypes$H = {\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Set a custom element for this component */\n  tag: tagPropType\n};\nvar defaultProps$H = {\n  tag: 'p'\n};\n\nfunction CardText(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$B);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'card-text'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nCardText.propTypes = propTypes$H;\nCardText.defaultProps = defaultProps$H;\n\nvar _excluded$A = [\"className\", \"cssModule\", \"tag\"];\nvar propTypes$G = {\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Set a custom element for this component */\n  tag: tagPropType\n};\nvar defaultProps$G = {\n  tag: 'div'\n};\n\nfunction CardTitle(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$A);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'card-title'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nCardTitle.propTypes = propTypes$G;\nCardTitle.defaultProps = defaultProps$G;\n\nvar _excluded$z = [\"cssModule\", \"children\", \"isOpen\", \"flip\", \"target\", \"offset\", \"fallbackPlacements\", \"placementPrefix\", \"arrowClassName\", \"hideArrow\", \"popperClassName\", \"tag\", \"container\", \"modifiers\", \"strategy\", \"boundariesElement\", \"onClosed\", \"fade\", \"transition\", \"placement\"];\n\nfunction noop$2() {}\n\nvar propTypes$F = {\n  children: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].node, PropTypes__default[\"default\"].func]).isRequired,\n  popperClassName: PropTypes__default[\"default\"].string,\n  placement: PropTypes__default[\"default\"].string,\n  placementPrefix: PropTypes__default[\"default\"].string,\n  arrowClassName: PropTypes__default[\"default\"].string,\n  hideArrow: PropTypes__default[\"default\"].bool,\n  tag: tagPropType,\n  isOpen: PropTypes__default[\"default\"].bool,\n  cssModule: PropTypes__default[\"default\"].object,\n  offset: PropTypes__default[\"default\"].arrayOf(PropTypes__default[\"default\"].number),\n  fallbackPlacements: PropTypes__default[\"default\"].array,\n  flip: PropTypes__default[\"default\"].bool,\n  container: targetPropType,\n  target: targetPropType.isRequired,\n  modifiers: PropTypes__default[\"default\"].array,\n  strategy: PropTypes__default[\"default\"].string,\n  boundariesElement: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].string, DOMElement]),\n  onClosed: PropTypes__default[\"default\"].func,\n  fade: PropTypes__default[\"default\"].bool,\n  transition: PropTypes__default[\"default\"].shape(Fade.propTypes)\n};\nvar defaultProps$F = {\n  boundariesElement: 'scrollParent',\n  placement: 'auto',\n  hideArrow: false,\n  isOpen: false,\n  offset: [0, 0],\n  flip: true,\n  container: 'body',\n  modifiers: [],\n  onClosed: noop$2,\n  fade: true,\n  transition: _objectSpread2({}, Fade.defaultProps)\n};\n\nvar PopperContent = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(PopperContent, _React$Component);\n\n  function PopperContent(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    _this.setTargetNode = _this.setTargetNode.bind(_assertThisInitialized(_this));\n    _this.getTargetNode = _this.getTargetNode.bind(_assertThisInitialized(_this));\n    _this.getRef = _this.getRef.bind(_assertThisInitialized(_this));\n    _this.onClosed = _this.onClosed.bind(_assertThisInitialized(_this));\n    _this.state = {\n      isOpen: props.isOpen\n    };\n    return _this;\n  }\n\n  PopperContent.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {\n    if (props.isOpen && !state.isOpen) {\n      return {\n        isOpen: props.isOpen\n      };\n    }\n\n    return null;\n  };\n\n  var _proto = PopperContent.prototype;\n\n  _proto.componentDidUpdate = function componentDidUpdate() {\n    if (this._element && this._element.childNodes && this._element.childNodes[0] && this._element.childNodes[0].focus) {\n      this._element.childNodes[0].focus();\n    }\n  };\n\n  _proto.onClosed = function onClosed() {\n    this.props.onClosed();\n    this.setState({\n      isOpen: false\n    });\n  };\n\n  _proto.getTargetNode = function getTargetNode() {\n    return this.targetNode;\n  };\n\n  _proto.getContainerNode = function getContainerNode() {\n    return getTarget(this.props.container);\n  };\n\n  _proto.getRef = function getRef(ref) {\n    this._element = ref;\n  };\n\n  _proto.setTargetNode = function setTargetNode(node) {\n    this.targetNode = typeof node === 'string' ? getTarget(node) : node;\n  };\n\n  _proto.renderChildren = function renderChildren() {\n    var _this$props = this.props,\n        cssModule = _this$props.cssModule,\n        children = _this$props.children,\n        isOpen = _this$props.isOpen,\n        flip = _this$props.flip,\n        offset = _this$props.offset,\n        fallbackPlacements = _this$props.fallbackPlacements,\n        placementPrefix = _this$props.placementPrefix,\n        _arrowClassName = _this$props.arrowClassName,\n        hideArrow = _this$props.hideArrow,\n        _popperClassName = _this$props.popperClassName,\n        tag = _this$props.tag,\n        modifiers = _this$props.modifiers,\n        strategy = _this$props.strategy,\n        boundariesElement = _this$props.boundariesElement,\n        fade = _this$props.fade,\n        transition = _this$props.transition,\n        placement = _this$props.placement,\n        attrs = _objectWithoutPropertiesLoose(_this$props, _excluded$z);\n\n    var arrowClassName = mapToCssModules(classNames__default[\"default\"]('arrow', _arrowClassName), cssModule);\n    var popperClassName = mapToCssModules(classNames__default[\"default\"](_popperClassName, placementPrefix ? placementPrefix + \"-auto\" : ''), this.props.cssModule);\n    var modifierNames = modifiers.map(function (m) {\n      return m.name;\n    });\n    var baseModifiers = [{\n      name: 'offset',\n      options: {\n        offset: offset\n      }\n    }, {\n      name: 'flip',\n      enabled: flip,\n      options: {\n        fallbackPlacements: fallbackPlacements\n      }\n    }, {\n      name: 'preventOverflow',\n      options: {\n        boundary: boundariesElement\n      }\n    }].filter(function (m) {\n      return !modifierNames.includes(m.name);\n    });\n    var extendedModifiers = [].concat(baseModifiers, modifiers);\n\n    var popperTransition = _objectSpread2(_objectSpread2(_objectSpread2({}, Fade.defaultProps), transition), {}, {\n      baseClass: fade ? transition.baseClass : '',\n      timeout: fade ? transition.timeout : 0\n    });\n\n    return /*#__PURE__*/React__default[\"default\"].createElement(Fade, _extends({}, popperTransition, attrs, {\n      \"in\": isOpen,\n      onExited: this.onClosed,\n      tag: tag\n    }), /*#__PURE__*/React__default[\"default\"].createElement(reactPopper.Popper, {\n      referenceElement: this.targetNode,\n      modifiers: extendedModifiers,\n      placement: placement,\n      strategy: strategy\n    }, function (_ref) {\n      var ref = _ref.ref,\n          style = _ref.style,\n          popperPlacement = _ref.placement,\n          isReferenceHidden = _ref.isReferenceHidden,\n          arrowProps = _ref.arrowProps,\n          update = _ref.update;\n      return /*#__PURE__*/React__default[\"default\"].createElement(\"div\", {\n        ref: ref,\n        style: style,\n        className: popperClassName,\n        \"data-popper-placement\": popperPlacement,\n        \"data-popper-reference-hidden\": isReferenceHidden ? 'true' : undefined\n      }, typeof children === 'function' ? children({\n        update: update\n      }) : children, !hideArrow && /*#__PURE__*/React__default[\"default\"].createElement(\"span\", {\n        ref: arrowProps.ref,\n        className: arrowClassName,\n        style: arrowProps.style\n      }));\n    }));\n  };\n\n  _proto.render = function render() {\n    this.setTargetNode(this.props.target);\n\n    if (this.state.isOpen) {\n      return this.props.container === 'inline' ? this.renderChildren() : ReactDOM__default[\"default\"].createPortal( /*#__PURE__*/React__default[\"default\"].createElement(\"div\", {\n        ref: this.getRef\n      }, this.renderChildren()), this.getContainerNode());\n    }\n\n    return null;\n  };\n\n  return PopperContent;\n}(React__default[\"default\"].Component);\n\nPopperContent.propTypes = propTypes$F;\nPopperContent.defaultProps = defaultProps$F;\nvar PopperContent$1 = PopperContent;\n\nfunction PopperTargetHelper(props, context) {\n  context.popperManager.setTargetNode(getTarget(props.target));\n  return null;\n}\n\nPopperTargetHelper.contextTypes = {\n  popperManager: PropTypes__default[\"default\"].object.isRequired\n};\nPopperTargetHelper.propTypes = {\n  target: targetPropType.isRequired\n};\n\nvar propTypes$E = {\n  children: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].node, PropTypes__default[\"default\"].func]),\n  placement: PropTypes__default[\"default\"].oneOf(PopperPlacements),\n  target: targetPropType.isRequired,\n  container: targetPropType,\n  isOpen: PropTypes__default[\"default\"].bool,\n  disabled: PropTypes__default[\"default\"].bool,\n  hideArrow: PropTypes__default[\"default\"].bool,\n  boundariesElement: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].string, DOMElement]),\n  className: PropTypes__default[\"default\"].string,\n  innerClassName: PropTypes__default[\"default\"].string,\n  arrowClassName: PropTypes__default[\"default\"].string,\n  popperClassName: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object,\n  toggle: PropTypes__default[\"default\"].func,\n  autohide: PropTypes__default[\"default\"].bool,\n  placementPrefix: PropTypes__default[\"default\"].string,\n  delay: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].shape({\n    show: PropTypes__default[\"default\"].number,\n    hide: PropTypes__default[\"default\"].number\n  }), PropTypes__default[\"default\"].number]),\n  modifiers: PropTypes__default[\"default\"].array,\n  strategy: PropTypes__default[\"default\"].string,\n  offset: PropTypes__default[\"default\"].arrayOf(PropTypes__default[\"default\"].number),\n  innerRef: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].func, PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].object]),\n  trigger: PropTypes__default[\"default\"].string,\n  fade: PropTypes__default[\"default\"].bool,\n  flip: PropTypes__default[\"default\"].bool\n};\nvar DEFAULT_DELAYS = {\n  show: 0,\n  hide: 50\n};\nvar defaultProps$E = {\n  isOpen: false,\n  hideArrow: false,\n  autohide: false,\n  delay: DEFAULT_DELAYS,\n  toggle: function toggle() {},\n  trigger: 'click',\n  fade: true\n};\n\nfunction isInDOMSubtree(element, subtreeRoot) {\n  return subtreeRoot && (element === subtreeRoot || subtreeRoot.contains(element));\n}\n\nfunction isInDOMSubtrees(element, subtreeRoots) {\n  if (subtreeRoots === void 0) {\n    subtreeRoots = [];\n  }\n\n  return subtreeRoots && subtreeRoots.length && subtreeRoots.filter(function (subTreeRoot) {\n    return isInDOMSubtree(element, subTreeRoot);\n  })[0];\n}\n\nvar TooltipPopoverWrapper = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(TooltipPopoverWrapper, _React$Component);\n\n  function TooltipPopoverWrapper(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    _this._targets = [];\n    _this.currentTargetElement = null;\n    _this.addTargetEvents = _this.addTargetEvents.bind(_assertThisInitialized(_this));\n    _this.handleDocumentClick = _this.handleDocumentClick.bind(_assertThisInitialized(_this));\n    _this.removeTargetEvents = _this.removeTargetEvents.bind(_assertThisInitialized(_this));\n    _this.toggle = _this.toggle.bind(_assertThisInitialized(_this));\n    _this.showWithDelay = _this.showWithDelay.bind(_assertThisInitialized(_this));\n    _this.hideWithDelay = _this.hideWithDelay.bind(_assertThisInitialized(_this));\n    _this.onMouseOverTooltipContent = _this.onMouseOverTooltipContent.bind(_assertThisInitialized(_this));\n    _this.onMouseLeaveTooltipContent = _this.onMouseLeaveTooltipContent.bind(_assertThisInitialized(_this));\n    _this.show = _this.show.bind(_assertThisInitialized(_this));\n    _this.hide = _this.hide.bind(_assertThisInitialized(_this));\n    _this.onEscKeyDown = _this.onEscKeyDown.bind(_assertThisInitialized(_this));\n    _this.getRef = _this.getRef.bind(_assertThisInitialized(_this));\n    _this.state = {\n      isOpen: props.isOpen\n    };\n    _this._isMounted = false;\n    return _this;\n  }\n\n  var _proto = TooltipPopoverWrapper.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this._isMounted = true;\n    this.updateTarget();\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this._isMounted = false;\n    this.removeTargetEvents();\n    this._targets = null;\n    this.clearShowTimeout();\n    this.clearHideTimeout();\n  };\n\n  TooltipPopoverWrapper.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {\n    if (props.isOpen && !state.isOpen) {\n      return {\n        isOpen: props.isOpen\n      };\n    }\n\n    return null;\n  };\n\n  _proto.handleDocumentClick = function handleDocumentClick(e) {\n    var triggers = this.props.trigger.split(' ');\n\n    if (triggers.indexOf('legacy') > -1 && (this.props.isOpen || isInDOMSubtrees(e.target, this._targets))) {\n      if (this._hideTimeout) {\n        this.clearHideTimeout();\n      }\n\n      if (this.props.isOpen && !isInDOMSubtree(e.target, this._popover)) {\n        this.hideWithDelay(e);\n      } else if (!this.props.isOpen) {\n        this.showWithDelay(e);\n      }\n    } else if (triggers.indexOf('click') > -1 && isInDOMSubtrees(e.target, this._targets)) {\n      if (this._hideTimeout) {\n        this.clearHideTimeout();\n      }\n\n      if (!this.props.isOpen) {\n        this.showWithDelay(e);\n      } else {\n        this.hideWithDelay(e);\n      }\n    }\n  };\n\n  _proto.onMouseOverTooltipContent = function onMouseOverTooltipContent() {\n    if (this.props.trigger.indexOf('hover') > -1 && !this.props.autohide) {\n      if (this._hideTimeout) {\n        this.clearHideTimeout();\n      }\n\n      if (this.state.isOpen && !this.props.isOpen) {\n        this.toggle();\n      }\n    }\n  };\n\n  _proto.onMouseLeaveTooltipContent = function onMouseLeaveTooltipContent(e) {\n    if (this.props.trigger.indexOf('hover') > -1 && !this.props.autohide) {\n      if (this._showTimeout) {\n        this.clearShowTimeout();\n      }\n\n      e.persist();\n      this._hideTimeout = setTimeout(this.hide.bind(this, e), this.getDelay('hide'));\n    }\n  };\n\n  _proto.onEscKeyDown = function onEscKeyDown(e) {\n    if (e.key === 'Escape') {\n      this.hide(e);\n    }\n  };\n\n  _proto.getRef = function getRef(ref) {\n    var innerRef = this.props.innerRef;\n\n    if (innerRef) {\n      if (typeof innerRef === 'function') {\n        innerRef(ref);\n      } else if (typeof innerRef === 'object') {\n        innerRef.current = ref;\n      }\n    }\n\n    this._popover = ref;\n  };\n\n  _proto.getDelay = function getDelay(key) {\n    var delay = this.props.delay;\n\n    if (typeof delay === 'object') {\n      return isNaN(delay[key]) ? DEFAULT_DELAYS[key] : delay[key];\n    }\n\n    return delay;\n  };\n\n  _proto.getCurrentTarget = function getCurrentTarget(target) {\n    if (!target) return null;\n\n    var index = this._targets.indexOf(target);\n\n    if (index >= 0) return this._targets[index];\n    return this.getCurrentTarget(target.parentElement);\n  };\n\n  _proto.show = function show(e) {\n    if (!this.props.isOpen) {\n      this.clearShowTimeout();\n      this.currentTargetElement = e ? e.currentTarget || this.getCurrentTarget(e.target) : null;\n\n      if (e && e.composedPath && typeof e.composedPath === 'function') {\n        var path = e.composedPath();\n        this.currentTargetElement = path && path[0] || this.currentTargetElement;\n      }\n\n      this.toggle(e);\n    }\n  };\n\n  _proto.showWithDelay = function showWithDelay(e) {\n    if (this._hideTimeout) {\n      this.clearHideTimeout();\n    }\n\n    this._showTimeout = setTimeout(this.show.bind(this, e), this.getDelay('show'));\n  };\n\n  _proto.hide = function hide(e) {\n    if (this.props.isOpen) {\n      this.clearHideTimeout();\n      this.currentTargetElement = null;\n      this.toggle(e);\n    }\n  };\n\n  _proto.hideWithDelay = function hideWithDelay(e) {\n    if (this._showTimeout) {\n      this.clearShowTimeout();\n    }\n\n    this._hideTimeout = setTimeout(this.hide.bind(this, e), this.getDelay('hide'));\n  };\n\n  _proto.clearShowTimeout = function clearShowTimeout() {\n    clearTimeout(this._showTimeout);\n    this._showTimeout = undefined;\n  };\n\n  _proto.clearHideTimeout = function clearHideTimeout() {\n    clearTimeout(this._hideTimeout);\n    this._hideTimeout = undefined;\n  };\n\n  _proto.addEventOnTargets = function addEventOnTargets(type, handler, isBubble) {\n    this._targets.forEach(function (target) {\n      target.addEventListener(type, handler, isBubble);\n    });\n  };\n\n  _proto.removeEventOnTargets = function removeEventOnTargets(type, handler, isBubble) {\n    this._targets.forEach(function (target) {\n      target.removeEventListener(type, handler, isBubble);\n    });\n  };\n\n  _proto.addTargetEvents = function addTargetEvents() {\n    if (this.props.trigger) {\n      var triggers = this.props.trigger.split(' ');\n\n      if (triggers.indexOf('manual') === -1) {\n        if (triggers.indexOf('click') > -1 || triggers.indexOf('legacy') > -1) {\n          document.addEventListener('click', this.handleDocumentClick, true);\n        }\n\n        if (this._targets && this._targets.length) {\n          if (triggers.indexOf('hover') > -1) {\n            this.addEventOnTargets('mouseover', this.showWithDelay, true);\n            this.addEventOnTargets('mouseout', this.hideWithDelay, true);\n          }\n\n          if (triggers.indexOf('focus') > -1) {\n            this.addEventOnTargets('focusin', this.show, true);\n            this.addEventOnTargets('focusout', this.hide, true);\n          }\n\n          this.addEventOnTargets('keydown', this.onEscKeyDown, true);\n        }\n      }\n    }\n  };\n\n  _proto.removeTargetEvents = function removeTargetEvents() {\n    if (this._targets) {\n      this.removeEventOnTargets('mouseover', this.showWithDelay, true);\n      this.removeEventOnTargets('mouseout', this.hideWithDelay, true);\n      this.removeEventOnTargets('keydown', this.onEscKeyDown, true);\n      this.removeEventOnTargets('focusin', this.show, true);\n      this.removeEventOnTargets('focusout', this.hide, true);\n    }\n\n    document.removeEventListener('click', this.handleDocumentClick, true);\n  };\n\n  _proto.updateTarget = function updateTarget() {\n    var newTarget = getTarget(this.props.target, true);\n\n    if (newTarget !== this._targets) {\n      this.removeTargetEvents();\n      this._targets = newTarget ? Array.from(newTarget) : [];\n      this.currentTargetElement = this.currentTargetElement || this._targets[0];\n      this.addTargetEvents();\n    }\n  };\n\n  _proto.toggle = function toggle(e) {\n    if (this.props.disabled || !this._isMounted) {\n      return e && e.preventDefault();\n    }\n\n    return this.props.toggle(e);\n  };\n\n  _proto.render = function render() {\n    var _this2 = this;\n\n    if (this.props.isOpen) {\n      this.updateTarget();\n    }\n\n    var target = this.currentTargetElement || this._targets[0];\n\n    if (!target) {\n      return null;\n    }\n\n    var _this$props = this.props,\n        className = _this$props.className,\n        cssModule = _this$props.cssModule,\n        innerClassName = _this$props.innerClassName,\n        isOpen = _this$props.isOpen,\n        hideArrow = _this$props.hideArrow,\n        boundariesElement = _this$props.boundariesElement,\n        placement = _this$props.placement,\n        placementPrefix = _this$props.placementPrefix,\n        arrowClassName = _this$props.arrowClassName,\n        popperClassName = _this$props.popperClassName,\n        container = _this$props.container,\n        modifiers = _this$props.modifiers,\n        strategy = _this$props.strategy,\n        offset = _this$props.offset,\n        fade = _this$props.fade,\n        flip = _this$props.flip,\n        children = _this$props.children;\n    var attributes = omit(this.props, Object.keys(propTypes$E));\n    var popperClasses = mapToCssModules(popperClassName, cssModule);\n    var classes = mapToCssModules(innerClassName, cssModule);\n    return /*#__PURE__*/React__default[\"default\"].createElement(PopperContent$1, {\n      className: className,\n      target: target,\n      isOpen: isOpen,\n      hideArrow: hideArrow,\n      boundariesElement: boundariesElement,\n      placement: placement,\n      placementPrefix: placementPrefix,\n      arrowClassName: arrowClassName,\n      popperClassName: popperClasses,\n      container: container,\n      modifiers: modifiers,\n      strategy: strategy,\n      offset: offset,\n      cssModule: cssModule,\n      fade: fade,\n      flip: flip\n    }, function (_ref) {\n      var update = _ref.update;\n      return /*#__PURE__*/React__default[\"default\"].createElement(\"div\", _extends({}, attributes, {\n        ref: _this2.getRef,\n        className: classes,\n        role: \"tooltip\",\n        onMouseOver: _this2.onMouseOverTooltipContent,\n        onMouseLeave: _this2.onMouseLeaveTooltipContent,\n        onKeyDown: _this2.onEscKeyDown\n      }), typeof children === 'function' ? children({\n        update: update\n      }) : children);\n    });\n  };\n\n  return TooltipPopoverWrapper;\n}(React__default[\"default\"].Component);\n\nTooltipPopoverWrapper.propTypes = propTypes$E;\nTooltipPopoverWrapper.defaultProps = defaultProps$E;\nvar TooltipPopoverWrapper$1 = TooltipPopoverWrapper;\n\nvar defaultProps$D = {\n  placement: 'right',\n  placementPrefix: 'bs-popover',\n  trigger: 'click',\n  offset: [0, 8]\n};\n\nfunction Popover(props) {\n  var popperClasses = classNames__default[\"default\"]('popover', 'show', props.popperClassName);\n  var classes = classNames__default[\"default\"]('popover-inner', props.innerClassName);\n  return /*#__PURE__*/React__default[\"default\"].createElement(TooltipPopoverWrapper$1, _extends({}, props, {\n    arrowClassName: \"popover-arrow\",\n    popperClassName: popperClasses,\n    innerClassName: classes\n  }));\n}\n\nPopover.propTypes = propTypes$E;\nPopover.defaultProps = defaultProps$D;\n\nvar omitKeys$4 = ['defaultOpen'];\n\nvar UncontrolledPopover = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(UncontrolledPopover, _Component);\n\n  function UncontrolledPopover(props) {\n    var _this;\n\n    _this = _Component.call(this, props) || this;\n    _this.state = {\n      isOpen: props.defaultOpen || false\n    };\n    _this.toggle = _this.toggle.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  var _proto = UncontrolledPopover.prototype;\n\n  _proto.toggle = function toggle() {\n    this.setState(function (prevState) {\n      return {\n        isOpen: !prevState.isOpen\n      };\n    });\n  };\n\n  _proto.render = function render() {\n    return /*#__PURE__*/React__default[\"default\"].createElement(Popover, _extends({\n      isOpen: this.state.isOpen,\n      toggle: this.toggle\n    }, omit(this.props, omitKeys$4)));\n  };\n\n  return UncontrolledPopover;\n}(React.Component);\nUncontrolledPopover.propTypes = _objectSpread2({\n  defaultOpen: PropTypes__default[\"default\"].bool\n}, Popover.propTypes);\n\nvar _excluded$y = [\"className\", \"cssModule\", \"tag\"];\nvar propTypes$D = {\n  tag: tagPropType,\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object\n};\nvar defaultProps$C = {\n  tag: 'h3'\n};\n\nfunction PopoverHeader(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$y);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'popover-header'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nPopoverHeader.propTypes = propTypes$D;\nPopoverHeader.defaultProps = defaultProps$C;\n\nvar _excluded$x = [\"className\", \"cssModule\", \"tag\"];\nvar propTypes$C = {\n  tag: tagPropType,\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object\n};\nvar defaultProps$B = {\n  tag: 'div'\n};\n\nfunction PopoverBody(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$x);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'popover-body'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nPopoverBody.propTypes = propTypes$C;\nPopoverBody.defaultProps = defaultProps$B;\n\nvar _excluded$w = [\"children\", \"className\", \"barClassName\", \"cssModule\", \"value\", \"min\", \"max\", \"animated\", \"striped\", \"color\", \"bar\", \"multi\", \"tag\", \"style\", \"barStyle\", \"barAriaValueText\", \"barAriaLabelledBy\"];\nvar propTypes$B = {\n  /** Enable animation to bar */\n  animated: PropTypes__default[\"default\"].bool,\n  bar: PropTypes__default[\"default\"].bool,\n  barAriaLabelledBy: PropTypes__default[\"default\"].string,\n  barAriaValueText: PropTypes__default[\"default\"].string,\n  barClassName: PropTypes__default[\"default\"].string,\n  barStyle: PropTypes__default[\"default\"].object,\n  children: PropTypes__default[\"default\"].node,\n\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Add custom color to the placeholder */\n  color: PropTypes__default[\"default\"].string,\n\n  /** Maximum value of progress */\n  max: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].number]),\n\n  /** Minimum value of progress, defaults to zero */\n  min: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].number]),\n  multi: PropTypes__default[\"default\"].bool,\n\n  /** Add stripes to progress bar */\n  striped: PropTypes__default[\"default\"].bool,\n  style: PropTypes__default[\"default\"].object,\n\n  /** Set a custom element for this component */\n  tag: tagPropType,\n\n  /** Current value of progress */\n  value: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].number])\n};\nvar defaultProps$A = {\n  tag: 'div',\n  value: 0,\n  min: 0,\n  max: 100,\n  style: {},\n  barStyle: {}\n};\n\nfunction Progress(props) {\n  var children = props.children,\n      className = props.className,\n      barClassName = props.barClassName,\n      cssModule = props.cssModule,\n      value = props.value,\n      min = props.min,\n      max = props.max,\n      animated = props.animated,\n      striped = props.striped,\n      color = props.color,\n      bar = props.bar,\n      multi = props.multi,\n      Tag = props.tag,\n      style = props.style,\n      barStyle = props.barStyle,\n      barAriaValueText = props.barAriaValueText,\n      barAriaLabelledBy = props.barAriaLabelledBy,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$w);\n\n  var percent = toNumber(value) / toNumber(max) * 100;\n  var progressClasses = mapToCssModules(classNames__default[\"default\"](className, 'progress'), cssModule);\n  var progressBarClasses = mapToCssModules(classNames__default[\"default\"]('progress-bar', bar ? className || barClassName : barClassName, animated ? 'progress-bar-animated' : null, color ? \"bg-\" + color : null, striped || animated ? 'progress-bar-striped' : null), cssModule);\n  var progressBarProps = {\n    className: progressBarClasses,\n    style: _objectSpread2(_objectSpread2(_objectSpread2({}, bar ? style : {}), barStyle), {}, {\n      width: percent + \"%\"\n    }),\n    role: 'progressbar',\n    'aria-valuenow': value,\n    'aria-valuemin': min,\n    'aria-valuemax': max,\n    'aria-valuetext': barAriaValueText,\n    'aria-labelledby': barAriaLabelledBy,\n    children: children\n  };\n\n  if (bar) {\n    return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, progressBarProps));\n  }\n\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    style: style,\n    className: progressClasses\n  }), multi ? children : /*#__PURE__*/React__default[\"default\"].createElement(\"div\", progressBarProps));\n}\n\nProgress.propTypes = propTypes$B;\nProgress.defaultProps = defaultProps$A;\n\nvar propTypes$A = {\n  children: PropTypes__default[\"default\"].node.isRequired,\n  node: PropTypes__default[\"default\"].any\n};\n\nvar Portal = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Portal, _React$Component);\n\n  function Portal() {\n    return _React$Component.apply(this, arguments) || this;\n  }\n\n  var _proto = Portal.prototype;\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    if (this.defaultNode) {\n      document.body.removeChild(this.defaultNode);\n    }\n\n    this.defaultNode = null;\n  };\n\n  _proto.render = function render() {\n    if (!canUseDOM) {\n      return null;\n    }\n\n    if (!this.props.node && !this.defaultNode) {\n      this.defaultNode = document.createElement('div');\n      document.body.appendChild(this.defaultNode);\n    }\n\n    return ReactDOM__default[\"default\"].createPortal(this.props.children, this.props.node || this.defaultNode);\n  };\n\n  return Portal;\n}(React__default[\"default\"].Component);\n\nPortal.propTypes = propTypes$A;\nvar Portal$1 = Portal;\n\nfunction noop$1() {}\n\nvar FadePropTypes$1 = PropTypes__default[\"default\"].shape(Fade.propTypes);\nvar propTypes$z = {\n  /** */\n  autoFocus: PropTypes__default[\"default\"].bool,\n\n  /** Add backdrop to modal */\n  backdrop: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].bool, PropTypes__default[\"default\"].oneOf(['static'])]),\n\n  /** add custom classname to backdrop */\n  backdropClassName: PropTypes__default[\"default\"].string,\n  backdropTransition: FadePropTypes$1,\n\n  /** Vertically center the modal */\n  centered: PropTypes__default[\"default\"].bool,\n\n  /** Add children for the modal to wrap */\n  children: PropTypes__default[\"default\"].node,\n\n  /** Add custom className for modal content */\n  contentClassName: PropTypes__default[\"default\"].string,\n  className: PropTypes__default[\"default\"].string,\n  container: targetPropType,\n  cssModule: PropTypes__default[\"default\"].object,\n  external: PropTypes__default[\"default\"].node,\n\n  /** Enable/Disable animation */\n  fade: PropTypes__default[\"default\"].bool,\n\n  /** Make the modal fullscreen */\n  fullscreen: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].bool, PropTypes__default[\"default\"].oneOf(['sm', 'md', 'lg', 'xl'])]),\n  innerRef: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].object, PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].func]),\n\n  /** The status of the modal, either open or close */\n  isOpen: PropTypes__default[\"default\"].bool,\n\n  /** Allow modal to be closed with escape key. */\n  keyboard: PropTypes__default[\"default\"].bool,\n\n  /** Identifies the element (or elements) that labels the current element. */\n  labelledBy: PropTypes__default[\"default\"].string,\n  modalClassName: PropTypes__default[\"default\"].string,\n  modalTransition: FadePropTypes$1,\n\n  /** Function to be triggered on close */\n  onClosed: PropTypes__default[\"default\"].func,\n\n  /** Function to be triggered on enter */\n  onEnter: PropTypes__default[\"default\"].func,\n\n  /** Function to be triggered on exit */\n  onExit: PropTypes__default[\"default\"].func,\n\n  /** Function to be triggered on open */\n  onOpened: PropTypes__default[\"default\"].func,\n\n  /** Returns focus to the element that triggered opening of the modal */\n  returnFocusAfterClose: PropTypes__default[\"default\"].bool,\n\n  /** Accessibility role */\n  role: PropTypes__default[\"default\"].string,\n\n  /** Make the modal scrollable */\n  scrollable: PropTypes__default[\"default\"].bool,\n\n  /** Two optional sizes `lg` and `sm` */\n  size: PropTypes__default[\"default\"].string,\n\n  /** Function to toggle modal visibility */\n  toggle: PropTypes__default[\"default\"].func,\n  trapFocus: PropTypes__default[\"default\"].bool,\n\n  /** Unmounts the modal when modal is closed */\n  unmountOnClose: PropTypes__default[\"default\"].bool,\n  wrapClassName: PropTypes__default[\"default\"].string,\n  zIndex: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].number, PropTypes__default[\"default\"].string])\n};\nvar propsToOmit$1 = Object.keys(propTypes$z);\nvar defaultProps$z = {\n  isOpen: false,\n  autoFocus: true,\n  centered: false,\n  scrollable: false,\n  role: 'dialog',\n  backdrop: true,\n  keyboard: true,\n  zIndex: 1050,\n  fade: true,\n  onOpened: noop$1,\n  onClosed: noop$1,\n  modalTransition: {\n    timeout: TransitionTimeouts.Modal\n  },\n  backdropTransition: {\n    mountOnEnter: true,\n    timeout: TransitionTimeouts.Fade // uses standard fade transition\n\n  },\n  unmountOnClose: true,\n  returnFocusAfterClose: true,\n  container: 'body',\n  trapFocus: false\n};\n\nvar Modal = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Modal, _React$Component);\n\n  function Modal(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    _this._element = null;\n    _this._originalBodyPadding = null;\n    _this.getFocusableChildren = _this.getFocusableChildren.bind(_assertThisInitialized(_this));\n    _this.handleBackdropClick = _this.handleBackdropClick.bind(_assertThisInitialized(_this));\n    _this.handleBackdropMouseDown = _this.handleBackdropMouseDown.bind(_assertThisInitialized(_this));\n    _this.handleEscape = _this.handleEscape.bind(_assertThisInitialized(_this));\n    _this.handleStaticBackdropAnimation = _this.handleStaticBackdropAnimation.bind(_assertThisInitialized(_this));\n    _this.handleTab = _this.handleTab.bind(_assertThisInitialized(_this));\n    _this.onOpened = _this.onOpened.bind(_assertThisInitialized(_this));\n    _this.onClosed = _this.onClosed.bind(_assertThisInitialized(_this));\n    _this.manageFocusAfterClose = _this.manageFocusAfterClose.bind(_assertThisInitialized(_this));\n    _this.clearBackdropAnimationTimeout = _this.clearBackdropAnimationTimeout.bind(_assertThisInitialized(_this));\n    _this.trapFocus = _this.trapFocus.bind(_assertThisInitialized(_this));\n    _this.state = {\n      isOpen: false,\n      showStaticBackdropAnimation: false\n    };\n    return _this;\n  }\n\n  var _proto = Modal.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    var _this$props = this.props,\n        isOpen = _this$props.isOpen,\n        autoFocus = _this$props.autoFocus,\n        onEnter = _this$props.onEnter;\n\n    if (isOpen) {\n      this.init();\n      this.setState({\n        isOpen: true\n      });\n\n      if (autoFocus) {\n        this.setFocus();\n      }\n    }\n\n    if (onEnter) {\n      onEnter();\n    } // traps focus inside the Modal, even if the browser address bar is focused\n\n\n    document.addEventListener('focus', this.trapFocus, true);\n    this._isMounted = true;\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    if (this.props.isOpen && !prevProps.isOpen) {\n      this.init();\n      this.setState({\n        isOpen: true\n      }); // let render() renders Modal Dialog first\n\n      return;\n    } // now Modal Dialog is rendered and we can refer this._element and this._dialog\n\n\n    if (this.props.autoFocus && this.state.isOpen && !prevState.isOpen) {\n      this.setFocus();\n    }\n\n    if (this._element && prevProps.zIndex !== this.props.zIndex) {\n      this._element.style.zIndex = this.props.zIndex;\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.clearBackdropAnimationTimeout();\n\n    if (this.props.onExit) {\n      this.props.onExit();\n    }\n\n    if (this._element) {\n      this.destroy();\n\n      if (this.props.isOpen || this.state.isOpen) {\n        this.close();\n      }\n    }\n\n    document.removeEventListener('focus', this.trapFocus, true);\n    this._isMounted = false;\n  } // not mouseUp because scrollbar fires it, shouldn't close when user scrolls\n  ;\n\n  _proto.handleBackdropClick = function handleBackdropClick(e) {\n    if (e.target === this._mouseDownElement) {\n      e.stopPropagation();\n      var backdrop = this._dialog ? this._dialog.parentNode : null;\n\n      if (backdrop && e.target === backdrop && this.props.backdrop === 'static') {\n        this.handleStaticBackdropAnimation();\n      }\n\n      if (!this.props.isOpen || this.props.backdrop !== true) return;\n\n      if (backdrop && e.target === backdrop && this.props.toggle) {\n        this.props.toggle(e);\n      }\n    }\n  };\n\n  _proto.handleTab = function handleTab(e) {\n    if (e.which !== 9) return;\n    if (this.modalIndex < Modal.openCount - 1) return; // last opened modal\n\n    var focusableChildren = this.getFocusableChildren();\n    var totalFocusable = focusableChildren.length;\n    if (totalFocusable === 0) return;\n    var currentFocus = this.getFocusedChild();\n    var focusedIndex = 0;\n\n    for (var i = 0; i < totalFocusable; i += 1) {\n      if (focusableChildren[i] === currentFocus) {\n        focusedIndex = i;\n        break;\n      }\n    }\n\n    if (e.shiftKey && focusedIndex === 0) {\n      e.preventDefault();\n      focusableChildren[totalFocusable - 1].focus();\n    } else if (!e.shiftKey && focusedIndex === totalFocusable - 1) {\n      e.preventDefault();\n      focusableChildren[0].focus();\n    }\n  };\n\n  _proto.handleBackdropMouseDown = function handleBackdropMouseDown(e) {\n    this._mouseDownElement = e.target;\n  };\n\n  _proto.handleEscape = function handleEscape(e) {\n    if (this.props.isOpen && e.keyCode === keyCodes.esc && this.props.toggle) {\n      if (this.props.keyboard) {\n        e.preventDefault();\n        e.stopPropagation();\n        this.props.toggle(e);\n      } else if (this.props.backdrop === 'static') {\n        e.preventDefault();\n        e.stopPropagation();\n        this.handleStaticBackdropAnimation();\n      }\n    }\n  };\n\n  _proto.handleStaticBackdropAnimation = function handleStaticBackdropAnimation() {\n    var _this2 = this;\n\n    this.clearBackdropAnimationTimeout();\n    this.setState({\n      showStaticBackdropAnimation: true\n    });\n    this._backdropAnimationTimeout = setTimeout(function () {\n      _this2.setState({\n        showStaticBackdropAnimation: false\n      });\n    }, 100);\n  };\n\n  _proto.onOpened = function onOpened(node, isAppearing) {\n    this.props.onOpened();\n    (this.props.modalTransition.onEntered || noop$1)(node, isAppearing);\n  };\n\n  _proto.onClosed = function onClosed(node) {\n    var unmountOnClose = this.props.unmountOnClose; // so all methods get called before it is unmounted\n\n    this.props.onClosed();\n    (this.props.modalTransition.onExited || noop$1)(node);\n\n    if (unmountOnClose) {\n      this.destroy();\n    }\n\n    this.close();\n\n    if (this._isMounted) {\n      this.setState({\n        isOpen: false\n      });\n    }\n  };\n\n  _proto.setFocus = function setFocus() {\n    if (this._dialog && this._dialog.parentNode && typeof this._dialog.parentNode.focus === 'function') {\n      this._dialog.parentNode.focus();\n    }\n  };\n\n  _proto.getFocusableChildren = function getFocusableChildren() {\n    return this._element.querySelectorAll(focusableElements.join(', '));\n  };\n\n  _proto.getFocusedChild = function getFocusedChild() {\n    var currentFocus;\n    var focusableChildren = this.getFocusableChildren();\n\n    try {\n      currentFocus = document.activeElement;\n    } catch (err) {\n      currentFocus = focusableChildren[0];\n    }\n\n    return currentFocus;\n  };\n\n  _proto.trapFocus = function trapFocus(ev) {\n    if (!this.props.trapFocus) {\n      return;\n    }\n\n    if (!this._element) {\n      // element is not attached\n      return;\n    }\n\n    if (this._dialog && this._dialog.parentNode === ev.target) {\n      // initial focus when the Modal is opened\n      return;\n    }\n\n    if (this.modalIndex < Modal.openCount - 1) {\n      // last opened modal\n      return;\n    }\n\n    var children = this.getFocusableChildren();\n\n    for (var i = 0; i < children.length; i += 1) {\n      // focus is already inside the Modal\n      if (children[i] === ev.target) return;\n    }\n\n    if (children.length > 0) {\n      // otherwise focus the first focusable element in the Modal\n      ev.preventDefault();\n      ev.stopPropagation();\n      children[0].focus();\n    }\n  };\n\n  _proto.init = function init() {\n    try {\n      this._triggeringElement = document.activeElement;\n    } catch (err) {\n      this._triggeringElement = null;\n    }\n\n    if (!this._element) {\n      this._element = document.createElement('div');\n\n      this._element.setAttribute('tabindex', '-1');\n\n      this._element.style.position = 'relative';\n      this._element.style.zIndex = this.props.zIndex;\n      this._mountContainer = getTarget(this.props.container);\n\n      this._mountContainer.appendChild(this._element);\n    }\n\n    this._originalBodyPadding = getOriginalBodyPadding();\n\n    if (Modal.openCount < 1) {\n      Modal.originalBodyOverflow = window.getComputedStyle(document.body).overflow;\n    }\n    conditionallyUpdateScrollbar();\n\n    if (Modal.openCount === 0) {\n      document.body.className = classNames__default[\"default\"](document.body.className, mapToCssModules('modal-open', this.props.cssModule));\n      document.body.style.overflow = 'hidden';\n    }\n\n    this.modalIndex = Modal.openCount;\n    Modal.openCount += 1;\n  };\n\n  _proto.destroy = function destroy() {\n    if (this._element) {\n      this._mountContainer.removeChild(this._element);\n\n      this._element = null;\n    }\n\n    this.manageFocusAfterClose();\n  };\n\n  _proto.manageFocusAfterClose = function manageFocusAfterClose() {\n    if (this._triggeringElement) {\n      var returnFocusAfterClose = this.props.returnFocusAfterClose;\n      if (this._triggeringElement.focus && returnFocusAfterClose) this._triggeringElement.focus();\n      this._triggeringElement = null;\n    }\n  };\n\n  _proto.close = function close() {\n    if (Modal.openCount <= 1) {\n      var modalOpenClassName = mapToCssModules('modal-open', this.props.cssModule); // Use regex to prevent matching `modal-open` as part of a different class, e.g. `my-modal-opened`\n\n      var modalOpenClassNameRegex = new RegExp(\"(^| )\" + modalOpenClassName + \"( |$)\");\n      document.body.className = document.body.className.replace(modalOpenClassNameRegex, ' ').trim();\n      document.body.style.overflow = Modal.originalBodyOverflow;\n    }\n\n    this.manageFocusAfterClose();\n    Modal.openCount = Math.max(0, Modal.openCount - 1);\n    setScrollbarWidth(this._originalBodyPadding);\n  };\n\n  _proto.clearBackdropAnimationTimeout = function clearBackdropAnimationTimeout() {\n    if (this._backdropAnimationTimeout) {\n      clearTimeout(this._backdropAnimationTimeout);\n      this._backdropAnimationTimeout = undefined;\n    }\n  };\n\n  _proto.renderModalDialog = function renderModalDialog() {\n    var _classNames,\n        _this3 = this;\n\n    var attributes = omit(this.props, propsToOmit$1);\n    var dialogBaseClass = 'modal-dialog';\n    return /*#__PURE__*/React__default[\"default\"].createElement(\"div\", _extends({}, attributes, {\n      className: mapToCssModules(classNames__default[\"default\"](dialogBaseClass, this.props.className, (_classNames = {}, _classNames[\"modal-\" + this.props.size] = this.props.size, _classNames[dialogBaseClass + \"-centered\"] = this.props.centered, _classNames[dialogBaseClass + \"-scrollable\"] = this.props.scrollable, _classNames['modal-fullscreen'] = this.props.fullscreen === true, _classNames[\"modal-fullscreen-\" + this.props.fullscreen + \"-down\"] = typeof this.props.fullscreen === 'string', _classNames)), this.props.cssModule),\n      role: \"document\",\n      ref: function ref(c) {\n        _this3._dialog = c;\n      }\n    }), /*#__PURE__*/React__default[\"default\"].createElement(\"div\", {\n      className: mapToCssModules(classNames__default[\"default\"]('modal-content', this.props.contentClassName), this.props.cssModule)\n    }, this.props.children));\n  };\n\n  _proto.render = function render() {\n    var unmountOnClose = this.props.unmountOnClose;\n\n    if (!!this._element && (this.state.isOpen || !unmountOnClose)) {\n      var isModalHidden = !!this._element && !this.state.isOpen && !unmountOnClose;\n      this._element.style.display = isModalHidden ? 'none' : 'block';\n      var _this$props2 = this.props,\n          wrapClassName = _this$props2.wrapClassName,\n          modalClassName = _this$props2.modalClassName,\n          backdropClassName = _this$props2.backdropClassName,\n          cssModule = _this$props2.cssModule,\n          isOpen = _this$props2.isOpen,\n          backdrop = _this$props2.backdrop,\n          role = _this$props2.role,\n          labelledBy = _this$props2.labelledBy,\n          external = _this$props2.external,\n          innerRef = _this$props2.innerRef;\n      var modalAttributes = {\n        onClick: this.handleBackdropClick,\n        onMouseDown: this.handleBackdropMouseDown,\n        onKeyUp: this.handleEscape,\n        onKeyDown: this.handleTab,\n        style: {\n          display: 'block'\n        },\n        'aria-labelledby': labelledBy,\n        role: role,\n        tabIndex: '-1'\n      };\n      var hasTransition = this.props.fade;\n\n      var modalTransition = _objectSpread2(_objectSpread2(_objectSpread2({}, Fade.defaultProps), this.props.modalTransition), {}, {\n        baseClass: hasTransition ? this.props.modalTransition.baseClass : '',\n        timeout: hasTransition ? this.props.modalTransition.timeout : 0\n      });\n\n      var backdropTransition = _objectSpread2(_objectSpread2(_objectSpread2({}, Fade.defaultProps), this.props.backdropTransition), {}, {\n        baseClass: hasTransition ? this.props.backdropTransition.baseClass : '',\n        timeout: hasTransition ? this.props.backdropTransition.timeout : 0\n      });\n\n      var Backdrop = backdrop && (hasTransition ? /*#__PURE__*/React__default[\"default\"].createElement(Fade, _extends({}, backdropTransition, {\n        \"in\": isOpen && !!backdrop,\n        cssModule: cssModule,\n        className: mapToCssModules(classNames__default[\"default\"]('modal-backdrop', backdropClassName), cssModule)\n      })) : /*#__PURE__*/React__default[\"default\"].createElement(\"div\", {\n        className: mapToCssModules(classNames__default[\"default\"]('modal-backdrop', 'show', backdropClassName), cssModule)\n      }));\n      return /*#__PURE__*/React__default[\"default\"].createElement(Portal$1, {\n        node: this._element\n      }, /*#__PURE__*/React__default[\"default\"].createElement(\"div\", {\n        className: mapToCssModules(wrapClassName)\n      }, /*#__PURE__*/React__default[\"default\"].createElement(Fade, _extends({}, modalAttributes, modalTransition, {\n        \"in\": isOpen,\n        onEntered: this.onOpened,\n        onExited: this.onClosed,\n        cssModule: cssModule,\n        className: mapToCssModules(classNames__default[\"default\"]('modal', modalClassName, this.state.showStaticBackdropAnimation && 'modal-static'), cssModule),\n        innerRef: innerRef\n      }), external, this.renderModalDialog()), Backdrop));\n    }\n\n    return null;\n  };\n\n  return Modal;\n}(React__default[\"default\"].Component);\n\nModal.propTypes = propTypes$z;\nModal.defaultProps = defaultProps$z;\nModal.openCount = 0;\nModal.originalBodyOverflow = null;\nvar Modal$1 = Modal;\n\nvar _excluded$v = [\"className\", \"cssModule\", \"children\", \"toggle\", \"tag\", \"wrapTag\", \"closeAriaLabel\", \"close\"];\nvar propTypes$y = {\n  children: PropTypes__default[\"default\"].node,\n\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Custom close button */\n  close: PropTypes__default[\"default\"].object,\n  closeAriaLabel: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Set a custom element for this component */\n  tag: tagPropType,\n\n  /** Function to be triggered when close button is clicked */\n  toggle: PropTypes__default[\"default\"].func,\n  wrapTag: tagPropType\n};\nvar defaultProps$y = {\n  tag: 'h5',\n  wrapTag: 'div',\n  closeAriaLabel: 'Close'\n};\n\nfunction ModalHeader(props) {\n  var closeButton;\n\n  var className = props.className,\n      cssModule = props.cssModule,\n      children = props.children,\n      toggle = props.toggle,\n      Tag = props.tag,\n      WrapTag = props.wrapTag,\n      closeAriaLabel = props.closeAriaLabel,\n      close = props.close,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$v);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'modal-header'), cssModule);\n\n  if (!close && toggle) {\n    closeButton = /*#__PURE__*/React__default[\"default\"].createElement(\"button\", {\n      type: \"button\",\n      onClick: toggle,\n      className: mapToCssModules('btn-close', cssModule),\n      \"aria-label\": closeAriaLabel\n    });\n  }\n\n  return /*#__PURE__*/React__default[\"default\"].createElement(WrapTag, _extends({}, attributes, {\n    className: classes\n  }), /*#__PURE__*/React__default[\"default\"].createElement(Tag, {\n    className: mapToCssModules('modal-title', cssModule)\n  }, children), close || closeButton);\n}\n\nModalHeader.propTypes = propTypes$y;\nModalHeader.defaultProps = defaultProps$y;\n\nvar _excluded$u = [\"className\", \"cssModule\", \"tag\"];\nvar propTypes$x = {\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Set a custom element for this component */\n  tag: tagPropType\n};\nvar defaultProps$x = {\n  tag: 'div'\n};\n\nfunction ModalBody(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$u);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'modal-body'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nModalBody.propTypes = propTypes$x;\nModalBody.defaultProps = defaultProps$x;\n\nvar _excluded$t = [\"className\", \"cssModule\", \"tag\"];\nvar propTypes$w = {\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Set a custom element for this component */\n  tag: tagPropType\n};\nvar defaultProps$w = {\n  tag: 'div'\n};\n\nfunction ModalFooter(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$t);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'modal-footer'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nModalFooter.propTypes = propTypes$w;\nModalFooter.defaultProps = defaultProps$w;\n\nvar defaultProps$v = {\n  placement: 'top',\n  autohide: true,\n  placementPrefix: 'bs-tooltip',\n  trigger: 'hover focus'\n};\n\nfunction Tooltip(props) {\n  var popperClasses = classNames__default[\"default\"]('tooltip', 'show', props.popperClassName);\n  var classes = classNames__default[\"default\"]('tooltip-inner', props.innerClassName);\n  return /*#__PURE__*/React__default[\"default\"].createElement(TooltipPopoverWrapper$1, _extends({}, props, {\n    arrowClassName: \"tooltip-arrow\",\n    popperClassName: popperClasses,\n    innerClassName: classes\n  }));\n}\n\nTooltip.propTypes = propTypes$E;\nTooltip.defaultProps = defaultProps$v;\n\nvar _excluded$s = [\"className\", \"cssModule\", \"size\", \"bordered\", \"borderless\", \"striped\", \"dark\", \"hover\", \"responsive\", \"tag\", \"responsiveTag\", \"innerRef\"];\nvar propTypes$v = {\n  /** Adds border to all sides of table */\n  bordered: PropTypes__default[\"default\"].bool,\n\n  /** Removes all borders */\n  borderless: PropTypes__default[\"default\"].bool,\n\n  /** Adds custom class name to component */\n  className: PropTypes__default[\"default\"].string,\n\n  /**  */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Makes the table dark */\n  dark: PropTypes__default[\"default\"].bool,\n\n  /** Enables a hover state on the rows within `<tbody>` */\n  hover: PropTypes__default[\"default\"].bool,\n  innerRef: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].func, PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].object]),\n\n  /** Responsive tables allow tables to be scrolled horizontally with ease */\n  responsive: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].bool, PropTypes__default[\"default\"].string]),\n  responsiveTag: tagPropType,\n\n  /** Make tables more compact by cutting cell padding in half when setting size as sm. */\n  size: PropTypes__default[\"default\"].string,\n\n  /** Adds zebra-striping to any table row within the `<tbody>` */\n  striped: PropTypes__default[\"default\"].bool,\n\n  /** Add custom tag to the component */\n  tag: tagPropType\n};\nvar defaultProps$u = {\n  tag: 'table',\n  responsiveTag: 'div'\n};\n\nfunction Table(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      size = props.size,\n      bordered = props.bordered,\n      borderless = props.borderless,\n      striped = props.striped,\n      dark = props.dark,\n      hover = props.hover,\n      responsive = props.responsive,\n      Tag = props.tag,\n      ResponsiveTag = props.responsiveTag,\n      innerRef = props.innerRef,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$s);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'table', size ? 'table-' + size : false, bordered ? 'table-bordered' : false, borderless ? 'table-borderless' : false, striped ? 'table-striped' : false, dark ? 'table-dark' : false, hover ? 'table-hover' : false), cssModule);\n  var table = /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    ref: innerRef,\n    className: classes\n  }));\n\n  if (responsive) {\n    var responsiveClassName = mapToCssModules(responsive === true ? 'table-responsive' : \"table-responsive-\" + responsive, cssModule);\n    return /*#__PURE__*/React__default[\"default\"].createElement(ResponsiveTag, {\n      className: responsiveClassName\n    }, table);\n  }\n\n  return table;\n}\n\nTable.propTypes = propTypes$v;\nTable.defaultProps = defaultProps$u;\n\nvar _excluded$r = [\"className\", \"cssModule\", \"tag\", \"flush\", \"horizontal\", \"numbered\"];\nvar propTypes$u = {\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Remove borders to make the list appear flush */\n  flush: PropTypes__default[\"default\"].bool,\n\n  /** Make the list horizontal instead of vertical */\n  horizontal: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].bool, PropTypes__default[\"default\"].string]),\n\n  /** Add number to the ListItems */\n  numbered: PropTypes__default[\"default\"].bool,\n\n  /** Set a custom element for this component */\n  tag: tagPropType\n};\nvar defaultProps$t = {\n  tag: 'ul',\n  horizontal: false,\n  numbered: false\n};\n\nvar getHorizontalClass = function getHorizontalClass(horizontal) {\n  if (horizontal === false) {\n    return false;\n  }\n\n  if (horizontal === true || horizontal === 'xs') {\n    return 'list-group-horizontal';\n  }\n\n  return \"list-group-horizontal-\" + horizontal;\n};\n\nfunction ListGroup(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      flush = props.flush,\n      horizontal = props.horizontal,\n      numbered = props.numbered,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$r);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'list-group', // list-group-horizontal cannot currently be mixed with list-group-flush\n  // we only try to apply horizontal classes if flush is false\n  flush ? 'list-group-flush' : getHorizontalClass(horizontal), {\n    'list-group-numbered': numbered\n  }), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nListGroup.propTypes = propTypes$u;\nListGroup.defaultProps = defaultProps$t;\n\nvar _excluded$q = [\"className\", \"cssModule\", \"tag\", \"innerRef\"];\nvar propTypes$t = {\n  children: PropTypes__default[\"default\"].node,\n  tag: tagPropType,\n  innerRef: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].object, PropTypes__default[\"default\"].func, PropTypes__default[\"default\"].string]),\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object\n};\nvar defaultProps$s = {\n  tag: 'form'\n};\n\nvar Form = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(Form, _Component);\n\n  function Form(props) {\n    var _this;\n\n    _this = _Component.call(this, props) || this;\n    _this.getRef = _this.getRef.bind(_assertThisInitialized(_this));\n    _this.submit = _this.submit.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  var _proto = Form.prototype;\n\n  _proto.getRef = function getRef(ref) {\n    if (this.props.innerRef) {\n      this.props.innerRef(ref);\n    }\n\n    this.ref = ref;\n  };\n\n  _proto.submit = function submit() {\n    if (this.ref) {\n      this.ref.submit();\n    }\n  };\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        className = _this$props.className,\n        cssModule = _this$props.cssModule,\n        Tag = _this$props.tag,\n        innerRef = _this$props.innerRef,\n        attributes = _objectWithoutPropertiesLoose(_this$props, _excluded$q);\n\n    var classes = mapToCssModules(className, cssModule);\n    return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n      ref: innerRef,\n      className: classes\n    }));\n  };\n\n  return Form;\n}(React.Component);\n\nForm.propTypes = propTypes$t;\nForm.defaultProps = defaultProps$s;\nvar Form$1 = Form;\n\nvar _excluded$p = [\"className\", \"cssModule\", \"valid\", \"tooltip\", \"tag\"];\nvar propTypes$s = {\n  children: PropTypes__default[\"default\"].node,\n  tag: tagPropType,\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object,\n  valid: PropTypes__default[\"default\"].bool,\n  tooltip: PropTypes__default[\"default\"].bool\n};\nvar defaultProps$r = {\n  tag: 'div',\n  valid: undefined\n};\n\nfunction FormFeedback(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      valid = props.valid,\n      tooltip = props.tooltip,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$p);\n\n  var validMode = tooltip ? 'tooltip' : 'feedback';\n  var classes = mapToCssModules(classNames__default[\"default\"](className, valid ? \"valid-\" + validMode : \"invalid-\" + validMode), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nFormFeedback.propTypes = propTypes$s;\nFormFeedback.defaultProps = defaultProps$r;\n\nvar _excluded$o = [\"className\", \"cssModule\", \"row\", \"disabled\", \"check\", \"inline\", \"floating\", \"tag\", \"switch\"];\nvar propTypes$r = {\n  children: PropTypes__default[\"default\"].node,\n  row: PropTypes__default[\"default\"].bool,\n  check: PropTypes__default[\"default\"].bool,\n  \"switch\": PropTypes__default[\"default\"].bool,\n  inline: PropTypes__default[\"default\"].bool,\n  floating: PropTypes__default[\"default\"].bool,\n  disabled: PropTypes__default[\"default\"].bool,\n  tag: tagPropType,\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object\n};\nvar defaultProps$q = {\n  tag: 'div'\n};\n\nfunction FormGroup(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      row = props.row,\n      disabled = props.disabled,\n      check = props.check,\n      inline = props.inline,\n      floating = props.floating,\n      Tag = props.tag,\n      switchProp = props[\"switch\"],\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$o);\n\n  var formCheck = check || switchProp;\n  var classes = mapToCssModules(classNames__default[\"default\"](className, row ? 'row' : false, formCheck ? 'form-check' : 'mb-3', switchProp ? 'form-switch' : false, formCheck && inline ? 'form-check-inline' : false, formCheck && disabled ? 'disabled' : false, floating && 'form-floating'), cssModule);\n\n  if (Tag === 'fieldset') {\n    attributes.disabled = disabled;\n  }\n\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nFormGroup.propTypes = propTypes$r;\nFormGroup.defaultProps = defaultProps$q;\n\nvar _excluded$n = [\"className\", \"cssModule\", \"inline\", \"color\", \"tag\"];\nvar propTypes$q = {\n  children: PropTypes__default[\"default\"].node,\n  inline: PropTypes__default[\"default\"].bool,\n  tag: tagPropType,\n  color: PropTypes__default[\"default\"].string,\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object\n};\nvar defaultProps$p = {\n  tag: 'small',\n  color: 'muted'\n};\n\nfunction FormText(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      inline = props.inline,\n      color = props.color,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$n);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, !inline ? 'form-text' : false, color ? \"text-\" + color : false), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nFormText.propTypes = propTypes$q;\nFormText.defaultProps = defaultProps$p;\n\nvar _excluded$m = [\"className\", \"cssModule\", \"type\", \"bsSize\", \"valid\", \"invalid\", \"tag\", \"addon\", \"plaintext\", \"innerRef\"];\nvar propTypes$p = {\n  children: PropTypes__default[\"default\"].node,\n  type: PropTypes__default[\"default\"].string,\n  size: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].number, PropTypes__default[\"default\"].string]),\n  bsSize: PropTypes__default[\"default\"].string,\n  valid: PropTypes__default[\"default\"].bool,\n  invalid: PropTypes__default[\"default\"].bool,\n  tag: tagPropType,\n  innerRef: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].object, PropTypes__default[\"default\"].func, PropTypes__default[\"default\"].string]),\n  plaintext: PropTypes__default[\"default\"].bool,\n  addon: PropTypes__default[\"default\"].bool,\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object\n};\nvar defaultProps$o = {\n  type: 'text'\n};\n\nvar Input = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Input, _React$Component);\n\n  function Input(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    _this.getRef = _this.getRef.bind(_assertThisInitialized(_this));\n    _this.focus = _this.focus.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  var _proto = Input.prototype;\n\n  _proto.getRef = function getRef(ref) {\n    if (this.props.innerRef) {\n      this.props.innerRef(ref);\n    }\n\n    this.ref = ref;\n  };\n\n  _proto.focus = function focus() {\n    if (this.ref) {\n      this.ref.focus();\n    }\n  };\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        className = _this$props.className,\n        cssModule = _this$props.cssModule,\n        type = _this$props.type,\n        bsSize = _this$props.bsSize,\n        valid = _this$props.valid,\n        invalid = _this$props.invalid,\n        tag = _this$props.tag,\n        addon = _this$props.addon,\n        plaintext = _this$props.plaintext,\n        innerRef = _this$props.innerRef,\n        attributes = _objectWithoutPropertiesLoose(_this$props, _excluded$m);\n\n    var checkInput = ['switch', 'radio', 'checkbox'].indexOf(type) > -1;\n    var isNotaNumber = /\\D/g;\n    var textareaInput = type === 'textarea';\n    var selectInput = type === 'select';\n    var rangeInput = type === 'range';\n    var Tag = tag || (selectInput || textareaInput ? type : 'input');\n    var formControlClass = 'form-control';\n\n    if (plaintext) {\n      formControlClass = formControlClass + \"-plaintext\";\n      Tag = tag || 'input';\n    } else if (rangeInput) {\n      formControlClass = 'form-range';\n    } else if (selectInput) {\n      formControlClass = 'form-select';\n    } else if (checkInput) {\n      if (addon) {\n        formControlClass = null;\n      } else {\n        formControlClass = 'form-check-input';\n      }\n    }\n\n    if (attributes.size && isNotaNumber.test(attributes.size)) {\n      warnOnce('Please use the prop \"bsSize\" instead of the \"size\" to bootstrap\\'s input sizing.');\n      bsSize = attributes.size;\n      delete attributes.size;\n    }\n\n    var classes = mapToCssModules(classNames__default[\"default\"](className, invalid && 'is-invalid', valid && 'is-valid', bsSize ? selectInput ? \"form-select-\" + bsSize : \"form-control-\" + bsSize : false, formControlClass), cssModule);\n\n    if (Tag === 'input' || tag && typeof tag === 'function') {\n      attributes.type = type === 'switch' ? 'checkbox' : type;\n    }\n\n    if (attributes.children && !(plaintext || type === 'select' || typeof Tag !== 'string' || Tag === 'select')) {\n      warnOnce(\"Input with a type of \\\"\" + type + \"\\\" cannot have children. Please use \\\"value\\\"/\\\"defaultValue\\\" instead.\");\n      delete attributes.children;\n    }\n\n    return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n      ref: innerRef,\n      className: classes,\n      \"aria-invalid\": invalid\n    }));\n  };\n\n  return Input;\n}(React__default[\"default\"].Component);\n\nInput.propTypes = propTypes$p;\nInput.defaultProps = defaultProps$o;\nvar Input$1 = Input;\n\nvar _excluded$l = [\"className\", \"cssModule\", \"tag\", \"type\", \"size\"];\nvar propTypes$o = {\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Sets size of InputGroup */\n  size: PropTypes__default[\"default\"].string,\n\n  /** Set a custom element for this component */\n  tag: tagPropType,\n  type: PropTypes__default[\"default\"].string\n};\nvar defaultProps$n = {\n  tag: 'div'\n};\n\nfunction InputGroup(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      size = props.size,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$l);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'input-group', size ? \"input-group-\" + size : null), cssModule);\n\n  if (props.type === 'dropdown') {\n    return /*#__PURE__*/React__default[\"default\"].createElement(Dropdown$1, _extends({}, attributes, {\n      className: classes\n    }));\n  }\n\n  return /*#__PURE__*/React__default[\"default\"].createElement(InputGroupContext.Provider, {\n    value: {\n      insideInputGroup: true\n    }\n  }, /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  })));\n}\n\nInputGroup.propTypes = propTypes$o;\nInputGroup.defaultProps = defaultProps$n;\n\nvar _excluded$k = [\"className\", \"cssModule\", \"tag\"];\nvar propTypes$n = {\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Set a custom element for this component */\n  tag: tagPropType\n};\nvar defaultProps$m = {\n  tag: 'span'\n};\n\nfunction InputGroupText(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$k);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'input-group-text'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nInputGroupText.propTypes = propTypes$n;\nInputGroupText.defaultProps = defaultProps$m;\n\nvar _excluded$j = [\"className\", \"cssModule\", \"hidden\", \"widths\", \"tag\", \"check\", \"size\", \"for\"];\nvar colWidths = ['xs', 'sm', 'md', 'lg', 'xl', 'xxl'];\nvar stringOrNumberProp = PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].number, PropTypes__default[\"default\"].string]);\nvar columnProps = PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].bool, PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].number, PropTypes__default[\"default\"].shape({\n  size: stringOrNumberProp,\n  order: stringOrNumberProp,\n  offset: stringOrNumberProp\n})]);\nvar propTypes$m = {\n  children: PropTypes__default[\"default\"].node,\n  hidden: PropTypes__default[\"default\"].bool,\n  check: PropTypes__default[\"default\"].bool,\n  size: PropTypes__default[\"default\"].string,\n  \"for\": PropTypes__default[\"default\"].string,\n  tag: tagPropType,\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object,\n  xs: columnProps,\n  sm: columnProps,\n  md: columnProps,\n  lg: columnProps,\n  xl: columnProps,\n  xxl: columnProps,\n  widths: PropTypes__default[\"default\"].array\n};\nvar defaultProps$l = {\n  tag: 'label',\n  widths: colWidths\n};\n\nvar getColumnSizeClass = function getColumnSizeClass(isXs, colWidth, colSize) {\n  if (colSize === true || colSize === '') {\n    return isXs ? 'col' : \"col-\" + colWidth;\n  }\n\n  if (colSize === 'auto') {\n    return isXs ? 'col-auto' : \"col-\" + colWidth + \"-auto\";\n  }\n\n  return isXs ? \"col-\" + colSize : \"col-\" + colWidth + \"-\" + colSize;\n};\n\nfunction Label(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      hidden = props.hidden,\n      widths = props.widths,\n      Tag = props.tag,\n      check = props.check,\n      size = props.size,\n      htmlFor = props[\"for\"],\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$j);\n\n  var colClasses = [];\n  widths.forEach(function (colWidth, i) {\n    var columnProp = props[colWidth];\n    delete attributes[colWidth];\n\n    if (!columnProp && columnProp !== '') {\n      return;\n    }\n\n    var isXs = !i;\n    var colClass;\n\n    if (isObject(columnProp)) {\n      var _classNames;\n\n      var colSizeInterfix = isXs ? '-' : \"-\" + colWidth + \"-\";\n      colClass = getColumnSizeClass(isXs, colWidth, columnProp.size);\n      colClasses.push(mapToCssModules(classNames__default[\"default\"]((_classNames = {}, _classNames[colClass] = columnProp.size || columnProp.size === '', _classNames[\"order\" + colSizeInterfix + columnProp.order] = columnProp.order || columnProp.order === 0, _classNames[\"offset\" + colSizeInterfix + columnProp.offset] = columnProp.offset || columnProp.offset === 0, _classNames))), cssModule);\n    } else {\n      colClass = getColumnSizeClass(isXs, colWidth, columnProp);\n      colClasses.push(colClass);\n    }\n  });\n  var colFormLabel = size || colClasses.length;\n  var formLabel = !(check || colFormLabel);\n  var classes = mapToCssModules(classNames__default[\"default\"](className, hidden ? 'visually-hidden' : false, check ? 'form-check-label' : false, size ? \"col-form-label-\" + size : false, colClasses, colFormLabel ? 'col-form-label' : false, formLabel ? 'form-label' : false), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({\n    htmlFor: htmlFor\n  }, attributes, {\n    className: classes\n  }));\n}\n\nLabel.propTypes = propTypes$m;\nLabel.defaultProps = defaultProps$l;\n\nvar _excluded$i = [\"body\", \"bottom\", \"className\", \"cssModule\", \"heading\", \"left\", \"list\", \"middle\", \"object\", \"right\", \"tag\", \"top\"];\nvar propTypes$l = {\n  body: PropTypes__default[\"default\"].bool,\n  bottom: PropTypes__default[\"default\"].bool,\n  children: PropTypes__default[\"default\"].node,\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object,\n  heading: PropTypes__default[\"default\"].bool,\n  left: PropTypes__default[\"default\"].bool,\n  list: PropTypes__default[\"default\"].bool,\n  middle: PropTypes__default[\"default\"].bool,\n  object: PropTypes__default[\"default\"].bool,\n  right: PropTypes__default[\"default\"].bool,\n  tag: tagPropType,\n  top: PropTypes__default[\"default\"].bool\n};\n\nfunction Media(props) {\n  var body = props.body,\n      bottom = props.bottom,\n      className = props.className,\n      cssModule = props.cssModule,\n      heading = props.heading,\n      left = props.left,\n      list = props.list,\n      middle = props.middle,\n      object = props.object,\n      right = props.right,\n      tag = props.tag,\n      top = props.top,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$i);\n\n  var defaultTag;\n\n  if (heading) {\n    defaultTag = 'h4';\n  } else if (attributes.href) {\n    defaultTag = 'a';\n  } else if (attributes.src || object) {\n    defaultTag = 'img';\n  } else if (list) {\n    defaultTag = 'ul';\n  } else {\n    defaultTag = 'div';\n  }\n\n  var Tag = tag || defaultTag;\n  var classes = mapToCssModules(classNames__default[\"default\"](className, {\n    'media-body': body,\n    'media-heading': heading,\n    'media-left': left,\n    'media-right': right,\n    'media-top': top,\n    'media-bottom': bottom,\n    'media-middle': middle,\n    'media-object': object,\n    'media-list': list,\n    media: !body && !heading && !left && !right && !top && !bottom && !middle && !object && !list\n  }), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nMedia.propTypes = propTypes$l;\n\nfunction noop() {}\n\nvar FadePropTypes = PropTypes__default[\"default\"].shape(Fade.propTypes);\nvar propTypes$k = {\n  autoFocus: PropTypes__default[\"default\"].bool,\n  backdrop: PropTypes__default[\"default\"].bool,\n  backdropClassName: PropTypes__default[\"default\"].string,\n  backdropTransition: FadePropTypes,\n  children: PropTypes__default[\"default\"].node,\n  className: PropTypes__default[\"default\"].string,\n  container: targetPropType,\n  cssModule: PropTypes__default[\"default\"].object,\n  direction: PropTypes__default[\"default\"].oneOf(['start', 'end', 'bottom', 'top']),\n  fade: PropTypes__default[\"default\"].bool,\n  innerRef: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].object, PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].func]),\n  isOpen: PropTypes__default[\"default\"].bool,\n  keyboard: PropTypes__default[\"default\"].bool,\n  labelledBy: PropTypes__default[\"default\"].string,\n  offcanvasTransition: FadePropTypes,\n  onClosed: PropTypes__default[\"default\"].func,\n  onEnter: PropTypes__default[\"default\"].func,\n  onExit: PropTypes__default[\"default\"].func,\n  style: PropTypes__default[\"default\"].object,\n  onOpened: PropTypes__default[\"default\"].func,\n  returnFocusAfterClose: PropTypes__default[\"default\"].bool,\n  role: PropTypes__default[\"default\"].string,\n  scrollable: PropTypes__default[\"default\"].bool,\n  toggle: PropTypes__default[\"default\"].func,\n  trapFocus: PropTypes__default[\"default\"].bool,\n  unmountOnClose: PropTypes__default[\"default\"].bool,\n  zIndex: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].number, PropTypes__default[\"default\"].string])\n};\nvar propsToOmit = Object.keys(propTypes$k);\nvar defaultProps$k = {\n  isOpen: false,\n  autoFocus: true,\n  direction: 'start',\n  scrollable: false,\n  role: 'dialog',\n  backdrop: true,\n  keyboard: true,\n  zIndex: 1050,\n  fade: true,\n  onOpened: noop,\n  onClosed: noop,\n  offcanvasTransition: {\n    timeout: TransitionTimeouts.Offcanvas\n  },\n  backdropTransition: {\n    mountOnEnter: true,\n    timeout: TransitionTimeouts.Fade // uses standard fade transition\n\n  },\n  unmountOnClose: true,\n  returnFocusAfterClose: true,\n  container: 'body',\n  trapFocus: false\n};\n\nvar Offcanvas = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(Offcanvas, _React$Component);\n\n  function Offcanvas(props) {\n    var _this;\n\n    _this = _React$Component.call(this, props) || this;\n    _this._element = null;\n    _this._originalBodyPadding = null;\n    _this.getFocusableChildren = _this.getFocusableChildren.bind(_assertThisInitialized(_this));\n    _this.handleBackdropClick = _this.handleBackdropClick.bind(_assertThisInitialized(_this));\n    _this.handleBackdropMouseDown = _this.handleBackdropMouseDown.bind(_assertThisInitialized(_this));\n    _this.handleEscape = _this.handleEscape.bind(_assertThisInitialized(_this));\n    _this.handleTab = _this.handleTab.bind(_assertThisInitialized(_this));\n    _this.onOpened = _this.onOpened.bind(_assertThisInitialized(_this));\n    _this.onClosed = _this.onClosed.bind(_assertThisInitialized(_this));\n    _this.manageFocusAfterClose = _this.manageFocusAfterClose.bind(_assertThisInitialized(_this));\n    _this.clearBackdropAnimationTimeout = _this.clearBackdropAnimationTimeout.bind(_assertThisInitialized(_this));\n    _this.trapFocus = _this.trapFocus.bind(_assertThisInitialized(_this));\n    _this.state = {\n      isOpen: false\n    };\n    return _this;\n  }\n\n  var _proto = Offcanvas.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    var _this$props = this.props,\n        isOpen = _this$props.isOpen,\n        autoFocus = _this$props.autoFocus,\n        onEnter = _this$props.onEnter;\n\n    if (isOpen) {\n      this.init();\n      this.setState({\n        isOpen: true\n      });\n\n      if (autoFocus) {\n        this.setFocus();\n      }\n    }\n\n    if (onEnter) {\n      onEnter();\n    } // traps focus inside the Offcanvas, even if the browser address bar is focused\n\n\n    document.addEventListener('focus', this.trapFocus, true);\n    this._isMounted = true;\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    if (this.props.isOpen && !prevProps.isOpen) {\n      this.init();\n      this.setState({\n        isOpen: true\n      });\n      return;\n    } // now Offcanvas Dialog is rendered and we can refer this._element and this._dialog\n\n\n    if (this.props.autoFocus && this.state.isOpen && !prevState.isOpen) {\n      this.setFocus();\n    }\n\n    if (this._element && prevProps.zIndex !== this.props.zIndex) {\n      this._element.style.zIndex = this.props.zIndex;\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.clearBackdropAnimationTimeout();\n\n    if (this.props.onExit) {\n      this.props.onExit();\n    }\n\n    if (this._element) {\n      this.destroy();\n\n      if (this.props.isOpen || this.state.isOpen) {\n        this.close();\n      }\n    }\n\n    document.removeEventListener('focus', this.trapFocus, true);\n    this._isMounted = false;\n  } // not mouseUp because scrollbar fires it, shouldn't close when user scrolls\n  ;\n\n  _proto.handleBackdropClick = function handleBackdropClick(e) {\n    if (e.target === this._mouseDownElement) {\n      e.stopPropagation();\n      var backdrop = this._backdrop;\n      if (!this.props.isOpen || this.props.backdrop !== true) return;\n\n      if (backdrop && e.target === backdrop && this.props.toggle) {\n        this.props.toggle(e);\n      }\n    }\n  };\n\n  _proto.handleTab = function handleTab(e) {\n    if (e.which !== 9) return;\n    if (this.offcanvasIndex < Offcanvas.openCount - 1) return; // last opened offcanvas\n\n    var focusableChildren = this.getFocusableChildren();\n    var totalFocusable = focusableChildren.length;\n    if (totalFocusable === 0) return;\n    var currentFocus = this.getFocusedChild();\n    var focusedIndex = 0;\n\n    for (var i = 0; i < totalFocusable; i += 1) {\n      if (focusableChildren[i] === currentFocus) {\n        focusedIndex = i;\n        break;\n      }\n    }\n\n    if (e.shiftKey && focusedIndex === 0) {\n      e.preventDefault();\n      focusableChildren[totalFocusable - 1].focus();\n    } else if (!e.shiftKey && focusedIndex === totalFocusable - 1) {\n      e.preventDefault();\n      focusableChildren[0].focus();\n    }\n  };\n\n  _proto.handleBackdropMouseDown = function handleBackdropMouseDown(e) {\n    this._mouseDownElement = e.target;\n  };\n\n  _proto.handleEscape = function handleEscape(e) {\n    if (this.props.isOpen && e.keyCode === keyCodes.esc && this.props.toggle) {\n      if (this.props.keyboard) {\n        e.preventDefault();\n        e.stopPropagation();\n        this.props.toggle(e);\n      }\n    }\n  };\n\n  _proto.onOpened = function onOpened(node, isAppearing) {\n    this.props.onOpened();\n    (this.props.offcanvasTransition.onEntered || noop)(node, isAppearing);\n  };\n\n  _proto.onClosed = function onClosed(node) {\n    var unmountOnClose = this.props.unmountOnClose; // so all methods get called before it is unmounted\n\n    this.props.onClosed();\n    (this.props.offcanvasTransition.onExited || noop)(node);\n\n    if (unmountOnClose) {\n      this.destroy();\n    }\n\n    this.close();\n\n    if (this._isMounted) {\n      this.setState({\n        isOpen: false\n      });\n    }\n  };\n\n  _proto.setFocus = function setFocus() {\n    if (this._dialog && typeof this._dialog.focus === 'function') {\n      this._dialog.focus();\n    }\n  };\n\n  _proto.getFocusableChildren = function getFocusableChildren() {\n    return this._element.querySelectorAll(focusableElements.join(', '));\n  };\n\n  _proto.getFocusedChild = function getFocusedChild() {\n    var currentFocus;\n    var focusableChildren = this.getFocusableChildren();\n\n    try {\n      currentFocus = document.activeElement;\n    } catch (err) {\n      currentFocus = focusableChildren[0];\n    }\n\n    return currentFocus;\n  };\n\n  _proto.trapFocus = function trapFocus(ev) {\n    if (!this.props.trapFocus) {\n      return;\n    }\n\n    if (!this._element) {\n      // element is not attached\n      return;\n    }\n\n    if (this._dialog === ev.target) {\n      // initial focus when the Offcanvas is opened\n      return;\n    }\n\n    if (this.offcanvasIndex < Offcanvas.openCount - 1) {\n      // last opened offcanvas\n      return;\n    }\n\n    var children = this.getFocusableChildren();\n\n    for (var i = 0; i < children.length; i += 1) {\n      // focus is already inside the Offcanvas\n      if (children[i] === ev.target) return;\n    }\n\n    if (children.length > 0) {\n      // otherwise focus the first focusable element in the Offcanvas\n      ev.preventDefault();\n      ev.stopPropagation();\n      children[0].focus();\n    }\n  };\n\n  _proto.init = function init() {\n    try {\n      this._triggeringElement = document.activeElement;\n    } catch (err) {\n      this._triggeringElement = null;\n    }\n\n    if (!this._element) {\n      this._element = document.createElement('div');\n\n      this._element.setAttribute('tabindex', '-1');\n\n      this._element.style.position = 'relative';\n      this._element.style.zIndex = this.props.zIndex;\n      this._mountContainer = getTarget(this.props.container);\n\n      this._mountContainer.appendChild(this._element);\n    }\n\n    this._originalBodyPadding = getOriginalBodyPadding();\n    conditionallyUpdateScrollbar();\n\n    if (Offcanvas.openCount === 0 && this.props.backdrop && !this.props.scrollable) {\n      document.body.style.overflow = 'hidden';\n    }\n\n    this.offcanvasIndex = Offcanvas.openCount;\n    Offcanvas.openCount += 1;\n  };\n\n  _proto.destroy = function destroy() {\n    if (this._element) {\n      this._mountContainer.removeChild(this._element);\n\n      this._element = null;\n    }\n\n    this.manageFocusAfterClose();\n  };\n\n  _proto.manageFocusAfterClose = function manageFocusAfterClose() {\n    if (this._triggeringElement) {\n      var returnFocusAfterClose = this.props.returnFocusAfterClose;\n      if (this._triggeringElement.focus && returnFocusAfterClose) this._triggeringElement.focus();\n      this._triggeringElement = null;\n    }\n  };\n\n  _proto.close = function close() {\n    this.manageFocusAfterClose();\n    Offcanvas.openCount = Math.max(0, Offcanvas.openCount - 1);\n    document.body.style.overflow = null;\n    setScrollbarWidth(this._originalBodyPadding);\n  };\n\n  _proto.clearBackdropAnimationTimeout = function clearBackdropAnimationTimeout() {\n    if (this._backdropAnimationTimeout) {\n      clearTimeout(this._backdropAnimationTimeout);\n      this._backdropAnimationTimeout = undefined;\n    }\n  };\n\n  _proto.render = function render() {\n    var _this2 = this;\n\n    var _this$props2 = this.props,\n        direction = _this$props2.direction,\n        unmountOnClose = _this$props2.unmountOnClose;\n\n    if (!!this._element && (this.state.isOpen || !unmountOnClose)) {\n      var isOffcanvasHidden = !!this._element && !this.state.isOpen && !unmountOnClose;\n      this._element.style.display = isOffcanvasHidden ? 'none' : 'block';\n      var _this$props3 = this.props,\n          className = _this$props3.className,\n          backdropClassName = _this$props3.backdropClassName,\n          cssModule = _this$props3.cssModule,\n          isOpen = _this$props3.isOpen,\n          backdrop = _this$props3.backdrop,\n          role = _this$props3.role,\n          labelledBy = _this$props3.labelledBy,\n          style = _this$props3.style;\n      var offcanvasAttributes = {\n        onKeyUp: this.handleEscape,\n        onKeyDown: this.handleTab,\n        'aria-labelledby': labelledBy,\n        role: role,\n        tabIndex: '-1'\n      };\n      var hasTransition = this.props.fade;\n\n      var offcanvasTransition = _objectSpread2(_objectSpread2(_objectSpread2({}, Fade.defaultProps), this.props.offcanvasTransition), {}, {\n        baseClass: hasTransition ? this.props.offcanvasTransition.baseClass : '',\n        timeout: hasTransition ? this.props.offcanvasTransition.timeout : 0\n      });\n\n      var backdropTransition = _objectSpread2(_objectSpread2(_objectSpread2({}, Fade.defaultProps), this.props.backdropTransition), {}, {\n        baseClass: hasTransition ? this.props.backdropTransition.baseClass : '',\n        timeout: hasTransition ? this.props.backdropTransition.timeout : 0\n      });\n\n      var Backdrop = backdrop && (hasTransition ? /*#__PURE__*/React__default[\"default\"].createElement(Fade, _extends({}, backdropTransition, {\n        \"in\": isOpen && !!backdrop,\n        innerRef: function innerRef(c) {\n          _this2._backdrop = c;\n        },\n        cssModule: cssModule,\n        className: mapToCssModules(classNames__default[\"default\"]('offcanvas-backdrop', backdropClassName), cssModule),\n        onClick: this.handleBackdropClick,\n        onMouseDown: this.handleBackdropMouseDown\n      })) : /*#__PURE__*/React__default[\"default\"].createElement(\"div\", {\n        className: mapToCssModules(classNames__default[\"default\"]('offcanvas-backdrop', 'show', backdropClassName), cssModule),\n        onClick: this.handleBackdropClick,\n        onMouseDown: this.handleBackdropMouseDown\n      }));\n      var attributes = omit(this.props, propsToOmit);\n      return /*#__PURE__*/React__default[\"default\"].createElement(Portal$1, {\n        node: this._element\n      }, /*#__PURE__*/React__default[\"default\"].createElement(Fade, _extends({}, attributes, offcanvasAttributes, offcanvasTransition, {\n        \"in\": isOpen,\n        onEntered: this.onOpened,\n        onExited: this.onClosed,\n        cssModule: cssModule,\n        className: mapToCssModules(classNames__default[\"default\"]('offcanvas', className, \"offcanvas-\" + direction), cssModule),\n        innerRef: function innerRef(c) {\n          _this2._dialog = c;\n        },\n        style: _objectSpread2(_objectSpread2({}, style), {}, {\n          visibility: isOpen ? 'visible' : 'hidden'\n        })\n      }), this.props.children), Backdrop);\n    }\n\n    return null;\n  };\n\n  return Offcanvas;\n}(React__default[\"default\"].Component);\n\nOffcanvas.propTypes = propTypes$k;\nOffcanvas.defaultProps = defaultProps$k;\nOffcanvas.openCount = 0;\nvar Offcanvas$1 = Offcanvas;\n\nvar _excluded$h = [\"className\", \"cssModule\", \"tag\"];\nvar propTypes$j = {\n  tag: tagPropType,\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object\n};\nvar defaultProps$j = {\n  tag: 'div'\n};\n\nfunction OffcanvasBody(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$h);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'offcanvas-body'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nOffcanvasBody.propTypes = propTypes$j;\nOffcanvasBody.defaultProps = defaultProps$j;\n\nvar _excluded$g = [\"children\", \"className\", \"close\", \"closeAriaLabel\", \"cssModule\", \"tag\", \"toggle\", \"wrapTag\"];\nvar propTypes$i = {\n  children: PropTypes__default[\"default\"].node,\n  className: PropTypes__default[\"default\"].string,\n  close: PropTypes__default[\"default\"].object,\n  closeAriaLabel: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object,\n  tag: tagPropType,\n  toggle: PropTypes__default[\"default\"].func,\n  wrapTag: tagPropType\n};\nvar defaultProps$i = {\n  closeAriaLabel: 'Close',\n  tag: 'h5',\n  wrapTag: 'div'\n};\n\nfunction OffcanvasHeader(props) {\n  var closeButton;\n\n  var children = props.children,\n      className = props.className,\n      close = props.close,\n      closeAriaLabel = props.closeAriaLabel,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      toggle = props.toggle,\n      WrapTag = props.wrapTag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$g);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'offcanvas-header'), cssModule);\n\n  if (!close && toggle) {\n    closeButton = /*#__PURE__*/React__default[\"default\"].createElement(\"button\", {\n      type: \"button\",\n      onClick: toggle,\n      className: mapToCssModules('btn-close', cssModule),\n      \"aria-label\": closeAriaLabel\n    });\n  }\n\n  return /*#__PURE__*/React__default[\"default\"].createElement(WrapTag, _extends({}, attributes, {\n    className: classes\n  }), /*#__PURE__*/React__default[\"default\"].createElement(Tag, {\n    className: mapToCssModules('offcanvas-title', cssModule)\n  }, children), close || closeButton);\n}\n\nOffcanvasHeader.propTypes = propTypes$i;\nOffcanvasHeader.defaultProps = defaultProps$i;\n\nvar _excluded$f = [\"className\", \"listClassName\", \"cssModule\", \"size\", \"tag\", \"listTag\", \"aria-label\"];\nvar propTypes$h = {\n  children: PropTypes__default[\"default\"].node,\n\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Add custom class for list */\n  listClassName: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Make the Pagination bigger or smaller  */\n  size: PropTypes__default[\"default\"].string,\n\n  /** Set a custom element for this component */\n  tag: tagPropType,\n\n  /** Set a custom element for list component */\n  listTag: tagPropType,\n  'aria-label': PropTypes__default[\"default\"].string\n};\nvar defaultProps$h = {\n  tag: 'nav',\n  listTag: 'ul',\n  'aria-label': 'pagination'\n};\n\nfunction Pagination(props) {\n  var _classNames;\n\n  var className = props.className,\n      listClassName = props.listClassName,\n      cssModule = props.cssModule,\n      size = props.size,\n      Tag = props.tag,\n      ListTag = props.listTag,\n      label = props['aria-label'],\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$f);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className), cssModule);\n  var listClasses = mapToCssModules(classNames__default[\"default\"](listClassName, 'pagination', (_classNames = {}, _classNames[\"pagination-\" + size] = !!size, _classNames)), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, {\n    className: classes,\n    \"aria-label\": label\n  }, /*#__PURE__*/React__default[\"default\"].createElement(ListTag, _extends({}, attributes, {\n    className: listClasses\n  })));\n}\n\nPagination.propTypes = propTypes$h;\nPagination.defaultProps = defaultProps$h;\n\nvar _excluded$e = [\"active\", \"className\", \"cssModule\", \"disabled\", \"tag\"];\nvar propTypes$g = {\n  /** Set item as active */\n  active: PropTypes__default[\"default\"].bool,\n  children: PropTypes__default[\"default\"].node,\n\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Set item as disabled */\n  disabled: PropTypes__default[\"default\"].bool,\n\n  /** Set a custom element for this component */\n  tag: tagPropType\n};\nvar defaultProps$g = {\n  tag: 'li'\n};\n\nfunction PaginationItem(props) {\n  var active = props.active,\n      className = props.className,\n      cssModule = props.cssModule,\n      disabled = props.disabled,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$e);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'page-item', {\n    active: active,\n    disabled: disabled\n  }), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nPaginationItem.propTypes = propTypes$g;\nPaginationItem.defaultProps = defaultProps$g;\n\nvar _excluded$d = [\"className\", \"cssModule\", \"next\", \"previous\", \"first\", \"last\", \"tag\"];\nvar propTypes$f = {\n  'aria-label': PropTypes__default[\"default\"].string,\n  children: PropTypes__default[\"default\"].node,\n\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Add to next button to add default aria label and icon */\n  next: PropTypes__default[\"default\"].bool,\n\n  /** Add to previous button to add default aria label and icon */\n  previous: PropTypes__default[\"default\"].bool,\n\n  /** Add to first button to add default aria label and icon */\n  first: PropTypes__default[\"default\"].bool,\n\n  /** Add to last button to add default aria label and icon */\n  last: PropTypes__default[\"default\"].bool,\n\n  /** Set a custom element for this component */\n  tag: tagPropType\n};\nvar defaultProps$f = {\n  tag: 'a'\n};\n\nfunction PaginationLink(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      next = props.next,\n      previous = props.previous,\n      first = props.first,\n      last = props.last,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$d);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'page-link'), cssModule);\n  var defaultAriaLabel;\n\n  if (previous) {\n    defaultAriaLabel = 'Previous';\n  } else if (next) {\n    defaultAriaLabel = 'Next';\n  } else if (first) {\n    defaultAriaLabel = 'First';\n  } else if (last) {\n    defaultAriaLabel = 'Last';\n  }\n\n  var ariaLabel = props['aria-label'] || defaultAriaLabel;\n  var defaultCaret;\n\n  if (previous) {\n    defaultCaret = \"\\u2039\";\n  } else if (next) {\n    defaultCaret = \"\\u203A\";\n  } else if (first) {\n    defaultCaret = \"\\xAB\";\n  } else if (last) {\n    defaultCaret = \"\\xBB\";\n  }\n\n  var children = props.children;\n\n  if (children && Array.isArray(children) && children.length === 0) {\n    children = null;\n  }\n\n  if (!attributes.href && Tag === 'a') {\n    Tag = 'button';\n  }\n\n  if (previous || next || first || last) {\n    children = [/*#__PURE__*/React__default[\"default\"].createElement(\"span\", {\n      \"aria-hidden\": \"true\",\n      key: \"caret\"\n    }, children || defaultCaret), /*#__PURE__*/React__default[\"default\"].createElement(\"span\", {\n      className: \"visually-hidden\",\n      key: \"ariaLabel\"\n    }, ariaLabel)];\n  }\n\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes,\n    \"aria-label\": ariaLabel\n  }), children);\n}\n\nPaginationLink.propTypes = propTypes$f;\nPaginationLink.defaultProps = defaultProps$f;\n\n/**\n * TabContext\n * {\n *  activeTabId: PropTypes.any\n * }\n */\n\nvar TabContext = React__default[\"default\"].createContext({});\n\nvar propTypes$e = {\n  tag: tagPropType,\n  activeTab: PropTypes__default[\"default\"].any,\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object\n};\nvar defaultProps$e = {\n  tag: 'div'\n};\n\nvar TabContent = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(TabContent, _Component);\n\n  TabContent.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n    if (prevState.activeTab !== nextProps.activeTab) {\n      return {\n        activeTab: nextProps.activeTab\n      };\n    }\n\n    return null;\n  };\n\n  function TabContent(props) {\n    var _this;\n\n    _this = _Component.call(this, props) || this;\n    _this.state = {\n      activeTab: _this.props.activeTab\n    };\n    return _this;\n  }\n\n  var _proto = TabContent.prototype;\n\n  _proto.render = function render() {\n    var _this$props = this.props,\n        className = _this$props.className,\n        cssModule = _this$props.cssModule,\n        Tag = _this$props.tag;\n    var attributes = omit(this.props, Object.keys(propTypes$e));\n    var classes = mapToCssModules(classNames__default[\"default\"]('tab-content', className), cssModule);\n    return /*#__PURE__*/React__default[\"default\"].createElement(TabContext.Provider, {\n      value: {\n        activeTabId: this.state.activeTab\n      }\n    }, /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n      className: classes\n    })));\n  };\n\n  return TabContent;\n}(React.Component);\n\nvar TabContent$1 = TabContent;\nTabContent.propTypes = propTypes$e;\nTabContent.defaultProps = defaultProps$e;\n\nvar _excluded$c = [\"className\", \"cssModule\", \"tabId\", \"tag\"];\nvar propTypes$d = {\n  tag: tagPropType,\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object,\n  tabId: PropTypes__default[\"default\"].any\n};\nvar defaultProps$d = {\n  tag: 'div'\n};\nfunction TabPane(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      tabId = props.tabId,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$c);\n\n  var getClasses = function getClasses(activeTabId) {\n    return mapToCssModules(classNames__default[\"default\"]('tab-pane', className, {\n      active: tabId === activeTabId\n    }), cssModule);\n  };\n\n  return /*#__PURE__*/React__default[\"default\"].createElement(TabContext.Consumer, null, function (_ref) {\n    var activeTabId = _ref.activeTabId;\n    return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n      className: getClasses(activeTabId)\n    }));\n  });\n}\nTabPane.propTypes = propTypes$d;\nTabPane.defaultProps = defaultProps$d;\n\nvar _excluded$b = [\"className\", \"closeClassName\", \"closeAriaLabel\", \"cssModule\", \"tag\", \"color\", \"isOpen\", \"toggle\", \"children\", \"transition\", \"fade\", \"innerRef\"];\nvar propTypes$c = {\n  /** Pass children so this component can wrap the child elements */\n  children: PropTypes__default[\"default\"].node,\n\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Add custom class for close button */\n  closeClassName: PropTypes__default[\"default\"].string,\n\n  /** Aria label for close button */\n  closeAriaLabel: PropTypes__default[\"default\"].string,\n\n  /** Change color of alert */\n  color: PropTypes__default[\"default\"].string,\n\n  /** Change existing className with a new className */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Toggle fade animation */\n  fade: PropTypes__default[\"default\"].bool,\n  innerRef: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].object, PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].func]),\n\n  /** Control visibility state of Alert */\n  isOpen: PropTypes__default[\"default\"].bool,\n\n  /** Set a custom element for this component */\n  tag: tagPropType,\n\n  /** Function to toggle visibility */\n  toggle: PropTypes__default[\"default\"].func,\n\n  /** Props to be passed to `Fade` to modify transition */\n  transition: PropTypes__default[\"default\"].shape(Fade.propTypes)\n};\nvar defaultProps$c = {\n  color: 'success',\n  isOpen: true,\n  tag: 'div',\n  closeAriaLabel: 'Close',\n  fade: true,\n  transition: _objectSpread2(_objectSpread2({}, Fade.defaultProps), {}, {\n    unmountOnExit: true\n  })\n};\n\nfunction Alert(props) {\n  var className = props.className,\n      closeClassName = props.closeClassName,\n      closeAriaLabel = props.closeAriaLabel,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      color = props.color,\n      isOpen = props.isOpen,\n      toggle = props.toggle,\n      children = props.children,\n      transition = props.transition,\n      fade = props.fade,\n      innerRef = props.innerRef,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$b);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'alert', \"alert-\" + color, {\n    'alert-dismissible': toggle\n  }), cssModule);\n  var closeClasses = mapToCssModules(classNames__default[\"default\"]('btn-close', closeClassName), cssModule);\n\n  var alertTransition = _objectSpread2(_objectSpread2(_objectSpread2({}, Fade.defaultProps), transition), {}, {\n    baseClass: fade ? transition.baseClass : '',\n    timeout: fade ? transition.timeout : 0\n  });\n\n  return /*#__PURE__*/React__default[\"default\"].createElement(Fade, _extends({}, attributes, alertTransition, {\n    tag: Tag,\n    className: classes,\n    \"in\": isOpen,\n    role: \"alert\",\n    innerRef: innerRef\n  }), toggle ? /*#__PURE__*/React__default[\"default\"].createElement(\"button\", {\n    type: \"button\",\n    className: closeClasses,\n    \"aria-label\": closeAriaLabel,\n    onClick: toggle\n  }) : null, children);\n}\n\nAlert.propTypes = propTypes$c;\nAlert.defaultProps = defaultProps$c;\n\nvar _excluded$a = [\"className\", \"cssModule\", \"tag\", \"isOpen\", \"children\", \"transition\", \"fade\", \"innerRef\"];\nvar propTypes$b = {\n  children: PropTypes__default[\"default\"].node,\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object,\n  fade: PropTypes__default[\"default\"].bool,\n  isOpen: PropTypes__default[\"default\"].bool,\n  tag: tagPropType,\n  transition: PropTypes__default[\"default\"].shape(Fade.propTypes),\n  innerRef: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].object, PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].func])\n};\nvar defaultProps$b = {\n  isOpen: true,\n  tag: 'div',\n  fade: true,\n  transition: _objectSpread2(_objectSpread2({}, Fade.defaultProps), {}, {\n    unmountOnExit: true\n  })\n};\n\nfunction Toast(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      isOpen = props.isOpen,\n      children = props.children,\n      transition = props.transition,\n      fade = props.fade,\n      innerRef = props.innerRef,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$a);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'toast'), cssModule);\n\n  var toastTransition = _objectSpread2(_objectSpread2(_objectSpread2({}, Fade.defaultProps), transition), {}, {\n    baseClass: fade ? transition.baseClass : '',\n    timeout: fade ? transition.timeout : 0\n  });\n\n  return /*#__PURE__*/React__default[\"default\"].createElement(Fade, _extends({}, attributes, toastTransition, {\n    tag: Tag,\n    className: classes,\n    \"in\": isOpen,\n    role: \"alert\",\n    innerRef: innerRef\n  }), children);\n}\n\nToast.propTypes = propTypes$b;\nToast.defaultProps = defaultProps$b;\n\nvar _excluded$9 = [\"className\", \"cssModule\", \"innerRef\", \"tag\"];\nvar propTypes$a = {\n  tag: tagPropType,\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object,\n  innerRef: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].object, PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].func])\n};\nvar defaultProps$a = {\n  tag: 'div'\n};\n\nfunction ToastBody(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      innerRef = props.innerRef,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$9);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'toast-body'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes,\n    ref: innerRef\n  }));\n}\n\nToastBody.propTypes = propTypes$a;\nToastBody.defaultProps = defaultProps$a;\n\nvar _excluded$8 = [\"className\", \"cssModule\", \"children\", \"toggle\", \"tag\", \"wrapTag\", \"closeAriaLabel\", \"close\", \"tagClassName\", \"icon\"];\nvar propTypes$9 = {\n  tag: tagPropType,\n  icon: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].node]),\n  wrapTag: tagPropType,\n  toggle: PropTypes__default[\"default\"].func,\n  className: PropTypes__default[\"default\"].string,\n  cssModule: PropTypes__default[\"default\"].object,\n  children: PropTypes__default[\"default\"].node,\n  closeAriaLabel: PropTypes__default[\"default\"].string,\n  charCode: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].number]),\n  close: PropTypes__default[\"default\"].object,\n  tagClassName: PropTypes__default[\"default\"].string\n};\nvar defaultProps$9 = {\n  tag: 'strong',\n  wrapTag: 'div',\n  tagClassName: 'me-auto',\n  closeAriaLabel: 'Close'\n};\n\nfunction ToastHeader(props) {\n  var closeButton;\n  var icon;\n\n  var className = props.className,\n      cssModule = props.cssModule,\n      children = props.children,\n      toggle = props.toggle,\n      Tag = props.tag,\n      WrapTag = props.wrapTag,\n      closeAriaLabel = props.closeAriaLabel,\n      close = props.close,\n      tagClassName = props.tagClassName,\n      iconProp = props.icon,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$8);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'toast-header'), cssModule);\n\n  if (!close && toggle) {\n    closeButton = /*#__PURE__*/React__default[\"default\"].createElement(\"button\", {\n      type: \"button\",\n      onClick: toggle,\n      className: mapToCssModules('btn-close', cssModule),\n      \"aria-label\": closeAriaLabel\n    });\n  }\n\n  if (typeof iconProp === 'string') {\n    icon = /*#__PURE__*/React__default[\"default\"].createElement(\"svg\", {\n      className: mapToCssModules(\"rounded text-\" + iconProp),\n      width: \"20\",\n      height: \"20\",\n      xmlns: \"http://www.w3.org/2000/svg\",\n      preserveAspectRatio: \"xMidYMid slice\",\n      focusable: \"false\",\n      role: \"img\"\n    }, /*#__PURE__*/React__default[\"default\"].createElement(\"rect\", {\n      fill: \"currentColor\",\n      width: \"100%\",\n      height: \"100%\"\n    }));\n  } else if (iconProp) {\n    icon = iconProp;\n  }\n\n  return /*#__PURE__*/React__default[\"default\"].createElement(WrapTag, _extends({}, attributes, {\n    className: classes\n  }), icon, /*#__PURE__*/React__default[\"default\"].createElement(Tag, {\n    className: mapToCssModules(classNames__default[\"default\"](tagClassName, {\n      'ms-2': icon != null\n    }), cssModule)\n  }, children), close || closeButton);\n}\n\nToastHeader.propTypes = propTypes$9;\nToastHeader.defaultProps = defaultProps$9;\n\nvar _excluded$7 = [\"className\", \"cssModule\", \"tag\", \"active\", \"disabled\", \"action\", \"color\"];\nvar propTypes$8 = {\n  /** Add action prop to give effects while hovering over element */\n  action: PropTypes__default[\"default\"].bool,\n\n  /** Add active prop to make the current selection active */\n  active: PropTypes__default[\"default\"].bool,\n\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Add background colour to the list item */\n  color: PropTypes__default[\"default\"].string,\n\n  /** Make the list item appear disabled */\n  disabled: PropTypes__default[\"default\"].bool,\n\n  /** Set a custom element for this component */\n  tag: tagPropType\n};\nvar defaultProps$8 = {\n  tag: 'li'\n};\n\nvar handleDisabledOnClick = function handleDisabledOnClick(e) {\n  e.preventDefault();\n};\n\nfunction ListGroupItem(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      active = props.active,\n      disabled = props.disabled,\n      action = props.action,\n      color = props.color,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$7);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, active ? 'active' : false, disabled ? 'disabled' : false, action ? 'list-group-item-action' : false, color ? \"list-group-item-\" + color : false, 'list-group-item'), cssModule); // Prevent click event when disabled.\n\n  if (disabled) {\n    attributes.onClick = handleDisabledOnClick;\n  }\n\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nListGroupItem.propTypes = propTypes$8;\nListGroupItem.defaultProps = defaultProps$8;\n\nvar _excluded$6 = [\"className\", \"cssModule\", \"tag\"];\nvar propTypes$7 = {\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Set a custom element for this component */\n  tag: tagPropType\n};\nvar defaultProps$7 = {\n  tag: 'h5'\n};\n\nfunction ListGroupItemHeading(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$6);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'list-group-item-heading'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nListGroupItemHeading.propTypes = propTypes$7;\nListGroupItemHeading.defaultProps = defaultProps$7;\n\nvar _excluded$5 = [\"className\", \"cssModule\", \"tag\"];\nvar propTypes$6 = {\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Set a custom element for this component */\n  tag: tagPropType\n};\nvar defaultProps$6 = {\n  tag: 'p'\n};\n\nfunction ListGroupItemText(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$5);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'list-group-item-text'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes\n  }));\n}\n\nListGroupItemText.propTypes = propTypes$6;\nListGroupItemText.defaultProps = defaultProps$6;\n\nvar _excluded$4 = [\"className\", \"cssModule\", \"tag\", \"type\"];\nvar propTypes$5 = {\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Set a custom element for this component */\n  tag: tagPropType,\n\n  /** Type of list `unstyled` or `inline` */\n  type: PropTypes__default[\"default\"].string\n};\nvar defaultProps$5 = {\n  tag: 'ul'\n};\nvar List = React.forwardRef(function (props, ref) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      type = props.type,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$4);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, type ? \"list-\" + type : false), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes,\n    ref: ref\n  }));\n});\nList.name = 'List';\nList.propTypes = propTypes$5;\nList.defaultProps = defaultProps$5;\nvar List$1 = List;\n\nvar _excluded$3 = [\"className\", \"cssModule\", \"tag\"];\nvar propTypes$4 = {\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change underlying component's CSS base class name */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Set a custom element for this component */\n  tag: tagPropType\n};\nvar defaultProps$4 = {\n  tag: 'li'\n};\nvar ListInlineItem = React.forwardRef(function (props, ref) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$3);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, 'list-inline-item'), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, attributes, {\n    className: classes,\n    ref: ref\n  }));\n});\nListInlineItem.name = 'ListInlineItem';\nListInlineItem.propTypes = propTypes$4;\nListInlineItem.defaultProps = defaultProps$4;\nvar ListInlineItem$1 = ListInlineItem;\n\nvar UncontrolledAlert = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(UncontrolledAlert, _Component);\n\n  function UncontrolledAlert(props) {\n    var _this;\n\n    _this = _Component.call(this, props) || this;\n    _this.state = {\n      isOpen: true\n    };\n    _this.toggle = _this.toggle.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  var _proto = UncontrolledAlert.prototype;\n\n  _proto.toggle = function toggle() {\n    this.setState(function (prevState) {\n      return {\n        isOpen: !prevState.isOpen\n      };\n    });\n  };\n\n  _proto.render = function render() {\n    return /*#__PURE__*/React__default[\"default\"].createElement(Alert, _extends({\n      isOpen: this.state.isOpen,\n      toggle: this.toggle\n    }, this.props));\n  };\n\n  return UncontrolledAlert;\n}(React.Component);\n\nvar UncontrolledAlert$1 = UncontrolledAlert;\n\nvar omitKeys$3 = ['defaultOpen'];\n\nvar UncontrolledButtonDropdown = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(UncontrolledButtonDropdown, _Component);\n\n  function UncontrolledButtonDropdown(props) {\n    var _this;\n\n    _this = _Component.call(this, props) || this;\n    _this.state = {\n      isOpen: props.defaultOpen || false\n    };\n    _this.toggle = _this.toggle.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  var _proto = UncontrolledButtonDropdown.prototype;\n\n  _proto.toggle = function toggle() {\n    this.setState(function (prevState) {\n      return {\n        isOpen: !prevState.isOpen\n      };\n    });\n  };\n\n  _proto.render = function render() {\n    return /*#__PURE__*/React__default[\"default\"].createElement(ButtonDropdown, _extends({\n      isOpen: this.state.isOpen,\n      toggle: this.toggle\n    }, omit(this.props, omitKeys$3)));\n  };\n\n  return UncontrolledButtonDropdown;\n}(React.Component);\nUncontrolledButtonDropdown.propTypes = _objectSpread2({\n  defaultOpen: PropTypes__default[\"default\"].bool\n}, ButtonDropdown.propTypes);\n\nvar omitKeys$2 = ['toggleEvents', 'defaultOpen'];\nvar propTypes$3 = {\n  /** set if Collapse is open by default */\n  defaultOpen: PropTypes__default[\"default\"].bool,\n\n  /** id of the element that should trigger toggle */\n  toggler: PropTypes__default[\"default\"].string.isRequired,\n\n  /** Events that should trigger the toggle */\n  toggleEvents: PropTypes__default[\"default\"].arrayOf(PropTypes__default[\"default\"].string)\n};\nvar defaultProps$3 = {\n  toggleEvents: defaultToggleEvents\n};\n\nvar UncontrolledCollapse = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(UncontrolledCollapse, _Component);\n\n  function UncontrolledCollapse(props) {\n    var _this;\n\n    _this = _Component.call(this, props) || this;\n    _this.togglers = null;\n    _this.removeEventListeners = null;\n    _this.toggle = _this.toggle.bind(_assertThisInitialized(_this));\n    _this.state = {\n      isOpen: props.defaultOpen || false\n    };\n    return _this;\n  }\n\n  var _proto = UncontrolledCollapse.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.togglers = findDOMElements(this.props.toggler);\n\n    if (this.togglers.length) {\n      this.removeEventListeners = addMultipleEventListeners(this.togglers, this.toggle, this.props.toggleEvents);\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    if (this.togglers.length && this.removeEventListeners) {\n      this.removeEventListeners();\n    }\n  };\n\n  _proto.toggle = function toggle(e) {\n    this.setState(function (_ref) {\n      var isOpen = _ref.isOpen;\n      return {\n        isOpen: !isOpen\n      };\n    });\n    e.preventDefault();\n  };\n\n  _proto.render = function render() {\n    return /*#__PURE__*/React__default[\"default\"].createElement(Collapse$1, _extends({\n      isOpen: this.state.isOpen\n    }, omit(this.props, omitKeys$2)));\n  };\n\n  return UncontrolledCollapse;\n}(React.Component);\n\nUncontrolledCollapse.propTypes = propTypes$3;\nUncontrolledCollapse.defaultProps = defaultProps$3;\nvar UncontrolledCollapse$1 = UncontrolledCollapse;\n\nvar omitKeys$1 = ['defaultOpen'];\n\nvar UncontrolledDropdown = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(UncontrolledDropdown, _Component);\n\n  function UncontrolledDropdown(props) {\n    var _this;\n\n    _this = _Component.call(this, props) || this;\n    _this.state = {\n      isOpen: props.defaultOpen || false\n    };\n    _this.toggle = _this.toggle.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  var _proto = UncontrolledDropdown.prototype;\n\n  _proto.toggle = function toggle(e) {\n    var _this2 = this;\n\n    this.setState(function (prevState) {\n      return {\n        isOpen: !prevState.isOpen\n      };\n    }, function () {\n      if (_this2.props.onToggle) {\n        _this2.props.onToggle(e, _this2.state.isOpen);\n      }\n    });\n  };\n\n  _proto.render = function render() {\n    return /*#__PURE__*/React__default[\"default\"].createElement(Dropdown$1, _extends({\n      isOpen: this.state.isOpen,\n      toggle: this.toggle\n    }, omit(this.props, omitKeys$1)));\n  };\n\n  return UncontrolledDropdown;\n}(React.Component);\nUncontrolledDropdown.propTypes = _objectSpread2({\n  defaultOpen: PropTypes__default[\"default\"].bool,\n  onToggle: PropTypes__default[\"default\"].func\n}, Dropdown$1.propTypes);\n\nvar omitKeys = ['defaultOpen'];\n\nvar UncontrolledTooltip = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(UncontrolledTooltip, _Component);\n\n  function UncontrolledTooltip(props) {\n    var _this;\n\n    _this = _Component.call(this, props) || this;\n    _this.state = {\n      isOpen: props.defaultOpen || false\n    };\n    _this.toggle = _this.toggle.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  var _proto = UncontrolledTooltip.prototype;\n\n  _proto.toggle = function toggle() {\n    this.setState(function (prevState) {\n      return {\n        isOpen: !prevState.isOpen\n      };\n    });\n  };\n\n  _proto.render = function render() {\n    return /*#__PURE__*/React__default[\"default\"].createElement(Tooltip, _extends({\n      isOpen: this.state.isOpen,\n      toggle: this.toggle\n    }, omit(this.props, omitKeys)));\n  };\n\n  return UncontrolledTooltip;\n}(React.Component);\nUncontrolledTooltip.propTypes = _objectSpread2({\n  defaultOpen: PropTypes__default[\"default\"].bool\n}, Tooltip.propTypes);\n\nvar _excluded$2 = [\"className\", \"cssModule\", \"type\", \"size\", \"color\", \"children\", \"tag\"];\nvar propTypes$2 = {\n  /** Set a custom element for this component */\n  tag: tagPropType,\n\n  /** Change animation of spinner */\n  type: PropTypes__default[\"default\"].oneOf(['border', 'grow']),\n\n  /** Change size of spinner */\n  size: PropTypes__default[\"default\"].oneOf(['sm']),\n\n  /** Change color of spinner */\n  color: PropTypes__default[\"default\"].oneOf(['primary', 'secondary', 'success', 'danger', 'warning', 'info', 'light', 'dark']),\n\n  /** Add custom class */\n  className: PropTypes__default[\"default\"].string,\n\n  /** Change existing className with a new className */\n  cssModule: PropTypes__default[\"default\"].object,\n\n  /** Pass children so this component can wrap the child elements */\n  children: PropTypes__default[\"default\"].string\n};\nvar defaultProps$2 = {\n  tag: 'div',\n  type: 'border',\n  children: 'Loading...'\n};\n\nfunction Spinner(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      type = props.type,\n      size = props.size,\n      color = props.color,\n      children = props.children,\n      Tag = props.tag,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$2);\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, size ? \"spinner-\" + type + \"-\" + size : false, \"spinner-\" + type, color ? \"text-\" + color : false), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({\n    role: \"status\"\n  }, attributes, {\n    className: classes\n  }), children && /*#__PURE__*/React__default[\"default\"].createElement(\"span\", {\n    className: mapToCssModules('visually-hidden', cssModule)\n  }, children));\n}\n\nSpinner.propTypes = propTypes$2;\nSpinner.defaultProps = defaultProps$2;\n\nvar _excluded$1 = [\"className\", \"cssModule\", \"color\", \"innerRef\", \"tag\", \"animation\", \"size\", \"widths\"];\n\nvar propTypes$1 = _objectSpread2(_objectSpread2({}, Col.propTypes), {}, {\n  /** Add custom color to the placeholder */\n  color: PropTypes__default[\"default\"].string,\n\n  /** Add custom tag. */\n  tag: tagPropType,\n\n  /** Apply either `glow` or `wave` animation. */\n  animation: PropTypes__default[\"default\"].oneOf(['glow', 'wave']),\n  innerRef: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].object, PropTypes__default[\"default\"].func, PropTypes__default[\"default\"].string]),\n\n  /** Make the size larger */\n  size: PropTypes__default[\"default\"].oneOf(['lg', 'sm', 'xs'])\n});\n\nvar defaultProps$1 = {\n  tag: 'span'\n};\n\nfunction Placeholder(props) {\n  var className = props.className,\n      cssModule = props.cssModule,\n      color = props.color,\n      innerRef = props.innerRef,\n      Tag = props.tag,\n      animation = props.animation,\n      size = props.size,\n      widths = props.widths,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded$1);\n\n  var _getColumnClasses = getColumnClasses(attributes, cssModule, widths),\n      modifiedAttributes = _getColumnClasses.attributes,\n      colClasses = _getColumnClasses.colClasses;\n\n  var classes = mapToCssModules(classNames__default[\"default\"](className, colClasses, 'placeholder' + (animation ? '-' + animation : ''), size ? 'placeholder-' + size : false, color ? 'bg-' + color : false), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Tag, _extends({}, modifiedAttributes, {\n    className: classes,\n    ref: innerRef\n  }));\n}\n\nPlaceholder.propTypes = propTypes$1;\nPlaceholder.defaultProps = defaultProps$1;\n\nvar _excluded = [\"cssModule\", \"className\", \"tag\"];\nvar propTypes = {\n  size: PropTypes__default[\"default\"].string,\n  color: PropTypes__default[\"default\"].string,\n  outline: PropTypes__default[\"default\"].bool,\n  className: PropTypes__default[\"default\"].string,\n  tag: tagPropType,\n  cssModule: PropTypes__default[\"default\"].object\n};\nvar defaultProps = {\n  color: 'primary',\n  tag: Button\n};\n\nfunction PlaceholderButton(props) {\n  var cssModule = props.cssModule,\n      className = props.className,\n      attributes = _objectWithoutPropertiesLoose(props, _excluded);\n\n  var _getColumnClasses = getColumnClasses(attributes, cssModule),\n      modifiedAttributes = _getColumnClasses.attributes,\n      colClasses = _getColumnClasses.colClasses;\n\n  var classes = mapToCssModules(classNames__default[\"default\"]('placeholder', className, colClasses), cssModule);\n  return /*#__PURE__*/React__default[\"default\"].createElement(Button, _extends({}, modifiedAttributes, {\n    className: classes,\n    disabled: true\n  }));\n}\n\nPlaceholderButton.propTypes = propTypes;\nPlaceholderButton.defaultProps = defaultProps;\n\n(function () {\n  if (typeof window !== 'object' || typeof window.CustomEvent === 'function') return;\n\n  var CustomEvent = function CustomEvent(event, params) {\n    params = params || {\n      bubbles: false,\n      cancelable: false,\n      detail: null\n    };\n    var evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n    return evt;\n  };\n\n  window.CustomEvent = CustomEvent;\n})();\n\n(function () {\n  if (typeof Object.values === 'function') return;\n\n  var values = function values(O) {\n    return Object.keys(O).map(function (key) {\n      return O[key];\n    });\n  };\n\n  Object.values = values;\n})();\n\nvar polyfill = {\n  __proto__: null\n};\n\nexports.Accordion = Accordion;\nexports.AccordionBody = AccordionBody;\nexports.AccordionContext = AccordionContext;\nexports.AccordionHeader = AccordionHeader;\nexports.AccordionItem = AccordionItem;\nexports.Alert = Alert;\nexports.Badge = Badge;\nexports.Breadcrumb = Breadcrumb;\nexports.BreadcrumbItem = BreadcrumbItem;\nexports.Button = Button;\nexports.ButtonDropdown = ButtonDropdown;\nexports.ButtonGroup = ButtonGroup;\nexports.ButtonToggle = ButtonToggle;\nexports.ButtonToolbar = ButtonToolbar;\nexports.Card = Card;\nexports.CardBody = CardBody;\nexports.CardColumns = CardColumns;\nexports.CardDeck = CardDeck;\nexports.CardFooter = CardFooter;\nexports.CardGroup = CardGroup;\nexports.CardHeader = CardHeader;\nexports.CardImg = CardImg;\nexports.CardImgOverlay = CardImgOverlay;\nexports.CardLink = CardLink;\nexports.CardSubtitle = CardSubtitle;\nexports.CardText = CardText;\nexports.CardTitle = CardTitle;\nexports.Carousel = Carousel$1;\nexports.CarouselCaption = CarouselCaption;\nexports.CarouselControl = CarouselControl;\nexports.CarouselIndicators = CarouselIndicators;\nexports.CarouselItem = CarouselItem$1;\nexports.CloseButton = CloseButton;\nexports.Col = Col;\nexports.Collapse = Collapse$1;\nexports.Container = Container;\nexports.Dropdown = Dropdown$1;\nexports.DropdownContext = DropdownContext;\nexports.DropdownItem = DropdownItem$1;\nexports.DropdownMenu = DropdownMenu$1;\nexports.DropdownToggle = DropdownToggle$1;\nexports.Fade = Fade;\nexports.Form = Form$1;\nexports.FormFeedback = FormFeedback;\nexports.FormGroup = FormGroup;\nexports.FormText = FormText;\nexports.Input = Input$1;\nexports.InputGroup = InputGroup;\nexports.InputGroupText = InputGroupText;\nexports.Label = Label;\nexports.List = List$1;\nexports.ListGroup = ListGroup;\nexports.ListGroupItem = ListGroupItem;\nexports.ListGroupItemHeading = ListGroupItemHeading;\nexports.ListGroupItemText = ListGroupItemText;\nexports.ListInlineItem = ListInlineItem$1;\nexports.Media = Media;\nexports.Modal = Modal$1;\nexports.ModalBody = ModalBody;\nexports.ModalFooter = ModalFooter;\nexports.ModalHeader = ModalHeader;\nexports.Nav = Nav;\nexports.NavItem = NavItem;\nexports.NavLink = NavLink$1;\nexports.Navbar = Navbar;\nexports.NavbarBrand = NavbarBrand;\nexports.NavbarText = NavbarText;\nexports.NavbarToggler = NavbarToggler;\nexports.Offcanvas = Offcanvas$1;\nexports.OffcanvasBody = OffcanvasBody;\nexports.OffcanvasHeader = OffcanvasHeader;\nexports.Pagination = Pagination;\nexports.PaginationItem = PaginationItem;\nexports.PaginationLink = PaginationLink;\nexports.Placeholder = Placeholder;\nexports.PlaceholderButton = PlaceholderButton;\nexports.Polyfill = polyfill;\nexports.Popover = Popover;\nexports.PopoverBody = PopoverBody;\nexports.PopoverHeader = PopoverHeader;\nexports.PopperContent = PopperContent$1;\nexports.PopperTargetHelper = PopperTargetHelper;\nexports.Progress = Progress;\nexports.Row = Row;\nexports.Spinner = Spinner;\nexports.TabContent = TabContent$1;\nexports.TabPane = TabPane;\nexports.Table = Table;\nexports.Toast = Toast;\nexports.ToastBody = ToastBody;\nexports.ToastHeader = ToastHeader;\nexports.Tooltip = Tooltip;\nexports.UncontrolledAccordion = UncontrolledAccordion;\nexports.UncontrolledAlert = UncontrolledAlert$1;\nexports.UncontrolledButtonDropdown = UncontrolledButtonDropdown;\nexports.UncontrolledCarousel = UncontrolledCarousel$1;\nexports.UncontrolledCollapse = UncontrolledCollapse$1;\nexports.UncontrolledDropdown = UncontrolledDropdown;\nexports.UncontrolledPopover = UncontrolledPopover;\nexports.UncontrolledTooltip = UncontrolledTooltip;\nexports.Util = utils;\n//# sourceMappingURL=reactstrap.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3RzdHJhcC9kaXN0L3JlYWN0c3RyYXAuY2pzPzgyMjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWSxtQkFBTyxDQUFDLG9CQUFPO0FBQzNCLGdCQUFnQixtQkFBTyxDQUFDLDhCQUFZO0FBQ3BDLGlCQUFpQixtQkFBTyxDQUFDLDhCQUFZO0FBQ3JDLGtCQUFrQixtQkFBTyxDQUFDLGtDQUFjO0FBQ3hDLGVBQWUsbUJBQU8sQ0FBQyw0QkFBVztBQUNsQywyQkFBMkIsbUJBQU8sQ0FBQyxzREFBd0I7O0FBRTNELG9DQUFvQyw0REFBNEQsZ0JBQWdCOztBQUVoSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDLE9BQU87QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEYsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDhFQUE4RTtBQUM5RTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdFQUFnRTs7QUFFaEUsa0VBQWtFOztBQUVsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREOztBQUU1RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQSx1QkFBdUIseUJBQXlCO0FBQ2hEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLEtBQUssdUpBQXVKLG1CQUFtQjtBQUMvSztBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0REFBNEQ7O0FBRTVEO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnRUFBZ0U7O0FBRWhFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRHQUE0RztBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUM7O0FBRUQseURBQXlELGdEQUFnRDtBQUN6RztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRCw0REFBNEQsbURBQW1EO0FBQy9HO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7O0FBRXREO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRzs7QUFFcEc7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSyxFQUFFOztBQUVQO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7O0FBR0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBLDBFQUEwRSxxQ0FBcUM7QUFDL0c7QUFDQTtBQUNBLEtBQUs7O0FBRUwsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRztBQUNsRztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsa0JBQWtCLGdCQUFnQjtBQUM1RjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0ZBQWdGO0FBQ2hGOztBQUVBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxFQUFFOztBQUVUO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0RBQXNEOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1GQUFtRjs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGLHdIQUF3SDtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJFQUEyRSxxREFBcUQ7QUFDaEk7QUFDQTtBQUNBLE9BQU87O0FBRVAsOEVBQThFLHdEQUF3RDtBQUN0STtBQUNBO0FBQ0EsT0FBTzs7QUFFUCx3SEFBd0g7QUFDeEg7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPLHdFQUF3RTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsa0ZBQWtGO0FBQ2xGO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsOEVBQThFO0FBQzlFO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhFQUE4RTtBQUM5RTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1RkFBdUY7QUFDdkY7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHVFQUF1RTtBQUMxRTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCw4RUFBOEU7QUFDOUU7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxrRkFBa0Y7QUFDbEY7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpSEFBaUg7QUFDakg7QUFDQTtBQUNBO0FBQ0EsR0FBRywyRUFBMkU7QUFDOUU7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsOEVBQThFO0FBQzlFO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkRBQTJEOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyx1RUFBdUU7QUFDNUU7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHdCQUF3QjtBQUN0RTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsdUVBQXVFLHFDQUFxQztBQUM1RztBQUNBO0FBQ0EsR0FBRzs7QUFFSCwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3QkFBd0I7QUFDdEU7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUVBQXVFLHFDQUFxQztBQUM1RztBQUNBO0FBQ0EsR0FBRzs7QUFFSCwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxrRkFBa0Y7QUFDbEY7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMFBBQTBQOztBQUUxUDtBQUNBO0FBQ0E7O0FBRUEsOEVBQThFO0FBQzlFO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGtEQUFrRCxvQkFBb0I7QUFDdEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpRkFBaUY7QUFDakY7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3JlYWN0c3RyYXAvZGlzdC9yZWFjdHN0cmFwLmNqcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcycpO1xudmFyIGNsYXNzTmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG52YXIgcmVhY3RQb3BwZXIgPSByZXF1aXJlKCdyZWFjdC1wb3BwZXInKTtcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xudmFyIHJlYWN0VHJhbnNpdGlvbkdyb3VwID0gcmVxdWlyZSgncmVhY3QtdHJhbnNpdGlvbi1ncm91cCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRMZWdhY3kgKGUpIHsgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxudmFyIFJlYWN0X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShSZWFjdCk7XG52YXIgUHJvcFR5cGVzX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShQcm9wVHlwZXMpO1xudmFyIGNsYXNzTmFtZXNfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KGNsYXNzTmFtZXMpO1xudmFyIFJlYWN0RE9NX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShSZWFjdERPTSk7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcblxuICAgIGlmIChlbnVtZXJhYmxlT25seSkge1xuICAgICAgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG5cbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG5cbiAgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxiYXJXaWR0aCgpIHtcbiAgdmFyIHNjcm9sbERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpOyAvLyAubW9kYWwtc2Nyb2xsYmFyLW1lYXN1cmUgc3R5bGVzIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL3Y0LjAuMC1hbHBoYS40L3Njc3MvX21vZGFsLnNjc3MjTDEwNi1MMTEzXG5cbiAgc2Nyb2xsRGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgc2Nyb2xsRGl2LnN0eWxlLnRvcCA9ICctOTk5OXB4JztcbiAgc2Nyb2xsRGl2LnN0eWxlLndpZHRoID0gJzUwcHgnO1xuICBzY3JvbGxEaXYuc3R5bGUuaGVpZ2h0ID0gJzUwcHgnO1xuICBzY3JvbGxEaXYuc3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJztcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JvbGxEaXYpO1xuICB2YXIgc2Nyb2xsYmFyV2lkdGggPSBzY3JvbGxEaXYub2Zmc2V0V2lkdGggLSBzY3JvbGxEaXYuY2xpZW50V2lkdGg7XG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc2Nyb2xsRGl2KTtcbiAgcmV0dXJuIHNjcm9sbGJhcldpZHRoO1xufVxuZnVuY3Rpb24gc2V0U2Nyb2xsYmFyV2lkdGgocGFkZGluZykge1xuICBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCA9IHBhZGRpbmcgPiAwID8gcGFkZGluZyArIFwicHhcIiA6IG51bGw7XG59XG5mdW5jdGlvbiBpc0JvZHlPdmVyZmxvd2luZygpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGggPCB3aW5kb3cuaW5uZXJXaWR0aDtcbn1cbmZ1bmN0aW9uIGdldE9yaWdpbmFsQm9keVBhZGRpbmcoKSB7XG4gIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHksIG51bGwpO1xuICByZXR1cm4gcGFyc2VJbnQoc3R5bGUgJiYgc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy1yaWdodCcpIHx8IDAsIDEwKTtcbn1cbmZ1bmN0aW9uIGNvbmRpdGlvbmFsbHlVcGRhdGVTY3JvbGxiYXIoKSB7XG4gIHZhciBzY3JvbGxiYXJXaWR0aCA9IGdldFNjcm9sbGJhcldpZHRoKCk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL3Y0LjAuMC1hbHBoYS42L2pzL3NyYy9tb2RhbC5qcyNMNDMzXG5cbiAgdmFyIGZpeGVkQ29udGVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5maXhlZC10b3AsIC5maXhlZC1ib3R0b20sIC5pcy1maXhlZCwgLnN0aWNreS10b3AnKVswXTtcbiAgdmFyIGJvZHlQYWRkaW5nID0gZml4ZWRDb250ZW50ID8gcGFyc2VJbnQoZml4ZWRDb250ZW50LnN0eWxlLnBhZGRpbmdSaWdodCB8fCAwLCAxMCkgOiAwO1xuXG4gIGlmIChpc0JvZHlPdmVyZmxvd2luZygpKSB7XG4gICAgc2V0U2Nyb2xsYmFyV2lkdGgoYm9keVBhZGRpbmcgKyBzY3JvbGxiYXJXaWR0aCk7XG4gIH1cbn1cbnZhciBnbG9iYWxDc3NNb2R1bGU7XG5mdW5jdGlvbiBzZXRHbG9iYWxDc3NNb2R1bGUoY3NzTW9kdWxlKSB7XG4gIGdsb2JhbENzc01vZHVsZSA9IGNzc01vZHVsZTtcbn1cbmZ1bmN0aW9uIG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWUsIGNzc01vZHVsZSkge1xuICBpZiAoY2xhc3NOYW1lID09PSB2b2lkIDApIHtcbiAgICBjbGFzc05hbWUgPSAnJztcbiAgfVxuXG4gIGlmIChjc3NNb2R1bGUgPT09IHZvaWQgMCkge1xuICAgIGNzc01vZHVsZSA9IGdsb2JhbENzc01vZHVsZTtcbiAgfVxuXG4gIGlmICghY3NzTW9kdWxlKSByZXR1cm4gY2xhc3NOYW1lO1xuICByZXR1cm4gY2xhc3NOYW1lLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuIGNzc01vZHVsZVtjXSB8fCBjO1xuICB9KS5qb2luKCcgJyk7XG59XG4vKipcbiAqIFJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggdGhlIGtleS92YWx1ZSBwYWlycyBmcm9tIGBvYmpgIHRoYXQgYXJlIG5vdCBpbiB0aGUgYXJyYXkgYG9taXRLZXlzYC5cbiAqL1xuXG5mdW5jdGlvbiBvbWl0KG9iaiwgb21pdEtleXMpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChvbWl0S2V5cy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG9ialtrZXldO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFJldHVybnMgYSBmaWx0ZXJlZCBjb3B5IG9mIGFuIG9iamVjdCB3aXRoIG9ubHkgdGhlIHNwZWNpZmllZCBrZXlzLlxuICovXG5cbmZ1bmN0aW9uIHBpY2sob2JqLCBrZXlzKSB7XG4gIHZhciBwaWNrS2V5cyA9IEFycmF5LmlzQXJyYXkoa2V5cykgPyBrZXlzIDogW2tleXNdO1xuICB2YXIgbGVuZ3RoID0gcGlja0tleXMubGVuZ3RoO1xuICB2YXIga2V5O1xuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgd2hpbGUgKGxlbmd0aCA+IDApIHtcbiAgICBsZW5ndGggLT0gMTtcbiAgICBrZXkgPSBwaWNrS2V5c1tsZW5ndGhdO1xuICAgIHJlc3VsdFtrZXldID0gb2JqW2tleV07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxudmFyIHdhcm5lZCA9IHt9O1xuZnVuY3Rpb24gd2Fybk9uY2UobWVzc2FnZSkge1xuICBpZiAoIXdhcm5lZFttZXNzYWdlXSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgfVxuXG4gICAgd2FybmVkW21lc3NhZ2VdID0gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gZGVwcmVjYXRlZChwcm9wVHlwZSwgZXhwbGFuYXRpb24pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gIT09IG51bGwgJiYgdHlwZW9mIHByb3BzW3Byb3BOYW1lXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHdhcm5PbmNlKFwiXFxcIlwiICsgcHJvcE5hbWUgKyBcIlxcXCIgcHJvcGVydHkgb2YgXFxcIlwiICsgY29tcG9uZW50TmFtZSArIFwiXFxcIiBoYXMgYmVlbiBkZXByZWNhdGVkLlxcblwiICsgZXhwbGFuYXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wVHlwZS5hcHBseSh2b2lkIDAsIFtwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWVdLmNvbmNhdChbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMykpKTtcbiAgfTtcbn0gLy8gU2hpbSBFbGVtZW50IGlmIG5lZWRlZCAoZS5nLiBpbiBOb2RlIGVudmlyb25tZW50KVxuXG52YXIgRWxlbWVudCA9IHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5FbGVtZW50IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG5mdW5jdGlvbiBET01FbGVtZW50KHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgcHJvcCBgJyArIHByb3BOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuIEV4cGVjdGVkIHByb3AgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgRWxlbWVudC4gVmFsaWRhdGlvbiBmYWlsZWQuJyk7XG4gIH1cbn1cbnZhciB0YXJnZXRQcm9wVHlwZSA9IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZywgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5mdW5jLCBET01FbGVtZW50LCBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnNoYXBlKHtcbiAgY3VycmVudDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5hbnlcbn0pXSk7XG52YXIgdGFnUHJvcFR5cGUgPSBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9uZU9mVHlwZShbUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5mdW5jLCBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZywgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zaGFwZSh7XG4gICQkdHlwZW9mOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN5bWJvbCxcbiAgcmVuZGVyOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZ1bmNcbn0pLCBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmFycmF5T2YoUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vbmVPZlR5cGUoW1Byb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuYywgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc2hhcGUoe1xuICAkJHR5cGVvZjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zeW1ib2wsXG4gIHJlbmRlcjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5mdW5jXG59KV0pKV0pOyAvLyBUaGVzZSBhcmUgYWxsIHNldHVwIHRvIG1hdGNoIHdoYXQgaXMgaW4gdGhlIGJvb3RzdHJhcCBfdmFyaWFibGVzLnNjc3Ncbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL3Y0LWRldi9zY3NzL192YXJpYWJsZXMuc2Nzc1xuXG52YXIgVHJhbnNpdGlvblRpbWVvdXRzID0ge1xuICBGYWRlOiAxNTAsXG4gIC8vICR0cmFuc2l0aW9uLWZhZGVcbiAgQ29sbGFwc2U6IDM1MCxcbiAgLy8gJHRyYW5zaXRpb24tY29sbGFwc2VcbiAgTW9kYWw6IDMwMCxcbiAgLy8gJG1vZGFsLXRyYW5zaXRpb25cbiAgQ2Fyb3VzZWw6IDYwMCxcbiAgLy8gJGNhcm91c2VsLXRyYW5zaXRpb25cbiAgT2ZmY2FudmFzOiAzMDAgLy8gJG9mZmNhbnZhcy10cmFuc2l0aW9uXG5cbn07IC8vIER1cGxpY2F0ZWQgVHJhbnNpdGlvbi5wcm9wVHlwZSBrZXlzIHRvIGVuc3VyZSB0aGF0IFJlYWN0c3RyYXAgYnVpbGRzXG4vLyBmb3IgZGlzdHJpYnV0aW9uIHByb3Blcmx5IGV4Y2x1ZGUgdGhlc2Uga2V5cyBmb3IgbmVzdGVkIGNoaWxkIEhUTUwgYXR0cmlidXRlc1xuLy8gc2luY2UgYHJlYWN0LXRyYW5zaXRpb24tZ3JvdXBgIHJlbW92ZXMgcHJvcFR5cGVzIGluIHByb2R1Y3Rpb24gYnVpbGRzLlxuXG52YXIgVHJhbnNpdGlvblByb3BUeXBlS2V5cyA9IFsnaW4nLCAnbW91bnRPbkVudGVyJywgJ3VubW91bnRPbkV4aXQnLCAnYXBwZWFyJywgJ2VudGVyJywgJ2V4aXQnLCAndGltZW91dCcsICdvbkVudGVyJywgJ29uRW50ZXJpbmcnLCAnb25FbnRlcmVkJywgJ29uRXhpdCcsICdvbkV4aXRpbmcnLCAnb25FeGl0ZWQnXTtcbnZhciBUcmFuc2l0aW9uU3RhdHVzZXMgPSB7XG4gIEVOVEVSSU5HOiAnZW50ZXJpbmcnLFxuICBFTlRFUkVEOiAnZW50ZXJlZCcsXG4gIEVYSVRJTkc6ICdleGl0aW5nJyxcbiAgRVhJVEVEOiAnZXhpdGVkJ1xufTtcbnZhciBrZXlDb2RlcyA9IHtcbiAgZXNjOiAyNyxcbiAgc3BhY2U6IDMyLFxuICBlbnRlcjogMTMsXG4gIHRhYjogOSxcbiAgdXA6IDM4LFxuICBkb3duOiA0MCxcbiAgaG9tZTogMzYsXG4gIGVuZDogMzUsXG4gIG46IDc4LFxuICBwOiA4MFxufTtcbnZhciBQb3BwZXJQbGFjZW1lbnRzID0gWydhdXRvLXN0YXJ0JywgJ2F1dG8nLCAnYXV0by1lbmQnLCAndG9wLXN0YXJ0JywgJ3RvcCcsICd0b3AtZW5kJywgJ3JpZ2h0LXN0YXJ0JywgJ3JpZ2h0JywgJ3JpZ2h0LWVuZCcsICdib3R0b20tZW5kJywgJ2JvdHRvbScsICdib3R0b20tc3RhcnQnLCAnbGVmdC1lbmQnLCAnbGVmdCcsICdsZWZ0LXN0YXJ0J107XG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbmZ1bmN0aW9uIGlzUmVhY3RSZWZPYmoodGFyZ2V0KSB7XG4gIGlmICh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gJ2N1cnJlbnQnIGluIHRhcmdldDtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyAnW29iamVjdCBVbmRlZmluZWRdJyA6ICdbb2JqZWN0IE51bGxdJztcbiAgfVxuXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpO1xufVxuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHZhciBOQU4gPSAwIC8gMDtcblxuICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gJ3N5bWJvbCcgfHwgdHlwZSA9PT0gJ29iamVjdCcgJiYgZ2V0VGFnKHZhbHVlKSA9PT0gJ1tvYmplY3QgU3ltYm9sXScpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG5cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyBcIlwiICsgb3RoZXIgOiBvdGhlcjtcbiAgfVxuXG4gIGlmICh0eXBlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG5cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG4gIHZhciBpc0JpbmFyeSA9IC9eMGJbMDFdKyQvaS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIGlzQmluYXJ5IHx8IC9eMG9bMC03XSskL2kudGVzdCh2YWx1ZSkgPyBwYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOCkgOiAvXlstK10weFswLTlhLWZdKyQvaS50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZTtcbn1cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJyB8fCB0YWcgPT09ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyB8fCB0YWcgPT09ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScgfHwgdGFnID09PSAnW29iamVjdCBQcm94eV0nO1xufVxuZnVuY3Rpb24gZmluZERPTUVsZW1lbnRzKHRhcmdldCkge1xuICBpZiAoaXNSZWFjdFJlZk9iaih0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldC5jdXJyZW50O1xuICB9XG5cbiAgaWYgKGlzRnVuY3Rpb24odGFyZ2V0KSkge1xuICAgIHJldHVybiB0YXJnZXQoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJyAmJiBjYW5Vc2VET00pIHtcbiAgICB2YXIgc2VsZWN0aW9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0YXJnZXQpO1xuXG4gICAgaWYgKCFzZWxlY3Rpb24ubGVuZ3RoKSB7XG4gICAgICBzZWxlY3Rpb24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiI1wiICsgdGFyZ2V0KTtcbiAgICB9XG5cbiAgICBpZiAoIXNlbGVjdGlvbi5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSB0YXJnZXQgJ1wiICsgdGFyZ2V0ICsgXCInIGNvdWxkIG5vdCBiZSBpZGVudGlmaWVkIGluIHRoZSBkb20sIHRpcDogY2hlY2sgc3BlbGxpbmdcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGVjdGlvbjtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBpc0FycmF5T3JOb2RlTGlzdChlbHMpIHtcbiAgaWYgKGVscyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBBcnJheS5pc0FycmF5KGVscykgfHwgY2FuVXNlRE9NICYmIHR5cGVvZiBlbHMubGVuZ3RoID09PSAnbnVtYmVyJztcbn1cbmZ1bmN0aW9uIGdldFRhcmdldCh0YXJnZXQsIGFsbEVsZW1lbnRzKSB7XG4gIHZhciBlbHMgPSBmaW5kRE9NRWxlbWVudHModGFyZ2V0KTtcblxuICBpZiAoYWxsRWxlbWVudHMpIHtcbiAgICBpZiAoaXNBcnJheU9yTm9kZUxpc3QoZWxzKSkge1xuICAgICAgcmV0dXJuIGVscztcbiAgICB9XG5cbiAgICBpZiAoZWxzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIFtlbHNdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXlPck5vZGVMaXN0KGVscykpIHtcbiAgICByZXR1cm4gZWxzWzBdO1xuICB9XG5cbiAgcmV0dXJuIGVscztcbn1cbnZhciBkZWZhdWx0VG9nZ2xlRXZlbnRzID0gWyd0b3VjaHN0YXJ0JywgJ2NsaWNrJ107XG5mdW5jdGlvbiBhZGRNdWx0aXBsZUV2ZW50TGlzdGVuZXJzKF9lbHMsIGhhbmRsZXIsIF9ldmVudHMsIHVzZUNhcHR1cmUpIHtcbiAgdmFyIGVscyA9IF9lbHM7XG5cbiAgaWYgKCFpc0FycmF5T3JOb2RlTGlzdChlbHMpKSB7XG4gICAgZWxzID0gW2Vsc107XG4gIH1cblxuICB2YXIgZXZlbnRzID0gX2V2ZW50cztcblxuICBpZiAodHlwZW9mIGV2ZW50cyA9PT0gJ3N0cmluZycpIHtcbiAgICBldmVudHMgPSBldmVudHMuc3BsaXQoL1xccysvKTtcbiAgfVxuXG4gIGlmICghaXNBcnJheU9yTm9kZUxpc3QoZWxzKSB8fCB0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJyB8fCAhQXJyYXkuaXNBcnJheShldmVudHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiXFxuICAgICAgVGhlIGZpcnN0IGFyZ3VtZW50IG9mIHRoaXMgZnVuY3Rpb24gbXVzdCBiZSBET00gbm9kZSBvciBhbiBhcnJheSBvbiBET00gbm9kZXMgb3IgTm9kZUxpc3QuXFxuICAgICAgVGhlIHNlY29uZCBtdXN0IGJlIGEgZnVuY3Rpb24uXFxuICAgICAgVGhlIHRoaXJkIGlzIGEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdCByZXByZXNlbnRzIERPTSBldmVudHNcXG4gICAgXCIpO1xuICB9XG5cbiAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChldmVudHMsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZWxzLCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZUV2ZW50cygpIHtcbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGV2ZW50cywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGVscywgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59XG52YXIgZm9jdXNhYmxlRWxlbWVudHMgPSBbJ2FbaHJlZl0nLCAnYXJlYVtocmVmXScsICdpbnB1dDpub3QoW2Rpc2FibGVkXSk6bm90KFt0eXBlPWhpZGRlbl0pJywgJ3NlbGVjdDpub3QoW2Rpc2FibGVkXSknLCAndGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pJywgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSknLCAnb2JqZWN0JywgJ2VtYmVkJywgJ1t0YWJpbmRleF06bm90KC5tb2RhbCk6bm90KC5vZmZjYW52YXMpJywgJ2F1ZGlvW2NvbnRyb2xzXScsICd2aWRlb1tjb250cm9sc10nLCAnW2NvbnRlbnRlZGl0YWJsZV06bm90KFtjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiXSknXTtcblxudmFyIHV0aWxzID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIGdldFNjcm9sbGJhcldpZHRoOiBnZXRTY3JvbGxiYXJXaWR0aCxcbiAgc2V0U2Nyb2xsYmFyV2lkdGg6IHNldFNjcm9sbGJhcldpZHRoLFxuICBpc0JvZHlPdmVyZmxvd2luZzogaXNCb2R5T3ZlcmZsb3dpbmcsXG4gIGdldE9yaWdpbmFsQm9keVBhZGRpbmc6IGdldE9yaWdpbmFsQm9keVBhZGRpbmcsXG4gIGNvbmRpdGlvbmFsbHlVcGRhdGVTY3JvbGxiYXI6IGNvbmRpdGlvbmFsbHlVcGRhdGVTY3JvbGxiYXIsXG4gIHNldEdsb2JhbENzc01vZHVsZTogc2V0R2xvYmFsQ3NzTW9kdWxlLFxuICBtYXBUb0Nzc01vZHVsZXM6IG1hcFRvQ3NzTW9kdWxlcyxcbiAgb21pdDogb21pdCxcbiAgcGljazogcGljayxcbiAgd2Fybk9uY2U6IHdhcm5PbmNlLFxuICBkZXByZWNhdGVkOiBkZXByZWNhdGVkLFxuICBET01FbGVtZW50OiBET01FbGVtZW50LFxuICB0YXJnZXRQcm9wVHlwZTogdGFyZ2V0UHJvcFR5cGUsXG4gIHRhZ1Byb3BUeXBlOiB0YWdQcm9wVHlwZSxcbiAgVHJhbnNpdGlvblRpbWVvdXRzOiBUcmFuc2l0aW9uVGltZW91dHMsXG4gIFRyYW5zaXRpb25Qcm9wVHlwZUtleXM6IFRyYW5zaXRpb25Qcm9wVHlwZUtleXMsXG4gIFRyYW5zaXRpb25TdGF0dXNlczogVHJhbnNpdGlvblN0YXR1c2VzLFxuICBrZXlDb2Rlczoga2V5Q29kZXMsXG4gIFBvcHBlclBsYWNlbWVudHM6IFBvcHBlclBsYWNlbWVudHMsXG4gIGNhblVzZURPTTogY2FuVXNlRE9NLFxuICBpc1JlYWN0UmVmT2JqOiBpc1JlYWN0UmVmT2JqLFxuICBpc09iamVjdDogaXNPYmplY3QsXG4gIHRvTnVtYmVyOiB0b051bWJlcixcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgZmluZERPTUVsZW1lbnRzOiBmaW5kRE9NRWxlbWVudHMsXG4gIGlzQXJyYXlPck5vZGVMaXN0OiBpc0FycmF5T3JOb2RlTGlzdCxcbiAgZ2V0VGFyZ2V0OiBnZXRUYXJnZXQsXG4gIGRlZmF1bHRUb2dnbGVFdmVudHM6IGRlZmF1bHRUb2dnbGVFdmVudHMsXG4gIGFkZE11bHRpcGxlRXZlbnRMaXN0ZW5lcnM6IGFkZE11bHRpcGxlRXZlbnRMaXN0ZW5lcnMsXG4gIGZvY3VzYWJsZUVsZW1lbnRzOiBmb2N1c2FibGVFbGVtZW50c1xufTtcblxudmFyIF9leGNsdWRlZCQxaCA9IFtcImNsYXNzTmFtZVwiLCBcImNzc01vZHVsZVwiLCBcImZsdWlkXCIsIFwidGFnXCJdO1xudmFyIHByb3BUeXBlcyQxbSA9IHtcbiAgdGFnOiB0YWdQcm9wVHlwZSxcbiAgZmx1aWQ6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nXSksXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3Rcbn07XG52YXIgZGVmYXVsdFByb3BzJDFrID0ge1xuICB0YWc6ICdkaXYnXG59O1xuXG5mdW5jdGlvbiBDb250YWluZXIocHJvcHMpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNzc01vZHVsZSA9IHByb3BzLmNzc01vZHVsZSxcbiAgICAgIGZsdWlkID0gcHJvcHMuZmx1aWQsXG4gICAgICBUYWcgPSBwcm9wcy50YWcsXG4gICAgICBhdHRyaWJ1dGVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZCQxaCk7XG5cbiAgdmFyIGNvbnRhaW5lckNsYXNzID0gJ2NvbnRhaW5lcic7XG5cbiAgaWYgKGZsdWlkID09PSB0cnVlKSB7XG4gICAgY29udGFpbmVyQ2xhc3MgPSAnY29udGFpbmVyLWZsdWlkJztcbiAgfSBlbHNlIGlmIChmbHVpZCkge1xuICAgIGNvbnRhaW5lckNsYXNzID0gXCJjb250YWluZXItXCIgKyBmbHVpZDtcbiAgfVxuXG4gIHZhciBjbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGNsYXNzTmFtZSwgY29udGFpbmVyQ2xhc3MpLCBjc3NNb2R1bGUpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzZXNcbiAgfSkpO1xufVxuXG5Db250YWluZXIucHJvcFR5cGVzID0gcHJvcFR5cGVzJDFtO1xuQ29udGFpbmVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyQxaztcblxudmFyIF9leGNsdWRlZCQxZyA9IFtcImNsYXNzTmFtZVwiLCBcImNzc01vZHVsZVwiLCBcIm5vR3V0dGVyc1wiLCBcInRhZ1wiLCBcIndpZHRoc1wiXTtcbnZhciByb3dDb2xXaWR0aHMgPSBbJ3hzJywgJ3NtJywgJ21kJywgJ2xnJywgJ3hsJywgJ3h4bCddO1xudmFyIHJvd0NvbHNQcm9wVHlwZSA9IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm51bWJlciwgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmddKTtcbnZhciBwcm9wVHlwZXMkMWwgPSB7XG4gIHRhZzogdGFnUHJvcFR5cGUsXG4gIG5vR3V0dGVyczogZGVwcmVjYXRlZChQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsICdQbGVhc2UgdXNlIEJvb3RzdHJhcCA1IGd1dHRlciB1dGlsaXR5IGNsYXNzZXMuIGh0dHBzOi8vZ2V0Ym9vdHN0cmFwLmNvbS9kb2NzLzUuMC9sYXlvdXQvZ3V0dGVycy8nKSxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgY3NzTW9kdWxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCxcbiAgeHM6IHJvd0NvbHNQcm9wVHlwZSxcbiAgc206IHJvd0NvbHNQcm9wVHlwZSxcbiAgbWQ6IHJvd0NvbHNQcm9wVHlwZSxcbiAgbGc6IHJvd0NvbHNQcm9wVHlwZSxcbiAgeGw6IHJvd0NvbHNQcm9wVHlwZSxcbiAgeHhsOiByb3dDb2xzUHJvcFR5cGUsXG4gIHdpZHRoczogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5hcnJheVxufTtcbnZhciBkZWZhdWx0UHJvcHMkMWogPSB7XG4gIHRhZzogJ2RpdicsXG4gIHdpZHRoczogcm93Q29sV2lkdGhzXG59O1xuXG5mdW5jdGlvbiBSb3cocHJvcHMpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNzc01vZHVsZSA9IHByb3BzLmNzc01vZHVsZSxcbiAgICAgIG5vR3V0dGVycyA9IHByb3BzLm5vR3V0dGVycyxcbiAgICAgIFRhZyA9IHByb3BzLnRhZyxcbiAgICAgIHdpZHRocyA9IHByb3BzLndpZHRocyxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkJDFnKTtcblxuICB2YXIgY29sQ2xhc3NlcyA9IFtdO1xuICB3aWR0aHMuZm9yRWFjaChmdW5jdGlvbiAoY29sV2lkdGgsIGkpIHtcbiAgICB2YXIgY29sU2l6ZSA9IHByb3BzW2NvbFdpZHRoXTtcbiAgICBkZWxldGUgYXR0cmlidXRlc1tjb2xXaWR0aF07XG5cbiAgICBpZiAoIWNvbFNpemUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaXNYcyA9ICFpO1xuICAgIGNvbENsYXNzZXMucHVzaChpc1hzID8gXCJyb3ctY29scy1cIiArIGNvbFNpemUgOiBcInJvdy1jb2xzLVwiICsgY29sV2lkdGggKyBcIi1cIiArIGNvbFNpemUpO1xuICB9KTtcbiAgdmFyIGNsYXNzZXMgPSBtYXBUb0Nzc01vZHVsZXMoY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oY2xhc3NOYW1lLCBub0d1dHRlcnMgPyAnZ3gtMCcgOiBudWxsLCAncm93JywgY29sQ2xhc3NlcyksIGNzc01vZHVsZSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoVGFnLCBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3Nlc1xuICB9KSk7XG59XG5cblJvdy5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkMWw7XG5Sb3cuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJDFqO1xuXG52YXIgX2V4Y2x1ZGVkJDFmID0gW1wiY2xhc3NOYW1lXCIsIFwiY3NzTW9kdWxlXCIsIFwid2lkdGhzXCIsIFwidGFnXCJdO1xudmFyIGNvbFdpZHRocyQxID0gWyd4cycsICdzbScsICdtZCcsICdsZycsICd4bCcsICd4eGwnXTtcbnZhciBzdHJpbmdPck51bWJlclByb3AkMSA9IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm51bWJlciwgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmddKTtcbnZhciBjb2x1bW5Qcm9wcyQxID0gUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vbmVPZlR5cGUoW1Byb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCwgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5udW1iZXIsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLCBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnNoYXBlKHtcbiAgc2l6ZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vbmVPZlR5cGUoW1Byb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCwgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5udW1iZXIsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nXSksXG4gIG9yZGVyOiBzdHJpbmdPck51bWJlclByb3AkMSxcbiAgb2Zmc2V0OiBzdHJpbmdPck51bWJlclByb3AkMVxufSldKTtcbnZhciBwcm9wVHlwZXMkMWsgPSB7XG4gIHRhZzogdGFnUHJvcFR5cGUsXG4gIHhzOiBjb2x1bW5Qcm9wcyQxLFxuICBzbTogY29sdW1uUHJvcHMkMSxcbiAgbWQ6IGNvbHVtblByb3BzJDEsXG4gIGxnOiBjb2x1bW5Qcm9wcyQxLFxuICB4bDogY29sdW1uUHJvcHMkMSxcbiAgeHhsOiBjb2x1bW5Qcm9wcyQxLFxuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICBjc3NNb2R1bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LFxuICB3aWR0aHM6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYXJyYXlcbn07XG52YXIgZGVmYXVsdFByb3BzJDFpID0ge1xuICB0YWc6ICdkaXYnLFxuICB3aWR0aHM6IGNvbFdpZHRocyQxXG59O1xuXG52YXIgZ2V0Q29sdW1uU2l6ZUNsYXNzJDEgPSBmdW5jdGlvbiBnZXRDb2x1bW5TaXplQ2xhc3MoaXNYcywgY29sV2lkdGgsIGNvbFNpemUpIHtcbiAgaWYgKGNvbFNpemUgPT09IHRydWUgfHwgY29sU2l6ZSA9PT0gJycpIHtcbiAgICByZXR1cm4gaXNYcyA/ICdjb2wnIDogXCJjb2wtXCIgKyBjb2xXaWR0aDtcbiAgfVxuXG4gIGlmIChjb2xTaXplID09PSAnYXV0bycpIHtcbiAgICByZXR1cm4gaXNYcyA/ICdjb2wtYXV0bycgOiBcImNvbC1cIiArIGNvbFdpZHRoICsgXCItYXV0b1wiO1xuICB9XG5cbiAgcmV0dXJuIGlzWHMgPyBcImNvbC1cIiArIGNvbFNpemUgOiBcImNvbC1cIiArIGNvbFdpZHRoICsgXCItXCIgKyBjb2xTaXplO1xufTtcblxudmFyIGdldENvbHVtbkNsYXNzZXMgPSBmdW5jdGlvbiBnZXRDb2x1bW5DbGFzc2VzKGF0dHJpYnV0ZXMsIGNzc01vZHVsZSwgd2lkdGhzKSB7XG4gIGlmICh3aWR0aHMgPT09IHZvaWQgMCkge1xuICAgIHdpZHRocyA9IGNvbFdpZHRocyQxO1xuICB9XG5cbiAgdmFyIG1vZGlmaWVkQXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gIHZhciBjb2xDbGFzc2VzID0gW107XG4gIHdpZHRocy5mb3JFYWNoKGZ1bmN0aW9uIChjb2xXaWR0aCwgaSkge1xuICAgIHZhciBjb2x1bW5Qcm9wID0gbW9kaWZpZWRBdHRyaWJ1dGVzW2NvbFdpZHRoXTtcbiAgICBkZWxldGUgbW9kaWZpZWRBdHRyaWJ1dGVzW2NvbFdpZHRoXTtcblxuICAgIGlmICghY29sdW1uUHJvcCAmJiBjb2x1bW5Qcm9wICE9PSAnJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpc1hzID0gIWk7XG5cbiAgICBpZiAoaXNPYmplY3QoY29sdW1uUHJvcCkpIHtcbiAgICAgIHZhciBfY2xhc3NOYW1lcztcblxuICAgICAgdmFyIGNvbFNpemVJbnRlcmZpeCA9IGlzWHMgPyAnLScgOiBcIi1cIiArIGNvbFdpZHRoICsgXCItXCI7XG4gICAgICB2YXIgY29sQ2xhc3MgPSBnZXRDb2x1bW5TaXplQ2xhc3MkMShpc1hzLCBjb2xXaWR0aCwgY29sdW1uUHJvcC5zaXplKTtcbiAgICAgIGNvbENsYXNzZXMucHVzaChtYXBUb0Nzc01vZHVsZXMoY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oKF9jbGFzc05hbWVzID0ge30sIF9jbGFzc05hbWVzW2NvbENsYXNzXSA9IGNvbHVtblByb3Auc2l6ZSB8fCBjb2x1bW5Qcm9wLnNpemUgPT09ICcnLCBfY2xhc3NOYW1lc1tcIm9yZGVyXCIgKyBjb2xTaXplSW50ZXJmaXggKyBjb2x1bW5Qcm9wLm9yZGVyXSA9IGNvbHVtblByb3Aub3JkZXIgfHwgY29sdW1uUHJvcC5vcmRlciA9PT0gMCwgX2NsYXNzTmFtZXNbXCJvZmZzZXRcIiArIGNvbFNpemVJbnRlcmZpeCArIGNvbHVtblByb3Aub2Zmc2V0XSA9IGNvbHVtblByb3Aub2Zmc2V0IHx8IGNvbHVtblByb3Aub2Zmc2V0ID09PSAwLCBfY2xhc3NOYW1lcykpLCBjc3NNb2R1bGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9jb2xDbGFzcyA9IGdldENvbHVtblNpemVDbGFzcyQxKGlzWHMsIGNvbFdpZHRoLCBjb2x1bW5Qcm9wKTtcblxuICAgICAgY29sQ2xhc3Nlcy5wdXNoKF9jb2xDbGFzcyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjb2xDbGFzc2VzOiBjb2xDbGFzc2VzLFxuICAgIG1vZGlmaWVkQXR0cmlidXRlczogbW9kaWZpZWRBdHRyaWJ1dGVzXG4gIH07XG59O1xuXG5mdW5jdGlvbiBDb2wocHJvcHMpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNzc01vZHVsZSA9IHByb3BzLmNzc01vZHVsZSxcbiAgICAgIHdpZHRocyA9IHByb3BzLndpZHRocyxcbiAgICAgIFRhZyA9IHByb3BzLnRhZyxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkJDFmKTtcblxuICB2YXIgX2dldENvbHVtbkNsYXNzZXMgPSBnZXRDb2x1bW5DbGFzc2VzKGF0dHJpYnV0ZXMsIGNzc01vZHVsZSwgd2lkdGhzKSxcbiAgICAgIG1vZGlmaWVkQXR0cmlidXRlcyA9IF9nZXRDb2x1bW5DbGFzc2VzLm1vZGlmaWVkQXR0cmlidXRlcyxcbiAgICAgIGNvbENsYXNzZXMgPSBfZ2V0Q29sdW1uQ2xhc3Nlcy5jb2xDbGFzc2VzO1xuXG4gIGlmICghY29sQ2xhc3Nlcy5sZW5ndGgpIHtcbiAgICBjb2xDbGFzc2VzLnB1c2goJ2NvbCcpO1xuICB9XG5cbiAgdmFyIGNsYXNzZXMgPSBtYXBUb0Nzc01vZHVsZXMoY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oY2xhc3NOYW1lLCBjb2xDbGFzc2VzKSwgY3NzTW9kdWxlKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChUYWcsIF9leHRlbmRzKHt9LCBtb2RpZmllZEF0dHJpYnV0ZXMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzZXNcbiAgfSkpO1xufVxuXG5Db2wucHJvcFR5cGVzID0gcHJvcFR5cGVzJDFrO1xuQ29sLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyQxaTtcblxudmFyIF9leGNsdWRlZCQxZSA9IFtcImV4cGFuZFwiLCBcImNsYXNzTmFtZVwiLCBcImNzc01vZHVsZVwiLCBcImxpZ2h0XCIsIFwiZGFya1wiLCBcImZpeGVkXCIsIFwic3RpY2t5XCIsIFwiY29sb3JcIiwgXCJjb250YWluZXJcIiwgXCJ0YWdcIiwgXCJjaGlsZHJlblwiXTtcbnZhciBwcm9wVHlwZXMkMWogPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm5vZGUsXG5cbiAgLyoqIEFkZCBjdXN0b20gY2xhc3MgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcblxuICAvKiogVGhlbWUgdGhlIG5hdmJhciBieSBhZGRpbmcgYSBiYWNrZ3JvdW5kIGNvbG9yICAqL1xuICBjb2xvcjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG5cbiAgLyoqIFVzZSBhbnkgb2YgdGhlIHJlc3BvbnNpdmUgY29udGFpbmVycyB0byBjaGFuZ2UgaG93IHdpZGUgdGhlIGNvbnRlbnQgaW4geW91ciBuYXZiYXIgaXMgcHJlc2VudGVkLiAqL1xuICBjb250YWluZXI6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nXSksXG5cbiAgLyoqIENoYW5nZSB1bmRlcmx5aW5nIGNvbXBvbmVudCdzIENTUyBiYXNlIGNsYXNzIG5hbWUgKi9cbiAgY3NzTW9kdWxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCxcblxuICAvKiogVGhpcyBwcm9wIGlzIHBhc3NlZCBpZiB0aGUgYmFja2dyb3VuZCBpcyBkYXJrLCB0byBtYWtlIHRoZSB0ZXh0IGxpZ2h0ZXIgKi9cbiAgZGFyazogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuXG4gIC8qKiBEZXRlcm1pbmUgaWYgdG8gc2hvdyB0b2dnbGVyIGJ1dHRvbiAqL1xuICBleHBhbmQ6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nXSksXG5cbiAgLyoqIE1ha2UgdGhlIG5hdmJhciBmaXhlZCBhdCB0aGUgdG9wICovXG4gIGZpeGVkOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgZnVsbDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuXG4gIC8qKiBBZGQgYC5uYXZiYXItbGlnaHRgIGNsYXNzICovXG4gIGxpZ2h0OiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG4gIHJvbGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuXG4gIC8qKiBVc2UgYHBvc2l0aW9uOiBzdGlja3lgIHdoaWNoIGlzbid0IGZ1bGx5IHN1cHBvcnRlZCBpbiBldmVyeSBicm93c2VyICovXG4gIHN0aWNreTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG5cbiAgLyoqIFNldCBhIGN1c3RvbSBlbGVtZW50IGZvciB0aGlzIGNvbXBvbmVudCAqL1xuICB0YWc6IHRhZ1Byb3BUeXBlXG59O1xudmFyIGRlZmF1bHRQcm9wcyQxaCA9IHtcbiAgdGFnOiAnbmF2JyxcbiAgZXhwYW5kOiBmYWxzZSxcbiAgY29udGFpbmVyOiAnZmx1aWQnXG59O1xuXG52YXIgZ2V0RXhwYW5kQ2xhc3MgPSBmdW5jdGlvbiBnZXRFeHBhbmRDbGFzcyhleHBhbmQpIHtcbiAgaWYgKGV4cGFuZCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoZXhwYW5kID09PSB0cnVlIHx8IGV4cGFuZCA9PT0gJ3hzJykge1xuICAgIHJldHVybiAnbmF2YmFyLWV4cGFuZCc7XG4gIH1cblxuICByZXR1cm4gXCJuYXZiYXItZXhwYW5kLVwiICsgZXhwYW5kO1xufTtcblxuZnVuY3Rpb24gTmF2YmFyKHByb3BzKSB7XG4gIHZhciBfY2xhc3NOYW1lcztcblxuICB2YXIgZXhwYW5kID0gcHJvcHMuZXhwYW5kLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY3NzTW9kdWxlID0gcHJvcHMuY3NzTW9kdWxlLFxuICAgICAgbGlnaHQgPSBwcm9wcy5saWdodCxcbiAgICAgIGRhcmsgPSBwcm9wcy5kYXJrLFxuICAgICAgZml4ZWQgPSBwcm9wcy5maXhlZCxcbiAgICAgIHN0aWNreSA9IHByb3BzLnN0aWNreSxcbiAgICAgIGNvbG9yID0gcHJvcHMuY29sb3IsXG4gICAgICBjb250YWluZXIgPSBwcm9wcy5jb250YWluZXIsXG4gICAgICBUYWcgPSBwcm9wcy50YWcsXG4gICAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQkMWUpO1xuXG4gIHZhciBjbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGNsYXNzTmFtZSwgJ25hdmJhcicsIGdldEV4cGFuZENsYXNzKGV4cGFuZCksIChfY2xhc3NOYW1lcyA9IHtcbiAgICAnbmF2YmFyLWxpZ2h0JzogbGlnaHQsXG4gICAgJ25hdmJhci1kYXJrJzogZGFya1xuICB9LCBfY2xhc3NOYW1lc1tcImJnLVwiICsgY29sb3JdID0gY29sb3IsIF9jbGFzc05hbWVzW1wiZml4ZWQtXCIgKyBmaXhlZF0gPSBmaXhlZCwgX2NsYXNzTmFtZXNbXCJzdGlja3ktXCIgKyBzdGlja3ldID0gc3RpY2t5LCBfY2xhc3NOYW1lcykpLCBjc3NNb2R1bGUpO1xuICB2YXIgY29udGFpbmVyQ2xhc3MgPSBjb250YWluZXIgJiYgY29udGFpbmVyID09PSB0cnVlID8gJ2NvbnRhaW5lcicgOiBcImNvbnRhaW5lci1cIiArIGNvbnRhaW5lcjtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChUYWcsIF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzXG4gIH0pLCBjb250YWluZXIgPyAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogY29udGFpbmVyQ2xhc3NcbiAgfSwgY2hpbGRyZW4pIDogY2hpbGRyZW4pO1xufVxuXG5OYXZiYXIucHJvcFR5cGVzID0gcHJvcFR5cGVzJDFqO1xuTmF2YmFyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyQxaDtcblxudmFyIF9leGNsdWRlZCQxZCA9IFtcImNsYXNzTmFtZVwiLCBcImNzc01vZHVsZVwiLCBcInRhZ1wiXTtcbnZhciBwcm9wVHlwZXMkMWkgPSB7XG4gIC8qKiBBZGQgY3VzdG9tIGNsYXNzICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG5cbiAgLyoqIENoYW5nZSB1bmRlcmx5aW5nIGNvbXBvbmVudCdzIENTUyBiYXNlIGNsYXNzIG5hbWUgKi9cbiAgY3NzTW9kdWxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCxcblxuICAvKiogU2V0IGEgY3VzdG9tIGVsZW1lbnQgZm9yIHRoaXMgY29tcG9uZW50ICovXG4gIHRhZzogdGFnUHJvcFR5cGVcbn07XG52YXIgZGVmYXVsdFByb3BzJDFnID0ge1xuICB0YWc6ICdhJ1xufTtcblxuZnVuY3Rpb24gTmF2YmFyQnJhbmQocHJvcHMpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNzc01vZHVsZSA9IHByb3BzLmNzc01vZHVsZSxcbiAgICAgIFRhZyA9IHByb3BzLnRhZyxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkJDFkKTtcblxuICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjbGFzc05hbWUsICduYXZiYXItYnJhbmQnKSwgY3NzTW9kdWxlKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChUYWcsIF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzXG4gIH0pKTtcbn1cblxuTmF2YmFyQnJhbmQucHJvcFR5cGVzID0gcHJvcFR5cGVzJDFpO1xuTmF2YmFyQnJhbmQuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJDFnO1xuXG52YXIgX2V4Y2x1ZGVkJDFjID0gW1wiY2xhc3NOYW1lXCIsIFwiY3NzTW9kdWxlXCIsIFwiYWN0aXZlXCIsIFwidGFnXCJdO1xudmFyIHByb3BUeXBlcyQxaCA9IHtcbiAgLyoqIEFkZCBjdXN0b20gY2xhc3MgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcblxuICAvKiogQ2hhbmdlIHVuZGVybHlpbmcgY29tcG9uZW50J3MgQ1NTIGJhc2UgY2xhc3MgbmFtZSAqL1xuICBjc3NNb2R1bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LFxuXG4gIC8qKiBTZXQgYSBjdXN0b20gZWxlbWVudCBmb3IgdGhpcyBjb21wb25lbnQgKi9cbiAgdGFnOiB0YWdQcm9wVHlwZSxcbiAgYWN0aXZlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2xcbn07XG52YXIgZGVmYXVsdFByb3BzJDFmID0ge1xuICB0YWc6ICdzcGFuJ1xufTtcblxuZnVuY3Rpb24gTmF2YmFyVGV4dChwcm9wcykge1xuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY3NzTW9kdWxlID0gcHJvcHMuY3NzTW9kdWxlLFxuICAgICAgVGFnID0gcHJvcHMudGFnLFxuICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQkMWMpO1xuXG4gIHZhciBjbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGNsYXNzTmFtZSwgJ25hdmJhci10ZXh0JyksIGNzc01vZHVsZSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoVGFnLCBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3Nlc1xuICB9KSk7XG59XG5cbk5hdmJhclRleHQucHJvcFR5cGVzID0gcHJvcFR5cGVzJDFoO1xuTmF2YmFyVGV4dC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHMkMWY7XG5cbnZhciBfZXhjbHVkZWQkMWIgPSBbXCJjbGFzc05hbWVcIiwgXCJjc3NNb2R1bGVcIiwgXCJjaGlsZHJlblwiLCBcInRhZ1wiXTtcbnZhciBwcm9wVHlwZXMkMWcgPSB7XG4gIC8qKiBBZGQgY3VzdG9tIGNsYXNzICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG5cbiAgLyoqIENoYW5nZSB1bmRlcmx5aW5nIGNvbXBvbmVudCdzIENTUyBiYXNlIGNsYXNzIG5hbWUgKi9cbiAgY3NzTW9kdWxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCxcblxuICAvKiogU2V0IGEgY3VzdG9tIGVsZW1lbnQgZm9yIHRoaXMgY29tcG9uZW50ICovXG4gIHRhZzogdGFnUHJvcFR5cGUsXG4gIHR5cGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuXG4gIC8qKiBQYXNzIGNoaWxkcmVuIHNvIHRoaXMgY29tcG9uZW50IGNhbiB3cmFwIHRoZSBjaGlsZCBlbGVtZW50cyAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ub2RlXG59O1xudmFyIGRlZmF1bHRQcm9wcyQxZSA9IHtcbiAgdGFnOiAnYnV0dG9uJyxcbiAgdHlwZTogJ2J1dHRvbidcbn07XG5cbmZ1bmN0aW9uIE5hdmJhclRvZ2dsZXIocHJvcHMpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNzc01vZHVsZSA9IHByb3BzLmNzc01vZHVsZSxcbiAgICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBUYWcgPSBwcm9wcy50YWcsXG4gICAgICBhdHRyaWJ1dGVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZCQxYik7XG5cbiAgdmFyIGNsYXNzZXMgPSBtYXBUb0Nzc01vZHVsZXMoY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oY2xhc3NOYW1lLCAnbmF2YmFyLXRvZ2dsZXInKSwgY3NzTW9kdWxlKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChUYWcsIF9leHRlbmRzKHtcbiAgICBcImFyaWEtbGFiZWxcIjogXCJUb2dnbGUgbmF2aWdhdGlvblwiXG4gIH0sIGF0dHJpYnV0ZXMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzZXNcbiAgfSksIGNoaWxkcmVuIHx8IC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIGNsYXNzTmFtZTogbWFwVG9Dc3NNb2R1bGVzKCduYXZiYXItdG9nZ2xlci1pY29uJywgY3NzTW9kdWxlKVxuICB9KSk7XG59XG5cbk5hdmJhclRvZ2dsZXIucHJvcFR5cGVzID0gcHJvcFR5cGVzJDFnO1xuTmF2YmFyVG9nZ2xlci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHMkMWU7XG5cbnZhciBfZXhjbHVkZWQkMWEgPSBbXCJjbGFzc05hbWVcIiwgXCJjc3NNb2R1bGVcIiwgXCJ0YWJzXCIsIFwicGlsbHNcIiwgXCJ2ZXJ0aWNhbFwiLCBcImhvcml6b250YWxcIiwgXCJqdXN0aWZpZWRcIiwgXCJmaWxsXCIsIFwibmF2YmFyXCIsIFwiY2FyZFwiLCBcInRhZ1wiXTtcbnZhciBwcm9wVHlwZXMkMWYgPSB7XG4gIC8qKiBBZGRpbmcgY2FyZCBwcm9wIGFkZHMgYC5jYXJkLWhlYWRlci10YWJzYCBvciBgLmNhcmQtaGVhZGVyLXBpbGxzYCBjbGFzcyAqL1xuICBjYXJkOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG5cbiAgLyoqIEFkZCBjdXN0b20gY2xhc3MgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcblxuICAvKiogQ2hhbmdlIHVuZGVybHlpbmcgY29tcG9uZW50J3MgQ1NTIGJhc2UgY2xhc3MgbmFtZSAqL1xuICBjc3NNb2R1bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LFxuXG4gIC8qKiBmaWxscyB0aGUgbmF2IHRvIGV4dGVuZCB0byBmdWxsIGF2YWlsYWJsZSB3aWR0aCAqL1xuICBmaWxsOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG5cbiAgLyoqIENoYW5nZSB0aGUgaG9yaXpvbnRhbCBhbGlnbm1lbnQgb2YgeW91ciBuYXYgKi9cbiAgaG9yaXpvbnRhbDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vbmVPZihbJ2NlbnRlcicsICdlbmQnXSksXG5cbiAgLyoqICBBbGwgaG9yaXpvbnRhbCBzcGFjZSB3aWxsIGJlIG9jY3VwaWVkIGJ5IG5hdiBsaW5rcywgYnV0IHVubGlrZSB0aGUgYGZpbGxgIGFib3ZlLCBldmVyeSBuYXYgaXRlbSB3aWxsIGJlIHRoZSBzYW1lIHdpZHRoLiAqL1xuICBqdXN0aWZpZWQ6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcblxuICAvKiogQWRkIG5hdmJhciBmb3IgYSBmdWxsLWhlaWdodCBhbmQgbGlnaHR3ZWlnaHQgbmF2aWdhdGlvbiAqL1xuICBuYXZiYXI6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcblxuICAvKiogTWFrZSBOYXZJdGVtcyBsb29rIGxpa2UgcGlsbHMgKi9cbiAgcGlsbHM6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcblxuICAvKiogTWFrZSBOYXZJdGVtcyBsb29rIGxpa2UgdGFicyAqL1xuICB0YWJzOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG5cbiAgLyoqIFNldCBhIGN1c3RvbSBlbGVtZW50IGZvciB0aGlzIGNvbXBvbmVudCAqL1xuICB0YWc6IHRhZ1Byb3BUeXBlLFxuXG4gIC8qKiBTdGFjayB5b3VyIG5hdmlnYXRpb24gYnkgY2hhbmdpbmcgdGhlIGZsZXggaXRlbSBkaXJlY3Rpb24gKi9cbiAgdmVydGljYWw6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nXSlcbn07XG52YXIgZGVmYXVsdFByb3BzJDFkID0ge1xuICB0YWc6ICd1bCcsXG4gIHZlcnRpY2FsOiBmYWxzZVxufTtcblxudmFyIGdldFZlcnRpY2FsQ2xhc3MgPSBmdW5jdGlvbiBnZXRWZXJ0aWNhbENsYXNzKHZlcnRpY2FsKSB7XG4gIGlmICh2ZXJ0aWNhbCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodmVydGljYWwgPT09IHRydWUgfHwgdmVydGljYWwgPT09ICd4cycpIHtcbiAgICByZXR1cm4gJ2ZsZXgtY29sdW1uJztcbiAgfVxuXG4gIHJldHVybiBcImZsZXgtXCIgKyB2ZXJ0aWNhbCArIFwiLWNvbHVtblwiO1xufTtcblxuZnVuY3Rpb24gTmF2KHByb3BzKSB7XG4gIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjc3NNb2R1bGUgPSBwcm9wcy5jc3NNb2R1bGUsXG4gICAgICB0YWJzID0gcHJvcHMudGFicyxcbiAgICAgIHBpbGxzID0gcHJvcHMucGlsbHMsXG4gICAgICB2ZXJ0aWNhbCA9IHByb3BzLnZlcnRpY2FsLFxuICAgICAgaG9yaXpvbnRhbCA9IHByb3BzLmhvcml6b250YWwsXG4gICAgICBqdXN0aWZpZWQgPSBwcm9wcy5qdXN0aWZpZWQsXG4gICAgICBmaWxsID0gcHJvcHMuZmlsbCxcbiAgICAgIG5hdmJhciA9IHByb3BzLm5hdmJhcixcbiAgICAgIGNhcmQgPSBwcm9wcy5jYXJkLFxuICAgICAgVGFnID0gcHJvcHMudGFnLFxuICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQkMWEpO1xuXG4gIHZhciBjbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGNsYXNzTmFtZSwgbmF2YmFyID8gJ25hdmJhci1uYXYnIDogJ25hdicsIGhvcml6b250YWwgPyBcImp1c3RpZnktY29udGVudC1cIiArIGhvcml6b250YWwgOiBmYWxzZSwgZ2V0VmVydGljYWxDbGFzcyh2ZXJ0aWNhbCksIHtcbiAgICAnbmF2LXRhYnMnOiB0YWJzLFxuICAgICdjYXJkLWhlYWRlci10YWJzJzogY2FyZCAmJiB0YWJzLFxuICAgICduYXYtcGlsbHMnOiBwaWxscyxcbiAgICAnY2FyZC1oZWFkZXItcGlsbHMnOiBjYXJkICYmIHBpbGxzLFxuICAgICduYXYtanVzdGlmaWVkJzoganVzdGlmaWVkLFxuICAgICduYXYtZmlsbCc6IGZpbGxcbiAgfSksIGNzc01vZHVsZSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoVGFnLCBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3Nlc1xuICB9KSk7XG59XG5cbk5hdi5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkMWY7XG5OYXYuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJDFkO1xuXG52YXIgX2V4Y2x1ZGVkJDE5ID0gW1wiY2xhc3NOYW1lXCIsIFwiY3NzTW9kdWxlXCIsIFwiYWN0aXZlXCIsIFwidGFnXCJdO1xudmFyIHByb3BUeXBlcyQxZSA9IHtcbiAgLyoqIEFkZCBhY3RpdmUgY2xhc3MgdG8gZWxlbWVudCAqL1xuICBhY3RpdmU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcblxuICAvKiogQWRkIGN1c3RvbSBjbGFzcyAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuXG4gIC8qKiBDaGFuZ2UgdW5kZXJseWluZyBjb21wb25lbnQncyBDU1MgYmFzZSBjbGFzcyBuYW1lICovXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG5cbiAgLyoqIFNldCBhIGN1c3RvbSBlbGVtZW50IGZvciB0aGlzIGNvbXBvbmVudCAqL1xuICB0YWc6IHRhZ1Byb3BUeXBlXG59O1xudmFyIGRlZmF1bHRQcm9wcyQxYyA9IHtcbiAgdGFnOiAnbGknXG59O1xuXG5mdW5jdGlvbiBOYXZJdGVtKHByb3BzKSB7XG4gIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjc3NNb2R1bGUgPSBwcm9wcy5jc3NNb2R1bGUsXG4gICAgICBhY3RpdmUgPSBwcm9wcy5hY3RpdmUsXG4gICAgICBUYWcgPSBwcm9wcy50YWcsXG4gICAgICBhdHRyaWJ1dGVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZCQxOSk7XG5cbiAgdmFyIGNsYXNzZXMgPSBtYXBUb0Nzc01vZHVsZXMoY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oY2xhc3NOYW1lLCAnbmF2LWl0ZW0nLCBhY3RpdmUgPyAnYWN0aXZlJyA6IGZhbHNlKSwgY3NzTW9kdWxlKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChUYWcsIF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzXG4gIH0pKTtcbn1cblxuTmF2SXRlbS5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkMWU7XG5OYXZJdGVtLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyQxYztcblxudmFyIF9leGNsdWRlZCQxOCA9IFtcImNsYXNzTmFtZVwiLCBcImNzc01vZHVsZVwiLCBcImFjdGl2ZVwiLCBcInRhZ1wiLCBcImlubmVyUmVmXCJdO1xudmFyIHByb3BUeXBlcyQxZCA9IHtcbiAgLyoqIEFkZCBhY3RpdmUgY2xhc3MgdG8gTmF2TGluayAqL1xuICBhY3RpdmU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcblxuICAvKiogQWRkIGN1c3RvbSBjbGFzcyAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuXG4gIC8qKiBDaGFuZ2UgdW5kZXJseWluZyBjb21wb25lbnQncyBDU1MgYmFzZSBjbGFzcyBuYW1lICovXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG5cbiAgLyoqIERpc2FibGUgdGhlIGxpbmsgKi9cbiAgZGlzYWJsZWQ6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcbiAgaHJlZjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5hbnksXG4gIGlubmVyUmVmOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9uZU9mVHlwZShbUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuYywgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmddKSxcblxuICAvKiogRnVuY3Rpb24gdG8gYmUgdHJpZ2dlcmVkIG9uIGNsaWNrICovXG4gIG9uQ2xpY2s6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuYyxcblxuICAvKiogU2V0IGEgY3VzdG9tIGVsZW1lbnQgZm9yIHRoaXMgY29tcG9uZW50ICovXG4gIHRhZzogdGFnUHJvcFR5cGVcbn07XG52YXIgZGVmYXVsdFByb3BzJDFiID0ge1xuICB0YWc6ICdhJ1xufTtcblxudmFyIE5hdkxpbmsgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoTmF2TGluaywgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gTmF2TGluayhwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgIF90aGlzLm9uQ2xpY2sgPSBfdGhpcy5vbkNsaWNrLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBOYXZMaW5rLnByb3RvdHlwZTtcblxuICBfcHJvdG8ub25DbGljayA9IGZ1bmN0aW9uIG9uQ2xpY2soZSkge1xuICAgIGlmICh0aGlzLnByb3BzLmRpc2FibGVkKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJvcHMuaHJlZiA9PT0gJyMnKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJvcHMub25DbGljaykge1xuICAgICAgdGhpcy5wcm9wcy5vbkNsaWNrKGUpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGNsYXNzTmFtZSA9IF90aGlzJHByb3BzLmNsYXNzTmFtZSxcbiAgICAgICAgY3NzTW9kdWxlID0gX3RoaXMkcHJvcHMuY3NzTW9kdWxlLFxuICAgICAgICBhY3RpdmUgPSBfdGhpcyRwcm9wcy5hY3RpdmUsXG4gICAgICAgIFRhZyA9IF90aGlzJHByb3BzLnRhZyxcbiAgICAgICAgaW5uZXJSZWYgPSBfdGhpcyRwcm9wcy5pbm5lclJlZixcbiAgICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzLCBfZXhjbHVkZWQkMTgpO1xuXG4gICAgdmFyIGNsYXNzZXMgPSBtYXBUb0Nzc01vZHVsZXMoY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oY2xhc3NOYW1lLCAnbmF2LWxpbmsnLCB7XG4gICAgICBkaXNhYmxlZDogYXR0cmlidXRlcy5kaXNhYmxlZCxcbiAgICAgIGFjdGl2ZTogYWN0aXZlXG4gICAgfSksIGNzc01vZHVsZSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChUYWcsIF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgICByZWY6IGlubmVyUmVmLFxuICAgICAgb25DbGljazogdGhpcy5vbkNsaWNrLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc2VzXG4gICAgfSkpO1xuICB9O1xuXG4gIHJldHVybiBOYXZMaW5rO1xufShSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uQ29tcG9uZW50KTtcblxuTmF2TGluay5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkMWQ7XG5OYXZMaW5rLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyQxYjtcbnZhciBOYXZMaW5rJDEgPSBOYXZMaW5rO1xuXG52YXIgX2V4Y2x1ZGVkJDE3ID0gW1wiY2xhc3NOYW1lXCIsIFwibGlzdENsYXNzTmFtZVwiLCBcImNzc01vZHVsZVwiLCBcImNoaWxkcmVuXCIsIFwidGFnXCIsIFwibGlzdFRhZ1wiLCBcImFyaWEtbGFiZWxcIl07XG52YXIgcHJvcFR5cGVzJDFjID0ge1xuICAvKiogQXJpYSBsYWJlbCAqL1xuICAnYXJpYS1sYWJlbCc6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuXG4gIC8qKiBQYXNzIGNoaWxkcmVuIHNvIHRoaXMgY29tcG9uZW50IGNhbiB3cmFwIHRoZW0gKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ubm9kZSxcblxuICAvKiogQWRkIGN1c3RvbSBjbGFzcyAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuXG4gIC8qKiBDaGFuZ2UgZXhpc3RpbmcgY2xhc3NOYW1lIHdpdGggYSBuZXcgY2xhc3NOYW1lICovXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG5cbiAgLyoqIEFkZCBjdXN0b20gY2xhc3MgdG8gbGlzdCB0YWcgKi9cbiAgbGlzdENsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG5cbiAgLyoqIFNldCBhIGN1c3RvbSBlbGVtZW50IGZvciBsaXN0IHRhZyAqL1xuICBsaXN0VGFnOiB0YWdQcm9wVHlwZSxcblxuICAvKiogU2V0IGEgY3VzdG9tIGVsZW1lbnQgZm9yIHRoaXMgY29tcG9uZW50ICovXG4gIHRhZzogdGFnUHJvcFR5cGVcbn07XG52YXIgZGVmYXVsdFByb3BzJDFhID0ge1xuICB0YWc6ICduYXYnLFxuICBsaXN0VGFnOiAnb2wnLFxuICAnYXJpYS1sYWJlbCc6ICdicmVhZGNydW1iJ1xufTtcblxuZnVuY3Rpb24gQnJlYWRjcnVtYihwcm9wcykge1xuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgbGlzdENsYXNzTmFtZSA9IHByb3BzLmxpc3RDbGFzc05hbWUsXG4gICAgICBjc3NNb2R1bGUgPSBwcm9wcy5jc3NNb2R1bGUsXG4gICAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgVGFnID0gcHJvcHMudGFnLFxuICAgICAgTGlzdFRhZyA9IHByb3BzLmxpc3RUYWcsXG4gICAgICBsYWJlbCA9IHByb3BzWydhcmlhLWxhYmVsJ10sXG4gICAgICBhdHRyaWJ1dGVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZCQxNyk7XG5cbiAgdmFyIGNsYXNzZXMgPSBtYXBUb0Nzc01vZHVsZXMoY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oY2xhc3NOYW1lKSwgY3NzTW9kdWxlKTtcbiAgdmFyIGxpc3RDbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKCdicmVhZGNydW1iJywgbGlzdENsYXNzTmFtZSksIGNzc01vZHVsZSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoVGFnLCBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NlcyxcbiAgICBcImFyaWEtbGFiZWxcIjogbGFiZWxcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChMaXN0VGFnLCB7XG4gICAgY2xhc3NOYW1lOiBsaXN0Q2xhc3Nlc1xuICB9LCBjaGlsZHJlbikpO1xufVxuXG5CcmVhZGNydW1iLnByb3BUeXBlcyA9IHByb3BUeXBlcyQxYztcbkJyZWFkY3J1bWIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJDFhO1xuXG52YXIgX2V4Y2x1ZGVkJDE2ID0gW1wiY2xhc3NOYW1lXCIsIFwiY3NzTW9kdWxlXCIsIFwiYWN0aXZlXCIsIFwidGFnXCJdO1xudmFyIHByb3BUeXBlcyQxYiA9IHtcbiAgLyoqIEFkZHMgYSB2aXN1YWwgXCJhY3RpdmVcIiBzdGF0ZSB0byBhIEJyZWFkY3J1bWIgSXRlbSAqL1xuICBhY3RpdmU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcblxuICAvKiogQWRkIGN1c3RvbSBjbGFzcyB0byB0aGUgZWxlbWVudCAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuXG4gIC8qKiBDaGFuZ2UgZXhpc3RpbmcgY2xhc3NOYW1lIHdpdGggYSBuZXcgY2xhc3NOYW1lICovXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG5cbiAgLyoqIFNldCBhIGN1c3RvbSBlbGVtZW50IGZvciB0aGlzIGNvbXBvbmVudCAqL1xuICB0YWc6IHRhZ1Byb3BUeXBlXG59O1xudmFyIGRlZmF1bHRQcm9wcyQxOSA9IHtcbiAgdGFnOiAnbGknXG59O1xuXG5mdW5jdGlvbiBCcmVhZGNydW1iSXRlbShwcm9wcykge1xuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY3NzTW9kdWxlID0gcHJvcHMuY3NzTW9kdWxlLFxuICAgICAgYWN0aXZlID0gcHJvcHMuYWN0aXZlLFxuICAgICAgVGFnID0gcHJvcHMudGFnLFxuICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQkMTYpO1xuXG4gIHZhciBjbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGNsYXNzTmFtZSwgYWN0aXZlID8gJ2FjdGl2ZScgOiBmYWxzZSwgJ2JyZWFkY3J1bWItaXRlbScpLCBjc3NNb2R1bGUpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzZXMsXG4gICAgXCJhcmlhLWN1cnJlbnRcIjogYWN0aXZlID8gJ3BhZ2UnIDogdW5kZWZpbmVkXG4gIH0pKTtcbn1cblxuQnJlYWRjcnVtYkl0ZW0ucHJvcFR5cGVzID0gcHJvcFR5cGVzJDFiO1xuQnJlYWRjcnVtYkl0ZW0uZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJDE5O1xuXG52YXIgX2V4Y2x1ZGVkJDE1ID0gW1wiY2xhc3NOYW1lXCIsIFwiY3NzTW9kdWxlXCIsIFwidmFyaWFudFwiLCBcImlubmVyUmVmXCJdO1xudmFyIHByb3BUeXBlcyQxYSA9IHtcbiAgLyoqIERpc2FibGUgdGhlIGJ1dHRvbiBpZiBuZWVkZWQgKi9cbiAgYWN0aXZlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG5cbiAgLyoqIEFyaWEgbGFiZWwgKi9cbiAgJ2FyaWEtbGFiZWwnOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcblxuICAvKiogRnVuY3Rpb24gdG8gYmUgdHJpZ2dlcmVkIG9uIGNsaWNrICovXG4gIG9uQ2xpY2s6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuYyxcblxuICAvKiogQ2hhbmdlIHRoZSB2YXJpYW50IHRvIHdoaXRlICovXG4gIHZhcmlhbnQ6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2YoWyd3aGl0ZSddKSxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgY3NzTW9kdWxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCxcbiAgaW5uZXJSZWY6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCwgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuY10pXG59O1xudmFyIGRlZmF1bHRQcm9wcyQxOCA9IHtcbiAgJ2FyaWEtbGFiZWwnOiAnY2xvc2UnXG59O1xuXG5mdW5jdGlvbiBDbG9zZUJ1dHRvbihwcm9wcykge1xuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgdmFyaWFudCA9IHByb3BzLnZhcmlhbnQsXG4gICAgICBpbm5lclJlZiA9IHByb3BzLmlubmVyUmVmLFxuICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQkMTUpO1xuXG4gIHZhciBjbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGNsYXNzTmFtZSwgJ2J0bi1jbG9zZScsIHZhcmlhbnQgJiYgXCJidG4tY2xvc2UtXCIgKyB2YXJpYW50KSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogaW5uZXJSZWYsXG4gICAgdHlwZTogXCJidXR0b25cIixcbiAgICBjbGFzc05hbWU6IGNsYXNzZXNcbiAgfSwgYXR0cmlidXRlcykpO1xufVxuXG5DbG9zZUJ1dHRvbi5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkMWE7XG5DbG9zZUJ1dHRvbi5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHMkMTg7XG5cbnZhciBfZXhjbHVkZWQkMTQgPSBbXCJhY3RpdmVcIiwgXCJhcmlhLWxhYmVsXCIsIFwiYmxvY2tcIiwgXCJjbGFzc05hbWVcIiwgXCJjbG9zZVwiLCBcImNzc01vZHVsZVwiLCBcImNvbG9yXCIsIFwib3V0bGluZVwiLCBcInNpemVcIiwgXCJ0YWdcIiwgXCJpbm5lclJlZlwiXTtcbnZhciBwcm9wVHlwZXMkMTkgPSB7XG4gIC8qKiBNYW51YWxseSBzZXQgdGhlIHZpc3VhbCBzdGF0ZSBvZiB0aGUgYnV0dG9uIHRvIGFjdGl2ZSAqL1xuICBhY3RpdmU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcblxuICAvKiogQXJpYSBsYWJlbCAqL1xuICAnYXJpYS1sYWJlbCc6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICBibG9jazogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuXG4gIC8qKiBQYXNzIGNoaWxkcmVuIHNvIHRoaXMgY29tcG9uZW50IGNhbiB3cmFwIHRoZW0gKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ubm9kZSxcblxuICAvKiogQWRkIGN1c3RvbSBjbGFzcyAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuXG4gIC8qKiBDaGFuZ2UgZXhpc3RpbmcgY2xhc3NOYW1lIHdpdGggYSBuZXcgY2xhc3NOYW1lICovXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG5cbiAgLyoqIFVzZSB0aGUgYnV0dG9uIGFzIGEgY2xvc2UgYnV0dG9uICovXG4gIGNsb3NlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG5cbiAgLyoqIENoYW5nZSBjb2xvciBvZiBCdXR0b24gdG8gb25lIG9mIHRoZSBhdmFpbGFibGUgY29sb3JzICovXG4gIGNvbG9yOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcblxuICAvKiogRGlzYWJsZXMgdGhlIGJ1dHRvbiAqL1xuICBkaXNhYmxlZDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBpbm5lclJlZjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vbmVPZlR5cGUoW1Byb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LCBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZ1bmMsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nXSksXG5cbiAgLyoqIEZ1bmN0aW9uIHRvIGJlIHRyaWdnZXJlZCBvbiBjbGljayAqL1xuICBvbkNsaWNrOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZ1bmMsXG5cbiAgLyoqIEFkZHMgb3V0bGluZSB0byB0aGUgYnV0dG9uICovXG4gIG91dGxpbmU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcblxuICAvKiogTWFrZSB0aGUgYnV0dG9uIGJpZ2dlciBvciBzbWFsbGVyICovXG4gIHNpemU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuXG4gIC8qKiBTZXQgYSBjdXN0b20gZWxlbWVudCBmb3IgdGhpcyBjb21wb25lbnQgKi9cbiAgdGFnOiB0YWdQcm9wVHlwZVxufTtcbnZhciBkZWZhdWx0UHJvcHMkMTcgPSB7XG4gIGNvbG9yOiAnc2Vjb25kYXJ5JyxcbiAgdGFnOiAnYnV0dG9uJ1xufTtcblxuZnVuY3Rpb24gQnV0dG9uKHByb3BzKSB7XG4gIHZhciBvbkNsaWNrID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAocHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcHMub25DbGljaykge1xuICAgICAgcmV0dXJuIHByb3BzLm9uQ2xpY2soZSk7XG4gICAgfVxuICB9LCBbcHJvcHMub25DbGljaywgcHJvcHMuZGlzYWJsZWRdKTtcblxuICB2YXIgYWN0aXZlID0gcHJvcHMuYWN0aXZlLFxuICAgICAgYXJpYUxhYmVsID0gcHJvcHNbJ2FyaWEtbGFiZWwnXSxcbiAgICAgIGJsb2NrID0gcHJvcHMuYmxvY2ssXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjbG9zZSA9IHByb3BzLmNsb3NlLFxuICAgICAgY3NzTW9kdWxlID0gcHJvcHMuY3NzTW9kdWxlLFxuICAgICAgY29sb3IgPSBwcm9wcy5jb2xvcixcbiAgICAgIG91dGxpbmUgPSBwcm9wcy5vdXRsaW5lLFxuICAgICAgc2l6ZSA9IHByb3BzLnNpemUsXG4gICAgICBUYWcgPSBwcm9wcy50YWcsXG4gICAgICBpbm5lclJlZiA9IHByb3BzLmlubmVyUmVmLFxuICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQkMTQpO1xuXG4gIGlmIChjbG9zZSkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoQ2xvc2VCdXR0b24sIGF0dHJpYnV0ZXMpO1xuICB9XG5cbiAgdmFyIGJ0bk91dGxpbmVDb2xvciA9IFwiYnRuXCIgKyAob3V0bGluZSA/ICctb3V0bGluZScgOiAnJykgKyBcIi1cIiArIGNvbG9yO1xuICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjbGFzc05hbWUsICdidG4nLCBidG5PdXRsaW5lQ29sb3IsIHNpemUgPyBcImJ0bi1cIiArIHNpemUgOiBmYWxzZSwgYmxvY2sgPyAnZC1ibG9jayB3LTEwMCcgOiBmYWxzZSwge1xuICAgIGFjdGl2ZTogYWN0aXZlLFxuICAgIGRpc2FibGVkOiBwcm9wcy5kaXNhYmxlZFxuICB9KSwgY3NzTW9kdWxlKTtcblxuICBpZiAoYXR0cmlidXRlcy5ocmVmICYmIFRhZyA9PT0gJ2J1dHRvbicpIHtcbiAgICBUYWcgPSAnYSc7XG4gIH1cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe1xuICAgIHR5cGU6IFRhZyA9PT0gJ2J1dHRvbicgJiYgYXR0cmlidXRlcy5vbkNsaWNrID8gJ2J1dHRvbicgOiB1bmRlZmluZWRcbiAgfSwgYXR0cmlidXRlcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NlcyxcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIG9uQ2xpY2s6IG9uQ2xpY2ssXG4gICAgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbFxuICB9KSk7XG59XG5cbkJ1dHRvbi5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkMTk7XG5CdXR0b24uZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJDE3O1xuXG52YXIgX2V4Y2x1ZGVkJDEzID0gW1wiY2xhc3NOYW1lXCJdO1xudmFyIHByb3BUeXBlcyQxOCA9IHtcbiAgb25DbGljazogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5mdW5jLFxuICBvbkJsdXI6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuYyxcbiAgb25Gb2N1czogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5mdW5jLFxuICBkZWZhdWx0VmFsdWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgY3NzTW9kdWxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdFxufTtcbnZhciBkZWZhdWx0UHJvcHMkMTYgPSB7XG4gIGRlZmF1bHRWYWx1ZTogZmFsc2Vcbn07XG5cbmZ1bmN0aW9uIEJ1dHRvblRvZ2dsZShwcm9wcykge1xuICB2YXIgX3VzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUocHJvcHMuZGVmYXVsdFZhbHVlKSxcbiAgICAgIHRvZ2dsZWQgPSBfdXNlU3RhdGVbMF0sXG4gICAgICBzZXRUb2dnbGVkID0gX3VzZVN0YXRlWzFdO1xuXG4gIHZhciBfdXNlU3RhdGUyID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpLFxuICAgICAgZm9jdXMgPSBfdXNlU3RhdGUyWzBdLFxuICAgICAgc2V0Rm9jdXMgPSBfdXNlU3RhdGUyWzFdO1xuXG4gIHZhciBvbkJsdXIgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xuICAgIGlmIChwcm9wcy5vbkJsdXIpIHtcbiAgICAgIHByb3BzLm9uQmx1cihlKTtcbiAgICB9XG5cbiAgICBzZXRGb2N1cyhmYWxzZSk7XG4gIH0sIFtwcm9wcy5vbkJsdXJdKTtcbiAgdmFyIG9uRm9jdXMgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xuICAgIGlmIChwcm9wcy5vbkZvY3VzKSB7XG4gICAgICBwcm9wcy5vbkZvY3VzKGUpO1xuICAgIH1cblxuICAgIHNldEZvY3VzKHRydWUpO1xuICB9LCBbcHJvcHMub25Gb2N1c10pO1xuICB2YXIgb25DbGljayA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKHByb3BzLm9uQ2xpY2spIHtcbiAgICAgIHByb3BzLm9uQ2xpY2soZSk7XG4gICAgfVxuXG4gICAgc2V0VG9nZ2xlZCghdG9nZ2xlZCk7XG4gIH0sIFtwcm9wcy5vbkNsaWNrXSk7XG5cbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkJDEzKTtcblxuICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjbGFzc05hbWUsIHtcbiAgICBmb2N1czogZm9jdXNcbiAgfSksIHByb3BzLmNzc01vZHVsZSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoQnV0dG9uLCBfZXh0ZW5kcyh7XG4gICAgYWN0aXZlOiB0b2dnbGVkLFxuICAgIG9uQmx1cjogb25CbHVyLFxuICAgIG9uRm9jdXM6IG9uRm9jdXMsXG4gICAgb25DbGljazogb25DbGljayxcbiAgICBjbGFzc05hbWU6IGNsYXNzZXNcbiAgfSwgYXR0cmlidXRlcykpO1xufVxuXG5CdXR0b25Ub2dnbGUucHJvcFR5cGVzID0gcHJvcFR5cGVzJDE4O1xuQnV0dG9uVG9nZ2xlLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyQxNjtcblxuLyoqXG4gKiBEcm9wZG93bkNvbnRleHRcbiAqIHtcbiAqICB0b2dnbGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gKiAgaXNPcGVuOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICogIGRpcmVjdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsndXAnLCAnZG93bicsICdzdGFydCcsICdlbmQnXSkuaXNSZXF1aXJlZCxcbiAqICBpbk5hdmJhcjogUHJvcFR5cGVzLmJvb2wuaXNSZXF1aXJlZCxcbiAqICBkaXNhYmxlZDogUHJvcFR5cGVzLmJvb2xcbiAqIH1cbiAqL1xuXG52YXIgRHJvcGRvd25Db250ZXh0ID0gUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUNvbnRleHQoe30pO1xuXG52YXIgSW5wdXRHcm91cENvbnRleHQgPSBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlQ29udGV4dCh7fSk7XG5cbnZhciBfZXhjbHVkZWQkMTIgPSBbXCJjbGFzc05hbWVcIiwgXCJjc3NNb2R1bGVcIiwgXCJkaXJlY3Rpb25cIiwgXCJpc09wZW5cIiwgXCJncm91cFwiLCBcInNpemVcIiwgXCJuYXZcIiwgXCJzZXRBY3RpdmVGcm9tQ2hpbGRcIiwgXCJhY3RpdmVcIiwgXCJ0YWdcIiwgXCJtZW51Um9sZVwiXTtcbnZhciBwcm9wVHlwZXMkMTcgPSB7XG4gIGExMXk6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcbiAgZGlzYWJsZWQ6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcbiAgZGlyZWN0aW9uOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9uZU9mKFsndXAnLCAnZG93bicsICdzdGFydCcsICdlbmQnLCAnbGVmdCcsICdyaWdodCddKSxcbiAgZ3JvdXA6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcbiAgaXNPcGVuOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG4gIG5hdjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBhY3RpdmU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcbiAgc2l6ZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIHRhZzogdGFnUHJvcFR5cGUsXG4gIHRvZ2dsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5mdW5jLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ub2RlLFxuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICBjc3NNb2R1bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LFxuICBkcm9wdXA6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcbiAgaW5OYXZiYXI6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcbiAgc2V0QWN0aXZlRnJvbUNoaWxkOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG4gIG1lbnVSb2xlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9uZU9mKFsnbGlzdGJveCcsICdtZW51J10pXG59O1xudmFyIGRlZmF1bHRQcm9wcyQxNSA9IHtcbiAgYTExeTogdHJ1ZSxcbiAgaXNPcGVuOiBmYWxzZSxcbiAgZGlyZWN0aW9uOiAnZG93bicsXG4gIG5hdjogZmFsc2UsXG4gIGFjdGl2ZTogZmFsc2UsXG4gIGluTmF2YmFyOiBmYWxzZSxcbiAgc2V0QWN0aXZlRnJvbUNoaWxkOiBmYWxzZVxufTtcbnZhciBwcmV2ZW50RGVmYXVsdEtleXMgPSBba2V5Q29kZXMuc3BhY2UsIGtleUNvZGVzLmVudGVyLCBrZXlDb2Rlcy51cCwga2V5Q29kZXMuZG93biwga2V5Q29kZXMuZW5kLCBrZXlDb2Rlcy5ob21lXTtcblxudmFyIERyb3Bkb3duID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKERyb3Bkb3duLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBEcm9wZG93bihwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgIF90aGlzLmFkZEV2ZW50cyA9IF90aGlzLmFkZEV2ZW50cy5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5oYW5kbGVEb2N1bWVudENsaWNrID0gX3RoaXMuaGFuZGxlRG9jdW1lbnRDbGljay5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5oYW5kbGVLZXlEb3duID0gX3RoaXMuaGFuZGxlS2V5RG93bi5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5yZW1vdmVFdmVudHMgPSBfdGhpcy5yZW1vdmVFdmVudHMuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMudG9nZ2xlID0gX3RoaXMudG9nZ2xlLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmhhbmRsZU1lbnVSZWYgPSBfdGhpcy5oYW5kbGVNZW51UmVmLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmhhbmRsZVRvZ2dsZVJlZiA9IF90aGlzLmhhbmRsZVRvZ2dsZVJlZi5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5jb250YWluZXJSZWYgPSBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlUmVmKCk7XG4gICAgX3RoaXMubWVudVJlZiA9IFJlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVSZWYoKTtcbiAgICBfdGhpcy50b2dnbGVSZWYgPSBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlUmVmKCk7IC8vIHJlZiBmb3IgRHJvcGRvd25Ub2dnbGVcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBEcm9wZG93bi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5oYW5kbGVQcm9wcygpO1xuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgaWYgKHRoaXMucHJvcHMuaXNPcGVuICE9PSBwcmV2UHJvcHMuaXNPcGVuKSB7XG4gICAgICB0aGlzLmhhbmRsZVByb3BzKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRzKCk7XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZU1lbnVSZWYgPSBmdW5jdGlvbiBoYW5kbGVNZW51UmVmKG1lbnVSZWYpIHtcbiAgICB0aGlzLm1lbnVSZWYuY3VycmVudCA9IG1lbnVSZWY7XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZVRvZ2dsZVJlZiA9IGZ1bmN0aW9uIGhhbmRsZVRvZ2dsZVJlZih0b2dnbGVSZWYpIHtcbiAgICB0aGlzLnRvZ2dsZVJlZi5jdXJyZW50ID0gdG9nZ2xlUmVmO1xuICB9O1xuXG4gIF9wcm90by5oYW5kbGVEb2N1bWVudENsaWNrID0gZnVuY3Rpb24gaGFuZGxlRG9jdW1lbnRDbGljayhlKSB7XG4gICAgaWYgKGUgJiYgKGUud2hpY2ggPT09IDMgfHwgZS50eXBlID09PSAna2V5dXAnICYmIGUud2hpY2ggIT09IGtleUNvZGVzLnRhYikpIHJldHVybjtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5nZXRDb250YWluZXIoKTtcbiAgICB2YXIgbWVudSA9IHRoaXMuZ2V0TWVudSgpO1xuICAgIHZhciB0b2dnbGUgPSB0aGlzLmdldFRvZ2dsZSgpO1xuICAgIHZhciB0YXJnZXRJc1RvZ2dsZSA9IGUudGFyZ2V0ID09PSB0b2dnbGU7XG4gICAgdmFyIGNsaWNrSXNJbk1lbnUgPSBtZW51ICYmIG1lbnUuY29udGFpbnMoZS50YXJnZXQpICYmIG1lbnUgIT09IGUudGFyZ2V0O1xuICAgIHZhciBjbGlja0lzSW5JbnB1dCA9IGZhbHNlO1xuXG4gICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgLy8gdGhpcyBpcyBvbmx5IGZvciBJbnB1dEdyb3VwIHdpdGggdHlwZSBkcm9wZG93blxuICAgICAgY2xpY2tJc0luSW5wdXQgPSBjb250YWluZXIuY2xhc3NMaXN0LmNvbnRhaW5zKCdpbnB1dC1ncm91cCcpICYmIGNvbnRhaW5lci5jbGFzc0xpc3QuY29udGFpbnMoJ2Ryb3Bkb3duJykgJiYgZS50YXJnZXQudGFnTmFtZSA9PT0gJ0lOUFVUJztcbiAgICB9XG5cbiAgICBpZiAoKHRhcmdldElzVG9nZ2xlICYmICFjbGlja0lzSW5JbnB1dCB8fCBjbGlja0lzSW5NZW51KSAmJiAoZS50eXBlICE9PSAna2V5dXAnIHx8IGUud2hpY2ggPT09IGtleUNvZGVzLnRhYikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnRvZ2dsZShlKTtcbiAgfTtcblxuICBfcHJvdG8uaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uIGhhbmRsZUtleURvd24oZSkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIGlzVGFyZ2V0TWVudUl0ZW0gPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSA9PT0gJ21lbnVpdGVtJyB8fCBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSA9PT0gJ29wdGlvbic7XG4gICAgdmFyIGlzVGFyZ2V0TWVudUN0cmwgPSB0aGlzLmdldE1lbnVDdHJsKCkgPT09IGUudGFyZ2V0O1xuICAgIHZhciBpc1RhYiA9IGtleUNvZGVzLnRhYiA9PT0gZS53aGljaDtcblxuICAgIGlmICgvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGUudGFyZ2V0LnRhZ05hbWUpIHx8IGlzVGFiICYmICF0aGlzLnByb3BzLmExMXkgfHwgaXNUYWIgJiYgIShpc1RhcmdldE1lbnVJdGVtIHx8IGlzVGFyZ2V0TWVudUN0cmwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByZXZlbnREZWZhdWx0S2V5cy5pbmRleE9mKGUud2hpY2gpICE9PSAtMSB8fCBlLndoaWNoID49IDQ4ICYmIGUud2hpY2ggPD0gOTApIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wcm9wcy5kaXNhYmxlZCkgcmV0dXJuO1xuXG4gICAgaWYgKGlzVGFyZ2V0TWVudUN0cmwpIHtcbiAgICAgIGlmIChba2V5Q29kZXMuc3BhY2UsIGtleUNvZGVzLmVudGVyLCBrZXlDb2Rlcy51cCwga2V5Q29kZXMuZG93bl0uaW5kZXhPZihlLndoaWNoKSA+IC0xKSB7XG4gICAgICAgIC8vIE9wZW4gdGhlIG1lbnUgKGlmIG5vdCBvcGVuKSBhbmQgZm9jdXMgdGhlIGZpcnN0IG1lbnUgaXRlbVxuICAgICAgICBpZiAoIXRoaXMucHJvcHMuaXNPcGVuKSB7XG4gICAgICAgICAgdGhpcy50b2dnbGUoZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLmdldE1lbnVJdGVtcygpWzBdLmZvY3VzKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLmlzT3BlbiAmJiBpc1RhYikge1xuICAgICAgICAvLyBGb2N1cyB0aGUgZmlyc3QgbWVudSBpdGVtIGlmIHRhYmJpbmcgZnJvbSBhbiBvcGVuIG1lbnUuIFdlIG5lZWQgdGhpc1xuICAgICAgICAvLyBmb3IgY2FzZXMgd2hlcmUgdGhlIERyb3Bkb3duTWVudSBzZXRzIGEgY3VzdG9tIGNvbnRhaW5lciwgd2hpY2ggbWF5XG4gICAgICAgIC8vIG5vdCBiZSB0aGUgbmF0dXJhbCBuZXh0IGl0ZW0gdG8gdGFiIHRvIGZyb20gdGhlIERyb3Bkb3duVG9nZ2xlLlxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuZ2V0TWVudUl0ZW1zKClbMF0uZm9jdXMoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5wcm9wcy5pc09wZW4gJiYgZS53aGljaCA9PT0ga2V5Q29kZXMuZXNjKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlKGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnByb3BzLmlzT3BlbiAmJiBpc1RhcmdldE1lbnVJdGVtKSB7XG4gICAgICBpZiAoW2tleUNvZGVzLnRhYiwga2V5Q29kZXMuZXNjXS5pbmRleE9mKGUud2hpY2gpID4gLTEpIHtcbiAgICAgICAgdGhpcy50b2dnbGUoZSk7XG4gICAgICAgIHRoaXMuZ2V0TWVudUN0cmwoKS5mb2N1cygpO1xuICAgICAgfSBlbHNlIGlmIChba2V5Q29kZXMuc3BhY2UsIGtleUNvZGVzLmVudGVyXS5pbmRleE9mKGUud2hpY2gpID4gLTEpIHtcbiAgICAgICAgZS50YXJnZXQuY2xpY2soKTtcbiAgICAgICAgdGhpcy5nZXRNZW51Q3RybCgpLmZvY3VzKCk7XG4gICAgICB9IGVsc2UgaWYgKFtrZXlDb2Rlcy5kb3duLCBrZXlDb2Rlcy51cF0uaW5kZXhPZihlLndoaWNoKSA+IC0xIHx8IFtrZXlDb2Rlcy5uLCBrZXlDb2Rlcy5wXS5pbmRleE9mKGUud2hpY2gpID4gLTEgJiYgZS5jdHJsS2V5KSB7XG4gICAgICAgIHZhciAkbWVudWl0ZW1zID0gdGhpcy5nZXRNZW51SXRlbXMoKTtcbiAgICAgICAgdmFyIGluZGV4ID0gJG1lbnVpdGVtcy5pbmRleE9mKGUudGFyZ2V0KTtcblxuICAgICAgICBpZiAoa2V5Q29kZXMudXAgPT09IGUud2hpY2ggfHwga2V5Q29kZXMucCA9PT0gZS53aGljaCAmJiBlLmN0cmxLZXkpIHtcbiAgICAgICAgICBpbmRleCA9IGluZGV4ICE9PSAwID8gaW5kZXggLSAxIDogJG1lbnVpdGVtcy5sZW5ndGggLSAxO1xuICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGVzLmRvd24gPT09IGUud2hpY2ggfHwga2V5Q29kZXMubiA9PT0gZS53aGljaCAmJiBlLmN0cmxLZXkpIHtcbiAgICAgICAgICBpbmRleCA9IGluZGV4ID09PSAkbWVudWl0ZW1zLmxlbmd0aCAtIDEgPyAwIDogaW5kZXggKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgJG1lbnVpdGVtc1tpbmRleF0uZm9jdXMoKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZXMuZW5kID09PSBlLndoaWNoKSB7XG4gICAgICAgIHZhciBfJG1lbnVpdGVtcyA9IHRoaXMuZ2V0TWVudUl0ZW1zKCk7XG5cbiAgICAgICAgXyRtZW51aXRlbXNbXyRtZW51aXRlbXMubGVuZ3RoIC0gMV0uZm9jdXMoKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZXMuaG9tZSA9PT0gZS53aGljaCkge1xuICAgICAgICB2YXIgXyRtZW51aXRlbXMyID0gdGhpcy5nZXRNZW51SXRlbXMoKTtcblxuICAgICAgICBfJG1lbnVpdGVtczJbMF0uZm9jdXMoKTtcbiAgICAgIH0gZWxzZSBpZiAoZS53aGljaCA+PSA0OCAmJiBlLndoaWNoIDw9IDkwKSB7XG4gICAgICAgIHZhciBfJG1lbnVpdGVtczMgPSB0aGlzLmdldE1lbnVJdGVtcygpO1xuXG4gICAgICAgIHZhciBjaGFyUHJlc3NlZCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZS53aGljaCkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF8kbWVudWl0ZW1zMy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHZhciBmaXJzdExldHRlciA9IF8kbWVudWl0ZW1zM1tpXS50ZXh0Q29udGVudCAmJiBfJG1lbnVpdGVtczNbaV0udGV4dENvbnRlbnRbMF0udG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgIGlmIChmaXJzdExldHRlciA9PT0gY2hhclByZXNzZWQpIHtcbiAgICAgICAgICAgIF8kbWVudWl0ZW1zM1tpXS5mb2N1cygpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZVByb3BzID0gZnVuY3Rpb24gaGFuZGxlUHJvcHMoKSB7XG4gICAgaWYgKHRoaXMucHJvcHMuaXNPcGVuKSB7XG4gICAgICB0aGlzLmFkZEV2ZW50cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50cygpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZ2V0Q29udGV4dFZhbHVlID0gZnVuY3Rpb24gZ2V0Q29udGV4dFZhbHVlKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b2dnbGU6IHRoaXMudG9nZ2xlLFxuICAgICAgaXNPcGVuOiB0aGlzLnByb3BzLmlzT3BlbixcbiAgICAgIGRpcmVjdGlvbjogdGhpcy5wcm9wcy5kaXJlY3Rpb24gPT09ICdkb3duJyAmJiB0aGlzLnByb3BzLmRyb3B1cCA/ICd1cCcgOiB0aGlzLnByb3BzLmRpcmVjdGlvbixcbiAgICAgIGluTmF2YmFyOiB0aGlzLnByb3BzLmluTmF2YmFyLFxuICAgICAgZGlzYWJsZWQ6IHRoaXMucHJvcHMuZGlzYWJsZWQsXG4gICAgICAvLyBDYWxsYmFjayB0aGF0IHNob3VsZCBiZSBjYWxsZWQgYnkgRHJvcGRvd25NZW51IHRvIHByb3ZpZGUgYSByZWYgdG9cbiAgICAgIC8vIGEgSFRNTCB0YWcgdGhhdCdzIHVzZWQgZm9yIHRoZSBEcm9wZG93bk1lbnVcbiAgICAgIG9uTWVudVJlZjogdGhpcy5oYW5kbGVNZW51UmVmLFxuICAgICAgb25Ub2dnbGVSZWY6IHRoaXMuaGFuZGxlVG9nZ2xlUmVmLFxuICAgICAgbWVudVJvbGU6IHRoaXMucHJvcHMubWVudVJvbGVcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5nZXRDb250YWluZXIgPSBmdW5jdGlvbiBnZXRDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gIH07XG5cbiAgX3Byb3RvLmdldE1lbnUgPSBmdW5jdGlvbiBnZXRNZW51KCkge1xuICAgIHJldHVybiB0aGlzLm1lbnVSZWYuY3VycmVudDtcbiAgfTtcblxuICBfcHJvdG8uZ2V0VG9nZ2xlID0gZnVuY3Rpb24gZ2V0VG9nZ2xlKCkge1xuICAgIHJldHVybiB0aGlzLnRvZ2dsZVJlZi5jdXJyZW50O1xuICB9O1xuXG4gIF9wcm90by5nZXRNZW51Q3RybCA9IGZ1bmN0aW9uIGdldE1lbnVDdHJsKCkge1xuICAgIGlmICh0aGlzLl8kbWVudUN0cmwpIHJldHVybiB0aGlzLl8kbWVudUN0cmw7XG4gICAgdGhpcy5fJG1lbnVDdHJsID0gdGhpcy5nZXRUb2dnbGUoKTtcbiAgICByZXR1cm4gdGhpcy5fJG1lbnVDdHJsO1xuICB9O1xuXG4gIF9wcm90by5nZXRJdGVtVHlwZSA9IGZ1bmN0aW9uIGdldEl0ZW1UeXBlKCkge1xuICAgIGlmICh0aGlzLnByb3BzLm1lbnVSb2xlID09PSAnbGlzdGJveCcpIHtcbiAgICAgIHJldHVybiAnb3B0aW9uJztcbiAgICB9XG5cbiAgICByZXR1cm4gJ21lbnVpdGVtJztcbiAgfTtcblxuICBfcHJvdG8uZ2V0TWVudUl0ZW1zID0gZnVuY3Rpb24gZ2V0TWVudUl0ZW1zKCkge1xuICAgIC8vIEluIGEgcmVhbCBtZW51IHdpdGggYSBjaGlsZCBEcm9wZG93bk1lbnUsIGB0aGlzLmdldE1lbnUoKWAgc2hvdWxkIG5ldmVyXG4gICAgLy8gYmUgbnVsbCwgYnV0IGl0IGlzIHNvbWV0aW1lcyBudWxsIGluIHRlc3RzLiBUbyBtaXRpZ2F0ZSB0aGF0LCB3ZSBqdXN0XG4gICAgLy8gdXNlIGB0aGlzLmdldENvbnRhaW5lcigpYCBhcyB0aGUgZmFsbGJhY2sgYG1lbnVDb250YWluZXJgLlxuICAgIHZhciBtZW51Q29udGFpbmVyID0gdGhpcy5nZXRNZW51KCkgfHwgdGhpcy5nZXRDb250YWluZXIoKTtcbiAgICByZXR1cm4gW10uc2xpY2UuY2FsbChtZW51Q29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbcm9sZT1cXFwiXCIgKyB0aGlzLmdldEl0ZW1UeXBlKCkgKyBcIlxcXCJdXCIpKTtcbiAgfTtcblxuICBfcHJvdG8uYWRkRXZlbnRzID0gZnVuY3Rpb24gYWRkRXZlbnRzKCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgWydjbGljaycsICd0b3VjaHN0YXJ0JywgJ2tleXVwJ10uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBfdGhpczMuaGFuZGxlRG9jdW1lbnRDbGljaywgdHJ1ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbW92ZUV2ZW50cyA9IGZ1bmN0aW9uIHJlbW92ZUV2ZW50cygpIHtcbiAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgIFsnY2xpY2snLCAndG91Y2hzdGFydCcsICdrZXl1cCddLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgX3RoaXM0LmhhbmRsZURvY3VtZW50Q2xpY2ssIHRydWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by50b2dnbGUgPSBmdW5jdGlvbiB0b2dnbGUoZSkge1xuICAgIGlmICh0aGlzLnByb3BzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm4gZSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucHJvcHMudG9nZ2xlKGUpO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9jbGFzc05hbWVzLFxuICAgICAgICBfdGhpczUgPSB0aGlzLFxuICAgICAgICBfcmVmO1xuXG4gICAgdmFyIF9vbWl0ID0gb21pdCh0aGlzLnByb3BzLCBbJ3RvZ2dsZScsICdkaXNhYmxlZCcsICdpbk5hdmJhcicsICdhMTF5J10pLFxuICAgICAgICBjbGFzc05hbWUgPSBfb21pdC5jbGFzc05hbWUsXG4gICAgICAgIGNzc01vZHVsZSA9IF9vbWl0LmNzc01vZHVsZSxcbiAgICAgICAgZGlyZWN0aW9uID0gX29taXQuZGlyZWN0aW9uLFxuICAgICAgICBpc09wZW4gPSBfb21pdC5pc09wZW4sXG4gICAgICAgIGdyb3VwID0gX29taXQuZ3JvdXAsXG4gICAgICAgIHNpemUgPSBfb21pdC5zaXplLFxuICAgICAgICBuYXYgPSBfb21pdC5uYXYsXG4gICAgICAgIHNldEFjdGl2ZUZyb21DaGlsZCA9IF9vbWl0LnNldEFjdGl2ZUZyb21DaGlsZCxcbiAgICAgICAgYWN0aXZlID0gX29taXQuYWN0aXZlLFxuICAgICAgICB0YWcgPSBfb21pdC50YWcsXG4gICAgICAgIGF0dHJzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX29taXQsIF9leGNsdWRlZCQxMik7XG5cbiAgICB2YXIgVGFnID0gdGFnIHx8IChuYXYgPyAnbGknIDogJ2RpdicpO1xuICAgIHZhciBzdWJJdGVtSXNBY3RpdmUgPSBmYWxzZTtcblxuICAgIGlmIChzZXRBY3RpdmVGcm9tQ2hpbGQpIHtcbiAgICAgIFJlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5DaGlsZHJlbi5tYXAodGhpcy5wcm9wcy5jaGlsZHJlblsxXS5wcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGRyb3Bkb3duSXRlbSkge1xuICAgICAgICBpZiAoZHJvcGRvd25JdGVtICYmIGRyb3Bkb3duSXRlbS5wcm9wcy5hY3RpdmUpIHN1Ykl0ZW1Jc0FjdGl2ZSA9IHRydWU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjbGFzc05hbWUsIG5hdiAmJiBhY3RpdmUgPyAnYWN0aXZlJyA6IGZhbHNlLCBzZXRBY3RpdmVGcm9tQ2hpbGQgJiYgc3ViSXRlbUlzQWN0aXZlID8gJ2FjdGl2ZScgOiBmYWxzZSwgKF9jbGFzc05hbWVzID0ge1xuICAgICAgJ2J0bi1ncm91cCc6IGdyb3VwXG4gICAgfSwgX2NsYXNzTmFtZXNbXCJidG4tZ3JvdXAtXCIgKyBzaXplXSA9ICEhc2l6ZSwgX2NsYXNzTmFtZXMuZHJvcGRvd24gPSAhZ3JvdXAsIF9jbGFzc05hbWVzLmRyb3B1cCA9IGRpcmVjdGlvbiA9PT0gJ3VwJywgX2NsYXNzTmFtZXMuZHJvcHN0YXJ0ID0gZGlyZWN0aW9uID09PSAnc3RhcnQnIHx8IGRpcmVjdGlvbiA9PT0gJ2xlZnQnLCBfY2xhc3NOYW1lcy5kcm9wZW5kID0gZGlyZWN0aW9uID09PSAnZW5kJyB8fCBkaXJlY3Rpb24gPT09ICdyaWdodCcsIF9jbGFzc05hbWVzLnNob3cgPSBpc09wZW4sIF9jbGFzc05hbWVzWyduYXYtaXRlbSddID0gbmF2LCBfY2xhc3NOYW1lcykpLCBjc3NNb2R1bGUpO1xuXG4gICAgaWYgKHRoaXMuY29udGV4dC5pbnNpZGVJbnB1dEdyb3VwKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KERyb3Bkb3duQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogdGhpcy5nZXRDb250ZXh0VmFsdWUoKVxuICAgICAgfSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KHJlYWN0UG9wcGVyLk1hbmFnZXIsIG51bGwsIFJlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5DaGlsZHJlbi5tYXAodGhpcy5wcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgICAgICAgb25LZXlEb3duOiBfdGhpczUuaGFuZGxlS2V5RG93blxuICAgICAgICB9KTtcbiAgICAgIH0pKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChEcm9wZG93bkNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiB0aGlzLmdldENvbnRleHRWYWx1ZSgpXG4gICAgfSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KHJlYWN0UG9wcGVyLk1hbmFnZXIsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChUYWcsIF9leHRlbmRzKHt9LCBhdHRycywgKF9yZWYgPSB7fSwgX3JlZlt0eXBlb2YgVGFnID09PSAnc3RyaW5nJyA/ICdyZWYnIDogJ2lubmVyUmVmJ10gPSB0aGlzLmNvbnRhaW5lclJlZiwgX3JlZiksIHtcbiAgICAgIG9uS2V5RG93bjogdGhpcy5oYW5kbGVLZXlEb3duLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc2VzXG4gICAgfSkpKSk7XG4gIH07XG5cbiAgcmV0dXJuIERyb3Bkb3duO1xufShSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uQ29tcG9uZW50KTtcblxuRHJvcGRvd24ucHJvcFR5cGVzID0gcHJvcFR5cGVzJDE3O1xuRHJvcGRvd24uZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJDE1O1xuRHJvcGRvd24uY29udGV4dFR5cGUgPSBJbnB1dEdyb3VwQ29udGV4dDtcbnZhciBEcm9wZG93biQxID0gRHJvcGRvd247XG5cbnZhciBwcm9wVHlwZXMkMTYgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm5vZGVcbn07XG5cbmZ1bmN0aW9uIEJ1dHRvbkRyb3Bkb3duKHByb3BzKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoRHJvcGRvd24kMSwgX2V4dGVuZHMoe1xuICAgIGdyb3VwOiB0cnVlXG4gIH0sIHByb3BzKSk7XG59XG5cbkJ1dHRvbkRyb3Bkb3duLnByb3BUeXBlcyA9IHByb3BUeXBlcyQxNjtcblxudmFyIF9leGNsdWRlZCQxMSA9IFtcImNsYXNzTmFtZVwiLCBcImNzc01vZHVsZVwiLCBcInNpemVcIiwgXCJ2ZXJ0aWNhbFwiLCBcInRhZ1wiXTtcbnZhciBwcm9wVHlwZXMkMTUgPSB7XG4gIC8qKiBBcmlhIGxhYmVsICovXG4gICdhcmlhLWxhYmVsJzogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG5cbiAgLyoqIEFkZCBjdXN0b20gY2xhc3MgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcblxuICAvKiogQ2hhbmdlIHVuZGVybHlpbmcgY29tcG9uZW50J3MgQ1NTIGJhc2UgY2xhc3MgbmFtZSAqL1xuICBjc3NNb2R1bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LFxuXG4gIC8qKiBJbiBvcmRlciBmb3IgYXNzaXN0aXZlIHRlY2hub2xvZ2llcyAoc3VjaCBhcyBzY3JlZW4gcmVhZGVycykgdG8gY29udmV5IHRoYXQgYSBzZXJpZXMgb2YgYnV0dG9ucyBpcyBncm91cGVkLCBhbiBhcHByb3ByaWF0ZSByb2xlIGF0dHJpYnV0ZSBuZWVkcyB0byBiZSBwcm92aWRlZC4gRm9yIGJ1dHRvbiBncm91cHMsIHRoaXMgd291bGQgYmUgcm9sZT1cImdyb3VwXCIsIHdoaWxlIHRvb2xiYXJzIHNob3VsZCBoYXZlIGEgcm9sZT1cInRvb2xiYXJcIi4gKi9cbiAgcm9sZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG5cbiAgLyoqIE1ha2UgdGhlIGJ1dHRvbiBiaWdnZXIgb3Igc21hbGxlciAqL1xuICBzaXplOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcblxuICAvKiogU2V0IGEgY3VzdG9tIGVsZW1lbnQgZm9yIHRoaXMgY29tcG9uZW50ICovXG4gIHRhZzogdGFnUHJvcFR5cGUsXG5cbiAgLyoqIE1ha2UgYnV0dG9uIGdyb3VwIHZlcnRpY2FsICovXG4gIHZlcnRpY2FsOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2xcbn07XG52YXIgZGVmYXVsdFByb3BzJDE0ID0ge1xuICB0YWc6ICdkaXYnLFxuICByb2xlOiAnZ3JvdXAnXG59O1xuXG5mdW5jdGlvbiBCdXR0b25Hcm91cChwcm9wcykge1xuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY3NzTW9kdWxlID0gcHJvcHMuY3NzTW9kdWxlLFxuICAgICAgc2l6ZSA9IHByb3BzLnNpemUsXG4gICAgICB2ZXJ0aWNhbCA9IHByb3BzLnZlcnRpY2FsLFxuICAgICAgVGFnID0gcHJvcHMudGFnLFxuICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQkMTEpO1xuXG4gIHZhciBjbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGNsYXNzTmFtZSwgc2l6ZSA/ICdidG4tZ3JvdXAtJyArIHNpemUgOiBmYWxzZSwgdmVydGljYWwgPyAnYnRuLWdyb3VwLXZlcnRpY2FsJyA6ICdidG4tZ3JvdXAnKSwgY3NzTW9kdWxlKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChUYWcsIF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzXG4gIH0pKTtcbn1cblxuQnV0dG9uR3JvdXAucHJvcFR5cGVzID0gcHJvcFR5cGVzJDE1O1xuQnV0dG9uR3JvdXAuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJDE0O1xuXG52YXIgX2V4Y2x1ZGVkJDEwID0gW1wiY2xhc3NOYW1lXCIsIFwiY3NzTW9kdWxlXCIsIFwidGFnXCJdO1xudmFyIHByb3BUeXBlcyQxNCA9IHtcbiAgLyoqIEFyaWEgbGFiZWwgKi9cbiAgJ2FyaWEtbGFiZWwnOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcblxuICAvKiogQWRkIGN1c3RvbSBjbGFzcyAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuXG4gIC8qKiBDaGFuZ2UgZXhpc3RpbmcgY2xhc3NOYW1lIHdpdGggYSBuZXcgY2xhc3NOYW1lICovXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG5cbiAgLyoqIEluIG9yZGVyIGZvciBhc3Npc3RpdmUgdGVjaG5vbG9naWVzIChzdWNoIGFzIHNjcmVlbiByZWFkZXJzKSB0byBjb252ZXkgdGhhdCBhIHNlcmllcyBvZiBidXR0b25zIGlzIGdyb3VwZWQsIGFuIGFwcHJvcHJpYXRlIHJvbGUgYXR0cmlidXRlIG5lZWRzIHRvIGJlIHByb3ZpZGVkLiBGb3IgYnV0dG9uIGdyb3VwcywgdGhpcyB3b3VsZCBiZSByb2xlPVwiZ3JvdXBcIiwgd2hpbGUgdG9vbGJhcnMgc2hvdWxkIGhhdmUgYSByb2xlPVwidG9vbGJhclwiLiAqL1xuICByb2xlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcblxuICAvKiogU2V0IGEgY3VzdG9tIGVsZW1lbnQgZm9yIHRoaXMgY29tcG9uZW50ICovXG4gIHRhZzogdGFnUHJvcFR5cGVcbn07XG52YXIgZGVmYXVsdFByb3BzJDEzID0ge1xuICB0YWc6ICdkaXYnLFxuICByb2xlOiAndG9vbGJhcidcbn07XG5cbmZ1bmN0aW9uIEJ1dHRvblRvb2xiYXIocHJvcHMpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNzc01vZHVsZSA9IHByb3BzLmNzc01vZHVsZSxcbiAgICAgIFRhZyA9IHByb3BzLnRhZyxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkJDEwKTtcblxuICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjbGFzc05hbWUsICdidG4tdG9vbGJhcicpLCBjc3NNb2R1bGUpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzZXNcbiAgfSkpO1xufVxuXG5CdXR0b25Ub29sYmFyLnByb3BUeXBlcyA9IHByb3BUeXBlcyQxNDtcbkJ1dHRvblRvb2xiYXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJDEzO1xuXG52YXIgX2V4Y2x1ZGVkJCQgPSBbXCJjbGFzc05hbWVcIiwgXCJjc3NNb2R1bGVcIiwgXCJkaXZpZGVyXCIsIFwidGFnXCIsIFwiaGVhZGVyXCIsIFwiYWN0aXZlXCIsIFwidGV4dFwiXTtcbnZhciBwcm9wVHlwZXMkMTMgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm5vZGUsXG4gIGFjdGl2ZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBkaXNhYmxlZDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBkaXZpZGVyOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG4gIHRhZzogdGFnUHJvcFR5cGUsXG4gIGhlYWRlcjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBvbkNsaWNrOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZ1bmMsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG4gIHRvZ2dsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICB0ZXh0OiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2xcbn07XG52YXIgZGVmYXVsdFByb3BzJDEyID0ge1xuICB0YWc6ICdidXR0b24nLFxuICB0b2dnbGU6IHRydWVcbn07XG5cbnZhciBEcm9wZG93bkl0ZW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoRHJvcGRvd25JdGVtLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBEcm9wZG93bkl0ZW0ocHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICBfdGhpcy5vbkNsaWNrID0gX3RoaXMub25DbGljay5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5nZXRUYWJJbmRleCA9IF90aGlzLmdldFRhYkluZGV4LmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBEcm9wZG93bkl0ZW0ucHJvdG90eXBlO1xuXG4gIF9wcm90by5vbkNsaWNrID0gZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgZGlzYWJsZWQgPSBfdGhpcyRwcm9wcy5kaXNhYmxlZCxcbiAgICAgICAgaGVhZGVyID0gX3RoaXMkcHJvcHMuaGVhZGVyLFxuICAgICAgICBkaXZpZGVyID0gX3RoaXMkcHJvcHMuZGl2aWRlcixcbiAgICAgICAgdGV4dCA9IF90aGlzJHByb3BzLnRleHQ7XG5cbiAgICBpZiAoZGlzYWJsZWQgfHwgaGVhZGVyIHx8IGRpdmlkZXIgfHwgdGV4dCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnByb3BzLm9uQ2xpY2spIHtcbiAgICAgIHRoaXMucHJvcHMub25DbGljayhlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wcm9wcy50b2dnbGUpIHtcbiAgICAgIHRoaXMuY29udGV4dC50b2dnbGUoZSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5nZXRSb2xlID0gZnVuY3Rpb24gZ2V0Um9sZSgpIHtcbiAgICBpZiAodGhpcy5jb250ZXh0Lm1lbnVSb2xlID09PSAnbGlzdGJveCcpIHtcbiAgICAgIHJldHVybiAnb3B0aW9uJztcbiAgICB9XG5cbiAgICByZXR1cm4gJ21lbnVpdGVtJztcbiAgfTtcblxuICBfcHJvdG8uZ2V0VGFiSW5kZXggPSBmdW5jdGlvbiBnZXRUYWJJbmRleCgpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgZGlzYWJsZWQgPSBfdGhpcyRwcm9wczIuZGlzYWJsZWQsXG4gICAgICAgIGhlYWRlciA9IF90aGlzJHByb3BzMi5oZWFkZXIsXG4gICAgICAgIGRpdmlkZXIgPSBfdGhpcyRwcm9wczIuZGl2aWRlcixcbiAgICAgICAgdGV4dCA9IF90aGlzJHByb3BzMi50ZXh0O1xuXG4gICAgaWYgKGRpc2FibGVkIHx8IGhlYWRlciB8fCBkaXZpZGVyIHx8IHRleHQpIHtcbiAgICAgIHJldHVybiAnLTEnO1xuICAgIH1cblxuICAgIHJldHVybiAnMCc7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgdGFiSW5kZXggPSB0aGlzLmdldFRhYkluZGV4KCk7XG4gICAgdmFyIHJvbGUgPSB0YWJJbmRleCA+IC0xID8gdGhpcy5nZXRSb2xlKCkgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgX29taXQgPSBvbWl0KHRoaXMucHJvcHMsIFsndG9nZ2xlJ10pLFxuICAgICAgICBjbGFzc05hbWUgPSBfb21pdC5jbGFzc05hbWUsXG4gICAgICAgIGNzc01vZHVsZSA9IF9vbWl0LmNzc01vZHVsZSxcbiAgICAgICAgZGl2aWRlciA9IF9vbWl0LmRpdmlkZXIsXG4gICAgICAgIFRhZyA9IF9vbWl0LnRhZyxcbiAgICAgICAgaGVhZGVyID0gX29taXQuaGVhZGVyLFxuICAgICAgICBhY3RpdmUgPSBfb21pdC5hY3RpdmUsXG4gICAgICAgIHRleHQgPSBfb21pdC50ZXh0LFxuICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9vbWl0LCBfZXhjbHVkZWQkJCk7XG5cbiAgICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjbGFzc05hbWUsIHtcbiAgICAgIGRpc2FibGVkOiBwcm9wcy5kaXNhYmxlZCxcbiAgICAgICdkcm9wZG93bi1pdGVtJzogIWRpdmlkZXIgJiYgIWhlYWRlciAmJiAhdGV4dCxcbiAgICAgIGFjdGl2ZTogYWN0aXZlLFxuICAgICAgJ2Ryb3Bkb3duLWhlYWRlcic6IGhlYWRlcixcbiAgICAgICdkcm9wZG93bi1kaXZpZGVyJzogZGl2aWRlcixcbiAgICAgICdkcm9wZG93bi1pdGVtLXRleHQnOiB0ZXh0XG4gICAgfSksIGNzc01vZHVsZSk7XG5cbiAgICBpZiAoVGFnID09PSAnYnV0dG9uJykge1xuICAgICAgaWYgKGhlYWRlcikge1xuICAgICAgICBUYWcgPSAnaDYnO1xuICAgICAgfSBlbHNlIGlmIChkaXZpZGVyKSB7XG4gICAgICAgIFRhZyA9ICdkaXYnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wcy5ocmVmKSB7XG4gICAgICAgIFRhZyA9ICdhJztcbiAgICAgIH0gZWxzZSBpZiAodGV4dCkge1xuICAgICAgICBUYWcgPSAnc3Bhbic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChUYWcsIF9leHRlbmRzKHtcbiAgICAgIHR5cGU6IFRhZyA9PT0gJ2J1dHRvbicgJiYgKHByb3BzLm9uQ2xpY2sgfHwgdGhpcy5wcm9wcy50b2dnbGUpID8gJ2J1dHRvbicgOiB1bmRlZmluZWRcbiAgICB9LCBwcm9wcywge1xuICAgICAgdGFiSW5kZXg6IHRhYkluZGV4LFxuICAgICAgcm9sZTogcm9sZSxcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NlcyxcbiAgICAgIG9uQ2xpY2s6IHRoaXMub25DbGlja1xuICAgIH0pKTtcbiAgfTtcblxuICByZXR1cm4gRHJvcGRvd25JdGVtO1xufShSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uQ29tcG9uZW50KTtcblxuRHJvcGRvd25JdGVtLnByb3BUeXBlcyA9IHByb3BUeXBlcyQxMztcbkRyb3Bkb3duSXRlbS5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHMkMTI7XG5Ecm9wZG93bkl0ZW0uY29udGV4dFR5cGUgPSBEcm9wZG93bkNvbnRleHQ7XG52YXIgRHJvcGRvd25JdGVtJDEgPSBEcm9wZG93bkl0ZW07XG5cbnZhciBfZXhjbHVkZWQkXyA9IFtcImNsYXNzTmFtZVwiLCBcImNzc01vZHVsZVwiLCBcImRhcmtcIiwgXCJlbmRcIiwgXCJyaWdodFwiLCBcInRhZ1wiLCBcImZsaXBcIiwgXCJtb2RpZmllcnNcIiwgXCJwZXJzaXN0XCIsIFwic3RyYXRlZ3lcIiwgXCJjb250YWluZXJcIiwgXCJ1cGRhdGVPblNlbGVjdFwiXTtcbnZhciBwcm9wVHlwZXMkMTIgPSB7XG4gIHRhZzogdGFnUHJvcFR5cGUsXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm5vZGUuaXNSZXF1aXJlZCxcbiAgZGFyazogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBlbmQ6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcblxuICAvKiogRmxpcHMgdGhlIG1lbnUgdG8gdGhlIG9wcG9zaXRlIHNpZGUgaWYgdGhlcmUgaXMgbm90IGVub3VnaCBzcGFjZSB0byBmaXQgKi9cbiAgZmxpcDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBtb2RpZmllcnM6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYXJyYXksXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG4gIHN0eWxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCxcbiAgcGVyc2lzdDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBzdHJhdGVneTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIGNvbnRhaW5lcjogdGFyZ2V0UHJvcFR5cGUsXG5cbiAgLyoqIFVwZGF0ZSBwb3BwZXIgbGF5b3V0IHdoZW4gYSBjbGljayBldmVudCBjb21lcyB1cC4gVGhpcyBsZXZlcmFnZXMgZXZlbnQgYnViYmxpbmcuICovXG4gIHVwZGF0ZU9uU2VsZWN0OiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG4gIHJpZ2h0OiBkZXByZWNhdGVkKFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCwgJ1BsZWFzZSB1c2UgXCJlbmRcIiBpbnN0ZWFkLicpXG59O1xudmFyIGRlZmF1bHRQcm9wcyQxMSA9IHtcbiAgdGFnOiAnZGl2JyxcbiAgZmxpcDogdHJ1ZSxcbiAgbW9kaWZpZXJzOiBbXVxufTtcbnZhciBkaXJlY3Rpb25Qb3NpdGlvbk1hcCA9IHtcbiAgdXA6ICd0b3AnLFxuICBsZWZ0OiAnbGVmdCcsXG4gIHJpZ2h0OiAncmlnaHQnLFxuICBzdGFydDogJ2xlZnQnLFxuICBlbmQ6ICdyaWdodCcsXG4gIGRvd246ICdib3R0b20nXG59O1xuXG52YXIgRHJvcGRvd25NZW51ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKERyb3Bkb3duTWVudSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gRHJvcGRvd25NZW51KCkge1xuICAgIHJldHVybiBfUmVhY3QkQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBEcm9wZG93bk1lbnUucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRSb2xlID0gZnVuY3Rpb24gZ2V0Um9sZSgpIHtcbiAgICBpZiAodGhpcy5jb250ZXh0Lm1lbnVSb2xlID09PSAnbGlzdGJveCcpIHtcbiAgICAgIHJldHVybiAnbGlzdGJveCc7XG4gICAgfVxuXG4gICAgcmV0dXJuICdtZW51JztcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wcy5jbGFzc05hbWUsXG4gICAgICAgIGNzc01vZHVsZSA9IF90aGlzJHByb3BzLmNzc01vZHVsZSxcbiAgICAgICAgZGFyayA9IF90aGlzJHByb3BzLmRhcmssXG4gICAgICAgIGVuZCA9IF90aGlzJHByb3BzLmVuZCxcbiAgICAgICAgcmlnaHQgPSBfdGhpcyRwcm9wcy5yaWdodCxcbiAgICAgICAgdGFnID0gX3RoaXMkcHJvcHMudGFnLFxuICAgICAgICBmbGlwID0gX3RoaXMkcHJvcHMuZmxpcCxcbiAgICAgICAgbW9kaWZpZXJzID0gX3RoaXMkcHJvcHMubW9kaWZpZXJzLFxuICAgICAgICBwZXJzaXN0ID0gX3RoaXMkcHJvcHMucGVyc2lzdCxcbiAgICAgICAgc3RyYXRlZ3kgPSBfdGhpcyRwcm9wcy5zdHJhdGVneSxcbiAgICAgICAgY29udGFpbmVyID0gX3RoaXMkcHJvcHMuY29udGFpbmVyLFxuICAgICAgICB1cGRhdGVPblNlbGVjdCA9IF90aGlzJHByb3BzLnVwZGF0ZU9uU2VsZWN0LFxuICAgICAgICBhdHRycyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzLCBfZXhjbHVkZWQkXyk7XG5cbiAgICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjbGFzc05hbWUsICdkcm9wZG93bi1tZW51Jywge1xuICAgICAgJ2Ryb3Bkb3duLW1lbnUtZGFyayc6IGRhcmssXG4gICAgICAnZHJvcGRvd24tbWVudS1lbmQnOiBlbmQgfHwgcmlnaHQsXG4gICAgICBzaG93OiB0aGlzLmNvbnRleHQuaXNPcGVuXG4gICAgfSksIGNzc01vZHVsZSk7XG4gICAgdmFyIFRhZyA9IHRhZztcblxuICAgIGlmIChwZXJzaXN0IHx8IHRoaXMuY29udGV4dC5pc09wZW4gJiYgIXRoaXMuY29udGV4dC5pbk5hdmJhcikge1xuICAgICAgdmFyIHBvc2l0aW9uMSA9IGRpcmVjdGlvblBvc2l0aW9uTWFwW3RoaXMuY29udGV4dC5kaXJlY3Rpb25dIHx8ICdib3R0b20nO1xuICAgICAgdmFyIHBvc2l0aW9uMiA9IGVuZCB8fCByaWdodCA/ICdlbmQnIDogJ3N0YXJ0JztcbiAgICAgIHZhciBwb3BlclBsYWNlbWVudCA9IHBvc2l0aW9uMSArIFwiLVwiICsgcG9zaXRpb24yO1xuICAgICAgdmFyIHBvcGVyTW9kaWZpZXJzID0gW10uY29uY2F0KG1vZGlmaWVycywgW3tcbiAgICAgICAgbmFtZTogJ2ZsaXAnLFxuICAgICAgICBlbmFibGVkOiAhIWZsaXBcbiAgICAgIH1dKTtcbiAgICAgIHZhciBwb3BwZXIgPSAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQocmVhY3RQb3BwZXIuUG9wcGVyLCB7XG4gICAgICAgIHBsYWNlbWVudDogcG9wZXJQbGFjZW1lbnQsXG4gICAgICAgIG1vZGlmaWVyczogcG9wZXJNb2RpZmllcnMsXG4gICAgICAgIHN0cmF0ZWd5OiBzdHJhdGVneVxuICAgICAgfSwgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIHJlZiA9IF9yZWYucmVmLFxuICAgICAgICAgICAgc3R5bGUgPSBfcmVmLnN0eWxlLFxuICAgICAgICAgICAgcGxhY2VtZW50ID0gX3JlZi5wbGFjZW1lbnQsXG4gICAgICAgICAgICB1cGRhdGUgPSBfcmVmLnVwZGF0ZTtcblxuICAgICAgICB2YXIgY29tYmluZWRTdHlsZSA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBfdGhpcy5wcm9wcy5zdHlsZSksIHN0eWxlKTtcblxuICAgICAgICB2YXIgaGFuZGxlUmVmID0gZnVuY3Rpb24gaGFuZGxlUmVmKHRhZ1JlZikge1xuICAgICAgICAgIC8vIFNlbmQgdGhlIHJlZiB0byBgcmVhY3QtcG9wcGVyYFxuICAgICAgICAgIHJlZih0YWdSZWYpOyAvLyBTZW5kIHRoZSByZWYgdG8gdGhlIHBhcmVudCBEcm9wZG93biBzbyB0aGF0IGNsaWNrcyBvdXRzaWRlXG4gICAgICAgICAgLy8gaXQgd2lsbCBjYXVzZSBpdCB0byBjbG9zZVxuXG4gICAgICAgICAgdmFyIG9uTWVudVJlZiA9IF90aGlzLmNvbnRleHQub25NZW51UmVmO1xuICAgICAgICAgIGlmIChvbk1lbnVSZWYpIG9uTWVudVJlZih0YWdSZWYpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoVGFnLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgdGFiSW5kZXg6IFwiLTFcIixcbiAgICAgICAgICByb2xlOiBfdGhpcy5nZXRSb2xlKCksXG4gICAgICAgICAgcmVmOiBoYW5kbGVSZWZcbiAgICAgICAgfSwgYXR0cnMsIHtcbiAgICAgICAgICBzdHlsZTogY29tYmluZWRTdHlsZSxcbiAgICAgICAgICBcImFyaWEtaGlkZGVuXCI6ICFfdGhpcy5jb250ZXh0LmlzT3BlbixcbiAgICAgICAgICBjbGFzc05hbWU6IGNsYXNzZXMsXG4gICAgICAgICAgXCJkYXRhLXBvcHBlci1wbGFjZW1lbnRcIjogcGxhY2VtZW50LFxuICAgICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soKSB7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlT25TZWxlY3QgJiYgdXBkYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICByZXR1cm4gUmVhY3RET01fX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZVBvcnRhbChwb3BwZXIsIGdldFRhcmdldChjb250YWluZXIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBvcHBlcjtcbiAgICB9XG5cbiAgICB2YXIgb25NZW51UmVmID0gdGhpcy5jb250ZXh0Lm9uTWVudVJlZjtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe1xuICAgICAgdGFiSW5kZXg6IFwiLTFcIixcbiAgICAgIHJvbGU6IHRoaXMuZ2V0Um9sZSgpXG4gICAgfSwgYXR0cnMsIHtcbiAgICAgIHJlZjogb25NZW51UmVmLFxuICAgICAgXCJhcmlhLWhpZGRlblwiOiAhdGhpcy5jb250ZXh0LmlzT3BlbixcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NlcyxcbiAgICAgIFwiZGF0YS1wb3BwZXItcGxhY2VtZW50XCI6IGF0dHJzLnBsYWNlbWVudFxuICAgIH0pKTtcbiAgfTtcblxuICByZXR1cm4gRHJvcGRvd25NZW51O1xufShSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uQ29tcG9uZW50KTtcblxuRHJvcGRvd25NZW51LnByb3BUeXBlcyA9IHByb3BUeXBlcyQxMjtcbkRyb3Bkb3duTWVudS5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHMkMTE7XG5Ecm9wZG93bk1lbnUuY29udGV4dFR5cGUgPSBEcm9wZG93bkNvbnRleHQ7XG52YXIgRHJvcGRvd25NZW51JDEgPSBEcm9wZG93bk1lbnU7XG5cbnZhciBfZXhjbHVkZWQkWiA9IFtcImNsYXNzTmFtZVwiLCBcImNvbG9yXCIsIFwiY3NzTW9kdWxlXCIsIFwiY2FyZXRcIiwgXCJzcGxpdFwiLCBcIm5hdlwiLCBcInRhZ1wiLCBcImlubmVyUmVmXCJdO1xudmFyIHByb3BUeXBlcyQxMSA9IHtcbiAgY2FyZXQ6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcbiAgY29sb3I6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ub2RlLFxuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICBjc3NNb2R1bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LFxuICBkaXNhYmxlZDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBvbkNsaWNrOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZ1bmMsXG4gICdhcmlhLWhhc3BvcHVwJzogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBzcGxpdDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICB0YWc6IHRhZ1Byb3BUeXBlLFxuICBuYXY6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcbiAgaW5uZXJSZWY6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCwgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuY10pXG59O1xudmFyIGRlZmF1bHRQcm9wcyQxMCA9IHtcbiAgY29sb3I6ICdzZWNvbmRhcnknLFxuICAnYXJpYS1oYXNwb3B1cCc6IHRydWVcbn07XG5cbnZhciBEcm9wZG93blRvZ2dsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShEcm9wZG93blRvZ2dsZSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gRHJvcGRvd25Ub2dnbGUocHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9SZWFjdCRDb21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICBfdGhpcy5vbkNsaWNrID0gX3RoaXMub25DbGljay5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRHJvcGRvd25Ub2dnbGUucHJvdG90eXBlO1xuXG4gIF9wcm90by5vbkNsaWNrID0gZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgaWYgKHRoaXMucHJvcHMuZGlzYWJsZWQgfHwgdGhpcy5jb250ZXh0LmRpc2FibGVkKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJvcHMubmF2ICYmICF0aGlzLnByb3BzLnRhZykge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnByb3BzLm9uQ2xpY2spIHtcbiAgICAgIHRoaXMucHJvcHMub25DbGljayhlKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRleHQudG9nZ2xlKGUpO1xuICB9O1xuXG4gIF9wcm90by5nZXRSb2xlID0gZnVuY3Rpb24gZ2V0Um9sZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0Lm1lbnVSb2xlIHx8IHRoaXMucHJvcHNbJ2FyaWEtaGFzcG9wdXAnXTtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgICBjb2xvciA9IF90aGlzJHByb3BzLmNvbG9yLFxuICAgICAgICBjc3NNb2R1bGUgPSBfdGhpcyRwcm9wcy5jc3NNb2R1bGUsXG4gICAgICAgIGNhcmV0ID0gX3RoaXMkcHJvcHMuY2FyZXQsXG4gICAgICAgIHNwbGl0ID0gX3RoaXMkcHJvcHMuc3BsaXQsXG4gICAgICAgIG5hdiA9IF90aGlzJHByb3BzLm5hdixcbiAgICAgICAgdGFnID0gX3RoaXMkcHJvcHMudGFnLFxuICAgICAgICBpbm5lclJlZiA9IF90aGlzJHByb3BzLmlubmVyUmVmLFxuICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzLCBfZXhjbHVkZWQkWik7XG5cbiAgICB2YXIgYXJpYUxhYmVsID0gcHJvcHNbJ2FyaWEtbGFiZWwnXSB8fCAnVG9nZ2xlIERyb3Bkb3duJztcbiAgICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjbGFzc05hbWUsIHtcbiAgICAgICdkcm9wZG93bi10b2dnbGUnOiBjYXJldCB8fCBzcGxpdCxcbiAgICAgICdkcm9wZG93bi10b2dnbGUtc3BsaXQnOiBzcGxpdCxcbiAgICAgICduYXYtbGluayc6IG5hdlxuICAgIH0pLCBjc3NNb2R1bGUpO1xuICAgIHZhciBjaGlsZHJlbiA9IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiAhPT0gJ3VuZGVmaW5lZCcgPyBwcm9wcy5jaGlsZHJlbiA6IC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgY2xhc3NOYW1lOiBcInZpc3VhbGx5LWhpZGRlblwiXG4gICAgfSwgYXJpYUxhYmVsKTtcbiAgICB2YXIgVGFnO1xuXG4gICAgaWYgKG5hdiAmJiAhdGFnKSB7XG4gICAgICBUYWcgPSAnYSc7XG4gICAgICBwcm9wcy5ocmVmID0gJyMnO1xuICAgIH0gZWxzZSBpZiAoIXRhZykge1xuICAgICAgVGFnID0gQnV0dG9uO1xuICAgICAgcHJvcHMuY29sb3IgPSBjb2xvcjtcbiAgICAgIHByb3BzLmNzc01vZHVsZSA9IGNzc01vZHVsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgVGFnID0gdGFnO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNvbnRleHQuaW5OYXZiYXIpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoVGFnLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc2VzLFxuICAgICAgICBvbkNsaWNrOiB0aGlzLm9uQ2xpY2ssXG4gICAgICAgIHJlZjogdGhpcy5jb250ZXh0Lm9uVG9nZ2xlUmVmLFxuICAgICAgICBcImFyaWEtZXhwYW5kZWRcIjogdGhpcy5jb250ZXh0LmlzT3BlbixcbiAgICAgICAgXCJhcmlhLWhhc3BvcHVwXCI6IHRoaXMuZ2V0Um9sZSgpLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KHJlYWN0UG9wcGVyLlJlZmVyZW5jZSwge1xuICAgICAgaW5uZXJSZWY6IGlubmVyUmVmXG4gICAgfSwgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBfcmVmMjtcblxuICAgICAgdmFyIHJlZiA9IF9yZWYucmVmO1xuXG4gICAgICB2YXIgaGFuZGxlUmVmID0gZnVuY3Rpb24gaGFuZGxlUmVmKHRhZ1JlZikge1xuICAgICAgICByZWYodGFnUmVmKTtcbiAgICAgICAgdmFyIG9uVG9nZ2xlUmVmID0gX3RoaXMyLmNvbnRleHQub25Ub2dnbGVSZWY7XG4gICAgICAgIGlmIChvblRvZ2dsZVJlZikgb25Ub2dnbGVSZWYodGFnUmVmKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoVGFnLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIChfcmVmMiA9IHt9LCBfcmVmMlt0eXBlb2YgVGFnID09PSAnc3RyaW5nJyA/ICdyZWYnIDogJ2lubmVyUmVmJ10gPSBoYW5kbGVSZWYsIF9yZWYyKSwge1xuICAgICAgICBjbGFzc05hbWU6IGNsYXNzZXMsXG4gICAgICAgIG9uQ2xpY2s6IF90aGlzMi5vbkNsaWNrLFxuICAgICAgICBcImFyaWEtZXhwYW5kZWRcIjogX3RoaXMyLmNvbnRleHQuaXNPcGVuLFxuICAgICAgICBcImFyaWEtaGFzcG9wdXBcIjogX3RoaXMyLmdldFJvbGUoKSxcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIERyb3Bkb3duVG9nZ2xlO1xufShSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uQ29tcG9uZW50KTtcblxuRHJvcGRvd25Ub2dnbGUucHJvcFR5cGVzID0gcHJvcFR5cGVzJDExO1xuRHJvcGRvd25Ub2dnbGUuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJDEwO1xuRHJvcGRvd25Ub2dnbGUuY29udGV4dFR5cGUgPSBEcm9wZG93bkNvbnRleHQ7XG52YXIgRHJvcGRvd25Ub2dnbGUkMSA9IERyb3Bkb3duVG9nZ2xlO1xuXG52YXIgX2V4Y2x1ZGVkJFkgPSBbXCJ0YWdcIiwgXCJiYXNlQ2xhc3NcIiwgXCJiYXNlQ2xhc3NBY3RpdmVcIiwgXCJjbGFzc05hbWVcIiwgXCJjc3NNb2R1bGVcIiwgXCJjaGlsZHJlblwiLCBcImlubmVyUmVmXCJdO1xuXG52YXIgcHJvcFR5cGVzJDEwID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHJlYWN0VHJhbnNpdGlvbkdyb3VwLlRyYW5zaXRpb24ucHJvcFR5cGVzKSwge30sIHtcbiAgY2hpbGRyZW46IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmFycmF5T2YoUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ub2RlKSwgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ub2RlXSksXG4gIHRhZzogdGFnUHJvcFR5cGUsXG4gIGJhc2VDbGFzczogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIGJhc2VDbGFzc0FjdGl2ZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG4gIGlubmVyUmVmOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9uZU9mVHlwZShbUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLCBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZ1bmNdKVxufSk7XG5cbnZhciBkZWZhdWx0UHJvcHMkJCA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCByZWFjdFRyYW5zaXRpb25Hcm91cC5UcmFuc2l0aW9uLmRlZmF1bHRQcm9wcyksIHt9LCB7XG4gIHRhZzogJ2RpdicsXG4gIGJhc2VDbGFzczogJ2ZhZGUnLFxuICBiYXNlQ2xhc3NBY3RpdmU6ICdzaG93JyxcbiAgdGltZW91dDogVHJhbnNpdGlvblRpbWVvdXRzLkZhZGUsXG4gIGFwcGVhcjogdHJ1ZSxcbiAgZW50ZXI6IHRydWUsXG4gIGV4aXQ6IHRydWUsXG4gIFwiaW5cIjogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIEZhZGUocHJvcHMpIHtcbiAgdmFyIFRhZyA9IHByb3BzLnRhZyxcbiAgICAgIGJhc2VDbGFzcyA9IHByb3BzLmJhc2VDbGFzcyxcbiAgICAgIGJhc2VDbGFzc0FjdGl2ZSA9IHByb3BzLmJhc2VDbGFzc0FjdGl2ZSxcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNzc01vZHVsZSA9IHByb3BzLmNzc01vZHVsZSxcbiAgICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBpbm5lclJlZiA9IHByb3BzLmlubmVyUmVmLFxuICAgICAgb3RoZXJQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQkWSk7XG5cbiAgdmFyIHRyYW5zaXRpb25Qcm9wcyA9IHBpY2sob3RoZXJQcm9wcywgVHJhbnNpdGlvblByb3BUeXBlS2V5cyk7XG4gIHZhciBjaGlsZFByb3BzID0gb21pdChvdGhlclByb3BzLCBUcmFuc2l0aW9uUHJvcFR5cGVLZXlzKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChyZWFjdFRyYW5zaXRpb25Hcm91cC5UcmFuc2l0aW9uLCB0cmFuc2l0aW9uUHJvcHMsIGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgICB2YXIgaXNBY3RpdmUgPSBzdGF0dXMgPT09ICdlbnRlcmVkJztcbiAgICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjbGFzc05hbWUsIGJhc2VDbGFzcywgaXNBY3RpdmUgJiYgYmFzZUNsYXNzQWN0aXZlKSwgY3NzTW9kdWxlKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe1xuICAgICAgY2xhc3NOYW1lOiBjbGFzc2VzXG4gICAgfSwgY2hpbGRQcm9wcywge1xuICAgICAgcmVmOiBpbm5lclJlZlxuICAgIH0pLCBjaGlsZHJlbik7XG4gIH0pO1xufVxuXG5GYWRlLnByb3BUeXBlcyA9IHByb3BUeXBlcyQxMDtcbkZhZGUuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJCQ7XG5cbi8qKlxuICogQWNjb3JkaW9uQ29udGV4dFxuICoge1xuICogIHRvZ2dsZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAqICBvcGVuSWQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gKiB9XG4gKi9cblxudmFyIEFjY29yZGlvbkNvbnRleHQgPSBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlQ29udGV4dCh7fSk7XG5cbnZhciBfZXhjbHVkZWQkWCA9IFtcImZsdXNoXCIsIFwib3BlblwiLCBcInRvZ2dsZVwiLCBcImNsYXNzTmFtZVwiLCBcImNzc01vZHVsZVwiLCBcInRhZ1wiLCBcImlubmVyUmVmXCJdO1xudmFyIHByb3BUeXBlcyQkID0ge1xuICBjaGlsZHJlbjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ub2RlLFxuXG4gIC8qKiBBZGQgY3VzdG9tIGNsYXNzICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG5cbiAgLyoqIENoYW5nZSBleGlzdGluZyBjbGFzc05hbWUgd2l0aCBhIG5ldyBjbGFzc05hbWUgKi9cbiAgY3NzTW9kdWxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCxcblxuICAvKiogUmVuZGVyIGFjY29yZGlvbnMgZWRnZS10by1lZGdlIHdpdGggdGhlaXIgcGFyZW50IGNvbnRhaW5lciAqL1xuICBmbHVzaDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBpbm5lclJlZjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vbmVPZlR5cGUoW1Byb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LCBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZywgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5mdW5jXSksXG5cbiAgLyoqIFRoZSBjdXJyZW50IGFjdGl2ZSBrZXkgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgY3VycmVudGx5IGV4cGFuZGVkIGNhcmQgKi9cbiAgb3BlbjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vbmVPZlR5cGUoW1Byb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYXJyYXksIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nXSkuaXNSZXF1aXJlZCxcblxuICAvKiogU2V0IGEgY3VzdG9tIGVsZW1lbnQgZm9yIHRoaXMgY29tcG9uZW50ICovXG4gIHRhZzogdGFnUHJvcFR5cGUsXG5cbiAgLyoqIEZ1bmN0aW9uIHRoYXQncyB0cmlnZ2VyZWQgb24gY2xpY2tpbmcgYEFjY29yZGlvbkhlYWRlcmAgKi9cbiAgdG9nZ2xlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZ1bmMuaXNSZXF1aXJlZFxufTtcbnZhciBkZWZhdWx0UHJvcHMkXyA9IHtcbiAgdGFnOiAnZGl2J1xufTtcblxuZnVuY3Rpb24gQWNjb3JkaW9uKHByb3BzKSB7XG4gIHZhciBmbHVzaCA9IHByb3BzLmZsdXNoLFxuICAgICAgb3BlbiA9IHByb3BzLm9wZW4sXG4gICAgICB0b2dnbGUgPSBwcm9wcy50b2dnbGUsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjc3NNb2R1bGUgPSBwcm9wcy5jc3NNb2R1bGUsXG4gICAgICBUYWcgPSBwcm9wcy50YWcsXG4gICAgICBpbm5lclJlZiA9IHByb3BzLmlubmVyUmVmLFxuICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQkWCk7XG5cbiAgdmFyIGNsYXNzZXMgPSBtYXBUb0Nzc01vZHVsZXMoY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oY2xhc3NOYW1lLCAnYWNjb3JkaW9uJywge1xuICAgICdhY2NvcmRpb24tZmx1c2gnOiBmbHVzaFxuICB9KSwgY3NzTW9kdWxlKTtcbiAgdmFyIGFjY29yZGlvbkNvbnRleHQgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3Blbjogb3BlbixcbiAgICAgIHRvZ2dsZTogdG9nZ2xlXG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoQWNjb3JkaW9uQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBhY2NvcmRpb25Db250ZXh0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChUYWcsIF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzLFxuICAgIHJlZjogaW5uZXJSZWZcbiAgfSkpKTtcbn1cblxuQWNjb3JkaW9uLnByb3BUeXBlcyA9IHByb3BUeXBlcyQkO1xuQWNjb3JkaW9uLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyRfO1xuXG52YXIgX2V4Y2x1ZGVkJFcgPSBbXCJkZWZhdWx0T3BlblwiLCBcInN0YXlPcGVuXCJdO1xudmFyIHByb3BUeXBlcyRfID0ge1xuICB0YWc6IHRhZ1Byb3BUeXBlLFxuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICBjc3NNb2R1bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LFxuICBpbm5lclJlZjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vbmVPZlR5cGUoW1Byb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LCBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZywgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5mdW5jXSksXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm5vZGUsXG4gIGRlZmF1bHRPcGVuOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9uZU9mVHlwZShbUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5hcnJheSwgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmddKSxcbiAgc3RheU9wZW46IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbFxufTtcbnZhciBkZWZhdWx0UHJvcHMkWiA9IHtcbiAgdGFnOiAnZGl2J1xufTtcblxuZnVuY3Rpb24gVW5jb250cm9sbGVkQWNjb3JkaW9uKF9yZWYpIHtcbiAgdmFyIGRlZmF1bHRPcGVuID0gX3JlZi5kZWZhdWx0T3BlbixcbiAgICAgIHN0YXlPcGVuID0gX3JlZi5zdGF5T3BlbixcbiAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgX2V4Y2x1ZGVkJFcpO1xuXG4gIHZhciBfdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZShkZWZhdWx0T3BlbiB8fCAoc3RheU9wZW4gPyBbXSA6IHVuZGVmaW5lZCkpLFxuICAgICAgb3BlbiA9IF91c2VTdGF0ZVswXSxcbiAgICAgIHNldE9wZW4gPSBfdXNlU3RhdGVbMV07XG5cbiAgdmFyIHRvZ2dsZSA9IGZ1bmN0aW9uIHRvZ2dsZShpZCkge1xuICAgIGlmIChzdGF5T3Blbikge1xuICAgICAgaWYgKG9wZW4uaW5jbHVkZXMoaWQpKSB7XG4gICAgICAgIHNldE9wZW4ob3Blbi5maWx0ZXIoZnVuY3Rpb24gKGFjY29yZGlvbklkKSB7XG4gICAgICAgICAgcmV0dXJuIGFjY29yZGlvbklkICE9PSBpZDtcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0T3BlbihbXS5jb25jYXQob3BlbiwgW2lkXSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3BlbiA9PT0gaWQpIHtcbiAgICAgIHNldE9wZW4odW5kZWZpbmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0T3BlbihpZCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoQWNjb3JkaW9uLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBvcGVuOiBvcGVuLFxuICAgIHRvZ2dsZTogdG9nZ2xlXG4gIH0pKTtcbn1cblxuVW5jb250cm9sbGVkQWNjb3JkaW9uLnByb3BUeXBlcyA9IHByb3BUeXBlcyRfO1xuVW5jb250cm9sbGVkQWNjb3JkaW9uLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyRaO1xuXG52YXIgX2V4Y2x1ZGVkJFYgPSBbXCJjbGFzc05hbWVcIiwgXCJjc3NNb2R1bGVcIiwgXCJ0YWdcIiwgXCJpbm5lclJlZlwiLCBcImNoaWxkcmVuXCIsIFwidGFyZ2V0SWRcIl07XG52YXIgcHJvcFR5cGVzJFogPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm5vZGUsXG5cbiAgLyoqIEFkZCBjdXN0b20gY2xhc3MgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcblxuICAvKiogQ2hhbmdlIGV4aXN0aW5nIGJhc2UgY2xhc3MgbmFtZSB3aXRoIGEgbmV3IGNsYXNzIG5hbWUgKi9cbiAgY3NzTW9kdWxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCxcbiAgaW5uZXJSZWY6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCwgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuY10pLFxuXG4gIC8qKiBTZXQgYSBjdXN0b20gZWxlbWVudCBmb3IgdGhpcyBjb21wb25lbnQgKi9cbiAgdGFnOiB0YWdQcm9wVHlwZSxcblxuICAvKiogVW5pcXVlIGtleSB1c2VkIHRvIGNvbnRyb2wgaXRlbSdzIGNvbGxhcHNlL2V4cGFuZCAqL1xuICB0YXJnZXRJZDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcuaXNSZXF1aXJlZFxufTtcbnZhciBkZWZhdWx0UHJvcHMkWSA9IHtcbiAgdGFnOiAnaDInXG59O1xuXG5mdW5jdGlvbiBBY2NvcmRpb25IZWFkZXIocHJvcHMpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNzc01vZHVsZSA9IHByb3BzLmNzc01vZHVsZSxcbiAgICAgIFRhZyA9IHByb3BzLnRhZyxcbiAgICAgIGlubmVyUmVmID0gcHJvcHMuaW5uZXJSZWYsXG4gICAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgdGFyZ2V0SWQgPSBwcm9wcy50YXJnZXRJZCxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkJFYpO1xuXG4gIHZhciBfdXNlQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoQWNjb3JkaW9uQ29udGV4dCksXG4gICAgICBvcGVuID0gX3VzZUNvbnRleHQub3BlbixcbiAgICAgIHRvZ2dsZSA9IF91c2VDb250ZXh0LnRvZ2dsZTtcblxuICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjbGFzc05hbWUsICdhY2NvcmRpb24taGVhZGVyJyksIGNzc01vZHVsZSk7XG4gIHZhciBidXR0b25DbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKCdhY2NvcmRpb24tYnV0dG9uJywge1xuICAgIGNvbGxhcHNlZDogIShBcnJheS5pc0FycmF5KG9wZW4pID8gb3Blbi5pbmNsdWRlcyh0YXJnZXRJZCkgOiBvcGVuID09PSB0YXJnZXRJZClcbiAgfSksIGNzc01vZHVsZSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoVGFnLCBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NlcyxcbiAgICByZWY6IGlubmVyUmVmXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgY2xhc3NOYW1lOiBidXR0b25DbGFzc2VzLFxuICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soKSB7XG4gICAgICByZXR1cm4gdG9nZ2xlKHRhcmdldElkKTtcbiAgICB9XG4gIH0sIGNoaWxkcmVuKSk7XG59XG5cbkFjY29yZGlvbkhlYWRlci5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkWjtcbkFjY29yZGlvbkhlYWRlci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHMkWTtcblxudmFyIF9leGNsdWRlZCRVID0gW1wiY2xhc3NOYW1lXCIsIFwiY3NzTW9kdWxlXCIsIFwidGFnXCIsIFwiaW5uZXJSZWZcIl07XG52YXIgcHJvcFR5cGVzJFkgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm5vZGUsXG5cbiAgLyoqIFRvIGFkZCBjdXN0b20gY2xhc3MgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcblxuICAvKiogQ2hhbmdlIGV4aXN0aW5nIGJhc2UgY2xhc3MgbmFtZSB3aXRoIGEgbmV3IGNsYXNzIG5hbWUgKi9cbiAgY3NzTW9kdWxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCxcbiAgaW5uZXJSZWY6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCwgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuY10pLFxuXG4gIC8qKiBTZXQgYSBjdXN0b20gZWxlbWVudCBmb3IgdGhpcyBjb21wb25lbnQgKi9cbiAgdGFnOiB0YWdQcm9wVHlwZVxufTtcbnZhciBkZWZhdWx0UHJvcHMkWCA9IHtcbiAgdGFnOiAnZGl2J1xufTtcblxuZnVuY3Rpb24gQWNjb3JkaW9uSXRlbShwcm9wcykge1xuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY3NzTW9kdWxlID0gcHJvcHMuY3NzTW9kdWxlLFxuICAgICAgVGFnID0gcHJvcHMudGFnLFxuICAgICAgaW5uZXJSZWYgPSBwcm9wcy5pbm5lclJlZixcbiAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkJFUpO1xuXG4gIHZhciBjbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGNsYXNzTmFtZSwgJ2FjY29yZGlvbi1pdGVtJyksIGNzc01vZHVsZSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoVGFnLCBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NlcyxcbiAgICByZWY6IGlubmVyUmVmXG4gIH0pKTtcbn1cblxuQWNjb3JkaW9uSXRlbS5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkWTtcbkFjY29yZGlvbkl0ZW0uZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJFg7XG5cbnZhciBfZXhjbHVkZWQkVCA9IFtcInRhZ1wiLCBcImhvcml6b250YWxcIiwgXCJpc09wZW5cIiwgXCJjbGFzc05hbWVcIiwgXCJuYXZiYXJcIiwgXCJjc3NNb2R1bGVcIiwgXCJjaGlsZHJlblwiLCBcImlubmVyUmVmXCJdO1xuXG52YXIgX3RyYW5zaXRpb25TdGF0dXNUb0NsO1xuXG52YXIgcHJvcFR5cGVzJFggPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgcmVhY3RUcmFuc2l0aW9uR3JvdXAuVHJhbnNpdGlvbi5wcm9wVHlwZXMpLCB7fSwge1xuICAvKiogTWFrZSBjb250ZW50IGFuaW1hdGlvbiBhcHBlYXIgaG9yaXpvbnRhbGx5ICovXG4gIGhvcml6b250YWw6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcblxuICAvKiogU2V0IGlmIENvbGxhcHNlIGlzIG9wZW4gb3IgY2xvc2VkICovXG4gIGlzT3BlbjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vbmVPZlR5cGUoW1Byb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYXJyYXlPZihQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm5vZGUpLCBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm5vZGVdKSxcblxuICAvKiogU2V0IGEgY3VzdG9tIGVsZW1lbnQgZm9yIHRoaXMgY29tcG9uZW50ICovXG4gIHRhZzogdGFnUHJvcFR5cGUsXG5cbiAgLyoqIEFkZCBjdXN0b20gY2xhc3MgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm5vZGUsXG4gIG5hdmJhcjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuXG4gIC8qKiBDaGFuZ2UgdW5kZXJseWluZyBjb21wb25lbnQncyBDU1MgYmFzZSBjbGFzcyBuYW1lICovXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG4gIGlubmVyUmVmOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnNoYXBlKHtcbiAgICBjdXJyZW50OiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdFxuICB9KVxufSk7XG5cbnZhciBkZWZhdWx0UHJvcHMkVyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCByZWFjdFRyYW5zaXRpb25Hcm91cC5UcmFuc2l0aW9uLmRlZmF1bHRQcm9wcyksIHt9LCB7XG4gIGhvcml6b250YWw6IGZhbHNlLFxuICBpc09wZW46IGZhbHNlLFxuICBhcHBlYXI6IGZhbHNlLFxuICBlbnRlcjogdHJ1ZSxcbiAgZXhpdDogdHJ1ZSxcbiAgdGFnOiAnZGl2JyxcbiAgdGltZW91dDogVHJhbnNpdGlvblRpbWVvdXRzLkNvbGxhcHNlXG59KTtcblxudmFyIHRyYW5zaXRpb25TdGF0dXNUb0NsYXNzSGFzaCA9IChfdHJhbnNpdGlvblN0YXR1c1RvQ2wgPSB7fSwgX3RyYW5zaXRpb25TdGF0dXNUb0NsW1RyYW5zaXRpb25TdGF0dXNlcy5FTlRFUklOR10gPSAnY29sbGFwc2luZycsIF90cmFuc2l0aW9uU3RhdHVzVG9DbFtUcmFuc2l0aW9uU3RhdHVzZXMuRU5URVJFRF0gPSAnY29sbGFwc2Ugc2hvdycsIF90cmFuc2l0aW9uU3RhdHVzVG9DbFtUcmFuc2l0aW9uU3RhdHVzZXMuRVhJVElOR10gPSAnY29sbGFwc2luZycsIF90cmFuc2l0aW9uU3RhdHVzVG9DbFtUcmFuc2l0aW9uU3RhdHVzZXMuRVhJVEVEXSA9ICdjb2xsYXBzZScsIF90cmFuc2l0aW9uU3RhdHVzVG9DbCk7XG5cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25DbGFzcyhzdGF0dXMpIHtcbiAgcmV0dXJuIHRyYW5zaXRpb25TdGF0dXNUb0NsYXNzSGFzaFtzdGF0dXNdIHx8ICdjb2xsYXBzZSc7XG59XG5cbnZhciBDb2xsYXBzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShDb2xsYXBzZSwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gQ29sbGFwc2UocHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9Db21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGRpbWVuc2lvbjogbnVsbFxuICAgIH07XG4gICAgX3RoaXMubm9kZVJlZiA9IHByb3BzLmlubmVyUmVmIHx8IFJlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVSZWYoKTtcbiAgICBbJ29uRW50ZXJpbmcnLCAnb25FbnRlcmVkJywgJ29uRXhpdCcsICdvbkV4aXRpbmcnLCAnb25FeGl0ZWQnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBfdGhpc1tuYW1lXSA9IF90aGlzW25hbWVdLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDb2xsYXBzZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLm9uRW50ZXJpbmcgPSBmdW5jdGlvbiBvbkVudGVyaW5nKF8sIGlzQXBwZWFyaW5nKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLmdldE5vZGUoKTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGRpbWVuc2lvbjogdGhpcy5nZXREaW1lbnNpb24obm9kZSlcbiAgICB9KTtcbiAgICB0aGlzLnByb3BzLm9uRW50ZXJpbmcobm9kZSwgaXNBcHBlYXJpbmcpO1xuICB9O1xuXG4gIF9wcm90by5vbkVudGVyZWQgPSBmdW5jdGlvbiBvbkVudGVyZWQoXywgaXNBcHBlYXJpbmcpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0Tm9kZSgpO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgZGltZW5zaW9uOiBudWxsXG4gICAgfSk7XG4gICAgdGhpcy5wcm9wcy5vbkVudGVyZWQobm9kZSwgaXNBcHBlYXJpbmcpO1xuICB9O1xuXG4gIF9wcm90by5vbkV4aXQgPSBmdW5jdGlvbiBvbkV4aXQoKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLmdldE5vZGUoKTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGRpbWVuc2lvbjogdGhpcy5nZXREaW1lbnNpb24obm9kZSlcbiAgICB9KTtcbiAgICB0aGlzLnByb3BzLm9uRXhpdChub2RlKTtcbiAgfTtcblxuICBfcHJvdG8ub25FeGl0aW5nID0gZnVuY3Rpb24gb25FeGl0aW5nKCkge1xuICAgIHZhciBub2RlID0gdGhpcy5nZXROb2RlKCk7IC8vIGdldHRpbmcgdGhpcyB2YXJpYWJsZSB0cmlnZ2VycyBhIHJlZmxvd1xuXG4gICAgdGhpcy5nZXREaW1lbnNpb24obm9kZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBkaW1lbnNpb246IDBcbiAgICB9KTtcbiAgICB0aGlzLnByb3BzLm9uRXhpdGluZyhub2RlKTtcbiAgfTtcblxuICBfcHJvdG8ub25FeGl0ZWQgPSBmdW5jdGlvbiBvbkV4aXRlZCgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuZ2V0Tm9kZSgpO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgZGltZW5zaW9uOiBudWxsXG4gICAgfSk7XG4gICAgdGhpcy5wcm9wcy5vbkV4aXRlZChub2RlKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0Tm9kZSA9IGZ1bmN0aW9uIGdldE5vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVJlZi5jdXJyZW50O1xuICB9O1xuXG4gIF9wcm90by5nZXREaW1lbnNpb24gPSBmdW5jdGlvbiBnZXREaW1lbnNpb24obm9kZSkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmhvcml6b250YWwgPyBub2RlLnNjcm9sbFdpZHRoIDogbm9kZS5zY3JvbGxIZWlnaHQ7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIFRhZyA9IF90aGlzJHByb3BzLnRhZyxcbiAgICAgICAgaG9yaXpvbnRhbCA9IF90aGlzJHByb3BzLmhvcml6b250YWwsXG4gICAgICAgIGlzT3BlbiA9IF90aGlzJHByb3BzLmlzT3BlbixcbiAgICAgICAgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgICBuYXZiYXIgPSBfdGhpcyRwcm9wcy5uYXZiYXIsXG4gICAgICAgIGNzc01vZHVsZSA9IF90aGlzJHByb3BzLmNzc01vZHVsZSxcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgb3RoZXJQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzLCBfZXhjbHVkZWQkVCk7XG5cbiAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5zdGF0ZS5kaW1lbnNpb247XG4gICAgdmFyIHRyYW5zaXRpb25Qcm9wcyA9IHBpY2sob3RoZXJQcm9wcywgVHJhbnNpdGlvblByb3BUeXBlS2V5cyk7XG4gICAgdmFyIGNoaWxkUHJvcHMgPSBvbWl0KG90aGVyUHJvcHMsIFRyYW5zaXRpb25Qcm9wVHlwZUtleXMpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQocmVhY3RUcmFuc2l0aW9uR3JvdXAuVHJhbnNpdGlvbiwgX2V4dGVuZHMoe30sIHRyYW5zaXRpb25Qcm9wcywge1xuICAgICAgXCJpblwiOiBpc09wZW4sXG4gICAgICBub2RlUmVmOiB0aGlzLm5vZGVSZWYsXG4gICAgICBvbkVudGVyaW5nOiB0aGlzLm9uRW50ZXJpbmcsXG4gICAgICBvbkVudGVyZWQ6IHRoaXMub25FbnRlcmVkLFxuICAgICAgb25FeGl0OiB0aGlzLm9uRXhpdCxcbiAgICAgIG9uRXhpdGluZzogdGhpcy5vbkV4aXRpbmcsXG4gICAgICBvbkV4aXRlZDogdGhpcy5vbkV4aXRlZFxuICAgIH0pLCBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gICAgICB2YXIgX3JlZjtcblxuICAgICAgdmFyIGNvbGxhcHNlQ2xhc3MgPSBnZXRUcmFuc2l0aW9uQ2xhc3Moc3RhdHVzKTtcbiAgICAgIHZhciBjbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGNsYXNzTmFtZSwgaG9yaXpvbnRhbCAmJiAnY29sbGFwc2UtaG9yaXpvbnRhbCcsIGNvbGxhcHNlQ2xhc3MsIG5hdmJhciAmJiAnbmF2YmFyLWNvbGxhcHNlJyksIGNzc01vZHVsZSk7XG4gICAgICB2YXIgc3R5bGUgPSBkaW1lbnNpb24gPT09IG51bGwgPyBudWxsIDogKF9yZWYgPSB7fSwgX3JlZltob3Jpem9udGFsID8gJ3dpZHRoJyA6ICdoZWlnaHQnXSA9IGRpbWVuc2lvbiwgX3JlZik7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe30sIGNoaWxkUHJvcHMsIHtcbiAgICAgICAgc3R5bGU6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBjaGlsZFByb3BzLnN0eWxlKSwgc3R5bGUpLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzZXMsXG4gICAgICAgIHJlZjogX3RoaXMyLm5vZGVSZWZcbiAgICAgIH0pLCBjaGlsZHJlbik7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIENvbGxhcHNlO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5Db2xsYXBzZS5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkWDtcbkNvbGxhcHNlLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyRXO1xudmFyIENvbGxhcHNlJDEgPSBDb2xsYXBzZTtcblxudmFyIF9leGNsdWRlZCRTID0gW1wiY2xhc3NOYW1lXCIsIFwiY3NzTW9kdWxlXCIsIFwidGFnXCIsIFwiaW5uZXJSZWZcIiwgXCJjaGlsZHJlblwiLCBcImFjY29yZGlvbklkXCJdO1xudmFyIHByb3BUeXBlcyRXID0ge1xuICAvKiogVW5pcXVlIGtleSB1c2VkIHRvIGNvbnRyb2wgaXRlbSdzIGNvbGxhcHNlL2V4cGFuZCAqL1xuICBhY2NvcmRpb25JZDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcuaXNSZXF1aXJlZCxcblxuICAvKiogVG8gYWRkIGN1c3RvbSBjbGFzcyAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ub2RlLFxuXG4gIC8qKiBDaGFuZ2UgZXhpc3RpbmcgYmFzZSBjbGFzcyBuYW1lIHdpdGggYSBuZXcgY2xhc3MgbmFtZSAqL1xuICBjc3NNb2R1bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LFxuXG4gIC8qKiBQYXNzIHJlZiB0byB0aGUgY29tcG9uZW50ICovXG4gIGlubmVyUmVmOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9uZU9mVHlwZShbUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLCBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZ1bmNdKSxcblxuICAvKiogU2V0IGEgY3VzdG9tIGVsZW1lbnQgZm9yIHRoaXMgY29tcG9uZW50ICovXG4gIHRhZzogdGFnUHJvcFR5cGVcbn07XG52YXIgZGVmYXVsdFByb3BzJFYgPSB7XG4gIHRhZzogJ2Rpdidcbn07XG5cbmZ1bmN0aW9uIEFjY29yZGlvbkJvZHkocHJvcHMpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNzc01vZHVsZSA9IHByb3BzLmNzc01vZHVsZSxcbiAgICAgIFRhZyA9IHByb3BzLnRhZyxcbiAgICAgIGlubmVyUmVmID0gcHJvcHMuaW5uZXJSZWYsXG4gICAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgYWNjb3JkaW9uSWQgPSBwcm9wcy5hY2NvcmRpb25JZCxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkJFMpO1xuXG4gIHZhciBfdXNlQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoQWNjb3JkaW9uQ29udGV4dCksXG4gICAgICBvcGVuID0gX3VzZUNvbnRleHQub3BlbjtcblxuICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjbGFzc05hbWUsICdhY2NvcmRpb24tY29sbGFwc2UnKSwgY3NzTW9kdWxlKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChDb2xsYXBzZSQxLCBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NlcyxcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGlzT3BlbjogQXJyYXkuaXNBcnJheShvcGVuKSA/IG9wZW4uaW5jbHVkZXMoYWNjb3JkaW9uSWQpIDogb3BlbiA9PT0gYWNjb3JkaW9uSWRcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChUYWcsIHtcbiAgICBjbGFzc05hbWU6IFwiYWNjb3JkaW9uLWJvZHlcIlxuICB9LCBjaGlsZHJlbikpO1xufVxuXG5BY2NvcmRpb25Cb2R5LnByb3BUeXBlcyA9IHByb3BUeXBlcyRXO1xuQWNjb3JkaW9uQm9keS5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHMkVjtcblxudmFyIF9leGNsdWRlZCRSID0gW1wiY2xhc3NOYW1lXCIsIFwiY3NzTW9kdWxlXCIsIFwiY29sb3JcIiwgXCJpbm5lclJlZlwiLCBcInBpbGxcIiwgXCJ0YWdcIl07XG52YXIgcHJvcFR5cGVzJFYgPSB7XG4gIC8qKiBQYXNzIGNoaWxkcmVuIHNvIHRoaXMgY29tcG9uZW50IGNhbiB3cmFwIHRoZSBjaGlsZCBlbGVtZW50cyAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ub2RlLFxuXG4gIC8qKiBBZGQgY3VzdG9tIGNsYXNzICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG5cbiAgLyoqIENoYW5nZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIEJhZGdlICovXG4gIGNvbG9yOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcblxuICAvKiogQ2hhbmdlIGV4aXN0aW5nIGNsYXNzTmFtZSB3aXRoIGEgbmV3IGNsYXNzTmFtZSAqL1xuICBjc3NNb2R1bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LFxuICBpbm5lclJlZjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vbmVPZlR5cGUoW1Byb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LCBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZ1bmMsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nXSksXG5cbiAgLyoqIEFkZCByb3VuZGVkIGNvcm5lcnMgdG8gdGhlIEJhZGdlICovXG4gIHBpbGw6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcblxuICAvKiogU2V0IGEgY3VzdG9tIGVsZW1lbnQgZm9yIHRoaXMgY29tcG9uZW50ICovXG4gIHRhZzogdGFnUHJvcFR5cGVcbn07XG52YXIgZGVmYXVsdFByb3BzJFUgPSB7XG4gIGNvbG9yOiAnc2Vjb25kYXJ5JyxcbiAgcGlsbDogZmFsc2UsXG4gIHRhZzogJ3NwYW4nXG59O1xuXG5mdW5jdGlvbiBCYWRnZShwcm9wcykge1xuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY3NzTW9kdWxlID0gcHJvcHMuY3NzTW9kdWxlLFxuICAgICAgY29sb3IgPSBwcm9wcy5jb2xvcixcbiAgICAgIGlubmVyUmVmID0gcHJvcHMuaW5uZXJSZWYsXG4gICAgICBwaWxsID0gcHJvcHMucGlsbCxcbiAgICAgIFRhZyA9IHByb3BzLnRhZyxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkJFIpO1xuXG4gIHZhciBjbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGNsYXNzTmFtZSwgJ2JhZGdlJywgJ2JnLScgKyBjb2xvciwgcGlsbCA/ICdyb3VuZGVkLXBpbGwnIDogZmFsc2UpLCBjc3NNb2R1bGUpO1xuXG4gIGlmIChhdHRyaWJ1dGVzLmhyZWYgJiYgVGFnID09PSAnc3BhbicpIHtcbiAgICBUYWcgPSAnYSc7XG4gIH1cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzZXMsXG4gICAgcmVmOiBpbm5lclJlZlxuICB9KSk7XG59XG5cbkJhZGdlLnByb3BUeXBlcyA9IHByb3BUeXBlcyRWO1xuQmFkZ2UuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJFU7XG5cbnZhciBfZXhjbHVkZWQkUSA9IFtcImNsYXNzTmFtZVwiLCBcImNzc01vZHVsZVwiLCBcImNvbG9yXCIsIFwiYm9keVwiLCBcImludmVyc2VcIiwgXCJvdXRsaW5lXCIsIFwidGFnXCIsIFwiaW5uZXJSZWZcIl07XG52YXIgcHJvcFR5cGVzJFUgPSB7XG4gIC8qKiBUb2dnbGVzIGNhcmQgcGFkZGluZyB1c2luZyBgLmNhcmQtYm9keWAgKi9cbiAgYm9keTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuXG4gIC8qKiBBZGQgY3VzdG9tIGNsYXNzICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG5cbiAgLyoqIENoYW5nZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIGNvbXBvbmVudCAqL1xuICBjb2xvcjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG5cbiAgLyoqIENoYW5nZSB1bmRlcmx5aW5nIGNvbXBvbmVudCdzIENTUyBiYXNlIGNsYXNzIG5hbWUgKi9cbiAgY3NzTW9kdWxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCxcbiAgaW5uZXJSZWY6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCwgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuY10pLFxuXG4gIC8qKiBJbnZlcnRzIHRoZSBjb2xvciAqL1xuICBpbnZlcnNlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG5cbiAgLyoqIENoYW5nZXMgdGhlIGNhcmQgdG8gaGF2ZSBvbmx5IG91dGxpbmUgKi9cbiAgb3V0bGluZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuXG4gIC8qKiBTZXQgYSBjdXN0b20gZWxlbWVudCBmb3IgdGhpcyBjb21wb25lbnQgKi9cbiAgdGFnOiB0YWdQcm9wVHlwZVxufTtcbnZhciBkZWZhdWx0UHJvcHMkVCA9IHtcbiAgdGFnOiAnZGl2J1xufTtcblxuZnVuY3Rpb24gQ2FyZChwcm9wcykge1xuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY3NzTW9kdWxlID0gcHJvcHMuY3NzTW9kdWxlLFxuICAgICAgY29sb3IgPSBwcm9wcy5jb2xvcixcbiAgICAgIGJvZHkgPSBwcm9wcy5ib2R5LFxuICAgICAgaW52ZXJzZSA9IHByb3BzLmludmVyc2UsXG4gICAgICBvdXRsaW5lID0gcHJvcHMub3V0bGluZSxcbiAgICAgIFRhZyA9IHByb3BzLnRhZyxcbiAgICAgIGlubmVyUmVmID0gcHJvcHMuaW5uZXJSZWYsXG4gICAgICBhdHRyaWJ1dGVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZCRRKTtcblxuICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjbGFzc05hbWUsICdjYXJkJywgaW52ZXJzZSA/ICd0ZXh0LXdoaXRlJyA6IGZhbHNlLCBib2R5ID8gJ2NhcmQtYm9keScgOiBmYWxzZSwgY29sb3IgPyAob3V0bGluZSA/ICdib3JkZXInIDogJ2JnJykgKyBcIi1cIiArIGNvbG9yIDogZmFsc2UpLCBjc3NNb2R1bGUpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzZXMsXG4gICAgcmVmOiBpbm5lclJlZlxuICB9KSk7XG59XG5cbkNhcmQucHJvcFR5cGVzID0gcHJvcFR5cGVzJFU7XG5DYXJkLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyRUO1xuXG52YXIgX2V4Y2x1ZGVkJFAgPSBbXCJjbGFzc05hbWVcIiwgXCJjc3NNb2R1bGVcIiwgXCJ0YWdcIl07XG52YXIgcHJvcFR5cGVzJFQgPSB7XG4gIHRhZzogdGFnUHJvcFR5cGUsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3Rcbn07XG52YXIgZGVmYXVsdFByb3BzJFMgPSB7XG4gIHRhZzogJ2Rpdidcbn07XG5cbmZ1bmN0aW9uIENhcmRHcm91cChwcm9wcykge1xuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY3NzTW9kdWxlID0gcHJvcHMuY3NzTW9kdWxlLFxuICAgICAgVGFnID0gcHJvcHMudGFnLFxuICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQkUCk7XG5cbiAgdmFyIGNsYXNzZXMgPSBtYXBUb0Nzc01vZHVsZXMoY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oY2xhc3NOYW1lLCAnY2FyZC1ncm91cCcpLCBjc3NNb2R1bGUpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzZXNcbiAgfSkpO1xufVxuXG5DYXJkR3JvdXAucHJvcFR5cGVzID0gcHJvcFR5cGVzJFQ7XG5DYXJkR3JvdXAuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJFM7XG5cbnZhciBfZXhjbHVkZWQkTyA9IFtcImNsYXNzTmFtZVwiLCBcImNzc01vZHVsZVwiLCBcInRhZ1wiXTtcbnZhciBwcm9wVHlwZXMkUyA9IHtcbiAgdGFnOiB0YWdQcm9wVHlwZSxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgY3NzTW9kdWxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdFxufTtcbnZhciBkZWZhdWx0UHJvcHMkUiA9IHtcbiAgdGFnOiAnZGl2J1xufTtcblxuZnVuY3Rpb24gQ2FyZERlY2socHJvcHMpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNzc01vZHVsZSA9IHByb3BzLmNzc01vZHVsZSxcbiAgICAgIFRhZyA9IHByb3BzLnRhZyxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkJE8pO1xuXG4gIHZhciBjbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGNsYXNzTmFtZSwgJ2NhcmQtZGVjaycpLCBjc3NNb2R1bGUpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzZXNcbiAgfSkpO1xufVxuXG5DYXJkRGVjay5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkUztcbkNhcmREZWNrLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyRSO1xuXG52YXIgX2V4Y2x1ZGVkJE4gPSBbXCJjbGFzc05hbWVcIiwgXCJjc3NNb2R1bGVcIiwgXCJ0YWdcIl07XG52YXIgcHJvcFR5cGVzJFIgPSB7XG4gIHRhZzogdGFnUHJvcFR5cGUsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3Rcbn07XG52YXIgZGVmYXVsdFByb3BzJFEgPSB7XG4gIHRhZzogJ2Rpdidcbn07XG5cbmZ1bmN0aW9uIENhcmRDb2x1bW5zKHByb3BzKSB7XG4gIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjc3NNb2R1bGUgPSBwcm9wcy5jc3NNb2R1bGUsXG4gICAgICBUYWcgPSBwcm9wcy50YWcsXG4gICAgICBhdHRyaWJ1dGVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZCROKTtcblxuICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjbGFzc05hbWUsICdjYXJkLWNvbHVtbnMnKSwgY3NzTW9kdWxlKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChUYWcsIF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzXG4gIH0pKTtcbn1cblxuQ2FyZENvbHVtbnMucHJvcFR5cGVzID0gcHJvcFR5cGVzJFI7XG5DYXJkQ29sdW1ucy5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHMkUTtcblxudmFyIF9leGNsdWRlZCRNID0gW1wiY2xhc3NOYW1lXCIsIFwiY3NzTW9kdWxlXCIsIFwiaW5uZXJSZWZcIiwgXCJ0YWdcIl07XG52YXIgcHJvcFR5cGVzJFEgPSB7XG4gIC8qKiBBZGQgY3VzdG9tIGNsYXNzICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG5cbiAgLyoqIENoYW5nZSB1bmRlcmx5aW5nIGNvbXBvbmVudCdzIENTUyBiYXNlIGNsYXNzIG5hbWUgKi9cbiAgY3NzTW9kdWxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCxcbiAgaW5uZXJSZWY6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCwgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuY10pLFxuXG4gIC8qKiBTZXQgYSBjdXN0b20gZWxlbWVudCBmb3IgdGhpcyBjb21wb25lbnQgKi9cbiAgdGFnOiB0YWdQcm9wVHlwZVxufTtcbnZhciBkZWZhdWx0UHJvcHMkUCA9IHtcbiAgdGFnOiAnZGl2J1xufTtcblxuZnVuY3Rpb24gQ2FyZEJvZHkocHJvcHMpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNzc01vZHVsZSA9IHByb3BzLmNzc01vZHVsZSxcbiAgICAgIGlubmVyUmVmID0gcHJvcHMuaW5uZXJSZWYsXG4gICAgICBUYWcgPSBwcm9wcy50YWcsXG4gICAgICBhdHRyaWJ1dGVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZCRNKTtcblxuICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjbGFzc05hbWUsICdjYXJkLWJvZHknKSwgY3NzTW9kdWxlKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChUYWcsIF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzLFxuICAgIHJlZjogaW5uZXJSZWZcbiAgfSkpO1xufVxuXG5DYXJkQm9keS5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkUTtcbkNhcmRCb2R5LmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyRQO1xuXG52YXIgX2V4Y2x1ZGVkJEwgPSBbXCJjbGFzc05hbWVcIiwgXCJjc3NNb2R1bGVcIiwgXCJ0YWdcIiwgXCJpbm5lclJlZlwiXTtcbnZhciBwcm9wVHlwZXMkUCA9IHtcbiAgdGFnOiB0YWdQcm9wVHlwZSxcbiAgaW5uZXJSZWY6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCwgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5mdW5jLCBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZ10pLFxuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICBjc3NNb2R1bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0XG59O1xudmFyIGRlZmF1bHRQcm9wcyRPID0ge1xuICB0YWc6ICdhJ1xufTtcblxuZnVuY3Rpb24gQ2FyZExpbmsocHJvcHMpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNzc01vZHVsZSA9IHByb3BzLmNzc01vZHVsZSxcbiAgICAgIFRhZyA9IHByb3BzLnRhZyxcbiAgICAgIGlubmVyUmVmID0gcHJvcHMuaW5uZXJSZWYsXG4gICAgICBhdHRyaWJ1dGVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZCRMKTtcblxuICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjbGFzc05hbWUsICdjYXJkLWxpbmsnKSwgY3NzTW9kdWxlKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChUYWcsIF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgcmVmOiBpbm5lclJlZixcbiAgICBjbGFzc05hbWU6IGNsYXNzZXNcbiAgfSkpO1xufVxuXG5DYXJkTGluay5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkUDtcbkNhcmRMaW5rLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyRPO1xuXG52YXIgX2V4Y2x1ZGVkJEsgPSBbXCJjbGFzc05hbWVcIiwgXCJjc3NNb2R1bGVcIiwgXCJ0YWdcIl07XG52YXIgcHJvcFR5cGVzJE8gPSB7XG4gIC8qKiBBZGQgY3VzdG9tIGNsYXNzICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG5cbiAgLyoqIENoYW5nZSB1bmRlcmx5aW5nIGNvbXBvbmVudCdzIENTUyBiYXNlIGNsYXNzIG5hbWUgKi9cbiAgY3NzTW9kdWxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCxcblxuICAvKiogU2V0IGEgY3VzdG9tIGVsZW1lbnQgZm9yIHRoaXMgY29tcG9uZW50ICovXG4gIHRhZzogdGFnUHJvcFR5cGVcbn07XG52YXIgZGVmYXVsdFByb3BzJE4gPSB7XG4gIHRhZzogJ2Rpdidcbn07XG5cbmZ1bmN0aW9uIENhcmRGb290ZXIocHJvcHMpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNzc01vZHVsZSA9IHByb3BzLmNzc01vZHVsZSxcbiAgICAgIFRhZyA9IHByb3BzLnRhZyxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkJEspO1xuXG4gIHZhciBjbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGNsYXNzTmFtZSwgJ2NhcmQtZm9vdGVyJyksIGNzc01vZHVsZSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoVGFnLCBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3Nlc1xuICB9KSk7XG59XG5cbkNhcmRGb290ZXIucHJvcFR5cGVzID0gcHJvcFR5cGVzJE87XG5DYXJkRm9vdGVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyROO1xuXG52YXIgX2V4Y2x1ZGVkJEogPSBbXCJjbGFzc05hbWVcIiwgXCJjc3NNb2R1bGVcIiwgXCJ0YWdcIl07XG52YXIgcHJvcFR5cGVzJE4gPSB7XG4gIC8qKiBBZGQgY3VzdG9tIGNsYXNzICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG5cbiAgLyoqIENoYW5nZSB1bmRlcmx5aW5nIGNvbXBvbmVudCdzIENTUyBiYXNlIGNsYXNzIG5hbWUgKi9cbiAgY3NzTW9kdWxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCxcblxuICAvKiogU2V0IGEgY3VzdG9tIGVsZW1lbnQgZm9yIHRoaXMgY29tcG9uZW50ICovXG4gIHRhZzogdGFnUHJvcFR5cGVcbn07XG52YXIgZGVmYXVsdFByb3BzJE0gPSB7XG4gIHRhZzogJ2Rpdidcbn07XG5cbmZ1bmN0aW9uIENhcmRIZWFkZXIocHJvcHMpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNzc01vZHVsZSA9IHByb3BzLmNzc01vZHVsZSxcbiAgICAgIFRhZyA9IHByb3BzLnRhZyxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkJEopO1xuXG4gIHZhciBjbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGNsYXNzTmFtZSwgJ2NhcmQtaGVhZGVyJyksIGNzc01vZHVsZSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoVGFnLCBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3Nlc1xuICB9KSk7XG59XG5cbkNhcmRIZWFkZXIucHJvcFR5cGVzID0gcHJvcFR5cGVzJE47XG5DYXJkSGVhZGVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyRNO1xuXG52YXIgX2V4Y2x1ZGVkJEkgPSBbXCJjbGFzc05hbWVcIiwgXCJjc3NNb2R1bGVcIiwgXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJ0YWdcIl07XG52YXIgcHJvcFR5cGVzJE0gPSB7XG4gIC8qKiBBZGQgYGJvdHRvbWAgcHJvcCBpZiBpbWFnZSBpcyBhdCBib3R0b20gb2YgY2FyZCAqL1xuICBib3R0b206IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcblxuICAvKiogQWRkIGN1c3RvbSBjbGFzcyAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuXG4gIC8qKiBDaGFuZ2UgZXhpc3RpbmcgY2xhc3NOYW1lIHdpdGggYSBuZXcgY2xhc3NOYW1lICovXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG5cbiAgLyoqIFNldCBhIGN1c3RvbSBlbGVtZW50IGZvciB0aGlzIGNvbXBvbmVudCAqL1xuICB0YWc6IHRhZ1Byb3BUeXBlLFxuXG4gIC8qKiBBZGQgYHRvcGAgcHJvcCBpZiBpbWFnZSBpcyBhdCB0b3Agb2YgY2FyZCAqL1xuICB0b3A6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbFxufTtcbnZhciBkZWZhdWx0UHJvcHMkTCA9IHtcbiAgdGFnOiAnaW1nJ1xufTtcblxuZnVuY3Rpb24gQ2FyZEltZyhwcm9wcykge1xuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY3NzTW9kdWxlID0gcHJvcHMuY3NzTW9kdWxlLFxuICAgICAgdG9wID0gcHJvcHMudG9wLFxuICAgICAgYm90dG9tID0gcHJvcHMuYm90dG9tLFxuICAgICAgVGFnID0gcHJvcHMudGFnLFxuICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQkSSk7XG5cbiAgdmFyIGNhcmRJbWdDbGFzc05hbWUgPSAnY2FyZC1pbWcnO1xuXG4gIGlmICh0b3ApIHtcbiAgICBjYXJkSW1nQ2xhc3NOYW1lID0gJ2NhcmQtaW1nLXRvcCc7XG4gIH1cblxuICBpZiAoYm90dG9tKSB7XG4gICAgY2FyZEltZ0NsYXNzTmFtZSA9ICdjYXJkLWltZy1ib3R0b20nO1xuICB9XG5cbiAgdmFyIGNsYXNzZXMgPSBtYXBUb0Nzc01vZHVsZXMoY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oY2xhc3NOYW1lLCBjYXJkSW1nQ2xhc3NOYW1lKSwgY3NzTW9kdWxlKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChUYWcsIF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzXG4gIH0pKTtcbn1cblxuQ2FyZEltZy5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkTTtcbkNhcmRJbWcuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJEw7XG5cbnZhciBfZXhjbHVkZWQkSCA9IFtcImNsYXNzTmFtZVwiLCBcImNzc01vZHVsZVwiLCBcInRhZ1wiXTtcbnZhciBwcm9wVHlwZXMkTCA9IHtcbiAgdGFnOiB0YWdQcm9wVHlwZSxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgY3NzTW9kdWxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdFxufTtcbnZhciBkZWZhdWx0UHJvcHMkSyA9IHtcbiAgdGFnOiAnZGl2J1xufTtcblxuZnVuY3Rpb24gQ2FyZEltZ092ZXJsYXkocHJvcHMpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNzc01vZHVsZSA9IHByb3BzLmNzc01vZHVsZSxcbiAgICAgIFRhZyA9IHByb3BzLnRhZyxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkJEgpO1xuXG4gIHZhciBjbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGNsYXNzTmFtZSwgJ2NhcmQtaW1nLW92ZXJsYXknKSwgY3NzTW9kdWxlKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChUYWcsIF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzXG4gIH0pKTtcbn1cblxuQ2FyZEltZ092ZXJsYXkucHJvcFR5cGVzID0gcHJvcFR5cGVzJEw7XG5DYXJkSW1nT3ZlcmxheS5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHMkSztcblxuLyoqXG4gKiBDYXJvdXNlbENvbnRleHRcbiAqIHtcbiAqICBkaXJlY3Rpb246IFByb3BUeXBlcy5vbmVPZihbJ3N0YXJ0JywgJ2VuZCddKS5pc1JlcXVpcmVkLFxuICogfVxuICovXG5cbnZhciBDYXJvdXNlbENvbnRleHQgPSBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlQ29udGV4dCh7fSk7XG5cbnZhciBfZXhjbHVkZWQkRyA9IFtcImluXCIsIFwiY2hpbGRyZW5cIiwgXCJjc3NNb2R1bGVcIiwgXCJzbGlkZVwiLCBcInRhZ1wiLCBcImNsYXNzTmFtZVwiXTtcblxudmFyIENhcm91c2VsSXRlbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShDYXJvdXNlbEl0ZW0sIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIENhcm91c2VsSXRlbShwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgc3RhcnRBbmltYXRpb246IGZhbHNlXG4gICAgfTtcbiAgICBfdGhpcy5vbkVudGVyID0gX3RoaXMub25FbnRlci5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5vbkVudGVyaW5nID0gX3RoaXMub25FbnRlcmluZy5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5vbkV4aXQgPSBfdGhpcy5vbkV4aXQuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMub25FeGl0aW5nID0gX3RoaXMub25FeGl0aW5nLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLm9uRXhpdGVkID0gX3RoaXMub25FeGl0ZWQuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENhcm91c2VsSXRlbS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLm9uRW50ZXIgPSBmdW5jdGlvbiBvbkVudGVyKG5vZGUsIGlzQXBwZWFyaW5nKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBzdGFydEFuaW1hdGlvbjogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLnByb3BzLm9uRW50ZXIobm9kZSwgaXNBcHBlYXJpbmcpO1xuICB9O1xuXG4gIF9wcm90by5vbkVudGVyaW5nID0gZnVuY3Rpb24gb25FbnRlcmluZyhub2RlLCBpc0FwcGVhcmluZykge1xuICAgIC8vIGdldHRpbmcgdGhpcyB2YXJpYWJsZSB0cmlnZ2VycyBhIHJlZmxvd1xuICAgIHZhciBvZmZzZXRIZWlnaHQgPSBub2RlLm9mZnNldEhlaWdodDtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHN0YXJ0QW5pbWF0aW9uOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5wcm9wcy5vbkVudGVyaW5nKG5vZGUsIGlzQXBwZWFyaW5nKTtcbiAgICByZXR1cm4gb2Zmc2V0SGVpZ2h0O1xuICB9O1xuXG4gIF9wcm90by5vbkV4aXQgPSBmdW5jdGlvbiBvbkV4aXQobm9kZSkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgc3RhcnRBbmltYXRpb246IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy5wcm9wcy5vbkV4aXQobm9kZSk7XG4gIH07XG5cbiAgX3Byb3RvLm9uRXhpdGluZyA9IGZ1bmN0aW9uIG9uRXhpdGluZyhub2RlKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBzdGFydEFuaW1hdGlvbjogdHJ1ZVxuICAgIH0pO1xuICAgIG5vZGUuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3NsaWRlLmJzLmNhcm91c2VsJykpO1xuICAgIHRoaXMucHJvcHMub25FeGl0aW5nKG5vZGUpO1xuICB9O1xuXG4gIF9wcm90by5vbkV4aXRlZCA9IGZ1bmN0aW9uIG9uRXhpdGVkKG5vZGUpIHtcbiAgICBub2RlLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdzbGlkLmJzLmNhcm91c2VsJykpO1xuICAgIHRoaXMucHJvcHMub25FeGl0ZWQobm9kZSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGlzSW4gPSBfdGhpcyRwcm9wc1tcImluXCJdLFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzLmNoaWxkcmVuLFxuICAgICAgICBjc3NNb2R1bGUgPSBfdGhpcyRwcm9wcy5jc3NNb2R1bGUsXG4gICAgICAgIHNsaWRlID0gX3RoaXMkcHJvcHMuc2xpZGUsXG4gICAgICAgIFRhZyA9IF90aGlzJHByb3BzLnRhZyxcbiAgICAgICAgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgICB0cmFuc2l0aW9uUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wcywgX2V4Y2x1ZGVkJEcpO1xuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChyZWFjdFRyYW5zaXRpb25Hcm91cC5UcmFuc2l0aW9uLCBfZXh0ZW5kcyh7fSwgdHJhbnNpdGlvblByb3BzLCB7XG4gICAgICBlbnRlcjogc2xpZGUsXG4gICAgICBleGl0OiBzbGlkZSxcbiAgICAgIFwiaW5cIjogaXNJbixcbiAgICAgIG9uRW50ZXI6IHRoaXMub25FbnRlcixcbiAgICAgIG9uRW50ZXJpbmc6IHRoaXMub25FbnRlcmluZyxcbiAgICAgIG9uRXhpdDogdGhpcy5vbkV4aXQsXG4gICAgICBvbkV4aXRpbmc6IHRoaXMub25FeGl0aW5nLFxuICAgICAgb25FeGl0ZWQ6IHRoaXMub25FeGl0ZWRcbiAgICB9KSwgZnVuY3Rpb24gKHN0YXR1cykge1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IF90aGlzMi5jb250ZXh0LmRpcmVjdGlvbjtcbiAgICAgIHZhciBpc0FjdGl2ZSA9IHN0YXR1cyA9PT0gVHJhbnNpdGlvblN0YXR1c2VzLkVOVEVSRUQgfHwgc3RhdHVzID09PSBUcmFuc2l0aW9uU3RhdHVzZXMuRVhJVElORztcbiAgICAgIHZhciBkaXJlY3Rpb25DbGFzc05hbWUgPSAoc3RhdHVzID09PSBUcmFuc2l0aW9uU3RhdHVzZXMuRU5URVJJTkcgfHwgc3RhdHVzID09PSBUcmFuc2l0aW9uU3RhdHVzZXMuRVhJVElORykgJiYgX3RoaXMyLnN0YXRlLnN0YXJ0QW5pbWF0aW9uICYmIChkaXJlY3Rpb24gPT09ICdlbmQnID8gJ2Nhcm91c2VsLWl0ZW0tc3RhcnQnIDogJ2Nhcm91c2VsLWl0ZW0tZW5kJyk7XG4gICAgICB2YXIgb3JkZXJDbGFzc05hbWUgPSBzdGF0dXMgPT09IFRyYW5zaXRpb25TdGF0dXNlcy5FTlRFUklORyAmJiAoZGlyZWN0aW9uID09PSAnZW5kJyA/ICdjYXJvdXNlbC1pdGVtLW5leHQnIDogJ2Nhcm91c2VsLWl0ZW0tcHJldicpO1xuICAgICAgdmFyIGl0ZW1DbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGNsYXNzTmFtZSwgJ2Nhcm91c2VsLWl0ZW0nLCBpc0FjdGl2ZSAmJiAnYWN0aXZlJywgZGlyZWN0aW9uQ2xhc3NOYW1lLCBvcmRlckNsYXNzTmFtZSksIGNzc01vZHVsZSk7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFRhZywge1xuICAgICAgICBjbGFzc05hbWU6IGl0ZW1DbGFzc2VzXG4gICAgICB9LCBjaGlsZHJlbik7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIENhcm91c2VsSXRlbTtcbn0oUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLkNvbXBvbmVudCk7XG5cbkNhcm91c2VsSXRlbS5wcm9wVHlwZXMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgcmVhY3RUcmFuc2l0aW9uR3JvdXAuVHJhbnNpdGlvbi5wcm9wVHlwZXMpLCB7fSwge1xuICAvKiogU2V0IGEgY3VzdG9tIGVsZW1lbnQgZm9yIHRoaXMgY29tcG9uZW50ICovXG4gIHRhZzogdGFnUHJvcFR5cGUsXG4gIFwiaW5cIjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuXG4gIC8qKiBDaGFuZ2UgdW5kZXJseWluZyBjb21wb25lbnQncyBDU1MgYmFzZSBjbGFzcyBuYW1lICovXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm5vZGUsXG5cbiAgLyoqIEVuYWJsZS9kaXNhYmxlIGFuaW1hdGlvbiAqL1xuICBzbGlkZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuXG4gIC8qKiBBZGQgY3VzdG9tIGNsYXNzICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmdcbn0pO1xuQ2Fyb3VzZWxJdGVtLmRlZmF1bHRQcm9wcyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCByZWFjdFRyYW5zaXRpb25Hcm91cC5UcmFuc2l0aW9uLmRlZmF1bHRQcm9wcyksIHt9LCB7XG4gIHRhZzogJ2RpdicsXG4gIHRpbWVvdXQ6IFRyYW5zaXRpb25UaW1lb3V0cy5DYXJvdXNlbCxcbiAgc2xpZGU6IHRydWVcbn0pO1xuQ2Fyb3VzZWxJdGVtLmNvbnRleHRUeXBlID0gQ2Fyb3VzZWxDb250ZXh0O1xudmFyIENhcm91c2VsSXRlbSQxID0gQ2Fyb3VzZWxJdGVtO1xuXG52YXIgU1dJUEVfVEhSRVNIT0xEID0gNDA7XG52YXIgcHJvcFR5cGVzJEsgPSB7XG4gIC8qKiB0aGUgY3VycmVudCBhY3RpdmUgc2xpZGUgb2YgdGhlIGNhcm91c2VsICovXG4gIGFjdGl2ZUluZGV4OiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm51bWJlcixcblxuICAvKiogYSBmdW5jdGlvbiB3aGljaCBzaG91bGQgYWR2YW5jZSB0aGUgY2Fyb3VzZWwgdG8gdGhlIG5leHQgc2xpZGUgKHZpYSBhY3RpdmVJbmRleCkgKi9cbiAgbmV4dDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5mdW5jLmlzUmVxdWlyZWQsXG5cbiAgLyoqIGEgZnVuY3Rpb24gd2hpY2ggc2hvdWxkIGFkdmFuY2UgdGhlIGNhcm91c2VsIHRvIHRoZSBwcmV2aW91cyBzbGlkZSAodmlhIGFjdGl2ZUluZGV4KSAqL1xuICBwcmV2aW91czogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5mdW5jLmlzUmVxdWlyZWQsXG5cbiAgLyoqIGNvbnRyb2xzIGlmIHRoZSBsZWZ0IGFuZCByaWdodCBhcnJvdyBrZXlzIHNob3VsZCBjb250cm9sIHRoZSBjYXJvdXNlbCAqL1xuICBrZXlib2FyZDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuXG4gIC8qKiBJZiBzZXQgdG8gXCJob3ZlclwiLCBwYXVzZXMgdGhlIGN5Y2xpbmcgb2YgdGhlIGNhcm91c2VsIG9uIG1vdXNlZW50ZXIgYW5kIHJlc3VtZXMgdGhlIGN5Y2xpbmcgb2YgdGhlIGNhcm91c2VsIG9uXG4gICAqIG1vdXNlbGVhdmUuIElmIHNldCB0byBmYWxzZSwgaG92ZXJpbmcgb3ZlciB0aGUgY2Fyb3VzZWwgd29uJ3QgcGF1c2UgaXQuXG4gICAqL1xuICBwYXVzZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vbmVPZihbJ2hvdmVyJywgZmFsc2VdKSxcblxuICAvKiogQXV0b3BsYXlzIHRoZSBjYXJvdXNlbCBhZnRlciB0aGUgdXNlciBtYW51YWxseSBjeWNsZXMgdGhlIGZpcnN0IGl0ZW0uIElmIFwiY2Fyb3VzZWxcIiwgYXV0b3BsYXlzIHRoZSBjYXJvdXNlbCBvbiBsb2FkLiAqL1xuICByaWRlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9uZU9mKFsnY2Fyb3VzZWwnXSksXG5cbiAgLyoqIHRoZSBpbnRlcnZhbCBhdCB3aGljaCB0aGUgY2Fyb3VzZWwgYXV0b21hdGljYWxseSBjeWNsZXMgKi9cbiAgaW50ZXJ2YWw6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm51bWJlciwgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbF0pLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5hcnJheSxcblxuICAvKiogY2FsbGVkIHdoZW4gdGhlIG1vdXNlIGVudGVycyB0aGUgQ2Fyb3VzZWwgKi9cbiAgbW91c2VFbnRlcjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5mdW5jLFxuXG4gIC8qKiBjYWxsZWQgd2hlbiB0aGUgbW91c2UgZXhpdHMgdGhlIENhcm91c2VsICovXG4gIG1vdXNlTGVhdmU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuYyxcblxuICAvKiogY29udHJvbHMgd2hldGhlciB0aGUgc2xpZGUgYW5pbWF0aW9uIG9uIHRoZSBDYXJvdXNlbCB3b3JrcyBvciBub3QgKi9cbiAgc2xpZGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcblxuICAvKiogbWFrZSB0aGUgY29udHJvbHMsIGluZGljYXRvcnMgYW5kIGNhcHRpb25zIGRhcmsgb24gdGhlIENhcm91c2VsICovXG4gIGRhcms6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcbiAgZmFkZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuXG4gIC8qKiBDaGFuZ2UgdW5kZXJseWluZyBjb21wb25lbnQncyBDU1MgYmFzZSBjbGFzcyBuYW1lICovXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG5cbiAgLyoqIEFkZCBjdXN0b20gY2xhc3MgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcblxuICAvKiogRW5hYmxlIHRvdWNoIHN1cHBvcnQgKi9cbiAgZW5hYmxlVG91Y2g6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbFxufTtcbnZhciBwcm9wc1RvT21pdCQyID0gT2JqZWN0LmtleXMocHJvcFR5cGVzJEspO1xudmFyIGRlZmF1bHRQcm9wcyRKID0ge1xuICBpbnRlcnZhbDogNTAwMCxcbiAgcGF1c2U6ICdob3ZlcicsXG4gIGtleWJvYXJkOiB0cnVlLFxuICBzbGlkZTogdHJ1ZSxcbiAgZW5hYmxlVG91Y2g6IHRydWUsXG4gIGZhZGU6IGZhbHNlXG59O1xuXG52YXIgQ2Fyb3VzZWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoQ2Fyb3VzZWwsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIENhcm91c2VsKHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuaGFuZGxlS2V5UHJlc3MgPSBfdGhpcy5oYW5kbGVLZXlQcmVzcy5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5yZW5kZXJJdGVtcyA9IF90aGlzLnJlbmRlckl0ZW1zLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmhvdmVyU3RhcnQgPSBfdGhpcy5ob3ZlclN0YXJ0LmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmhvdmVyRW5kID0gX3RoaXMuaG92ZXJFbmQuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMuaGFuZGxlVG91Y2hTdGFydCA9IF90aGlzLmhhbmRsZVRvdWNoU3RhcnQuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMuaGFuZGxlVG91Y2hFbmQgPSBfdGhpcy5oYW5kbGVUb3VjaEVuZC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy50b3VjaFN0YXJ0WCA9IDA7XG4gICAgX3RoaXMudG91Y2hTdGFydFkgPSAwO1xuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgYWN0aXZlSW5kZXg6IF90aGlzLnByb3BzLmFjdGl2ZUluZGV4LFxuICAgICAgZGlyZWN0aW9uOiAnZW5kJyxcbiAgICAgIGluZGljYXRvckNsaWNrZWQ6IGZhbHNlXG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQ2Fyb3VzZWwucHJvdG90eXBlO1xuXG4gIF9wcm90by5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIC8vIFNldCB1cCB0aGUgY3ljbGVcbiAgICBpZiAodGhpcy5wcm9wcy5yaWRlID09PSAnY2Fyb3VzZWwnKSB7XG4gICAgICB0aGlzLnNldEludGVydmFsKCk7XG4gICAgfSAvLyBUT0RPOiBtb3ZlIHRoaXMgdG8gdGhlIHNwZWNpZmljIGNhcm91c2VsIGxpa2UgYm9vdHN0cmFwLiBDdXJyZW50bHkgaXQgd2lsbCB0cmlnZ2VyIEFMTCBjYXJvdXNlbHMgb24gdGhlIHBhZ2UuXG5cblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5oYW5kbGVLZXlQcmVzcyk7XG4gIH07XG5cbiAgQ2Fyb3VzZWwuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgdmFyIG5ld1N0YXRlID0gbnVsbDtcbiAgICB2YXIgYWN0aXZlSW5kZXggPSBwcmV2U3RhdGUuYWN0aXZlSW5kZXgsXG4gICAgICAgIGRpcmVjdGlvbiA9IHByZXZTdGF0ZS5kaXJlY3Rpb24sXG4gICAgICAgIGluZGljYXRvckNsaWNrZWQgPSBwcmV2U3RhdGUuaW5kaWNhdG9yQ2xpY2tlZDtcblxuICAgIGlmIChuZXh0UHJvcHMuYWN0aXZlSW5kZXggIT09IGFjdGl2ZUluZGV4KSB7XG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGRpcmVjdGlvbiB0byB0dXJuXG4gICAgICBpZiAobmV4dFByb3BzLmFjdGl2ZUluZGV4ID09PSBhY3RpdmVJbmRleCArIDEpIHtcbiAgICAgICAgZGlyZWN0aW9uID0gJ2VuZCc7XG4gICAgICB9IGVsc2UgaWYgKG5leHRQcm9wcy5hY3RpdmVJbmRleCA9PT0gYWN0aXZlSW5kZXggLSAxKSB7XG4gICAgICAgIGRpcmVjdGlvbiA9ICdzdGFydCc7XG4gICAgICB9IGVsc2UgaWYgKG5leHRQcm9wcy5hY3RpdmVJbmRleCA8IGFjdGl2ZUluZGV4KSB7XG4gICAgICAgIGRpcmVjdGlvbiA9IGluZGljYXRvckNsaWNrZWQgPyAnc3RhcnQnIDogJ2VuZCc7XG4gICAgICB9IGVsc2UgaWYgKG5leHRQcm9wcy5hY3RpdmVJbmRleCAhPT0gYWN0aXZlSW5kZXgpIHtcbiAgICAgICAgZGlyZWN0aW9uID0gaW5kaWNhdG9yQ2xpY2tlZCA/ICdlbmQnIDogJ3N0YXJ0JztcbiAgICAgIH1cblxuICAgICAgbmV3U3RhdGUgPSB7XG4gICAgICAgIGFjdGl2ZUluZGV4OiBuZXh0UHJvcHMuYWN0aXZlSW5kZXgsXG4gICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgICAgICBpbmRpY2F0b3JDbGlja2VkOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3U3RhdGU7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgIGlmIChwcmV2U3RhdGUuYWN0aXZlSW5kZXggPT09IHRoaXMuc3RhdGUuYWN0aXZlSW5kZXgpIHJldHVybjtcbiAgICB0aGlzLnNldEludGVydmFsKCk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLmhhbmRsZUtleVByZXNzKTtcbiAgfTtcblxuICBfcHJvdG8uaGFuZGxlS2V5UHJlc3MgPSBmdW5jdGlvbiBoYW5kbGVLZXlQcmVzcyhldnQpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5rZXlib2FyZCkge1xuICAgICAgaWYgKGV2dC5rZXlDb2RlID09PSAzNykge1xuICAgICAgICB0aGlzLnByb3BzLnByZXZpb3VzKCk7XG4gICAgICB9IGVsc2UgaWYgKGV2dC5rZXlDb2RlID09PSAzOSkge1xuICAgICAgICB0aGlzLnByb3BzLm5leHQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZVRvdWNoU3RhcnQgPSBmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0KGUpIHtcbiAgICBpZiAoIXRoaXMucHJvcHMuZW5hYmxlVG91Y2gpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnRvdWNoU3RhcnRYID0gZS5jaGFuZ2VkVG91Y2hlc1swXS5zY3JlZW5YO1xuICAgIHRoaXMudG91Y2hTdGFydFkgPSBlLmNoYW5nZWRUb3VjaGVzWzBdLnNjcmVlblk7XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZVRvdWNoRW5kID0gZnVuY3Rpb24gaGFuZGxlVG91Y2hFbmQoZSkge1xuICAgIGlmICghdGhpcy5wcm9wcy5lbmFibGVUb3VjaCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50WCA9IGUuY2hhbmdlZFRvdWNoZXNbMF0uc2NyZWVuWDtcbiAgICB2YXIgY3VycmVudFkgPSBlLmNoYW5nZWRUb3VjaGVzWzBdLnNjcmVlblk7XG4gICAgdmFyIGRpZmZYID0gTWF0aC5hYnModGhpcy50b3VjaFN0YXJ0WCAtIGN1cnJlbnRYKTtcbiAgICB2YXIgZGlmZlkgPSBNYXRoLmFicyh0aGlzLnRvdWNoU3RhcnRZIC0gY3VycmVudFkpOyAvLyBEb24ndCBzd2lwZSBpZiBZLW1vdmVtZW50IGlzIGJpZ2dlciB0aGFuIFgtbW92ZW1lbnRcblxuICAgIGlmIChkaWZmWCA8IGRpZmZZKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGRpZmZYIDwgU1dJUEVfVEhSRVNIT0xEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRYIDwgdGhpcy50b3VjaFN0YXJ0WCkge1xuICAgICAgdGhpcy5wcm9wcy5uZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJvcHMucHJldmlvdXMoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmdldENvbnRleHRWYWx1ZSA9IGZ1bmN0aW9uIGdldENvbnRleHRWYWx1ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGlyZWN0aW9uOiB0aGlzLnN0YXRlLmRpcmVjdGlvblxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLnNldEludGVydmFsID0gZnVuY3Rpb24gKF9zZXRJbnRlcnZhbCkge1xuICAgIGZ1bmN0aW9uIHNldEludGVydmFsKCkge1xuICAgICAgcmV0dXJuIF9zZXRJbnRlcnZhbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHNldEludGVydmFsLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9zZXRJbnRlcnZhbC50b1N0cmluZygpO1xuICAgIH07XG5cbiAgICByZXR1cm4gc2V0SW50ZXJ2YWw7XG4gIH0oZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgLy8gbWFrZSBzdXJlIG5vdCB0byBoYXZlIG11bHRpcGxlIGludGVydmFscyBnb2luZy4uLlxuICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xuXG4gICAgaWYgKHRoaXMucHJvcHMuaW50ZXJ2YWwpIHtcbiAgICAgIHRoaXMuY3ljbGVJbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnByb3BzLm5leHQoKTtcbiAgICAgIH0sIHBhcnNlSW50KHRoaXMucHJvcHMuaW50ZXJ2YWwsIDEwKSk7XG4gICAgfVxuICB9KTtcblxuICBfcHJvdG8uY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uIChfY2xlYXJJbnRlcnZhbCkge1xuICAgIGZ1bmN0aW9uIGNsZWFySW50ZXJ2YWwoKSB7XG4gICAgICByZXR1cm4gX2NsZWFySW50ZXJ2YWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBjbGVhckludGVydmFsLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9jbGVhckludGVydmFsLnRvU3RyaW5nKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBjbGVhckludGVydmFsO1xuICB9KGZ1bmN0aW9uICgpIHtcbiAgICBjbGVhckludGVydmFsKHRoaXMuY3ljbGVJbnRlcnZhbCk7XG4gIH0pO1xuXG4gIF9wcm90by5ob3ZlclN0YXJ0ID0gZnVuY3Rpb24gaG92ZXJTdGFydCgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5wYXVzZSA9PT0gJ2hvdmVyJykge1xuICAgICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJvcHMubW91c2VFbnRlcikge1xuICAgICAgdmFyIF90aGlzJHByb3BzO1xuXG4gICAgICAoX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzKS5tb3VzZUVudGVyLmFwcGx5KF90aGlzJHByb3BzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uaG92ZXJFbmQgPSBmdW5jdGlvbiBob3ZlckVuZCgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5wYXVzZSA9PT0gJ2hvdmVyJykge1xuICAgICAgdGhpcy5zZXRJbnRlcnZhbCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnByb3BzLm1vdXNlTGVhdmUpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczI7XG5cbiAgICAgIChfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzKS5tb3VzZUxlYXZlLmFwcGx5KF90aGlzJHByb3BzMiwgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlckl0ZW1zID0gZnVuY3Rpb24gcmVuZGVySXRlbXMoY2Fyb3VzZWxJdGVtcywgY2xhc3NOYW1lKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgc2xpZGUgPSB0aGlzLnByb3BzLnNsaWRlO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbiAgICB9LCBjYXJvdXNlbEl0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSwgaW5kZXgpIHtcbiAgICAgIHZhciBpc0luID0gaW5kZXggPT09IF90aGlzMy5zdGF0ZS5hY3RpdmVJbmRleDtcbiAgICAgIHJldHVybiBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY2xvbmVFbGVtZW50KGl0ZW0sIHtcbiAgICAgICAgXCJpblwiOiBpc0luLFxuICAgICAgICBzbGlkZTogc2xpZGVcbiAgICAgIH0pO1xuICAgIH0pKTtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgdmFyIF90aGlzJHByb3BzMyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGNzc01vZHVsZSA9IF90aGlzJHByb3BzMy5jc3NNb2R1bGUsXG4gICAgICAgIHNsaWRlID0gX3RoaXMkcHJvcHMzLnNsaWRlLFxuICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wczMuY2xhc3NOYW1lLFxuICAgICAgICBkYXJrID0gX3RoaXMkcHJvcHMzLmRhcmssXG4gICAgICAgIGZhZGUgPSBfdGhpcyRwcm9wczMuZmFkZTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IG9taXQodGhpcy5wcm9wcywgcHJvcHNUb09taXQkMik7XG4gICAgdmFyIG91dGVyQ2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjbGFzc05hbWUsICdjYXJvdXNlbCcsIGZhZGUgJiYgJ2Nhcm91c2VsLWZhZGUnLCBzbGlkZSAmJiAnc2xpZGUnLCBkYXJrICYmICdjYXJvdXNlbC1kYXJrJyksIGNzc01vZHVsZSk7XG4gICAgdmFyIGlubmVyQ2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXSgnY2Fyb3VzZWwtaW5uZXInKSwgY3NzTW9kdWxlKTsgLy8gZmlsdGVyIG91dCBib29sZWFucywgbnVsbCwgb3IgdW5kZWZpbmVkXG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIHJldHVybiBjaGlsZCAhPT0gbnVsbCAmJiBjaGlsZCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBjaGlsZCAhPT0gJ2Jvb2xlYW4nO1xuICAgIH0pO1xuICAgIHZhciBzbGlkZXNPbmx5ID0gY2hpbGRyZW4uZXZlcnkoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQudHlwZSA9PT0gQ2Fyb3VzZWxJdGVtJDE7XG4gICAgfSk7IC8vIFJlbmRlcmluZyBvbmx5IHNsaWRlc1xuXG4gICAgaWYgKHNsaWRlc09ubHkpIHtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBvdXRlckNsYXNzZXMsXG4gICAgICAgIG9uTW91c2VFbnRlcjogdGhpcy5ob3ZlclN0YXJ0LFxuICAgICAgICBvbk1vdXNlTGVhdmU6IHRoaXMuaG92ZXJFbmRcbiAgICAgIH0pLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoQ2Fyb3VzZWxDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiB0aGlzLmdldENvbnRleHRWYWx1ZSgpXG4gICAgICB9LCB0aGlzLnJlbmRlckl0ZW1zKGNoaWxkcmVuLCBpbm5lckNsYXNzZXMpKSk7XG4gICAgfSAvLyBSZW5kZXJpbmcgc2xpZGVzIGFuZCBjb250cm9sc1xuXG5cbiAgICBpZiAoY2hpbGRyZW5bMF0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgdmFyIF9jYXJvdXNlbEl0ZW1zID0gY2hpbGRyZW5bMF07XG4gICAgICB2YXIgX2NvbnRyb2xMZWZ0ID0gY2hpbGRyZW5bMV07XG4gICAgICB2YXIgX2NvbnRyb2xSaWdodCA9IGNoaWxkcmVuWzJdO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywge1xuICAgICAgICBjbGFzc05hbWU6IG91dGVyQ2xhc3NlcyxcbiAgICAgICAgb25Nb3VzZUVudGVyOiB0aGlzLmhvdmVyU3RhcnQsXG4gICAgICAgIG9uTW91c2VMZWF2ZTogdGhpcy5ob3ZlckVuZFxuICAgICAgfSksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChDYXJvdXNlbENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IHRoaXMuZ2V0Q29udGV4dFZhbHVlKClcbiAgICAgIH0sIHRoaXMucmVuZGVySXRlbXMoX2Nhcm91c2VsSXRlbXMsIGlubmVyQ2xhc3NlcyksIF9jb250cm9sTGVmdCwgX2NvbnRyb2xSaWdodCkpO1xuICAgIH0gLy8gUmVuZGVyaW5nIGluZGljYXRvcnMsIHNsaWRlcyBhbmQgY29udHJvbHNcblxuXG4gICAgdmFyIGluZGljYXRvcnMgPSBjaGlsZHJlblswXTtcblxuICAgIHZhciB3cmFwcGVkT25DbGljayA9IGZ1bmN0aW9uIHdyYXBwZWRPbkNsaWNrKGUpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5kaWNhdG9ycy5wcm9wcy5vbkNsaWNrSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBfdGhpczQuc2V0U3RhdGUoe1xuICAgICAgICAgIGluZGljYXRvckNsaWNrZWQ6IHRydWVcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBpbmRpY2F0b3JzLnByb3BzLm9uQ2xpY2tIYW5kbGVyKGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHdyYXBwZWRJbmRpY2F0b3JzID0gUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNsb25lRWxlbWVudChpbmRpY2F0b3JzLCB7XG4gICAgICBvbkNsaWNrSGFuZGxlcjogd3JhcHBlZE9uQ2xpY2tcbiAgICB9KTtcbiAgICB2YXIgY2Fyb3VzZWxJdGVtcyA9IGNoaWxkcmVuWzFdO1xuICAgIHZhciBjb250cm9sTGVmdCA9IGNoaWxkcmVuWzJdO1xuICAgIHZhciBjb250cm9sUmlnaHQgPSBjaGlsZHJlblszXTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgICBjbGFzc05hbWU6IG91dGVyQ2xhc3NlcyxcbiAgICAgIG9uTW91c2VFbnRlcjogdGhpcy5ob3ZlclN0YXJ0LFxuICAgICAgb25Nb3VzZUxlYXZlOiB0aGlzLmhvdmVyRW5kLFxuICAgICAgb25Ub3VjaFN0YXJ0OiB0aGlzLmhhbmRsZVRvdWNoU3RhcnQsXG4gICAgICBvblRvdWNoRW5kOiB0aGlzLmhhbmRsZVRvdWNoRW5kXG4gICAgfSksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChDYXJvdXNlbENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiB0aGlzLmdldENvbnRleHRWYWx1ZSgpXG4gICAgfSwgd3JhcHBlZEluZGljYXRvcnMsIHRoaXMucmVuZGVySXRlbXMoY2Fyb3VzZWxJdGVtcywgaW5uZXJDbGFzc2VzKSwgY29udHJvbExlZnQsIGNvbnRyb2xSaWdodCkpO1xuICB9O1xuXG4gIHJldHVybiBDYXJvdXNlbDtcbn0oUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLkNvbXBvbmVudCk7XG5cbkNhcm91c2VsLnByb3BUeXBlcyA9IHByb3BUeXBlcyRLO1xuQ2Fyb3VzZWwuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJEo7XG52YXIgQ2Fyb3VzZWwkMSA9IENhcm91c2VsO1xuXG52YXIgX2V4Y2x1ZGVkJEYgPSBbXCJkaXJlY3Rpb25cIiwgXCJvbkNsaWNrSGFuZGxlclwiLCBcImNzc01vZHVsZVwiLCBcImRpcmVjdGlvblRleHRcIiwgXCJjbGFzc05hbWVcIl07XG5cbmZ1bmN0aW9uIENhcm91c2VsQ29udHJvbChwcm9wcykge1xuICB2YXIgZGlyZWN0aW9uID0gcHJvcHMuZGlyZWN0aW9uLFxuICAgICAgb25DbGlja0hhbmRsZXIgPSBwcm9wcy5vbkNsaWNrSGFuZGxlcixcbiAgICAgIGNzc01vZHVsZSA9IHByb3BzLmNzc01vZHVsZSxcbiAgICAgIGRpcmVjdGlvblRleHQgPSBwcm9wcy5kaXJlY3Rpb25UZXh0LFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQkRik7XG5cbiAgdmFyIGFuY2hvckNsYXNzZXMgPSBtYXBUb0Nzc01vZHVsZXMoY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oY2xhc3NOYW1lLCBcImNhcm91c2VsLWNvbnRyb2wtXCIgKyBkaXJlY3Rpb24pLCBjc3NNb2R1bGUpO1xuICB2YXIgaWNvbkNsYXNzZXMgPSBtYXBUb0Nzc01vZHVsZXMoY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oXCJjYXJvdXNlbC1jb250cm9sLVwiICsgZGlyZWN0aW9uICsgXCItaWNvblwiKSwgY3NzTW9kdWxlKTtcbiAgdmFyIHNjcmVlblJlYWRlckNsYXNzZXMgPSBtYXBUb0Nzc01vZHVsZXMoY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oJ3Zpc3VhbGx5LWhpZGRlbicpLCBjc3NNb2R1bGUpO1xuICByZXR1cm4gKFxuICAgIC8qI19fUFVSRV9fKi9cbiAgICAvLyBXZSBuZWVkIHRvIGRpc2FibGUgdGhpcyBsaW50aW5nIHJ1bGUgdG8gdXNlIGFuIGA8YT5gIGluc3RlYWQgb2ZcbiAgICAvLyBgPGJ1dHRvbj5gIGJlY2F1c2UgdGhhdCdzIHdoYXQgdGhlIEJvb3RzdHJhcCBleGFtcGxlcyByZXF1aXJlOlxuICAgIC8vIGh0dHBzOi8vZ2V0Ym9vdHN0cmFwLmNvbS9kb2NzLzQuNS9jb21wb25lbnRzL2Nhcm91c2VsLyN3aXRoLWNvbnRyb2xzXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzeC1hMTF5L2FuY2hvci1pcy12YWxpZFxuICAgIFJlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiYVwiLCBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywge1xuICAgICAgY2xhc3NOYW1lOiBhbmNob3JDbGFzc2VzLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgY3Vyc29yOiAncG9pbnRlcidcbiAgICAgIH0sXG4gICAgICByb2xlOiBcImJ1dHRvblwiLFxuICAgICAgdGFiSW5kZXg6IFwiMFwiLFxuICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgb25DbGlja0hhbmRsZXIoKTtcbiAgICAgIH1cbiAgICB9KSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICBjbGFzc05hbWU6IGljb25DbGFzc2VzLFxuICAgICAgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIlxuICAgIH0pLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgIGNsYXNzTmFtZTogc2NyZWVuUmVhZGVyQ2xhc3Nlc1xuICAgIH0sIGRpcmVjdGlvblRleHQgfHwgZGlyZWN0aW9uKSlcbiAgKTtcbn1cblxuQ2Fyb3VzZWxDb250cm9sLnByb3BUeXBlcyA9IHtcbiAgLyoqIFNldCB0aGUgZGlyZWN0aW9uIG9mIGNvbnRyb2wgYnV0dG9uICovXG4gIGRpcmVjdGlvbjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vbmVPZihbJ3ByZXYnLCAnbmV4dCddKS5pc1JlcXVpcmVkLFxuXG4gIC8qKiBGdW5jdGlvbiB0byBiZSB0cmlnZ2VyZWQgb24gY2xpY2sgKi9cbiAgb25DbGlja0hhbmRsZXI6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuYy5pc1JlcXVpcmVkLFxuXG4gIC8qKiBDaGFuZ2UgdW5kZXJseWluZyBjb21wb25lbnQncyBDU1MgYmFzZSBjbGFzcyBuYW1lICovXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG5cbiAgLyoqIFNjcmVlbiByZWFkZXIgdGV4dCAqL1xuICBkaXJlY3Rpb25UZXh0OiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcblxuICAvKiogQWRkIGN1c3RvbSBjbGFzcyAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nXG59O1xuXG52YXIgX2V4Y2x1ZGVkJEUgPSBbXCJpdGVtc1wiLCBcImFjdGl2ZUluZGV4XCIsIFwiY3NzTW9kdWxlXCIsIFwib25DbGlja0hhbmRsZXJcIiwgXCJjbGFzc05hbWVcIl07XG5cbmZ1bmN0aW9uIENhcm91c2VsSW5kaWNhdG9ycyhwcm9wcykge1xuICB2YXIgaXRlbXMgPSBwcm9wcy5pdGVtcyxcbiAgICAgIGFjdGl2ZUluZGV4ID0gcHJvcHMuYWN0aXZlSW5kZXgsXG4gICAgICBjc3NNb2R1bGUgPSBwcm9wcy5jc3NNb2R1bGUsXG4gICAgICBvbkNsaWNrSGFuZGxlciA9IHByb3BzLm9uQ2xpY2tIYW5kbGVyLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQkRSk7XG5cbiAgdmFyIGxpc3RDbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGNsYXNzTmFtZSwgJ2Nhcm91c2VsLWluZGljYXRvcnMnKSwgY3NzTW9kdWxlKTtcbiAgdmFyIGluZGljYXRvcnMgPSBpdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0sIGlkeCkge1xuICAgIHZhciBpbmRpY2F0b3JDbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKHtcbiAgICAgIGFjdGl2ZTogYWN0aXZlSW5kZXggPT09IGlkeFxuICAgIH0pLCBjc3NNb2R1bGUpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgICAgXCJhcmlhLWxhYmVsXCI6IGl0ZW0uY2FwdGlvbixcbiAgICAgIFwiZGF0YS1icy10YXJnZXRcIjogdHJ1ZSxcbiAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICBrZXk6IFwiXCIgKyAoaXRlbS5rZXkgfHwgT2JqZWN0LnZhbHVlcyhpdGVtKS5qb2luKCcnKSksXG4gICAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBvbkNsaWNrSGFuZGxlcihpZHgpO1xuICAgICAgfSxcbiAgICAgIGNsYXNzTmFtZTogaW5kaWNhdG9yQ2xhc3Nlc1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7XG4gICAgY2xhc3NOYW1lOiBsaXN0Q2xhc3Nlc1xuICB9LCBhdHRyaWJ1dGVzKSwgaW5kaWNhdG9ycyk7XG59XG5cbkNhcm91c2VsSW5kaWNhdG9ycy5wcm9wVHlwZXMgPSB7XG4gIC8qKiBUaGUgY3VycmVudCBhY3RpdmUgaW5kZXggKi9cbiAgYWN0aXZlSW5kZXg6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ubnVtYmVyLmlzUmVxdWlyZWQsXG5cbiAgLyoqIEFkZCBjdXN0b20gY2xhc3MgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcblxuICAvKiogQ2hhbmdlIHVuZGVybHlpbmcgY29tcG9uZW50J3MgQ1NTIGJhc2UgY2xhc3MgbmFtZSAqL1xuICBjc3NNb2R1bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LFxuXG4gIC8qKiBBcnJheSBvZiBpdGVtcyB0byBzaG93ICovXG4gIGl0ZW1zOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmFycmF5LmlzUmVxdWlyZWQsXG5cbiAgLyoqIEZ1bmN0aW9uIHRvIGJlIHRyaWdnZXJlZCBvbiBjbGljayAqL1xuICBvbkNsaWNrSGFuZGxlcjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5mdW5jLmlzUmVxdWlyZWRcbn07XG5cbmZ1bmN0aW9uIENhcm91c2VsQ2FwdGlvbihwcm9wcykge1xuICB2YXIgY2FwdGlvbkhlYWRlciA9IHByb3BzLmNhcHRpb25IZWFkZXIsXG4gICAgICBjYXB0aW9uVGV4dCA9IHByb3BzLmNhcHRpb25UZXh0LFxuICAgICAgY3NzTW9kdWxlID0gcHJvcHMuY3NzTW9kdWxlLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lO1xuICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjbGFzc05hbWUsICdjYXJvdXNlbC1jYXB0aW9uJywgJ2Qtbm9uZScsICdkLW1kLWJsb2NrJyksIGNzc01vZHVsZSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogY2xhc3Nlc1xuICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJoM1wiLCBudWxsLCBjYXB0aW9uSGVhZGVyKSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwicFwiLCBudWxsLCBjYXB0aW9uVGV4dCkpO1xufVxuXG5DYXJvdXNlbENhcHRpb24ucHJvcFR5cGVzID0ge1xuICAvKiogSGVhZGluZyBmb3IgdGhlIGNhcHRpb24gKi9cbiAgY2FwdGlvbkhlYWRlcjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ub2RlLFxuXG4gIC8qKiBUZXh0IGZvciBjYXB0aW9uICovXG4gIGNhcHRpb25UZXh0OiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm5vZGUuaXNSZXF1aXJlZCxcblxuICAvKiogQWRkIGN1c3RvbSBjbGFzcyAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuXG4gIC8qKiBDaGFuZ2UgdW5kZXJseWluZyBjb21wb25lbnQncyBDU1MgYmFzZSBjbGFzcyBuYW1lICovXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3Rcbn07XG5cbnZhciBfZXhjbHVkZWQkRCA9IFtcImRlZmF1bHRBY3RpdmVJbmRleFwiLCBcImF1dG9QbGF5XCIsIFwiaW5kaWNhdG9yc1wiLCBcImNvbnRyb2xzXCIsIFwiaXRlbXNcIiwgXCJnb1RvSW5kZXhcIl07XG52YXIgcHJvcFR5cGVzJEogPSB7XG4gIGl0ZW1zOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmFycmF5LmlzUmVxdWlyZWQsXG4gIGluZGljYXRvcnM6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcbiAgY29udHJvbHM6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcbiAgYXV0b1BsYXk6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcbiAgZGVmYXVsdEFjdGl2ZUluZGV4OiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm51bWJlcixcbiAgYWN0aXZlSW5kZXg6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ubnVtYmVyLFxuICBuZXh0OiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZ1bmMsXG4gIHByZXZpb3VzOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZ1bmMsXG4gIGdvVG9JbmRleDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5mdW5jXG59O1xuXG52YXIgVW5jb250cm9sbGVkQ2Fyb3VzZWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoVW5jb250cm9sbGVkQ2Fyb3VzZWwsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFVuY29udHJvbGxlZENhcm91c2VsKHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuYW5pbWF0aW5nID0gZmFsc2U7XG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBhY3RpdmVJbmRleDogcHJvcHMuZGVmYXVsdEFjdGl2ZUluZGV4IHx8IDBcbiAgICB9O1xuICAgIF90aGlzLm5leHQgPSBfdGhpcy5uZXh0LmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLnByZXZpb3VzID0gX3RoaXMucHJldmlvdXMuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMuZ29Ub0luZGV4ID0gX3RoaXMuZ29Ub0luZGV4LmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLm9uRXhpdGluZyA9IF90aGlzLm9uRXhpdGluZy5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5vbkV4aXRlZCA9IF90aGlzLm9uRXhpdGVkLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBVbmNvbnRyb2xsZWRDYXJvdXNlbC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLm9uRXhpdGluZyA9IGZ1bmN0aW9uIG9uRXhpdGluZygpIHtcbiAgICB0aGlzLmFuaW1hdGluZyA9IHRydWU7XG4gIH07XG5cbiAgX3Byb3RvLm9uRXhpdGVkID0gZnVuY3Rpb24gb25FeGl0ZWQoKSB7XG4gICAgdGhpcy5hbmltYXRpbmcgPSBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8ubmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5hbmltYXRpbmcpIHJldHVybjtcbiAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChwcmV2U3RhdGUpIHtcbiAgICAgIHZhciBuZXh0SW5kZXggPSBwcmV2U3RhdGUuYWN0aXZlSW5kZXggPT09IF90aGlzMi5wcm9wcy5pdGVtcy5sZW5ndGggLSAxID8gMCA6IHByZXZTdGF0ZS5hY3RpdmVJbmRleCArIDE7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhY3RpdmVJbmRleDogbmV4dEluZGV4XG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5wcmV2aW91cyA9IGZ1bmN0aW9uIHByZXZpb3VzKCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuYW5pbWF0aW5nKSByZXR1cm47XG4gICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAocHJldlN0YXRlKSB7XG4gICAgICB2YXIgbmV4dEluZGV4ID0gcHJldlN0YXRlLmFjdGl2ZUluZGV4ID09PSAwID8gX3RoaXMzLnByb3BzLml0ZW1zLmxlbmd0aCAtIDEgOiBwcmV2U3RhdGUuYWN0aXZlSW5kZXggLSAxO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWN0aXZlSW5kZXg6IG5leHRJbmRleFxuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uZ29Ub0luZGV4ID0gZnVuY3Rpb24gZ29Ub0luZGV4KG5ld0luZGV4KSB7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW5nKSByZXR1cm47XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBhY3RpdmVJbmRleDogbmV3SW5kZXhcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgYXV0b1BsYXkgPSBfdGhpcyRwcm9wcy5hdXRvUGxheSxcbiAgICAgICAgaW5kaWNhdG9ycyA9IF90aGlzJHByb3BzLmluZGljYXRvcnMsXG4gICAgICAgIGNvbnRyb2xzID0gX3RoaXMkcHJvcHMuY29udHJvbHMsXG4gICAgICAgIGl0ZW1zID0gX3RoaXMkcHJvcHMuaXRlbXMsXG4gICAgICAgIGdvVG9JbmRleCA9IF90aGlzJHByb3BzLmdvVG9JbmRleCxcbiAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wcywgX2V4Y2x1ZGVkJEQpO1xuXG4gICAgdmFyIGFjdGl2ZUluZGV4ID0gdGhpcy5zdGF0ZS5hY3RpdmVJbmRleDtcbiAgICB2YXIgc2xpZGVzID0gaXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIga2V5ID0gaXRlbS5rZXkgfHwgaXRlbS5zcmM7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KENhcm91c2VsSXRlbSQxLCB7XG4gICAgICAgIG9uRXhpdGluZzogX3RoaXM0Lm9uRXhpdGluZyxcbiAgICAgICAgb25FeGl0ZWQ6IF90aGlzNC5vbkV4aXRlZCxcbiAgICAgICAga2V5OiBrZXlcbiAgICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImltZ1wiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJkLWJsb2NrIHctMTAwXCIsXG4gICAgICAgIHNyYzogaXRlbS5zcmMsXG4gICAgICAgIGFsdDogaXRlbS5hbHRUZXh0XG4gICAgICB9KSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KENhcm91c2VsQ2FwdGlvbiwge1xuICAgICAgICBjYXB0aW9uVGV4dDogaXRlbS5jYXB0aW9uLFxuICAgICAgICBjYXB0aW9uSGVhZGVyOiBpdGVtLmhlYWRlciB8fCBpdGVtLmNhcHRpb25cbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KENhcm91c2VsJDEsIF9leHRlbmRzKHtcbiAgICAgIGFjdGl2ZUluZGV4OiBhY3RpdmVJbmRleCxcbiAgICAgIG5leHQ6IHRoaXMubmV4dCxcbiAgICAgIHByZXZpb3VzOiB0aGlzLnByZXZpb3VzLFxuICAgICAgcmlkZTogYXV0b1BsYXkgPyAnY2Fyb3VzZWwnIDogdW5kZWZpbmVkXG4gICAgfSwgcHJvcHMpLCBpbmRpY2F0b3JzICYmIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChDYXJvdXNlbEluZGljYXRvcnMsIHtcbiAgICAgIGl0ZW1zOiBpdGVtcyxcbiAgICAgIGFjdGl2ZUluZGV4OiBwcm9wcy5hY3RpdmVJbmRleCB8fCBhY3RpdmVJbmRleCxcbiAgICAgIG9uQ2xpY2tIYW5kbGVyOiBnb1RvSW5kZXggfHwgdGhpcy5nb1RvSW5kZXhcbiAgICB9KSwgc2xpZGVzLCBjb250cm9scyAmJiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoQ2Fyb3VzZWxDb250cm9sLCB7XG4gICAgICBkaXJlY3Rpb246IFwicHJldlwiLFxuICAgICAgZGlyZWN0aW9uVGV4dDogXCJQcmV2aW91c1wiLFxuICAgICAgb25DbGlja0hhbmRsZXI6IHByb3BzLnByZXZpb3VzIHx8IHRoaXMucHJldmlvdXNcbiAgICB9KSwgY29udHJvbHMgJiYgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KENhcm91c2VsQ29udHJvbCwge1xuICAgICAgZGlyZWN0aW9uOiBcIm5leHRcIixcbiAgICAgIGRpcmVjdGlvblRleHQ6IFwiTmV4dFwiLFxuICAgICAgb25DbGlja0hhbmRsZXI6IHByb3BzLm5leHQgfHwgdGhpcy5uZXh0XG4gICAgfSkpO1xuICB9O1xuXG4gIHJldHVybiBVbmNvbnRyb2xsZWRDYXJvdXNlbDtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuVW5jb250cm9sbGVkQ2Fyb3VzZWwucHJvcFR5cGVzID0gcHJvcFR5cGVzJEo7XG5VbmNvbnRyb2xsZWRDYXJvdXNlbC5kZWZhdWx0UHJvcHMgPSB7XG4gIGNvbnRyb2xzOiB0cnVlLFxuICBpbmRpY2F0b3JzOiB0cnVlLFxuICBhdXRvUGxheTogdHJ1ZVxufTtcbnZhciBVbmNvbnRyb2xsZWRDYXJvdXNlbCQxID0gVW5jb250cm9sbGVkQ2Fyb3VzZWw7XG5cbnZhciBfZXhjbHVkZWQkQyA9IFtcImNsYXNzTmFtZVwiLCBcImNzc01vZHVsZVwiLCBcInRhZ1wiXTtcbnZhciBwcm9wVHlwZXMkSSA9IHtcbiAgLyoqIEFkZCBjdXN0b20gY2xhc3MgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcblxuICAvKiogQ2hhbmdlIHVuZGVybHlpbmcgY29tcG9uZW50J3MgQ1NTIGJhc2UgY2xhc3MgbmFtZSAqL1xuICBjc3NNb2R1bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LFxuXG4gIC8qKiBTZXQgYSBjdXN0b20gZWxlbWVudCBmb3IgdGhpcyBjb21wb25lbnQgKi9cbiAgdGFnOiB0YWdQcm9wVHlwZVxufTtcbnZhciBkZWZhdWx0UHJvcHMkSSA9IHtcbiAgdGFnOiAnZGl2J1xufTtcblxuZnVuY3Rpb24gQ2FyZFN1YnRpdGxlKHByb3BzKSB7XG4gIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjc3NNb2R1bGUgPSBwcm9wcy5jc3NNb2R1bGUsXG4gICAgICBUYWcgPSBwcm9wcy50YWcsXG4gICAgICBhdHRyaWJ1dGVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZCRDKTtcblxuICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjbGFzc05hbWUsICdjYXJkLXN1YnRpdGxlJyksIGNzc01vZHVsZSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoVGFnLCBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3Nlc1xuICB9KSk7XG59XG5cbkNhcmRTdWJ0aXRsZS5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkSTtcbkNhcmRTdWJ0aXRsZS5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHMkSTtcblxudmFyIF9leGNsdWRlZCRCID0gW1wiY2xhc3NOYW1lXCIsIFwiY3NzTW9kdWxlXCIsIFwidGFnXCJdO1xudmFyIHByb3BUeXBlcyRIID0ge1xuICAvKiogQWRkIGN1c3RvbSBjbGFzcyAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuXG4gIC8qKiBDaGFuZ2UgdW5kZXJseWluZyBjb21wb25lbnQncyBDU1MgYmFzZSBjbGFzcyBuYW1lICovXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG5cbiAgLyoqIFNldCBhIGN1c3RvbSBlbGVtZW50IGZvciB0aGlzIGNvbXBvbmVudCAqL1xuICB0YWc6IHRhZ1Byb3BUeXBlXG59O1xudmFyIGRlZmF1bHRQcm9wcyRIID0ge1xuICB0YWc6ICdwJ1xufTtcblxuZnVuY3Rpb24gQ2FyZFRleHQocHJvcHMpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNzc01vZHVsZSA9IHByb3BzLmNzc01vZHVsZSxcbiAgICAgIFRhZyA9IHByb3BzLnRhZyxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkJEIpO1xuXG4gIHZhciBjbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGNsYXNzTmFtZSwgJ2NhcmQtdGV4dCcpLCBjc3NNb2R1bGUpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzZXNcbiAgfSkpO1xufVxuXG5DYXJkVGV4dC5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkSDtcbkNhcmRUZXh0LmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyRIO1xuXG52YXIgX2V4Y2x1ZGVkJEEgPSBbXCJjbGFzc05hbWVcIiwgXCJjc3NNb2R1bGVcIiwgXCJ0YWdcIl07XG52YXIgcHJvcFR5cGVzJEcgPSB7XG4gIC8qKiBBZGQgY3VzdG9tIGNsYXNzICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG5cbiAgLyoqIENoYW5nZSB1bmRlcmx5aW5nIGNvbXBvbmVudCdzIENTUyBiYXNlIGNsYXNzIG5hbWUgKi9cbiAgY3NzTW9kdWxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCxcblxuICAvKiogU2V0IGEgY3VzdG9tIGVsZW1lbnQgZm9yIHRoaXMgY29tcG9uZW50ICovXG4gIHRhZzogdGFnUHJvcFR5cGVcbn07XG52YXIgZGVmYXVsdFByb3BzJEcgPSB7XG4gIHRhZzogJ2Rpdidcbn07XG5cbmZ1bmN0aW9uIENhcmRUaXRsZShwcm9wcykge1xuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY3NzTW9kdWxlID0gcHJvcHMuY3NzTW9kdWxlLFxuICAgICAgVGFnID0gcHJvcHMudGFnLFxuICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQkQSk7XG5cbiAgdmFyIGNsYXNzZXMgPSBtYXBUb0Nzc01vZHVsZXMoY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oY2xhc3NOYW1lLCAnY2FyZC10aXRsZScpLCBjc3NNb2R1bGUpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzZXNcbiAgfSkpO1xufVxuXG5DYXJkVGl0bGUucHJvcFR5cGVzID0gcHJvcFR5cGVzJEc7XG5DYXJkVGl0bGUuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJEc7XG5cbnZhciBfZXhjbHVkZWQkeiA9IFtcImNzc01vZHVsZVwiLCBcImNoaWxkcmVuXCIsIFwiaXNPcGVuXCIsIFwiZmxpcFwiLCBcInRhcmdldFwiLCBcIm9mZnNldFwiLCBcImZhbGxiYWNrUGxhY2VtZW50c1wiLCBcInBsYWNlbWVudFByZWZpeFwiLCBcImFycm93Q2xhc3NOYW1lXCIsIFwiaGlkZUFycm93XCIsIFwicG9wcGVyQ2xhc3NOYW1lXCIsIFwidGFnXCIsIFwiY29udGFpbmVyXCIsIFwibW9kaWZpZXJzXCIsIFwic3RyYXRlZ3lcIiwgXCJib3VuZGFyaWVzRWxlbWVudFwiLCBcIm9uQ2xvc2VkXCIsIFwiZmFkZVwiLCBcInRyYW5zaXRpb25cIiwgXCJwbGFjZW1lbnRcIl07XG5cbmZ1bmN0aW9uIG5vb3AkMigpIHt9XG5cbnZhciBwcm9wVHlwZXMkRiA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm5vZGUsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuY10pLmlzUmVxdWlyZWQsXG4gIHBvcHBlckNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIHBsYWNlbWVudDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIHBsYWNlbWVudFByZWZpeDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIGFycm93Q2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgaGlkZUFycm93OiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG4gIHRhZzogdGFnUHJvcFR5cGUsXG4gIGlzT3BlbjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBjc3NNb2R1bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LFxuICBvZmZzZXQ6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYXJyYXlPZihQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm51bWJlciksXG4gIGZhbGxiYWNrUGxhY2VtZW50czogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5hcnJheSxcbiAgZmxpcDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBjb250YWluZXI6IHRhcmdldFByb3BUeXBlLFxuICB0YXJnZXQ6IHRhcmdldFByb3BUeXBlLmlzUmVxdWlyZWQsXG4gIG1vZGlmaWVyczogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5hcnJheSxcbiAgc3RyYXRlZ3k6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICBib3VuZGFyaWVzRWxlbWVudDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vbmVPZlR5cGUoW1Byb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLCBET01FbGVtZW50XSksXG4gIG9uQ2xvc2VkOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZ1bmMsXG4gIGZhZGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcbiAgdHJhbnNpdGlvbjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zaGFwZShGYWRlLnByb3BUeXBlcylcbn07XG52YXIgZGVmYXVsdFByb3BzJEYgPSB7XG4gIGJvdW5kYXJpZXNFbGVtZW50OiAnc2Nyb2xsUGFyZW50JyxcbiAgcGxhY2VtZW50OiAnYXV0bycsXG4gIGhpZGVBcnJvdzogZmFsc2UsXG4gIGlzT3BlbjogZmFsc2UsXG4gIG9mZnNldDogWzAsIDBdLFxuICBmbGlwOiB0cnVlLFxuICBjb250YWluZXI6ICdib2R5JyxcbiAgbW9kaWZpZXJzOiBbXSxcbiAgb25DbG9zZWQ6IG5vb3AkMixcbiAgZmFkZTogdHJ1ZSxcbiAgdHJhbnNpdGlvbjogX29iamVjdFNwcmVhZDIoe30sIEZhZGUuZGVmYXVsdFByb3BzKVxufTtcblxudmFyIFBvcHBlckNvbnRlbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoUG9wcGVyQ29udGVudCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUG9wcGVyQ29udGVudChwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgIF90aGlzLnNldFRhcmdldE5vZGUgPSBfdGhpcy5zZXRUYXJnZXROb2RlLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmdldFRhcmdldE5vZGUgPSBfdGhpcy5nZXRUYXJnZXROb2RlLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmdldFJlZiA9IF90aGlzLmdldFJlZi5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5vbkNsb3NlZCA9IF90aGlzLm9uQ2xvc2VkLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgaXNPcGVuOiBwcm9wcy5pc09wZW5cbiAgICB9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFBvcHBlckNvbnRlbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzLCBzdGF0ZSkge1xuICAgIGlmIChwcm9wcy5pc09wZW4gJiYgIXN0YXRlLmlzT3Blbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNPcGVuOiBwcm9wcy5pc09wZW5cbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgdmFyIF9wcm90byA9IFBvcHBlckNvbnRlbnQucHJvdG90eXBlO1xuXG4gIF9wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQgJiYgdGhpcy5fZWxlbWVudC5jaGlsZE5vZGVzICYmIHRoaXMuX2VsZW1lbnQuY2hpbGROb2Rlc1swXSAmJiB0aGlzLl9lbGVtZW50LmNoaWxkTm9kZXNbMF0uZm9jdXMpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2hpbGROb2Rlc1swXS5mb2N1cygpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ub25DbG9zZWQgPSBmdW5jdGlvbiBvbkNsb3NlZCgpIHtcbiAgICB0aGlzLnByb3BzLm9uQ2xvc2VkKCk7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBpc09wZW46IGZhbHNlXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmdldFRhcmdldE5vZGUgPSBmdW5jdGlvbiBnZXRUYXJnZXROb2RlKCkge1xuICAgIHJldHVybiB0aGlzLnRhcmdldE5vZGU7XG4gIH07XG5cbiAgX3Byb3RvLmdldENvbnRhaW5lck5vZGUgPSBmdW5jdGlvbiBnZXRDb250YWluZXJOb2RlKCkge1xuICAgIHJldHVybiBnZXRUYXJnZXQodGhpcy5wcm9wcy5jb250YWluZXIpO1xuICB9O1xuXG4gIF9wcm90by5nZXRSZWYgPSBmdW5jdGlvbiBnZXRSZWYocmVmKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHJlZjtcbiAgfTtcblxuICBfcHJvdG8uc2V0VGFyZ2V0Tm9kZSA9IGZ1bmN0aW9uIHNldFRhcmdldE5vZGUobm9kZSkge1xuICAgIHRoaXMudGFyZ2V0Tm9kZSA9IHR5cGVvZiBub2RlID09PSAnc3RyaW5nJyA/IGdldFRhcmdldChub2RlKSA6IG5vZGU7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlckNoaWxkcmVuID0gZnVuY3Rpb24gcmVuZGVyQ2hpbGRyZW4oKSB7XG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY3NzTW9kdWxlID0gX3RoaXMkcHJvcHMuY3NzTW9kdWxlLFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzLmNoaWxkcmVuLFxuICAgICAgICBpc09wZW4gPSBfdGhpcyRwcm9wcy5pc09wZW4sXG4gICAgICAgIGZsaXAgPSBfdGhpcyRwcm9wcy5mbGlwLFxuICAgICAgICBvZmZzZXQgPSBfdGhpcyRwcm9wcy5vZmZzZXQsXG4gICAgICAgIGZhbGxiYWNrUGxhY2VtZW50cyA9IF90aGlzJHByb3BzLmZhbGxiYWNrUGxhY2VtZW50cyxcbiAgICAgICAgcGxhY2VtZW50UHJlZml4ID0gX3RoaXMkcHJvcHMucGxhY2VtZW50UHJlZml4LFxuICAgICAgICBfYXJyb3dDbGFzc05hbWUgPSBfdGhpcyRwcm9wcy5hcnJvd0NsYXNzTmFtZSxcbiAgICAgICAgaGlkZUFycm93ID0gX3RoaXMkcHJvcHMuaGlkZUFycm93LFxuICAgICAgICBfcG9wcGVyQ2xhc3NOYW1lID0gX3RoaXMkcHJvcHMucG9wcGVyQ2xhc3NOYW1lLFxuICAgICAgICB0YWcgPSBfdGhpcyRwcm9wcy50YWcsXG4gICAgICAgIG1vZGlmaWVycyA9IF90aGlzJHByb3BzLm1vZGlmaWVycyxcbiAgICAgICAgc3RyYXRlZ3kgPSBfdGhpcyRwcm9wcy5zdHJhdGVneSxcbiAgICAgICAgYm91bmRhcmllc0VsZW1lbnQgPSBfdGhpcyRwcm9wcy5ib3VuZGFyaWVzRWxlbWVudCxcbiAgICAgICAgZmFkZSA9IF90aGlzJHByb3BzLmZhZGUsXG4gICAgICAgIHRyYW5zaXRpb24gPSBfdGhpcyRwcm9wcy50cmFuc2l0aW9uLFxuICAgICAgICBwbGFjZW1lbnQgPSBfdGhpcyRwcm9wcy5wbGFjZW1lbnQsXG4gICAgICAgIGF0dHJzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMsIF9leGNsdWRlZCR6KTtcblxuICAgIHZhciBhcnJvd0NsYXNzTmFtZSA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXSgnYXJyb3cnLCBfYXJyb3dDbGFzc05hbWUpLCBjc3NNb2R1bGUpO1xuICAgIHZhciBwb3BwZXJDbGFzc05hbWUgPSBtYXBUb0Nzc01vZHVsZXMoY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oX3BvcHBlckNsYXNzTmFtZSwgcGxhY2VtZW50UHJlZml4ID8gcGxhY2VtZW50UHJlZml4ICsgXCItYXV0b1wiIDogJycpLCB0aGlzLnByb3BzLmNzc01vZHVsZSk7XG4gICAgdmFyIG1vZGlmaWVyTmFtZXMgPSBtb2RpZmllcnMubWFwKGZ1bmN0aW9uIChtKSB7XG4gICAgICByZXR1cm4gbS5uYW1lO1xuICAgIH0pO1xuICAgIHZhciBiYXNlTW9kaWZpZXJzID0gW3tcbiAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBvZmZzZXQ6IG9mZnNldFxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdmbGlwJyxcbiAgICAgIGVuYWJsZWQ6IGZsaXAsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGZhbGxiYWNrUGxhY2VtZW50czogZmFsbGJhY2tQbGFjZW1lbnRzXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGJvdW5kYXJ5OiBib3VuZGFyaWVzRWxlbWVudFxuICAgICAgfVxuICAgIH1dLmZpbHRlcihmdW5jdGlvbiAobSkge1xuICAgICAgcmV0dXJuICFtb2RpZmllck5hbWVzLmluY2x1ZGVzKG0ubmFtZSk7XG4gICAgfSk7XG4gICAgdmFyIGV4dGVuZGVkTW9kaWZpZXJzID0gW10uY29uY2F0KGJhc2VNb2RpZmllcnMsIG1vZGlmaWVycyk7XG5cbiAgICB2YXIgcG9wcGVyVHJhbnNpdGlvbiA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBGYWRlLmRlZmF1bHRQcm9wcyksIHRyYW5zaXRpb24pLCB7fSwge1xuICAgICAgYmFzZUNsYXNzOiBmYWRlID8gdHJhbnNpdGlvbi5iYXNlQ2xhc3MgOiAnJyxcbiAgICAgIHRpbWVvdXQ6IGZhZGUgPyB0cmFuc2l0aW9uLnRpbWVvdXQgOiAwXG4gICAgfSk7XG5cbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KEZhZGUsIF9leHRlbmRzKHt9LCBwb3BwZXJUcmFuc2l0aW9uLCBhdHRycywge1xuICAgICAgXCJpblwiOiBpc09wZW4sXG4gICAgICBvbkV4aXRlZDogdGhpcy5vbkNsb3NlZCxcbiAgICAgIHRhZzogdGFnXG4gICAgfSksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChyZWFjdFBvcHBlci5Qb3BwZXIsIHtcbiAgICAgIHJlZmVyZW5jZUVsZW1lbnQ6IHRoaXMudGFyZ2V0Tm9kZSxcbiAgICAgIG1vZGlmaWVyczogZXh0ZW5kZWRNb2RpZmllcnMsXG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIHN0cmF0ZWd5OiBzdHJhdGVneVxuICAgIH0sIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgcmVmID0gX3JlZi5yZWYsXG4gICAgICAgICAgc3R5bGUgPSBfcmVmLnN0eWxlLFxuICAgICAgICAgIHBvcHBlclBsYWNlbWVudCA9IF9yZWYucGxhY2VtZW50LFxuICAgICAgICAgIGlzUmVmZXJlbmNlSGlkZGVuID0gX3JlZi5pc1JlZmVyZW5jZUhpZGRlbixcbiAgICAgICAgICBhcnJvd1Byb3BzID0gX3JlZi5hcnJvd1Byb3BzLFxuICAgICAgICAgIHVwZGF0ZSA9IF9yZWYudXBkYXRlO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIHJlZjogcmVmLFxuICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgIGNsYXNzTmFtZTogcG9wcGVyQ2xhc3NOYW1lLFxuICAgICAgICBcImRhdGEtcG9wcGVyLXBsYWNlbWVudFwiOiBwb3BwZXJQbGFjZW1lbnQsXG4gICAgICAgIFwiZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlblwiOiBpc1JlZmVyZW5jZUhpZGRlbiA/ICd0cnVlJyA6IHVuZGVmaW5lZFxuICAgICAgfSwgdHlwZW9mIGNoaWxkcmVuID09PSAnZnVuY3Rpb24nID8gY2hpbGRyZW4oe1xuICAgICAgICB1cGRhdGU6IHVwZGF0ZVxuICAgICAgfSkgOiBjaGlsZHJlbiwgIWhpZGVBcnJvdyAmJiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgICAgcmVmOiBhcnJvd1Byb3BzLnJlZixcbiAgICAgICAgY2xhc3NOYW1lOiBhcnJvd0NsYXNzTmFtZSxcbiAgICAgICAgc3R5bGU6IGFycm93UHJvcHMuc3R5bGVcbiAgICAgIH0pKTtcbiAgICB9KSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB0aGlzLnNldFRhcmdldE5vZGUodGhpcy5wcm9wcy50YXJnZXQpO1xuXG4gICAgaWYgKHRoaXMuc3RhdGUuaXNPcGVuKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5jb250YWluZXIgPT09ICdpbmxpbmUnID8gdGhpcy5yZW5kZXJDaGlsZHJlbigpIDogUmVhY3RET01fX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZVBvcnRhbCggLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgcmVmOiB0aGlzLmdldFJlZlxuICAgICAgfSwgdGhpcy5yZW5kZXJDaGlsZHJlbigpKSwgdGhpcy5nZXRDb250YWluZXJOb2RlKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBQb3BwZXJDb250ZW50O1xufShSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uQ29tcG9uZW50KTtcblxuUG9wcGVyQ29udGVudC5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkRjtcblBvcHBlckNvbnRlbnQuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJEY7XG52YXIgUG9wcGVyQ29udGVudCQxID0gUG9wcGVyQ29udGVudDtcblxuZnVuY3Rpb24gUG9wcGVyVGFyZ2V0SGVscGVyKHByb3BzLCBjb250ZXh0KSB7XG4gIGNvbnRleHQucG9wcGVyTWFuYWdlci5zZXRUYXJnZXROb2RlKGdldFRhcmdldChwcm9wcy50YXJnZXQpKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cblBvcHBlclRhcmdldEhlbHBlci5jb250ZXh0VHlwZXMgPSB7XG4gIHBvcHBlck1hbmFnZXI6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LmlzUmVxdWlyZWRcbn07XG5Qb3BwZXJUYXJnZXRIZWxwZXIucHJvcFR5cGVzID0ge1xuICB0YXJnZXQ6IHRhcmdldFByb3BUeXBlLmlzUmVxdWlyZWRcbn07XG5cbnZhciBwcm9wVHlwZXMkRSA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm5vZGUsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuY10pLFxuICBwbGFjZW1lbnQ6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2YoUG9wcGVyUGxhY2VtZW50cyksXG4gIHRhcmdldDogdGFyZ2V0UHJvcFR5cGUuaXNSZXF1aXJlZCxcbiAgY29udGFpbmVyOiB0YXJnZXRQcm9wVHlwZSxcbiAgaXNPcGVuOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG4gIGRpc2FibGVkOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG4gIGhpZGVBcnJvdzogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBib3VuZGFyaWVzRWxlbWVudDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vbmVPZlR5cGUoW1Byb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLCBET01FbGVtZW50XSksXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIGlubmVyQ2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgYXJyb3dDbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICBwb3BwZXJDbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICBjc3NNb2R1bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LFxuICB0b2dnbGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuYyxcbiAgYXV0b2hpZGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcbiAgcGxhY2VtZW50UHJlZml4OiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgZGVsYXk6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnNoYXBlKHtcbiAgICBzaG93OiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm51bWJlcixcbiAgICBoaWRlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm51bWJlclxuICB9KSwgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5udW1iZXJdKSxcbiAgbW9kaWZpZXJzOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmFycmF5LFxuICBzdHJhdGVneTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIG9mZnNldDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5hcnJheU9mKFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ubnVtYmVyKSxcbiAgaW5uZXJSZWY6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZ1bmMsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLCBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdF0pLFxuICB0cmlnZ2VyOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgZmFkZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBmbGlwOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2xcbn07XG52YXIgREVGQVVMVF9ERUxBWVMgPSB7XG4gIHNob3c6IDAsXG4gIGhpZGU6IDUwXG59O1xudmFyIGRlZmF1bHRQcm9wcyRFID0ge1xuICBpc09wZW46IGZhbHNlLFxuICBoaWRlQXJyb3c6IGZhbHNlLFxuICBhdXRvaGlkZTogZmFsc2UsXG4gIGRlbGF5OiBERUZBVUxUX0RFTEFZUyxcbiAgdG9nZ2xlOiBmdW5jdGlvbiB0b2dnbGUoKSB7fSxcbiAgdHJpZ2dlcjogJ2NsaWNrJyxcbiAgZmFkZTogdHJ1ZVxufTtcblxuZnVuY3Rpb24gaXNJbkRPTVN1YnRyZWUoZWxlbWVudCwgc3VidHJlZVJvb3QpIHtcbiAgcmV0dXJuIHN1YnRyZWVSb290ICYmIChlbGVtZW50ID09PSBzdWJ0cmVlUm9vdCB8fCBzdWJ0cmVlUm9vdC5jb250YWlucyhlbGVtZW50KSk7XG59XG5cbmZ1bmN0aW9uIGlzSW5ET01TdWJ0cmVlcyhlbGVtZW50LCBzdWJ0cmVlUm9vdHMpIHtcbiAgaWYgKHN1YnRyZWVSb290cyA9PT0gdm9pZCAwKSB7XG4gICAgc3VidHJlZVJvb3RzID0gW107XG4gIH1cblxuICByZXR1cm4gc3VidHJlZVJvb3RzICYmIHN1YnRyZWVSb290cy5sZW5ndGggJiYgc3VidHJlZVJvb3RzLmZpbHRlcihmdW5jdGlvbiAoc3ViVHJlZVJvb3QpIHtcbiAgICByZXR1cm4gaXNJbkRPTVN1YnRyZWUoZWxlbWVudCwgc3ViVHJlZVJvb3QpO1xuICB9KVswXTtcbn1cblxudmFyIFRvb2x0aXBQb3BvdmVyV3JhcHBlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShUb29sdGlwUG9wb3ZlcldyYXBwZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFRvb2x0aXBQb3BvdmVyV3JhcHBlcihwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgIF90aGlzLl90YXJnZXRzID0gW107XG4gICAgX3RoaXMuY3VycmVudFRhcmdldEVsZW1lbnQgPSBudWxsO1xuICAgIF90aGlzLmFkZFRhcmdldEV2ZW50cyA9IF90aGlzLmFkZFRhcmdldEV2ZW50cy5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5oYW5kbGVEb2N1bWVudENsaWNrID0gX3RoaXMuaGFuZGxlRG9jdW1lbnRDbGljay5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5yZW1vdmVUYXJnZXRFdmVudHMgPSBfdGhpcy5yZW1vdmVUYXJnZXRFdmVudHMuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMudG9nZ2xlID0gX3RoaXMudG9nZ2xlLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLnNob3dXaXRoRGVsYXkgPSBfdGhpcy5zaG93V2l0aERlbGF5LmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmhpZGVXaXRoRGVsYXkgPSBfdGhpcy5oaWRlV2l0aERlbGF5LmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLm9uTW91c2VPdmVyVG9vbHRpcENvbnRlbnQgPSBfdGhpcy5vbk1vdXNlT3ZlclRvb2x0aXBDb250ZW50LmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLm9uTW91c2VMZWF2ZVRvb2x0aXBDb250ZW50ID0gX3RoaXMub25Nb3VzZUxlYXZlVG9vbHRpcENvbnRlbnQuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMuc2hvdyA9IF90aGlzLnNob3cuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMuaGlkZSA9IF90aGlzLmhpZGUuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMub25Fc2NLZXlEb3duID0gX3RoaXMub25Fc2NLZXlEb3duLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmdldFJlZiA9IF90aGlzLmdldFJlZi5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGlzT3BlbjogcHJvcHMuaXNPcGVuXG4gICAgfTtcbiAgICBfdGhpcy5faXNNb3VudGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFRvb2x0aXBQb3BvdmVyV3JhcHBlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICB0aGlzLnVwZGF0ZVRhcmdldCgpO1xuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuX2lzTW91bnRlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVtb3ZlVGFyZ2V0RXZlbnRzKCk7XG4gICAgdGhpcy5fdGFyZ2V0cyA9IG51bGw7XG4gICAgdGhpcy5jbGVhclNob3dUaW1lb3V0KCk7XG4gICAgdGhpcy5jbGVhckhpZGVUaW1lb3V0KCk7XG4gIH07XG5cbiAgVG9vbHRpcFBvcG92ZXJXcmFwcGVyLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wcywgc3RhdGUpIHtcbiAgICBpZiAocHJvcHMuaXNPcGVuICYmICFzdGF0ZS5pc09wZW4pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzT3BlbjogcHJvcHMuaXNPcGVuXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIF9wcm90by5oYW5kbGVEb2N1bWVudENsaWNrID0gZnVuY3Rpb24gaGFuZGxlRG9jdW1lbnRDbGljayhlKSB7XG4gICAgdmFyIHRyaWdnZXJzID0gdGhpcy5wcm9wcy50cmlnZ2VyLnNwbGl0KCcgJyk7XG5cbiAgICBpZiAodHJpZ2dlcnMuaW5kZXhPZignbGVnYWN5JykgPiAtMSAmJiAodGhpcy5wcm9wcy5pc09wZW4gfHwgaXNJbkRPTVN1YnRyZWVzKGUudGFyZ2V0LCB0aGlzLl90YXJnZXRzKSkpIHtcbiAgICAgIGlmICh0aGlzLl9oaWRlVGltZW91dCkge1xuICAgICAgICB0aGlzLmNsZWFySGlkZVRpbWVvdXQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucHJvcHMuaXNPcGVuICYmICFpc0luRE9NU3VidHJlZShlLnRhcmdldCwgdGhpcy5fcG9wb3ZlcikpIHtcbiAgICAgICAgdGhpcy5oaWRlV2l0aERlbGF5KGUpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5wcm9wcy5pc09wZW4pIHtcbiAgICAgICAgdGhpcy5zaG93V2l0aERlbGF5KGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHJpZ2dlcnMuaW5kZXhPZignY2xpY2snKSA+IC0xICYmIGlzSW5ET01TdWJ0cmVlcyhlLnRhcmdldCwgdGhpcy5fdGFyZ2V0cykpIHtcbiAgICAgIGlmICh0aGlzLl9oaWRlVGltZW91dCkge1xuICAgICAgICB0aGlzLmNsZWFySGlkZVRpbWVvdXQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnByb3BzLmlzT3Blbikge1xuICAgICAgICB0aGlzLnNob3dXaXRoRGVsYXkoZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhpZGVXaXRoRGVsYXkoZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbk1vdXNlT3ZlclRvb2x0aXBDb250ZW50ID0gZnVuY3Rpb24gb25Nb3VzZU92ZXJUb29sdGlwQ29udGVudCgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy50cmlnZ2VyLmluZGV4T2YoJ2hvdmVyJykgPiAtMSAmJiAhdGhpcy5wcm9wcy5hdXRvaGlkZSkge1xuICAgICAgaWYgKHRoaXMuX2hpZGVUaW1lb3V0KSB7XG4gICAgICAgIHRoaXMuY2xlYXJIaWRlVGltZW91dCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdGF0ZS5pc09wZW4gJiYgIXRoaXMucHJvcHMuaXNPcGVuKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5vbk1vdXNlTGVhdmVUb29sdGlwQ29udGVudCA9IGZ1bmN0aW9uIG9uTW91c2VMZWF2ZVRvb2x0aXBDb250ZW50KGUpIHtcbiAgICBpZiAodGhpcy5wcm9wcy50cmlnZ2VyLmluZGV4T2YoJ2hvdmVyJykgPiAtMSAmJiAhdGhpcy5wcm9wcy5hdXRvaGlkZSkge1xuICAgICAgaWYgKHRoaXMuX3Nob3dUaW1lb3V0KSB7XG4gICAgICAgIHRoaXMuY2xlYXJTaG93VGltZW91dCgpO1xuICAgICAgfVxuXG4gICAgICBlLnBlcnNpc3QoKTtcbiAgICAgIHRoaXMuX2hpZGVUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLmhpZGUuYmluZCh0aGlzLCBlKSwgdGhpcy5nZXREZWxheSgnaGlkZScpKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uRXNjS2V5RG93biA9IGZ1bmN0aW9uIG9uRXNjS2V5RG93bihlKSB7XG4gICAgaWYgKGUua2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgdGhpcy5oaWRlKGUpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZ2V0UmVmID0gZnVuY3Rpb24gZ2V0UmVmKHJlZikge1xuICAgIHZhciBpbm5lclJlZiA9IHRoaXMucHJvcHMuaW5uZXJSZWY7XG5cbiAgICBpZiAoaW5uZXJSZWYpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5uZXJSZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5uZXJSZWYocmVmKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlubmVyUmVmID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpbm5lclJlZi5jdXJyZW50ID0gcmVmO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3BvcG92ZXIgPSByZWY7XG4gIH07XG5cbiAgX3Byb3RvLmdldERlbGF5ID0gZnVuY3Rpb24gZ2V0RGVsYXkoa2V5KSB7XG4gICAgdmFyIGRlbGF5ID0gdGhpcy5wcm9wcy5kZWxheTtcblxuICAgIGlmICh0eXBlb2YgZGVsYXkgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gaXNOYU4oZGVsYXlba2V5XSkgPyBERUZBVUxUX0RFTEFZU1trZXldIDogZGVsYXlba2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVsYXk7XG4gIH07XG5cbiAgX3Byb3RvLmdldEN1cnJlbnRUYXJnZXQgPSBmdW5jdGlvbiBnZXRDdXJyZW50VGFyZ2V0KHRhcmdldCkge1xuICAgIGlmICghdGFyZ2V0KSByZXR1cm4gbnVsbDtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX3RhcmdldHMuaW5kZXhPZih0YXJnZXQpO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHJldHVybiB0aGlzLl90YXJnZXRzW2luZGV4XTtcbiAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50VGFyZ2V0KHRhcmdldC5wYXJlbnRFbGVtZW50KTtcbiAgfTtcblxuICBfcHJvdG8uc2hvdyA9IGZ1bmN0aW9uIHNob3coZSkge1xuICAgIGlmICghdGhpcy5wcm9wcy5pc09wZW4pIHtcbiAgICAgIHRoaXMuY2xlYXJTaG93VGltZW91dCgpO1xuICAgICAgdGhpcy5jdXJyZW50VGFyZ2V0RWxlbWVudCA9IGUgPyBlLmN1cnJlbnRUYXJnZXQgfHwgdGhpcy5nZXRDdXJyZW50VGFyZ2V0KGUudGFyZ2V0KSA6IG51bGw7XG5cbiAgICAgIGlmIChlICYmIGUuY29tcG9zZWRQYXRoICYmIHR5cGVvZiBlLmNvbXBvc2VkUGF0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgcGF0aCA9IGUuY29tcG9zZWRQYXRoKCk7XG4gICAgICAgIHRoaXMuY3VycmVudFRhcmdldEVsZW1lbnQgPSBwYXRoICYmIHBhdGhbMF0gfHwgdGhpcy5jdXJyZW50VGFyZ2V0RWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgdGhpcy50b2dnbGUoZSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5zaG93V2l0aERlbGF5ID0gZnVuY3Rpb24gc2hvd1dpdGhEZWxheShlKSB7XG4gICAgaWYgKHRoaXMuX2hpZGVUaW1lb3V0KSB7XG4gICAgICB0aGlzLmNsZWFySGlkZVRpbWVvdXQoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zaG93VGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5zaG93LmJpbmQodGhpcywgZSksIHRoaXMuZ2V0RGVsYXkoJ3Nob3cnKSk7XG4gIH07XG5cbiAgX3Byb3RvLmhpZGUgPSBmdW5jdGlvbiBoaWRlKGUpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5pc09wZW4pIHtcbiAgICAgIHRoaXMuY2xlYXJIaWRlVGltZW91dCgpO1xuICAgICAgdGhpcy5jdXJyZW50VGFyZ2V0RWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLnRvZ2dsZShlKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmhpZGVXaXRoRGVsYXkgPSBmdW5jdGlvbiBoaWRlV2l0aERlbGF5KGUpIHtcbiAgICBpZiAodGhpcy5fc2hvd1RpbWVvdXQpIHtcbiAgICAgIHRoaXMuY2xlYXJTaG93VGltZW91dCgpO1xuICAgIH1cblxuICAgIHRoaXMuX2hpZGVUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLmhpZGUuYmluZCh0aGlzLCBlKSwgdGhpcy5nZXREZWxheSgnaGlkZScpKTtcbiAgfTtcblxuICBfcHJvdG8uY2xlYXJTaG93VGltZW91dCA9IGZ1bmN0aW9uIGNsZWFyU2hvd1RpbWVvdXQoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3Nob3dUaW1lb3V0KTtcbiAgICB0aGlzLl9zaG93VGltZW91dCA9IHVuZGVmaW5lZDtcbiAgfTtcblxuICBfcHJvdG8uY2xlYXJIaWRlVGltZW91dCA9IGZ1bmN0aW9uIGNsZWFySGlkZVRpbWVvdXQoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2hpZGVUaW1lb3V0KTtcbiAgICB0aGlzLl9oaWRlVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgfTtcblxuICBfcHJvdG8uYWRkRXZlbnRPblRhcmdldHMgPSBmdW5jdGlvbiBhZGRFdmVudE9uVGFyZ2V0cyh0eXBlLCBoYW5kbGVyLCBpc0J1YmJsZSkge1xuICAgIHRoaXMuX3RhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBpc0J1YmJsZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbW92ZUV2ZW50T25UYXJnZXRzID0gZnVuY3Rpb24gcmVtb3ZlRXZlbnRPblRhcmdldHModHlwZSwgaGFuZGxlciwgaXNCdWJibGUpIHtcbiAgICB0aGlzLl90YXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgaXNCdWJibGUpO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5hZGRUYXJnZXRFdmVudHMgPSBmdW5jdGlvbiBhZGRUYXJnZXRFdmVudHMoKSB7XG4gICAgaWYgKHRoaXMucHJvcHMudHJpZ2dlcikge1xuICAgICAgdmFyIHRyaWdnZXJzID0gdGhpcy5wcm9wcy50cmlnZ2VyLnNwbGl0KCcgJyk7XG5cbiAgICAgIGlmICh0cmlnZ2Vycy5pbmRleE9mKCdtYW51YWwnKSA9PT0gLTEpIHtcbiAgICAgICAgaWYgKHRyaWdnZXJzLmluZGV4T2YoJ2NsaWNrJykgPiAtMSB8fCB0cmlnZ2Vycy5pbmRleE9mKCdsZWdhY3knKSA+IC0xKSB7XG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZURvY3VtZW50Q2xpY2ssIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3RhcmdldHMgJiYgdGhpcy5fdGFyZ2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAodHJpZ2dlcnMuaW5kZXhPZignaG92ZXInKSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50T25UYXJnZXRzKCdtb3VzZW92ZXInLCB0aGlzLnNob3dXaXRoRGVsYXksIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5hZGRFdmVudE9uVGFyZ2V0cygnbW91c2VvdXQnLCB0aGlzLmhpZGVXaXRoRGVsYXksIHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0cmlnZ2Vycy5pbmRleE9mKCdmb2N1cycpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRPblRhcmdldHMoJ2ZvY3VzaW4nLCB0aGlzLnNob3csIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5hZGRFdmVudE9uVGFyZ2V0cygnZm9jdXNvdXQnLCB0aGlzLmhpZGUsIHRydWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYWRkRXZlbnRPblRhcmdldHMoJ2tleWRvd24nLCB0aGlzLm9uRXNjS2V5RG93biwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbW92ZVRhcmdldEV2ZW50cyA9IGZ1bmN0aW9uIHJlbW92ZVRhcmdldEV2ZW50cygpIHtcbiAgICBpZiAodGhpcy5fdGFyZ2V0cykge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudE9uVGFyZ2V0cygnbW91c2VvdmVyJywgdGhpcy5zaG93V2l0aERlbGF5LCB0cnVlKTtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRPblRhcmdldHMoJ21vdXNlb3V0JywgdGhpcy5oaWRlV2l0aERlbGF5LCB0cnVlKTtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRPblRhcmdldHMoJ2tleWRvd24nLCB0aGlzLm9uRXNjS2V5RG93biwgdHJ1ZSk7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50T25UYXJnZXRzKCdmb2N1c2luJywgdGhpcy5zaG93LCB0cnVlKTtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRPblRhcmdldHMoJ2ZvY3Vzb3V0JywgdGhpcy5oaWRlLCB0cnVlKTtcbiAgICB9XG5cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlRG9jdW1lbnRDbGljaywgdHJ1ZSk7XG4gIH07XG5cbiAgX3Byb3RvLnVwZGF0ZVRhcmdldCA9IGZ1bmN0aW9uIHVwZGF0ZVRhcmdldCgpIHtcbiAgICB2YXIgbmV3VGFyZ2V0ID0gZ2V0VGFyZ2V0KHRoaXMucHJvcHMudGFyZ2V0LCB0cnVlKTtcblxuICAgIGlmIChuZXdUYXJnZXQgIT09IHRoaXMuX3RhcmdldHMpIHtcbiAgICAgIHRoaXMucmVtb3ZlVGFyZ2V0RXZlbnRzKCk7XG4gICAgICB0aGlzLl90YXJnZXRzID0gbmV3VGFyZ2V0ID8gQXJyYXkuZnJvbShuZXdUYXJnZXQpIDogW107XG4gICAgICB0aGlzLmN1cnJlbnRUYXJnZXRFbGVtZW50ID0gdGhpcy5jdXJyZW50VGFyZ2V0RWxlbWVudCB8fCB0aGlzLl90YXJnZXRzWzBdO1xuICAgICAgdGhpcy5hZGRUYXJnZXRFdmVudHMoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnRvZ2dsZSA9IGZ1bmN0aW9uIHRvZ2dsZShlKSB7XG4gICAgaWYgKHRoaXMucHJvcHMuZGlzYWJsZWQgfHwgIXRoaXMuX2lzTW91bnRlZCkge1xuICAgICAgcmV0dXJuIGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnByb3BzLnRvZ2dsZShlKTtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMucHJvcHMuaXNPcGVuKSB7XG4gICAgICB0aGlzLnVwZGF0ZVRhcmdldCgpO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXQgPSB0aGlzLmN1cnJlbnRUYXJnZXRFbGVtZW50IHx8IHRoaXMuX3RhcmdldHNbMF07XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgICBjc3NNb2R1bGUgPSBfdGhpcyRwcm9wcy5jc3NNb2R1bGUsXG4gICAgICAgIGlubmVyQ2xhc3NOYW1lID0gX3RoaXMkcHJvcHMuaW5uZXJDbGFzc05hbWUsXG4gICAgICAgIGlzT3BlbiA9IF90aGlzJHByb3BzLmlzT3BlbixcbiAgICAgICAgaGlkZUFycm93ID0gX3RoaXMkcHJvcHMuaGlkZUFycm93LFxuICAgICAgICBib3VuZGFyaWVzRWxlbWVudCA9IF90aGlzJHByb3BzLmJvdW5kYXJpZXNFbGVtZW50LFxuICAgICAgICBwbGFjZW1lbnQgPSBfdGhpcyRwcm9wcy5wbGFjZW1lbnQsXG4gICAgICAgIHBsYWNlbWVudFByZWZpeCA9IF90aGlzJHByb3BzLnBsYWNlbWVudFByZWZpeCxcbiAgICAgICAgYXJyb3dDbGFzc05hbWUgPSBfdGhpcyRwcm9wcy5hcnJvd0NsYXNzTmFtZSxcbiAgICAgICAgcG9wcGVyQ2xhc3NOYW1lID0gX3RoaXMkcHJvcHMucG9wcGVyQ2xhc3NOYW1lLFxuICAgICAgICBjb250YWluZXIgPSBfdGhpcyRwcm9wcy5jb250YWluZXIsXG4gICAgICAgIG1vZGlmaWVycyA9IF90aGlzJHByb3BzLm1vZGlmaWVycyxcbiAgICAgICAgc3RyYXRlZ3kgPSBfdGhpcyRwcm9wcy5zdHJhdGVneSxcbiAgICAgICAgb2Zmc2V0ID0gX3RoaXMkcHJvcHMub2Zmc2V0LFxuICAgICAgICBmYWRlID0gX3RoaXMkcHJvcHMuZmFkZSxcbiAgICAgICAgZmxpcCA9IF90aGlzJHByb3BzLmZsaXAsXG4gICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMuY2hpbGRyZW47XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBvbWl0KHRoaXMucHJvcHMsIE9iamVjdC5rZXlzKHByb3BUeXBlcyRFKSk7XG4gICAgdmFyIHBvcHBlckNsYXNzZXMgPSBtYXBUb0Nzc01vZHVsZXMocG9wcGVyQ2xhc3NOYW1lLCBjc3NNb2R1bGUpO1xuICAgIHZhciBjbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGlubmVyQ2xhc3NOYW1lLCBjc3NNb2R1bGUpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoUG9wcGVyQ29udGVudCQxLCB7XG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgaXNPcGVuOiBpc09wZW4sXG4gICAgICBoaWRlQXJyb3c6IGhpZGVBcnJvdyxcbiAgICAgIGJvdW5kYXJpZXNFbGVtZW50OiBib3VuZGFyaWVzRWxlbWVudCxcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50UHJlZml4OiBwbGFjZW1lbnRQcmVmaXgsXG4gICAgICBhcnJvd0NsYXNzTmFtZTogYXJyb3dDbGFzc05hbWUsXG4gICAgICBwb3BwZXJDbGFzc05hbWU6IHBvcHBlckNsYXNzZXMsXG4gICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgIG1vZGlmaWVyczogbW9kaWZpZXJzLFxuICAgICAgc3RyYXRlZ3k6IHN0cmF0ZWd5LFxuICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICBjc3NNb2R1bGU6IGNzc01vZHVsZSxcbiAgICAgIGZhZGU6IGZhZGUsXG4gICAgICBmbGlwOiBmbGlwXG4gICAgfSwgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciB1cGRhdGUgPSBfcmVmLnVwZGF0ZTtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIHtcbiAgICAgICAgcmVmOiBfdGhpczIuZ2V0UmVmLFxuICAgICAgICBjbGFzc05hbWU6IGNsYXNzZXMsXG4gICAgICAgIHJvbGU6IFwidG9vbHRpcFwiLFxuICAgICAgICBvbk1vdXNlT3ZlcjogX3RoaXMyLm9uTW91c2VPdmVyVG9vbHRpcENvbnRlbnQsXG4gICAgICAgIG9uTW91c2VMZWF2ZTogX3RoaXMyLm9uTW91c2VMZWF2ZVRvb2x0aXBDb250ZW50LFxuICAgICAgICBvbktleURvd246IF90aGlzMi5vbkVzY0tleURvd25cbiAgICAgIH0pLCB0eXBlb2YgY2hpbGRyZW4gPT09ICdmdW5jdGlvbicgPyBjaGlsZHJlbih7XG4gICAgICAgIHVwZGF0ZTogdXBkYXRlXG4gICAgICB9KSA6IGNoaWxkcmVuKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gVG9vbHRpcFBvcG92ZXJXcmFwcGVyO1xufShSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uQ29tcG9uZW50KTtcblxuVG9vbHRpcFBvcG92ZXJXcmFwcGVyLnByb3BUeXBlcyA9IHByb3BUeXBlcyRFO1xuVG9vbHRpcFBvcG92ZXJXcmFwcGVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyRFO1xudmFyIFRvb2x0aXBQb3BvdmVyV3JhcHBlciQxID0gVG9vbHRpcFBvcG92ZXJXcmFwcGVyO1xuXG52YXIgZGVmYXVsdFByb3BzJEQgPSB7XG4gIHBsYWNlbWVudDogJ3JpZ2h0JyxcbiAgcGxhY2VtZW50UHJlZml4OiAnYnMtcG9wb3ZlcicsXG4gIHRyaWdnZXI6ICdjbGljaycsXG4gIG9mZnNldDogWzAsIDhdXG59O1xuXG5mdW5jdGlvbiBQb3BvdmVyKHByb3BzKSB7XG4gIHZhciBwb3BwZXJDbGFzc2VzID0gY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oJ3BvcG92ZXInLCAnc2hvdycsIHByb3BzLnBvcHBlckNsYXNzTmFtZSk7XG4gIHZhciBjbGFzc2VzID0gY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oJ3BvcG92ZXItaW5uZXInLCBwcm9wcy5pbm5lckNsYXNzTmFtZSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoVG9vbHRpcFBvcG92ZXJXcmFwcGVyJDEsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIGFycm93Q2xhc3NOYW1lOiBcInBvcG92ZXItYXJyb3dcIixcbiAgICBwb3BwZXJDbGFzc05hbWU6IHBvcHBlckNsYXNzZXMsXG4gICAgaW5uZXJDbGFzc05hbWU6IGNsYXNzZXNcbiAgfSkpO1xufVxuXG5Qb3BvdmVyLnByb3BUeXBlcyA9IHByb3BUeXBlcyRFO1xuUG9wb3Zlci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHMkRDtcblxudmFyIG9taXRLZXlzJDQgPSBbJ2RlZmF1bHRPcGVuJ107XG5cbnZhciBVbmNvbnRyb2xsZWRQb3BvdmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFVuY29udHJvbGxlZFBvcG92ZXIsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFVuY29udHJvbGxlZFBvcG92ZXIocHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9Db21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGlzT3BlbjogcHJvcHMuZGVmYXVsdE9wZW4gfHwgZmFsc2VcbiAgICB9O1xuICAgIF90aGlzLnRvZ2dsZSA9IF90aGlzLnRvZ2dsZS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVW5jb250cm9sbGVkUG9wb3Zlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnRvZ2dsZSA9IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChwcmV2U3RhdGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzT3BlbjogIXByZXZTdGF0ZS5pc09wZW5cbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFBvcG92ZXIsIF9leHRlbmRzKHtcbiAgICAgIGlzT3BlbjogdGhpcy5zdGF0ZS5pc09wZW4sXG4gICAgICB0b2dnbGU6IHRoaXMudG9nZ2xlXG4gICAgfSwgb21pdCh0aGlzLnByb3BzLCBvbWl0S2V5cyQ0KSkpO1xuICB9O1xuXG4gIHJldHVybiBVbmNvbnRyb2xsZWRQb3BvdmVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuVW5jb250cm9sbGVkUG9wb3Zlci5wcm9wVHlwZXMgPSBfb2JqZWN0U3ByZWFkMih7XG4gIGRlZmF1bHRPcGVuOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2xcbn0sIFBvcG92ZXIucHJvcFR5cGVzKTtcblxudmFyIF9leGNsdWRlZCR5ID0gW1wiY2xhc3NOYW1lXCIsIFwiY3NzTW9kdWxlXCIsIFwidGFnXCJdO1xudmFyIHByb3BUeXBlcyREID0ge1xuICB0YWc6IHRhZ1Byb3BUeXBlLFxuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICBjc3NNb2R1bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0XG59O1xudmFyIGRlZmF1bHRQcm9wcyRDID0ge1xuICB0YWc6ICdoMydcbn07XG5cbmZ1bmN0aW9uIFBvcG92ZXJIZWFkZXIocHJvcHMpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNzc01vZHVsZSA9IHByb3BzLmNzc01vZHVsZSxcbiAgICAgIFRhZyA9IHByb3BzLnRhZyxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkJHkpO1xuXG4gIHZhciBjbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGNsYXNzTmFtZSwgJ3BvcG92ZXItaGVhZGVyJyksIGNzc01vZHVsZSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoVGFnLCBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3Nlc1xuICB9KSk7XG59XG5cblBvcG92ZXJIZWFkZXIucHJvcFR5cGVzID0gcHJvcFR5cGVzJEQ7XG5Qb3BvdmVySGVhZGVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyRDO1xuXG52YXIgX2V4Y2x1ZGVkJHggPSBbXCJjbGFzc05hbWVcIiwgXCJjc3NNb2R1bGVcIiwgXCJ0YWdcIl07XG52YXIgcHJvcFR5cGVzJEMgPSB7XG4gIHRhZzogdGFnUHJvcFR5cGUsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3Rcbn07XG52YXIgZGVmYXVsdFByb3BzJEIgPSB7XG4gIHRhZzogJ2Rpdidcbn07XG5cbmZ1bmN0aW9uIFBvcG92ZXJCb2R5KHByb3BzKSB7XG4gIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjc3NNb2R1bGUgPSBwcm9wcy5jc3NNb2R1bGUsXG4gICAgICBUYWcgPSBwcm9wcy50YWcsXG4gICAgICBhdHRyaWJ1dGVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZCR4KTtcblxuICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjbGFzc05hbWUsICdwb3BvdmVyLWJvZHknKSwgY3NzTW9kdWxlKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChUYWcsIF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzXG4gIH0pKTtcbn1cblxuUG9wb3ZlckJvZHkucHJvcFR5cGVzID0gcHJvcFR5cGVzJEM7XG5Qb3BvdmVyQm9keS5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHMkQjtcblxudmFyIF9leGNsdWRlZCR3ID0gW1wiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIiwgXCJiYXJDbGFzc05hbWVcIiwgXCJjc3NNb2R1bGVcIiwgXCJ2YWx1ZVwiLCBcIm1pblwiLCBcIm1heFwiLCBcImFuaW1hdGVkXCIsIFwic3RyaXBlZFwiLCBcImNvbG9yXCIsIFwiYmFyXCIsIFwibXVsdGlcIiwgXCJ0YWdcIiwgXCJzdHlsZVwiLCBcImJhclN0eWxlXCIsIFwiYmFyQXJpYVZhbHVlVGV4dFwiLCBcImJhckFyaWFMYWJlbGxlZEJ5XCJdO1xudmFyIHByb3BUeXBlcyRCID0ge1xuICAvKiogRW5hYmxlIGFuaW1hdGlvbiB0byBiYXIgKi9cbiAgYW5pbWF0ZWQ6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcbiAgYmFyOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG4gIGJhckFyaWFMYWJlbGxlZEJ5OiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgYmFyQXJpYVZhbHVlVGV4dDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIGJhckNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIGJhclN0eWxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCxcbiAgY2hpbGRyZW46IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ubm9kZSxcblxuICAvKiogQWRkIGN1c3RvbSBjbGFzcyAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuXG4gIC8qKiBDaGFuZ2UgdW5kZXJseWluZyBjb21wb25lbnQncyBDU1MgYmFzZSBjbGFzcyBuYW1lICovXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG5cbiAgLyoqIEFkZCBjdXN0b20gY29sb3IgdG8gdGhlIHBsYWNlaG9sZGVyICovXG4gIGNvbG9yOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcblxuICAvKiogTWF4aW11bSB2YWx1ZSBvZiBwcm9ncmVzcyAqL1xuICBtYXg6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZywgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5udW1iZXJdKSxcblxuICAvKiogTWluaW11bSB2YWx1ZSBvZiBwcm9ncmVzcywgZGVmYXVsdHMgdG8gemVybyAqL1xuICBtaW46IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZywgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5udW1iZXJdKSxcbiAgbXVsdGk6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcblxuICAvKiogQWRkIHN0cmlwZXMgdG8gcHJvZ3Jlc3MgYmFyICovXG4gIHN0cmlwZWQ6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcbiAgc3R5bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LFxuXG4gIC8qKiBTZXQgYSBjdXN0b20gZWxlbWVudCBmb3IgdGhpcyBjb21wb25lbnQgKi9cbiAgdGFnOiB0YWdQcm9wVHlwZSxcblxuICAvKiogQ3VycmVudCB2YWx1ZSBvZiBwcm9ncmVzcyAqL1xuICB2YWx1ZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vbmVPZlR5cGUoW1Byb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLCBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm51bWJlcl0pXG59O1xudmFyIGRlZmF1bHRQcm9wcyRBID0ge1xuICB0YWc6ICdkaXYnLFxuICB2YWx1ZTogMCxcbiAgbWluOiAwLFxuICBtYXg6IDEwMCxcbiAgc3R5bGU6IHt9LFxuICBiYXJTdHlsZToge31cbn07XG5cbmZ1bmN0aW9uIFByb2dyZXNzKHByb3BzKSB7XG4gIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgYmFyQ2xhc3NOYW1lID0gcHJvcHMuYmFyQ2xhc3NOYW1lLFxuICAgICAgY3NzTW9kdWxlID0gcHJvcHMuY3NzTW9kdWxlLFxuICAgICAgdmFsdWUgPSBwcm9wcy52YWx1ZSxcbiAgICAgIG1pbiA9IHByb3BzLm1pbixcbiAgICAgIG1heCA9IHByb3BzLm1heCxcbiAgICAgIGFuaW1hdGVkID0gcHJvcHMuYW5pbWF0ZWQsXG4gICAgICBzdHJpcGVkID0gcHJvcHMuc3RyaXBlZCxcbiAgICAgIGNvbG9yID0gcHJvcHMuY29sb3IsXG4gICAgICBiYXIgPSBwcm9wcy5iYXIsXG4gICAgICBtdWx0aSA9IHByb3BzLm11bHRpLFxuICAgICAgVGFnID0gcHJvcHMudGFnLFxuICAgICAgc3R5bGUgPSBwcm9wcy5zdHlsZSxcbiAgICAgIGJhclN0eWxlID0gcHJvcHMuYmFyU3R5bGUsXG4gICAgICBiYXJBcmlhVmFsdWVUZXh0ID0gcHJvcHMuYmFyQXJpYVZhbHVlVGV4dCxcbiAgICAgIGJhckFyaWFMYWJlbGxlZEJ5ID0gcHJvcHMuYmFyQXJpYUxhYmVsbGVkQnksXG4gICAgICBhdHRyaWJ1dGVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZCR3KTtcblxuICB2YXIgcGVyY2VudCA9IHRvTnVtYmVyKHZhbHVlKSAvIHRvTnVtYmVyKG1heCkgKiAxMDA7XG4gIHZhciBwcm9ncmVzc0NsYXNzZXMgPSBtYXBUb0Nzc01vZHVsZXMoY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oY2xhc3NOYW1lLCAncHJvZ3Jlc3MnKSwgY3NzTW9kdWxlKTtcbiAgdmFyIHByb2dyZXNzQmFyQ2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXSgncHJvZ3Jlc3MtYmFyJywgYmFyID8gY2xhc3NOYW1lIHx8IGJhckNsYXNzTmFtZSA6IGJhckNsYXNzTmFtZSwgYW5pbWF0ZWQgPyAncHJvZ3Jlc3MtYmFyLWFuaW1hdGVkJyA6IG51bGwsIGNvbG9yID8gXCJiZy1cIiArIGNvbG9yIDogbnVsbCwgc3RyaXBlZCB8fCBhbmltYXRlZCA/ICdwcm9ncmVzcy1iYXItc3RyaXBlZCcgOiBudWxsKSwgY3NzTW9kdWxlKTtcbiAgdmFyIHByb2dyZXNzQmFyUHJvcHMgPSB7XG4gICAgY2xhc3NOYW1lOiBwcm9ncmVzc0JhckNsYXNzZXMsXG4gICAgc3R5bGU6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBiYXIgPyBzdHlsZSA6IHt9KSwgYmFyU3R5bGUpLCB7fSwge1xuICAgICAgd2lkdGg6IHBlcmNlbnQgKyBcIiVcIlxuICAgIH0pLFxuICAgIHJvbGU6ICdwcm9ncmVzc2JhcicsXG4gICAgJ2FyaWEtdmFsdWVub3cnOiB2YWx1ZSxcbiAgICAnYXJpYS12YWx1ZW1pbic6IG1pbixcbiAgICAnYXJpYS12YWx1ZW1heCc6IG1heCxcbiAgICAnYXJpYS12YWx1ZXRleHQnOiBiYXJBcmlhVmFsdWVUZXh0LFxuICAgICdhcmlhLWxhYmVsbGVkYnknOiBiYXJBcmlhTGFiZWxsZWRCeSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgfTtcblxuICBpZiAoYmFyKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChUYWcsIF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCBwcm9ncmVzc0JhclByb3BzKSk7XG4gIH1cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIHtcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgY2xhc3NOYW1lOiBwcm9ncmVzc0NsYXNzZXNcbiAgfSksIG11bHRpID8gY2hpbGRyZW4gOiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgcHJvZ3Jlc3NCYXJQcm9wcykpO1xufVxuXG5Qcm9ncmVzcy5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkQjtcblByb2dyZXNzLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyRBO1xuXG52YXIgcHJvcFR5cGVzJEEgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm5vZGUuaXNSZXF1aXJlZCxcbiAgbm9kZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5hbnlcbn07XG5cbnZhciBQb3J0YWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoUG9ydGFsLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBQb3J0YWwoKSB7XG4gICAgcmV0dXJuIF9SZWFjdCRDb21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFBvcnRhbC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuZGVmYXVsdE5vZGUpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5kZWZhdWx0Tm9kZSk7XG4gICAgfVxuXG4gICAgdGhpcy5kZWZhdWx0Tm9kZSA9IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICBpZiAoIWNhblVzZURPTSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnByb3BzLm5vZGUgJiYgIXRoaXMuZGVmYXVsdE5vZGUpIHtcbiAgICAgIHRoaXMuZGVmYXVsdE5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5kZWZhdWx0Tm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0RE9NX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVQb3J0YWwodGhpcy5wcm9wcy5jaGlsZHJlbiwgdGhpcy5wcm9wcy5ub2RlIHx8IHRoaXMuZGVmYXVsdE5vZGUpO1xuICB9O1xuXG4gIHJldHVybiBQb3J0YWw7XG59KFJlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5Db21wb25lbnQpO1xuXG5Qb3J0YWwucHJvcFR5cGVzID0gcHJvcFR5cGVzJEE7XG52YXIgUG9ydGFsJDEgPSBQb3J0YWw7XG5cbmZ1bmN0aW9uIG5vb3AkMSgpIHt9XG5cbnZhciBGYWRlUHJvcFR5cGVzJDEgPSBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnNoYXBlKEZhZGUucHJvcFR5cGVzKTtcbnZhciBwcm9wVHlwZXMkeiA9IHtcbiAgLyoqICovXG4gIGF1dG9Gb2N1czogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuXG4gIC8qKiBBZGQgYmFja2Ryb3AgdG8gbW9kYWwgKi9cbiAgYmFja2Ryb3A6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2YoWydzdGF0aWMnXSldKSxcblxuICAvKiogYWRkIGN1c3RvbSBjbGFzc25hbWUgdG8gYmFja2Ryb3AgKi9cbiAgYmFja2Ryb3BDbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICBiYWNrZHJvcFRyYW5zaXRpb246IEZhZGVQcm9wVHlwZXMkMSxcblxuICAvKiogVmVydGljYWxseSBjZW50ZXIgdGhlIG1vZGFsICovXG4gIGNlbnRlcmVkOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG5cbiAgLyoqIEFkZCBjaGlsZHJlbiBmb3IgdGhlIG1vZGFsIHRvIHdyYXAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ubm9kZSxcblxuICAvKiogQWRkIGN1c3RvbSBjbGFzc05hbWUgZm9yIG1vZGFsIGNvbnRlbnQgKi9cbiAgY29udGVudENsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIGNvbnRhaW5lcjogdGFyZ2V0UHJvcFR5cGUsXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG4gIGV4dGVybmFsOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm5vZGUsXG5cbiAgLyoqIEVuYWJsZS9EaXNhYmxlIGFuaW1hdGlvbiAqL1xuICBmYWRlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG5cbiAgLyoqIE1ha2UgdGhlIG1vZGFsIGZ1bGxzY3JlZW4gKi9cbiAgZnVsbHNjcmVlbjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vbmVPZlR5cGUoW1Byb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCwgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vbmVPZihbJ3NtJywgJ21kJywgJ2xnJywgJ3hsJ10pXSksXG4gIGlubmVyUmVmOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9uZU9mVHlwZShbUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLCBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZ1bmNdKSxcblxuICAvKiogVGhlIHN0YXR1cyBvZiB0aGUgbW9kYWwsIGVpdGhlciBvcGVuIG9yIGNsb3NlICovXG4gIGlzT3BlbjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuXG4gIC8qKiBBbGxvdyBtb2RhbCB0byBiZSBjbG9zZWQgd2l0aCBlc2NhcGUga2V5LiAqL1xuICBrZXlib2FyZDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuXG4gIC8qKiBJZGVudGlmaWVzIHRoZSBlbGVtZW50IChvciBlbGVtZW50cykgdGhhdCBsYWJlbHMgdGhlIGN1cnJlbnQgZWxlbWVudC4gKi9cbiAgbGFiZWxsZWRCeTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIG1vZGFsQ2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgbW9kYWxUcmFuc2l0aW9uOiBGYWRlUHJvcFR5cGVzJDEsXG5cbiAgLyoqIEZ1bmN0aW9uIHRvIGJlIHRyaWdnZXJlZCBvbiBjbG9zZSAqL1xuICBvbkNsb3NlZDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5mdW5jLFxuXG4gIC8qKiBGdW5jdGlvbiB0byBiZSB0cmlnZ2VyZWQgb24gZW50ZXIgKi9cbiAgb25FbnRlcjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5mdW5jLFxuXG4gIC8qKiBGdW5jdGlvbiB0byBiZSB0cmlnZ2VyZWQgb24gZXhpdCAqL1xuICBvbkV4aXQ6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuYyxcblxuICAvKiogRnVuY3Rpb24gdG8gYmUgdHJpZ2dlcmVkIG9uIG9wZW4gKi9cbiAgb25PcGVuZWQ6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuYyxcblxuICAvKiogUmV0dXJucyBmb2N1cyB0byB0aGUgZWxlbWVudCB0aGF0IHRyaWdnZXJlZCBvcGVuaW5nIG9mIHRoZSBtb2RhbCAqL1xuICByZXR1cm5Gb2N1c0FmdGVyQ2xvc2U6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcblxuICAvKiogQWNjZXNzaWJpbGl0eSByb2xlICovXG4gIHJvbGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuXG4gIC8qKiBNYWtlIHRoZSBtb2RhbCBzY3JvbGxhYmxlICovXG4gIHNjcm9sbGFibGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcblxuICAvKiogVHdvIG9wdGlvbmFsIHNpemVzIGBsZ2AgYW5kIGBzbWAgKi9cbiAgc2l6ZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG5cbiAgLyoqIEZ1bmN0aW9uIHRvIHRvZ2dsZSBtb2RhbCB2aXNpYmlsaXR5ICovXG4gIHRvZ2dsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5mdW5jLFxuICB0cmFwRm9jdXM6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcblxuICAvKiogVW5tb3VudHMgdGhlIG1vZGFsIHdoZW4gbW9kYWwgaXMgY2xvc2VkICovXG4gIHVubW91bnRPbkNsb3NlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG4gIHdyYXBDbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICB6SW5kZXg6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm51bWJlciwgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmddKVxufTtcbnZhciBwcm9wc1RvT21pdCQxID0gT2JqZWN0LmtleXMocHJvcFR5cGVzJHopO1xudmFyIGRlZmF1bHRQcm9wcyR6ID0ge1xuICBpc09wZW46IGZhbHNlLFxuICBhdXRvRm9jdXM6IHRydWUsXG4gIGNlbnRlcmVkOiBmYWxzZSxcbiAgc2Nyb2xsYWJsZTogZmFsc2UsXG4gIHJvbGU6ICdkaWFsb2cnLFxuICBiYWNrZHJvcDogdHJ1ZSxcbiAga2V5Ym9hcmQ6IHRydWUsXG4gIHpJbmRleDogMTA1MCxcbiAgZmFkZTogdHJ1ZSxcbiAgb25PcGVuZWQ6IG5vb3AkMSxcbiAgb25DbG9zZWQ6IG5vb3AkMSxcbiAgbW9kYWxUcmFuc2l0aW9uOiB7XG4gICAgdGltZW91dDogVHJhbnNpdGlvblRpbWVvdXRzLk1vZGFsXG4gIH0sXG4gIGJhY2tkcm9wVHJhbnNpdGlvbjoge1xuICAgIG1vdW50T25FbnRlcjogdHJ1ZSxcbiAgICB0aW1lb3V0OiBUcmFuc2l0aW9uVGltZW91dHMuRmFkZSAvLyB1c2VzIHN0YW5kYXJkIGZhZGUgdHJhbnNpdGlvblxuXG4gIH0sXG4gIHVubW91bnRPbkNsb3NlOiB0cnVlLFxuICByZXR1cm5Gb2N1c0FmdGVyQ2xvc2U6IHRydWUsXG4gIGNvbnRhaW5lcjogJ2JvZHknLFxuICB0cmFwRm9jdXM6IGZhbHNlXG59O1xuXG52YXIgTW9kYWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoTW9kYWwsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIE1vZGFsKHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgIF90aGlzLl9vcmlnaW5hbEJvZHlQYWRkaW5nID0gbnVsbDtcbiAgICBfdGhpcy5nZXRGb2N1c2FibGVDaGlsZHJlbiA9IF90aGlzLmdldEZvY3VzYWJsZUNoaWxkcmVuLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmhhbmRsZUJhY2tkcm9wQ2xpY2sgPSBfdGhpcy5oYW5kbGVCYWNrZHJvcENsaWNrLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmhhbmRsZUJhY2tkcm9wTW91c2VEb3duID0gX3RoaXMuaGFuZGxlQmFja2Ryb3BNb3VzZURvd24uYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMuaGFuZGxlRXNjYXBlID0gX3RoaXMuaGFuZGxlRXNjYXBlLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmhhbmRsZVN0YXRpY0JhY2tkcm9wQW5pbWF0aW9uID0gX3RoaXMuaGFuZGxlU3RhdGljQmFja2Ryb3BBbmltYXRpb24uYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMuaGFuZGxlVGFiID0gX3RoaXMuaGFuZGxlVGFiLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLm9uT3BlbmVkID0gX3RoaXMub25PcGVuZWQuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMub25DbG9zZWQgPSBfdGhpcy5vbkNsb3NlZC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5tYW5hZ2VGb2N1c0FmdGVyQ2xvc2UgPSBfdGhpcy5tYW5hZ2VGb2N1c0FmdGVyQ2xvc2UuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMuY2xlYXJCYWNrZHJvcEFuaW1hdGlvblRpbWVvdXQgPSBfdGhpcy5jbGVhckJhY2tkcm9wQW5pbWF0aW9uVGltZW91dC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy50cmFwRm9jdXMgPSBfdGhpcy50cmFwRm9jdXMuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBpc09wZW46IGZhbHNlLFxuICAgICAgc2hvd1N0YXRpY0JhY2tkcm9wQW5pbWF0aW9uOiBmYWxzZVxuICAgIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE1vZGFsLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBpc09wZW4gPSBfdGhpcyRwcm9wcy5pc09wZW4sXG4gICAgICAgIGF1dG9Gb2N1cyA9IF90aGlzJHByb3BzLmF1dG9Gb2N1cyxcbiAgICAgICAgb25FbnRlciA9IF90aGlzJHByb3BzLm9uRW50ZXI7XG5cbiAgICBpZiAoaXNPcGVuKSB7XG4gICAgICB0aGlzLmluaXQoKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpc09wZW46IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoYXV0b0ZvY3VzKSB7XG4gICAgICAgIHRoaXMuc2V0Rm9jdXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob25FbnRlcikge1xuICAgICAgb25FbnRlcigpO1xuICAgIH0gLy8gdHJhcHMgZm9jdXMgaW5zaWRlIHRoZSBNb2RhbCwgZXZlbiBpZiB0aGUgYnJvd3NlciBhZGRyZXNzIGJhciBpcyBmb2N1c2VkXG5cblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy50cmFwRm9jdXMsIHRydWUpO1xuICAgIHRoaXMuX2lzTW91bnRlZCA9IHRydWU7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgIGlmICh0aGlzLnByb3BzLmlzT3BlbiAmJiAhcHJldlByb3BzLmlzT3Blbikge1xuICAgICAgdGhpcy5pbml0KCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaXNPcGVuOiB0cnVlXG4gICAgICB9KTsgLy8gbGV0IHJlbmRlcigpIHJlbmRlcnMgTW9kYWwgRGlhbG9nIGZpcnN0XG5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIG5vdyBNb2RhbCBEaWFsb2cgaXMgcmVuZGVyZWQgYW5kIHdlIGNhbiByZWZlciB0aGlzLl9lbGVtZW50IGFuZCB0aGlzLl9kaWFsb2dcblxuXG4gICAgaWYgKHRoaXMucHJvcHMuYXV0b0ZvY3VzICYmIHRoaXMuc3RhdGUuaXNPcGVuICYmICFwcmV2U3RhdGUuaXNPcGVuKSB7XG4gICAgICB0aGlzLnNldEZvY3VzKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2VsZW1lbnQgJiYgcHJldlByb3BzLnpJbmRleCAhPT0gdGhpcy5wcm9wcy56SW5kZXgpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuekluZGV4ID0gdGhpcy5wcm9wcy56SW5kZXg7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuY2xlYXJCYWNrZHJvcEFuaW1hdGlvblRpbWVvdXQoKTtcblxuICAgIGlmICh0aGlzLnByb3BzLm9uRXhpdCkge1xuICAgICAgdGhpcy5wcm9wcy5vbkV4aXQoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZWxlbWVudCkge1xuICAgICAgdGhpcy5kZXN0cm95KCk7XG5cbiAgICAgIGlmICh0aGlzLnByb3BzLmlzT3BlbiB8fCB0aGlzLnN0YXRlLmlzT3Blbikge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLnRyYXBGb2N1cywgdHJ1ZSk7XG4gICAgdGhpcy5faXNNb3VudGVkID0gZmFsc2U7XG4gIH0gLy8gbm90IG1vdXNlVXAgYmVjYXVzZSBzY3JvbGxiYXIgZmlyZXMgaXQsIHNob3VsZG4ndCBjbG9zZSB3aGVuIHVzZXIgc2Nyb2xsc1xuICA7XG5cbiAgX3Byb3RvLmhhbmRsZUJhY2tkcm9wQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVCYWNrZHJvcENsaWNrKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IHRoaXMuX21vdXNlRG93bkVsZW1lbnQpIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB2YXIgYmFja2Ryb3AgPSB0aGlzLl9kaWFsb2cgPyB0aGlzLl9kaWFsb2cucGFyZW50Tm9kZSA6IG51bGw7XG5cbiAgICAgIGlmIChiYWNrZHJvcCAmJiBlLnRhcmdldCA9PT0gYmFja2Ryb3AgJiYgdGhpcy5wcm9wcy5iYWNrZHJvcCA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTdGF0aWNCYWNrZHJvcEFuaW1hdGlvbigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMucHJvcHMuaXNPcGVuIHx8IHRoaXMucHJvcHMuYmFja2Ryb3AgIT09IHRydWUpIHJldHVybjtcblxuICAgICAgaWYgKGJhY2tkcm9wICYmIGUudGFyZ2V0ID09PSBiYWNrZHJvcCAmJiB0aGlzLnByb3BzLnRvZ2dsZSkge1xuICAgICAgICB0aGlzLnByb3BzLnRvZ2dsZShlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZVRhYiA9IGZ1bmN0aW9uIGhhbmRsZVRhYihlKSB7XG4gICAgaWYgKGUud2hpY2ggIT09IDkpIHJldHVybjtcbiAgICBpZiAodGhpcy5tb2RhbEluZGV4IDwgTW9kYWwub3BlbkNvdW50IC0gMSkgcmV0dXJuOyAvLyBsYXN0IG9wZW5lZCBtb2RhbFxuXG4gICAgdmFyIGZvY3VzYWJsZUNoaWxkcmVuID0gdGhpcy5nZXRGb2N1c2FibGVDaGlsZHJlbigpO1xuICAgIHZhciB0b3RhbEZvY3VzYWJsZSA9IGZvY3VzYWJsZUNoaWxkcmVuLmxlbmd0aDtcbiAgICBpZiAodG90YWxGb2N1c2FibGUgPT09IDApIHJldHVybjtcbiAgICB2YXIgY3VycmVudEZvY3VzID0gdGhpcy5nZXRGb2N1c2VkQ2hpbGQoKTtcbiAgICB2YXIgZm9jdXNlZEluZGV4ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWxGb2N1c2FibGU7IGkgKz0gMSkge1xuICAgICAgaWYgKGZvY3VzYWJsZUNoaWxkcmVuW2ldID09PSBjdXJyZW50Rm9jdXMpIHtcbiAgICAgICAgZm9jdXNlZEluZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGUuc2hpZnRLZXkgJiYgZm9jdXNlZEluZGV4ID09PSAwKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBmb2N1c2FibGVDaGlsZHJlblt0b3RhbEZvY3VzYWJsZSAtIDFdLmZvY3VzKCk7XG4gICAgfSBlbHNlIGlmICghZS5zaGlmdEtleSAmJiBmb2N1c2VkSW5kZXggPT09IHRvdGFsRm9jdXNhYmxlIC0gMSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZm9jdXNhYmxlQ2hpbGRyZW5bMF0uZm9jdXMoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZUJhY2tkcm9wTW91c2VEb3duID0gZnVuY3Rpb24gaGFuZGxlQmFja2Ryb3BNb3VzZURvd24oZSkge1xuICAgIHRoaXMuX21vdXNlRG93bkVsZW1lbnQgPSBlLnRhcmdldDtcbiAgfTtcblxuICBfcHJvdG8uaGFuZGxlRXNjYXBlID0gZnVuY3Rpb24gaGFuZGxlRXNjYXBlKGUpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5pc09wZW4gJiYgZS5rZXlDb2RlID09PSBrZXlDb2Rlcy5lc2MgJiYgdGhpcy5wcm9wcy50b2dnbGUpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLmtleWJvYXJkKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdGhpcy5wcm9wcy50b2dnbGUoZSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucHJvcHMuYmFja2Ryb3AgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdGhpcy5oYW5kbGVTdGF0aWNCYWNrZHJvcEFuaW1hdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uaGFuZGxlU3RhdGljQmFja2Ryb3BBbmltYXRpb24gPSBmdW5jdGlvbiBoYW5kbGVTdGF0aWNCYWNrZHJvcEFuaW1hdGlvbigpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHRoaXMuY2xlYXJCYWNrZHJvcEFuaW1hdGlvblRpbWVvdXQoKTtcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHNob3dTdGF0aWNCYWNrZHJvcEFuaW1hdGlvbjogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuX2JhY2tkcm9wQW5pbWF0aW9uVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMyLnNldFN0YXRlKHtcbiAgICAgICAgc2hvd1N0YXRpY0JhY2tkcm9wQW5pbWF0aW9uOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSwgMTAwKTtcbiAgfTtcblxuICBfcHJvdG8ub25PcGVuZWQgPSBmdW5jdGlvbiBvbk9wZW5lZChub2RlLCBpc0FwcGVhcmluZykge1xuICAgIHRoaXMucHJvcHMub25PcGVuZWQoKTtcbiAgICAodGhpcy5wcm9wcy5tb2RhbFRyYW5zaXRpb24ub25FbnRlcmVkIHx8IG5vb3AkMSkobm9kZSwgaXNBcHBlYXJpbmcpO1xuICB9O1xuXG4gIF9wcm90by5vbkNsb3NlZCA9IGZ1bmN0aW9uIG9uQ2xvc2VkKG5vZGUpIHtcbiAgICB2YXIgdW5tb3VudE9uQ2xvc2UgPSB0aGlzLnByb3BzLnVubW91bnRPbkNsb3NlOyAvLyBzbyBhbGwgbWV0aG9kcyBnZXQgY2FsbGVkIGJlZm9yZSBpdCBpcyB1bm1vdW50ZWRcblxuICAgIHRoaXMucHJvcHMub25DbG9zZWQoKTtcbiAgICAodGhpcy5wcm9wcy5tb2RhbFRyYW5zaXRpb24ub25FeGl0ZWQgfHwgbm9vcCQxKShub2RlKTtcblxuICAgIGlmICh1bm1vdW50T25DbG9zZSkge1xuICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbG9zZSgpO1xuXG4gICAgaWYgKHRoaXMuX2lzTW91bnRlZCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIGlzT3BlbjogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uc2V0Rm9jdXMgPSBmdW5jdGlvbiBzZXRGb2N1cygpIHtcbiAgICBpZiAodGhpcy5fZGlhbG9nICYmIHRoaXMuX2RpYWxvZy5wYXJlbnROb2RlICYmIHR5cGVvZiB0aGlzLl9kaWFsb2cucGFyZW50Tm9kZS5mb2N1cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fZGlhbG9nLnBhcmVudE5vZGUuZm9jdXMoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmdldEZvY3VzYWJsZUNoaWxkcmVuID0gZnVuY3Rpb24gZ2V0Rm9jdXNhYmxlQ2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQucXVlcnlTZWxlY3RvckFsbChmb2N1c2FibGVFbGVtZW50cy5qb2luKCcsICcpKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0Rm9jdXNlZENoaWxkID0gZnVuY3Rpb24gZ2V0Rm9jdXNlZENoaWxkKCkge1xuICAgIHZhciBjdXJyZW50Rm9jdXM7XG4gICAgdmFyIGZvY3VzYWJsZUNoaWxkcmVuID0gdGhpcy5nZXRGb2N1c2FibGVDaGlsZHJlbigpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGN1cnJlbnRGb2N1cyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjdXJyZW50Rm9jdXMgPSBmb2N1c2FibGVDaGlsZHJlblswXTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VycmVudEZvY3VzO1xuICB9O1xuXG4gIF9wcm90by50cmFwRm9jdXMgPSBmdW5jdGlvbiB0cmFwRm9jdXMoZXYpIHtcbiAgICBpZiAoIXRoaXMucHJvcHMudHJhcEZvY3VzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9lbGVtZW50KSB7XG4gICAgICAvLyBlbGVtZW50IGlzIG5vdCBhdHRhY2hlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kaWFsb2cgJiYgdGhpcy5fZGlhbG9nLnBhcmVudE5vZGUgPT09IGV2LnRhcmdldCkge1xuICAgICAgLy8gaW5pdGlhbCBmb2N1cyB3aGVuIHRoZSBNb2RhbCBpcyBvcGVuZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tb2RhbEluZGV4IDwgTW9kYWwub3BlbkNvdW50IC0gMSkge1xuICAgICAgLy8gbGFzdCBvcGVuZWQgbW9kYWxcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmdldEZvY3VzYWJsZUNoaWxkcmVuKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAvLyBmb2N1cyBpcyBhbHJlYWR5IGluc2lkZSB0aGUgTW9kYWxcbiAgICAgIGlmIChjaGlsZHJlbltpXSA9PT0gZXYudGFyZ2V0KSByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIG90aGVyd2lzZSBmb2N1cyB0aGUgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQgaW4gdGhlIE1vZGFsXG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBjaGlsZHJlblswXS5mb2N1cygpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX3RyaWdnZXJpbmdFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuX3RyaWdnZXJpbmdFbGVtZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2VsZW1lbnQpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS56SW5kZXggPSB0aGlzLnByb3BzLnpJbmRleDtcbiAgICAgIHRoaXMuX21vdW50Q29udGFpbmVyID0gZ2V0VGFyZ2V0KHRoaXMucHJvcHMuY29udGFpbmVyKTtcblxuICAgICAgdGhpcy5fbW91bnRDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fZWxlbWVudCk7XG4gICAgfVxuXG4gICAgdGhpcy5fb3JpZ2luYWxCb2R5UGFkZGluZyA9IGdldE9yaWdpbmFsQm9keVBhZGRpbmcoKTtcblxuICAgIGlmIChNb2RhbC5vcGVuQ291bnQgPCAxKSB7XG4gICAgICBNb2RhbC5vcmlnaW5hbEJvZHlPdmVyZmxvdyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHkpLm92ZXJmbG93O1xuICAgIH1cbiAgICBjb25kaXRpb25hbGx5VXBkYXRlU2Nyb2xsYmFyKCk7XG5cbiAgICBpZiAoTW9kYWwub3BlbkNvdW50ID09PSAwKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTmFtZSA9IGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGRvY3VtZW50LmJvZHkuY2xhc3NOYW1lLCBtYXBUb0Nzc01vZHVsZXMoJ21vZGFsLW9wZW4nLCB0aGlzLnByb3BzLmNzc01vZHVsZSkpO1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgIH1cblxuICAgIHRoaXMubW9kYWxJbmRleCA9IE1vZGFsLm9wZW5Db3VudDtcbiAgICBNb2RhbC5vcGVuQ291bnQgKz0gMTtcbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQpIHtcbiAgICAgIHRoaXMuX21vdW50Q29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuX2VsZW1lbnQpO1xuXG4gICAgICB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLm1hbmFnZUZvY3VzQWZ0ZXJDbG9zZSgpO1xuICB9O1xuXG4gIF9wcm90by5tYW5hZ2VGb2N1c0FmdGVyQ2xvc2UgPSBmdW5jdGlvbiBtYW5hZ2VGb2N1c0FmdGVyQ2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuX3RyaWdnZXJpbmdFbGVtZW50KSB7XG4gICAgICB2YXIgcmV0dXJuRm9jdXNBZnRlckNsb3NlID0gdGhpcy5wcm9wcy5yZXR1cm5Gb2N1c0FmdGVyQ2xvc2U7XG4gICAgICBpZiAodGhpcy5fdHJpZ2dlcmluZ0VsZW1lbnQuZm9jdXMgJiYgcmV0dXJuRm9jdXNBZnRlckNsb3NlKSB0aGlzLl90cmlnZ2VyaW5nRWxlbWVudC5mb2N1cygpO1xuICAgICAgdGhpcy5fdHJpZ2dlcmluZ0VsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY2xvc2UgPSBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBpZiAoTW9kYWwub3BlbkNvdW50IDw9IDEpIHtcbiAgICAgIHZhciBtb2RhbE9wZW5DbGFzc05hbWUgPSBtYXBUb0Nzc01vZHVsZXMoJ21vZGFsLW9wZW4nLCB0aGlzLnByb3BzLmNzc01vZHVsZSk7IC8vIFVzZSByZWdleCB0byBwcmV2ZW50IG1hdGNoaW5nIGBtb2RhbC1vcGVuYCBhcyBwYXJ0IG9mIGEgZGlmZmVyZW50IGNsYXNzLCBlLmcuIGBteS1tb2RhbC1vcGVuZWRgXG5cbiAgICAgIHZhciBtb2RhbE9wZW5DbGFzc05hbWVSZWdleCA9IG5ldyBSZWdFeHAoXCIoXnwgKVwiICsgbW9kYWxPcGVuQ2xhc3NOYW1lICsgXCIoIHwkKVwiKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NOYW1lID0gZG9jdW1lbnQuYm9keS5jbGFzc05hbWUucmVwbGFjZShtb2RhbE9wZW5DbGFzc05hbWVSZWdleCwgJyAnKS50cmltKCk7XG4gICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gTW9kYWwub3JpZ2luYWxCb2R5T3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgdGhpcy5tYW5hZ2VGb2N1c0FmdGVyQ2xvc2UoKTtcbiAgICBNb2RhbC5vcGVuQ291bnQgPSBNYXRoLm1heCgwLCBNb2RhbC5vcGVuQ291bnQgLSAxKTtcbiAgICBzZXRTY3JvbGxiYXJXaWR0aCh0aGlzLl9vcmlnaW5hbEJvZHlQYWRkaW5nKTtcbiAgfTtcblxuICBfcHJvdG8uY2xlYXJCYWNrZHJvcEFuaW1hdGlvblRpbWVvdXQgPSBmdW5jdGlvbiBjbGVhckJhY2tkcm9wQW5pbWF0aW9uVGltZW91dCgpIHtcbiAgICBpZiAodGhpcy5fYmFja2Ryb3BBbmltYXRpb25UaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fYmFja2Ryb3BBbmltYXRpb25UaW1lb3V0KTtcbiAgICAgIHRoaXMuX2JhY2tkcm9wQW5pbWF0aW9uVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlck1vZGFsRGlhbG9nID0gZnVuY3Rpb24gcmVuZGVyTW9kYWxEaWFsb2coKSB7XG4gICAgdmFyIF9jbGFzc05hbWVzLFxuICAgICAgICBfdGhpczMgPSB0aGlzO1xuXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBvbWl0KHRoaXMucHJvcHMsIHByb3BzVG9PbWl0JDEpO1xuICAgIHZhciBkaWFsb2dCYXNlQ2xhc3MgPSAnbW9kYWwtZGlhbG9nJztcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgICBjbGFzc05hbWU6IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShkaWFsb2dCYXNlQ2xhc3MsIHRoaXMucHJvcHMuY2xhc3NOYW1lLCAoX2NsYXNzTmFtZXMgPSB7fSwgX2NsYXNzTmFtZXNbXCJtb2RhbC1cIiArIHRoaXMucHJvcHMuc2l6ZV0gPSB0aGlzLnByb3BzLnNpemUsIF9jbGFzc05hbWVzW2RpYWxvZ0Jhc2VDbGFzcyArIFwiLWNlbnRlcmVkXCJdID0gdGhpcy5wcm9wcy5jZW50ZXJlZCwgX2NsYXNzTmFtZXNbZGlhbG9nQmFzZUNsYXNzICsgXCItc2Nyb2xsYWJsZVwiXSA9IHRoaXMucHJvcHMuc2Nyb2xsYWJsZSwgX2NsYXNzTmFtZXNbJ21vZGFsLWZ1bGxzY3JlZW4nXSA9IHRoaXMucHJvcHMuZnVsbHNjcmVlbiA9PT0gdHJ1ZSwgX2NsYXNzTmFtZXNbXCJtb2RhbC1mdWxsc2NyZWVuLVwiICsgdGhpcy5wcm9wcy5mdWxsc2NyZWVuICsgXCItZG93blwiXSA9IHR5cGVvZiB0aGlzLnByb3BzLmZ1bGxzY3JlZW4gPT09ICdzdHJpbmcnLCBfY2xhc3NOYW1lcykpLCB0aGlzLnByb3BzLmNzc01vZHVsZSksXG4gICAgICByb2xlOiBcImRvY3VtZW50XCIsXG4gICAgICByZWY6IGZ1bmN0aW9uIHJlZihjKSB7XG4gICAgICAgIF90aGlzMy5fZGlhbG9nID0gYztcbiAgICAgIH1cbiAgICB9KSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKCdtb2RhbC1jb250ZW50JywgdGhpcy5wcm9wcy5jb250ZW50Q2xhc3NOYW1lKSwgdGhpcy5wcm9wcy5jc3NNb2R1bGUpXG4gICAgfSwgdGhpcy5wcm9wcy5jaGlsZHJlbikpO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHVubW91bnRPbkNsb3NlID0gdGhpcy5wcm9wcy51bm1vdW50T25DbG9zZTtcblxuICAgIGlmICghIXRoaXMuX2VsZW1lbnQgJiYgKHRoaXMuc3RhdGUuaXNPcGVuIHx8ICF1bm1vdW50T25DbG9zZSkpIHtcbiAgICAgIHZhciBpc01vZGFsSGlkZGVuID0gISF0aGlzLl9lbGVtZW50ICYmICF0aGlzLnN0YXRlLmlzT3BlbiAmJiAhdW5tb3VudE9uQ2xvc2U7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBpc01vZGFsSGlkZGVuID8gJ25vbmUnIDogJ2Jsb2NrJztcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIHdyYXBDbGFzc05hbWUgPSBfdGhpcyRwcm9wczIud3JhcENsYXNzTmFtZSxcbiAgICAgICAgICBtb2RhbENsYXNzTmFtZSA9IF90aGlzJHByb3BzMi5tb2RhbENsYXNzTmFtZSxcbiAgICAgICAgICBiYWNrZHJvcENsYXNzTmFtZSA9IF90aGlzJHByb3BzMi5iYWNrZHJvcENsYXNzTmFtZSxcbiAgICAgICAgICBjc3NNb2R1bGUgPSBfdGhpcyRwcm9wczIuY3NzTW9kdWxlLFxuICAgICAgICAgIGlzT3BlbiA9IF90aGlzJHByb3BzMi5pc09wZW4sXG4gICAgICAgICAgYmFja2Ryb3AgPSBfdGhpcyRwcm9wczIuYmFja2Ryb3AsXG4gICAgICAgICAgcm9sZSA9IF90aGlzJHByb3BzMi5yb2xlLFxuICAgICAgICAgIGxhYmVsbGVkQnkgPSBfdGhpcyRwcm9wczIubGFiZWxsZWRCeSxcbiAgICAgICAgICBleHRlcm5hbCA9IF90aGlzJHByb3BzMi5leHRlcm5hbCxcbiAgICAgICAgICBpbm5lclJlZiA9IF90aGlzJHByb3BzMi5pbm5lclJlZjtcbiAgICAgIHZhciBtb2RhbEF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIG9uQ2xpY2s6IHRoaXMuaGFuZGxlQmFja2Ryb3BDbGljayxcbiAgICAgICAgb25Nb3VzZURvd246IHRoaXMuaGFuZGxlQmFja2Ryb3BNb3VzZURvd24sXG4gICAgICAgIG9uS2V5VXA6IHRoaXMuaGFuZGxlRXNjYXBlLFxuICAgICAgICBvbktleURvd246IHRoaXMuaGFuZGxlVGFiLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgICAgfSxcbiAgICAgICAgJ2FyaWEtbGFiZWxsZWRieSc6IGxhYmVsbGVkQnksXG4gICAgICAgIHJvbGU6IHJvbGUsXG4gICAgICAgIHRhYkluZGV4OiAnLTEnXG4gICAgICB9O1xuICAgICAgdmFyIGhhc1RyYW5zaXRpb24gPSB0aGlzLnByb3BzLmZhZGU7XG5cbiAgICAgIHZhciBtb2RhbFRyYW5zaXRpb24gPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgRmFkZS5kZWZhdWx0UHJvcHMpLCB0aGlzLnByb3BzLm1vZGFsVHJhbnNpdGlvbiksIHt9LCB7XG4gICAgICAgIGJhc2VDbGFzczogaGFzVHJhbnNpdGlvbiA/IHRoaXMucHJvcHMubW9kYWxUcmFuc2l0aW9uLmJhc2VDbGFzcyA6ICcnLFxuICAgICAgICB0aW1lb3V0OiBoYXNUcmFuc2l0aW9uID8gdGhpcy5wcm9wcy5tb2RhbFRyYW5zaXRpb24udGltZW91dCA6IDBcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgYmFja2Ryb3BUcmFuc2l0aW9uID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIEZhZGUuZGVmYXVsdFByb3BzKSwgdGhpcy5wcm9wcy5iYWNrZHJvcFRyYW5zaXRpb24pLCB7fSwge1xuICAgICAgICBiYXNlQ2xhc3M6IGhhc1RyYW5zaXRpb24gPyB0aGlzLnByb3BzLmJhY2tkcm9wVHJhbnNpdGlvbi5iYXNlQ2xhc3MgOiAnJyxcbiAgICAgICAgdGltZW91dDogaGFzVHJhbnNpdGlvbiA/IHRoaXMucHJvcHMuYmFja2Ryb3BUcmFuc2l0aW9uLnRpbWVvdXQgOiAwXG4gICAgICB9KTtcblxuICAgICAgdmFyIEJhY2tkcm9wID0gYmFja2Ryb3AgJiYgKGhhc1RyYW5zaXRpb24gPyAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoRmFkZSwgX2V4dGVuZHMoe30sIGJhY2tkcm9wVHJhbnNpdGlvbiwge1xuICAgICAgICBcImluXCI6IGlzT3BlbiAmJiAhIWJhY2tkcm9wLFxuICAgICAgICBjc3NNb2R1bGU6IGNzc01vZHVsZSxcbiAgICAgICAgY2xhc3NOYW1lOiBtYXBUb0Nzc01vZHVsZXMoY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oJ21vZGFsLWJhY2tkcm9wJywgYmFja2Ryb3BDbGFzc05hbWUpLCBjc3NNb2R1bGUpXG4gICAgICB9KSkgOiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBjbGFzc05hbWU6IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXSgnbW9kYWwtYmFja2Ryb3AnLCAnc2hvdycsIGJhY2tkcm9wQ2xhc3NOYW1lKSwgY3NzTW9kdWxlKVxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChQb3J0YWwkMSwge1xuICAgICAgICBub2RlOiB0aGlzLl9lbGVtZW50XG4gICAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBjbGFzc05hbWU6IG1hcFRvQ3NzTW9kdWxlcyh3cmFwQ2xhc3NOYW1lKVxuICAgICAgfSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KEZhZGUsIF9leHRlbmRzKHt9LCBtb2RhbEF0dHJpYnV0ZXMsIG1vZGFsVHJhbnNpdGlvbiwge1xuICAgICAgICBcImluXCI6IGlzT3BlbixcbiAgICAgICAgb25FbnRlcmVkOiB0aGlzLm9uT3BlbmVkLFxuICAgICAgICBvbkV4aXRlZDogdGhpcy5vbkNsb3NlZCxcbiAgICAgICAgY3NzTW9kdWxlOiBjc3NNb2R1bGUsXG4gICAgICAgIGNsYXNzTmFtZTogbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKCdtb2RhbCcsIG1vZGFsQ2xhc3NOYW1lLCB0aGlzLnN0YXRlLnNob3dTdGF0aWNCYWNrZHJvcEFuaW1hdGlvbiAmJiAnbW9kYWwtc3RhdGljJyksIGNzc01vZHVsZSksXG4gICAgICAgIGlubmVyUmVmOiBpbm5lclJlZlxuICAgICAgfSksIGV4dGVybmFsLCB0aGlzLnJlbmRlck1vZGFsRGlhbG9nKCkpLCBCYWNrZHJvcCkpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBNb2RhbDtcbn0oUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLkNvbXBvbmVudCk7XG5cbk1vZGFsLnByb3BUeXBlcyA9IHByb3BUeXBlcyR6O1xuTW9kYWwuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJHo7XG5Nb2RhbC5vcGVuQ291bnQgPSAwO1xuTW9kYWwub3JpZ2luYWxCb2R5T3ZlcmZsb3cgPSBudWxsO1xudmFyIE1vZGFsJDEgPSBNb2RhbDtcblxudmFyIF9leGNsdWRlZCR2ID0gW1wiY2xhc3NOYW1lXCIsIFwiY3NzTW9kdWxlXCIsIFwiY2hpbGRyZW5cIiwgXCJ0b2dnbGVcIiwgXCJ0YWdcIiwgXCJ3cmFwVGFnXCIsIFwiY2xvc2VBcmlhTGFiZWxcIiwgXCJjbG9zZVwiXTtcbnZhciBwcm9wVHlwZXMkeSA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ubm9kZSxcblxuICAvKiogQWRkIGN1c3RvbSBjbGFzcyAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuXG4gIC8qKiBDdXN0b20gY2xvc2UgYnV0dG9uICovXG4gIGNsb3NlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCxcbiAgY2xvc2VBcmlhTGFiZWw6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuXG4gIC8qKiBDaGFuZ2UgdW5kZXJseWluZyBjb21wb25lbnQncyBDU1MgYmFzZSBjbGFzcyBuYW1lICovXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG5cbiAgLyoqIFNldCBhIGN1c3RvbSBlbGVtZW50IGZvciB0aGlzIGNvbXBvbmVudCAqL1xuICB0YWc6IHRhZ1Byb3BUeXBlLFxuXG4gIC8qKiBGdW5jdGlvbiB0byBiZSB0cmlnZ2VyZWQgd2hlbiBjbG9zZSBidXR0b24gaXMgY2xpY2tlZCAqL1xuICB0b2dnbGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuYyxcbiAgd3JhcFRhZzogdGFnUHJvcFR5cGVcbn07XG52YXIgZGVmYXVsdFByb3BzJHkgPSB7XG4gIHRhZzogJ2g1JyxcbiAgd3JhcFRhZzogJ2RpdicsXG4gIGNsb3NlQXJpYUxhYmVsOiAnQ2xvc2UnXG59O1xuXG5mdW5jdGlvbiBNb2RhbEhlYWRlcihwcm9wcykge1xuICB2YXIgY2xvc2VCdXR0b247XG5cbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNzc01vZHVsZSA9IHByb3BzLmNzc01vZHVsZSxcbiAgICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICB0b2dnbGUgPSBwcm9wcy50b2dnbGUsXG4gICAgICBUYWcgPSBwcm9wcy50YWcsXG4gICAgICBXcmFwVGFnID0gcHJvcHMud3JhcFRhZyxcbiAgICAgIGNsb3NlQXJpYUxhYmVsID0gcHJvcHMuY2xvc2VBcmlhTGFiZWwsXG4gICAgICBjbG9zZSA9IHByb3BzLmNsb3NlLFxuICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQkdik7XG5cbiAgdmFyIGNsYXNzZXMgPSBtYXBUb0Nzc01vZHVsZXMoY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oY2xhc3NOYW1lLCAnbW9kYWwtaGVhZGVyJyksIGNzc01vZHVsZSk7XG5cbiAgaWYgKCFjbG9zZSAmJiB0b2dnbGUpIHtcbiAgICBjbG9zZUJ1dHRvbiA9IC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7XG4gICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgb25DbGljazogdG9nZ2xlLFxuICAgICAgY2xhc3NOYW1lOiBtYXBUb0Nzc01vZHVsZXMoJ2J0bi1jbG9zZScsIGNzc01vZHVsZSksXG4gICAgICBcImFyaWEtbGFiZWxcIjogY2xvc2VBcmlhTGFiZWxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoV3JhcFRhZywgX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzZXNcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChUYWcsIHtcbiAgICBjbGFzc05hbWU6IG1hcFRvQ3NzTW9kdWxlcygnbW9kYWwtdGl0bGUnLCBjc3NNb2R1bGUpXG4gIH0sIGNoaWxkcmVuKSwgY2xvc2UgfHwgY2xvc2VCdXR0b24pO1xufVxuXG5Nb2RhbEhlYWRlci5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkeTtcbk1vZGFsSGVhZGVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyR5O1xuXG52YXIgX2V4Y2x1ZGVkJHUgPSBbXCJjbGFzc05hbWVcIiwgXCJjc3NNb2R1bGVcIiwgXCJ0YWdcIl07XG52YXIgcHJvcFR5cGVzJHggPSB7XG4gIC8qKiBBZGQgY3VzdG9tIGNsYXNzICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG5cbiAgLyoqIENoYW5nZSB1bmRlcmx5aW5nIGNvbXBvbmVudCdzIENTUyBiYXNlIGNsYXNzIG5hbWUgKi9cbiAgY3NzTW9kdWxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCxcblxuICAvKiogU2V0IGEgY3VzdG9tIGVsZW1lbnQgZm9yIHRoaXMgY29tcG9uZW50ICovXG4gIHRhZzogdGFnUHJvcFR5cGVcbn07XG52YXIgZGVmYXVsdFByb3BzJHggPSB7XG4gIHRhZzogJ2Rpdidcbn07XG5cbmZ1bmN0aW9uIE1vZGFsQm9keShwcm9wcykge1xuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY3NzTW9kdWxlID0gcHJvcHMuY3NzTW9kdWxlLFxuICAgICAgVGFnID0gcHJvcHMudGFnLFxuICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQkdSk7XG5cbiAgdmFyIGNsYXNzZXMgPSBtYXBUb0Nzc01vZHVsZXMoY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oY2xhc3NOYW1lLCAnbW9kYWwtYm9keScpLCBjc3NNb2R1bGUpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzZXNcbiAgfSkpO1xufVxuXG5Nb2RhbEJvZHkucHJvcFR5cGVzID0gcHJvcFR5cGVzJHg7XG5Nb2RhbEJvZHkuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJHg7XG5cbnZhciBfZXhjbHVkZWQkdCA9IFtcImNsYXNzTmFtZVwiLCBcImNzc01vZHVsZVwiLCBcInRhZ1wiXTtcbnZhciBwcm9wVHlwZXMkdyA9IHtcbiAgLyoqIEFkZCBjdXN0b20gY2xhc3MgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcblxuICAvKiogQ2hhbmdlIHVuZGVybHlpbmcgY29tcG9uZW50J3MgQ1NTIGJhc2UgY2xhc3MgbmFtZSAqL1xuICBjc3NNb2R1bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LFxuXG4gIC8qKiBTZXQgYSBjdXN0b20gZWxlbWVudCBmb3IgdGhpcyBjb21wb25lbnQgKi9cbiAgdGFnOiB0YWdQcm9wVHlwZVxufTtcbnZhciBkZWZhdWx0UHJvcHMkdyA9IHtcbiAgdGFnOiAnZGl2J1xufTtcblxuZnVuY3Rpb24gTW9kYWxGb290ZXIocHJvcHMpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNzc01vZHVsZSA9IHByb3BzLmNzc01vZHVsZSxcbiAgICAgIFRhZyA9IHByb3BzLnRhZyxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkJHQpO1xuXG4gIHZhciBjbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGNsYXNzTmFtZSwgJ21vZGFsLWZvb3RlcicpLCBjc3NNb2R1bGUpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzZXNcbiAgfSkpO1xufVxuXG5Nb2RhbEZvb3Rlci5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkdztcbk1vZGFsRm9vdGVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyR3O1xuXG52YXIgZGVmYXVsdFByb3BzJHYgPSB7XG4gIHBsYWNlbWVudDogJ3RvcCcsXG4gIGF1dG9oaWRlOiB0cnVlLFxuICBwbGFjZW1lbnRQcmVmaXg6ICdicy10b29sdGlwJyxcbiAgdHJpZ2dlcjogJ2hvdmVyIGZvY3VzJ1xufTtcblxuZnVuY3Rpb24gVG9vbHRpcChwcm9wcykge1xuICB2YXIgcG9wcGVyQ2xhc3NlcyA9IGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKCd0b29sdGlwJywgJ3Nob3cnLCBwcm9wcy5wb3BwZXJDbGFzc05hbWUpO1xuICB2YXIgY2xhc3NlcyA9IGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKCd0b29sdGlwLWlubmVyJywgcHJvcHMuaW5uZXJDbGFzc05hbWUpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFRvb2x0aXBQb3BvdmVyV3JhcHBlciQxLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBhcnJvd0NsYXNzTmFtZTogXCJ0b29sdGlwLWFycm93XCIsXG4gICAgcG9wcGVyQ2xhc3NOYW1lOiBwb3BwZXJDbGFzc2VzLFxuICAgIGlubmVyQ2xhc3NOYW1lOiBjbGFzc2VzXG4gIH0pKTtcbn1cblxuVG9vbHRpcC5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkRTtcblRvb2x0aXAuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJHY7XG5cbnZhciBfZXhjbHVkZWQkcyA9IFtcImNsYXNzTmFtZVwiLCBcImNzc01vZHVsZVwiLCBcInNpemVcIiwgXCJib3JkZXJlZFwiLCBcImJvcmRlcmxlc3NcIiwgXCJzdHJpcGVkXCIsIFwiZGFya1wiLCBcImhvdmVyXCIsIFwicmVzcG9uc2l2ZVwiLCBcInRhZ1wiLCBcInJlc3BvbnNpdmVUYWdcIiwgXCJpbm5lclJlZlwiXTtcbnZhciBwcm9wVHlwZXMkdiA9IHtcbiAgLyoqIEFkZHMgYm9yZGVyIHRvIGFsbCBzaWRlcyBvZiB0YWJsZSAqL1xuICBib3JkZXJlZDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuXG4gIC8qKiBSZW1vdmVzIGFsbCBib3JkZXJzICovXG4gIGJvcmRlcmxlc3M6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcblxuICAvKiogQWRkcyBjdXN0b20gY2xhc3MgbmFtZSB0byBjb21wb25lbnQgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcblxuICAvKiogICovXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG5cbiAgLyoqIE1ha2VzIHRoZSB0YWJsZSBkYXJrICovXG4gIGRhcms6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcblxuICAvKiogRW5hYmxlcyBhIGhvdmVyIHN0YXRlIG9uIHRoZSByb3dzIHdpdGhpbiBgPHRib2R5PmAgKi9cbiAgaG92ZXI6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcbiAgaW5uZXJSZWY6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZ1bmMsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLCBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdF0pLFxuXG4gIC8qKiBSZXNwb25zaXZlIHRhYmxlcyBhbGxvdyB0YWJsZXMgdG8gYmUgc2Nyb2xsZWQgaG9yaXpvbnRhbGx5IHdpdGggZWFzZSAqL1xuICByZXNwb25zaXZlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9uZU9mVHlwZShbUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLCBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZ10pLFxuICByZXNwb25zaXZlVGFnOiB0YWdQcm9wVHlwZSxcblxuICAvKiogTWFrZSB0YWJsZXMgbW9yZSBjb21wYWN0IGJ5IGN1dHRpbmcgY2VsbCBwYWRkaW5nIGluIGhhbGYgd2hlbiBzZXR0aW5nIHNpemUgYXMgc20uICovXG4gIHNpemU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuXG4gIC8qKiBBZGRzIHplYnJhLXN0cmlwaW5nIHRvIGFueSB0YWJsZSByb3cgd2l0aGluIHRoZSBgPHRib2R5PmAgKi9cbiAgc3RyaXBlZDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuXG4gIC8qKiBBZGQgY3VzdG9tIHRhZyB0byB0aGUgY29tcG9uZW50ICovXG4gIHRhZzogdGFnUHJvcFR5cGVcbn07XG52YXIgZGVmYXVsdFByb3BzJHUgPSB7XG4gIHRhZzogJ3RhYmxlJyxcbiAgcmVzcG9uc2l2ZVRhZzogJ2Rpdidcbn07XG5cbmZ1bmN0aW9uIFRhYmxlKHByb3BzKSB7XG4gIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjc3NNb2R1bGUgPSBwcm9wcy5jc3NNb2R1bGUsXG4gICAgICBzaXplID0gcHJvcHMuc2l6ZSxcbiAgICAgIGJvcmRlcmVkID0gcHJvcHMuYm9yZGVyZWQsXG4gICAgICBib3JkZXJsZXNzID0gcHJvcHMuYm9yZGVybGVzcyxcbiAgICAgIHN0cmlwZWQgPSBwcm9wcy5zdHJpcGVkLFxuICAgICAgZGFyayA9IHByb3BzLmRhcmssXG4gICAgICBob3ZlciA9IHByb3BzLmhvdmVyLFxuICAgICAgcmVzcG9uc2l2ZSA9IHByb3BzLnJlc3BvbnNpdmUsXG4gICAgICBUYWcgPSBwcm9wcy50YWcsXG4gICAgICBSZXNwb25zaXZlVGFnID0gcHJvcHMucmVzcG9uc2l2ZVRhZyxcbiAgICAgIGlubmVyUmVmID0gcHJvcHMuaW5uZXJSZWYsXG4gICAgICBhdHRyaWJ1dGVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZCRzKTtcblxuICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjbGFzc05hbWUsICd0YWJsZScsIHNpemUgPyAndGFibGUtJyArIHNpemUgOiBmYWxzZSwgYm9yZGVyZWQgPyAndGFibGUtYm9yZGVyZWQnIDogZmFsc2UsIGJvcmRlcmxlc3MgPyAndGFibGUtYm9yZGVybGVzcycgOiBmYWxzZSwgc3RyaXBlZCA/ICd0YWJsZS1zdHJpcGVkJyA6IGZhbHNlLCBkYXJrID8gJ3RhYmxlLWRhcmsnIDogZmFsc2UsIGhvdmVyID8gJ3RhYmxlLWhvdmVyJyA6IGZhbHNlKSwgY3NzTW9kdWxlKTtcbiAgdmFyIHRhYmxlID0gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIHtcbiAgICByZWY6IGlubmVyUmVmLFxuICAgIGNsYXNzTmFtZTogY2xhc3Nlc1xuICB9KSk7XG5cbiAgaWYgKHJlc3BvbnNpdmUpIHtcbiAgICB2YXIgcmVzcG9uc2l2ZUNsYXNzTmFtZSA9IG1hcFRvQ3NzTW9kdWxlcyhyZXNwb25zaXZlID09PSB0cnVlID8gJ3RhYmxlLXJlc3BvbnNpdmUnIDogXCJ0YWJsZS1yZXNwb25zaXZlLVwiICsgcmVzcG9uc2l2ZSwgY3NzTW9kdWxlKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFJlc3BvbnNpdmVUYWcsIHtcbiAgICAgIGNsYXNzTmFtZTogcmVzcG9uc2l2ZUNsYXNzTmFtZVxuICAgIH0sIHRhYmxlKTtcbiAgfVxuXG4gIHJldHVybiB0YWJsZTtcbn1cblxuVGFibGUucHJvcFR5cGVzID0gcHJvcFR5cGVzJHY7XG5UYWJsZS5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHMkdTtcblxudmFyIF9leGNsdWRlZCRyID0gW1wiY2xhc3NOYW1lXCIsIFwiY3NzTW9kdWxlXCIsIFwidGFnXCIsIFwiZmx1c2hcIiwgXCJob3Jpem9udGFsXCIsIFwibnVtYmVyZWRcIl07XG52YXIgcHJvcFR5cGVzJHUgPSB7XG4gIC8qKiBBZGQgY3VzdG9tIGNsYXNzICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG5cbiAgLyoqIENoYW5nZSB1bmRlcmx5aW5nIGNvbXBvbmVudCdzIENTUyBiYXNlIGNsYXNzIG5hbWUgKi9cbiAgY3NzTW9kdWxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCxcblxuICAvKiogUmVtb3ZlIGJvcmRlcnMgdG8gbWFrZSB0aGUgbGlzdCBhcHBlYXIgZmx1c2ggKi9cbiAgZmx1c2g6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcblxuICAvKiogTWFrZSB0aGUgbGlzdCBob3Jpem9udGFsIGluc3RlYWQgb2YgdmVydGljYWwgKi9cbiAgaG9yaXpvbnRhbDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vbmVPZlR5cGUoW1Byb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCwgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmddKSxcblxuICAvKiogQWRkIG51bWJlciB0byB0aGUgTGlzdEl0ZW1zICovXG4gIG51bWJlcmVkOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG5cbiAgLyoqIFNldCBhIGN1c3RvbSBlbGVtZW50IGZvciB0aGlzIGNvbXBvbmVudCAqL1xuICB0YWc6IHRhZ1Byb3BUeXBlXG59O1xudmFyIGRlZmF1bHRQcm9wcyR0ID0ge1xuICB0YWc6ICd1bCcsXG4gIGhvcml6b250YWw6IGZhbHNlLFxuICBudW1iZXJlZDogZmFsc2Vcbn07XG5cbnZhciBnZXRIb3Jpem9udGFsQ2xhc3MgPSBmdW5jdGlvbiBnZXRIb3Jpem9udGFsQ2xhc3MoaG9yaXpvbnRhbCkge1xuICBpZiAoaG9yaXpvbnRhbCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaG9yaXpvbnRhbCA9PT0gdHJ1ZSB8fCBob3Jpem9udGFsID09PSAneHMnKSB7XG4gICAgcmV0dXJuICdsaXN0LWdyb3VwLWhvcml6b250YWwnO1xuICB9XG5cbiAgcmV0dXJuIFwibGlzdC1ncm91cC1ob3Jpem9udGFsLVwiICsgaG9yaXpvbnRhbDtcbn07XG5cbmZ1bmN0aW9uIExpc3RHcm91cChwcm9wcykge1xuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY3NzTW9kdWxlID0gcHJvcHMuY3NzTW9kdWxlLFxuICAgICAgVGFnID0gcHJvcHMudGFnLFxuICAgICAgZmx1c2ggPSBwcm9wcy5mbHVzaCxcbiAgICAgIGhvcml6b250YWwgPSBwcm9wcy5ob3Jpem9udGFsLFxuICAgICAgbnVtYmVyZWQgPSBwcm9wcy5udW1iZXJlZCxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkJHIpO1xuXG4gIHZhciBjbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGNsYXNzTmFtZSwgJ2xpc3QtZ3JvdXAnLCAvLyBsaXN0LWdyb3VwLWhvcml6b250YWwgY2Fubm90IGN1cnJlbnRseSBiZSBtaXhlZCB3aXRoIGxpc3QtZ3JvdXAtZmx1c2hcbiAgLy8gd2Ugb25seSB0cnkgdG8gYXBwbHkgaG9yaXpvbnRhbCBjbGFzc2VzIGlmIGZsdXNoIGlzIGZhbHNlXG4gIGZsdXNoID8gJ2xpc3QtZ3JvdXAtZmx1c2gnIDogZ2V0SG9yaXpvbnRhbENsYXNzKGhvcml6b250YWwpLCB7XG4gICAgJ2xpc3QtZ3JvdXAtbnVtYmVyZWQnOiBudW1iZXJlZFxuICB9KSwgY3NzTW9kdWxlKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChUYWcsIF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzXG4gIH0pKTtcbn1cblxuTGlzdEdyb3VwLnByb3BUeXBlcyA9IHByb3BUeXBlcyR1O1xuTGlzdEdyb3VwLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyR0O1xuXG52YXIgX2V4Y2x1ZGVkJHEgPSBbXCJjbGFzc05hbWVcIiwgXCJjc3NNb2R1bGVcIiwgXCJ0YWdcIiwgXCJpbm5lclJlZlwiXTtcbnZhciBwcm9wVHlwZXMkdCA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ubm9kZSxcbiAgdGFnOiB0YWdQcm9wVHlwZSxcbiAgaW5uZXJSZWY6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCwgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5mdW5jLCBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZ10pLFxuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICBjc3NNb2R1bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0XG59O1xudmFyIGRlZmF1bHRQcm9wcyRzID0ge1xuICB0YWc6ICdmb3JtJ1xufTtcblxudmFyIEZvcm0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoRm9ybSwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gRm9ybShwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0NvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgIF90aGlzLmdldFJlZiA9IF90aGlzLmdldFJlZi5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5zdWJtaXQgPSBfdGhpcy5zdWJtaXQuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEZvcm0ucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRSZWYgPSBmdW5jdGlvbiBnZXRSZWYocmVmKSB7XG4gICAgaWYgKHRoaXMucHJvcHMuaW5uZXJSZWYpIHtcbiAgICAgIHRoaXMucHJvcHMuaW5uZXJSZWYocmVmKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlZiA9IHJlZjtcbiAgfTtcblxuICBfcHJvdG8uc3VibWl0ID0gZnVuY3Rpb24gc3VibWl0KCkge1xuICAgIGlmICh0aGlzLnJlZikge1xuICAgICAgdGhpcy5yZWYuc3VibWl0KCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgICBjc3NNb2R1bGUgPSBfdGhpcyRwcm9wcy5jc3NNb2R1bGUsXG4gICAgICAgIFRhZyA9IF90aGlzJHByb3BzLnRhZyxcbiAgICAgICAgaW5uZXJSZWYgPSBfdGhpcyRwcm9wcy5pbm5lclJlZixcbiAgICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzLCBfZXhjbHVkZWQkcSk7XG5cbiAgICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWUsIGNzc01vZHVsZSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChUYWcsIF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgICByZWY6IGlubmVyUmVmLFxuICAgICAgY2xhc3NOYW1lOiBjbGFzc2VzXG4gICAgfSkpO1xuICB9O1xuXG4gIHJldHVybiBGb3JtO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5Gb3JtLnByb3BUeXBlcyA9IHByb3BUeXBlcyR0O1xuRm9ybS5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHMkcztcbnZhciBGb3JtJDEgPSBGb3JtO1xuXG52YXIgX2V4Y2x1ZGVkJHAgPSBbXCJjbGFzc05hbWVcIiwgXCJjc3NNb2R1bGVcIiwgXCJ2YWxpZFwiLCBcInRvb2x0aXBcIiwgXCJ0YWdcIl07XG52YXIgcHJvcFR5cGVzJHMgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm5vZGUsXG4gIHRhZzogdGFnUHJvcFR5cGUsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG4gIHZhbGlkOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG4gIHRvb2x0aXA6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbFxufTtcbnZhciBkZWZhdWx0UHJvcHMkciA9IHtcbiAgdGFnOiAnZGl2JyxcbiAgdmFsaWQ6IHVuZGVmaW5lZFxufTtcblxuZnVuY3Rpb24gRm9ybUZlZWRiYWNrKHByb3BzKSB7XG4gIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjc3NNb2R1bGUgPSBwcm9wcy5jc3NNb2R1bGUsXG4gICAgICB2YWxpZCA9IHByb3BzLnZhbGlkLFxuICAgICAgdG9vbHRpcCA9IHByb3BzLnRvb2x0aXAsXG4gICAgICBUYWcgPSBwcm9wcy50YWcsXG4gICAgICBhdHRyaWJ1dGVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZCRwKTtcblxuICB2YXIgdmFsaWRNb2RlID0gdG9vbHRpcCA/ICd0b29sdGlwJyA6ICdmZWVkYmFjayc7XG4gIHZhciBjbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGNsYXNzTmFtZSwgdmFsaWQgPyBcInZhbGlkLVwiICsgdmFsaWRNb2RlIDogXCJpbnZhbGlkLVwiICsgdmFsaWRNb2RlKSwgY3NzTW9kdWxlKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChUYWcsIF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzXG4gIH0pKTtcbn1cblxuRm9ybUZlZWRiYWNrLnByb3BUeXBlcyA9IHByb3BUeXBlcyRzO1xuRm9ybUZlZWRiYWNrLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyRyO1xuXG52YXIgX2V4Y2x1ZGVkJG8gPSBbXCJjbGFzc05hbWVcIiwgXCJjc3NNb2R1bGVcIiwgXCJyb3dcIiwgXCJkaXNhYmxlZFwiLCBcImNoZWNrXCIsIFwiaW5saW5lXCIsIFwiZmxvYXRpbmdcIiwgXCJ0YWdcIiwgXCJzd2l0Y2hcIl07XG52YXIgcHJvcFR5cGVzJHIgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm5vZGUsXG4gIHJvdzogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBjaGVjazogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBcInN3aXRjaFwiOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG4gIGlubGluZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBmbG9hdGluZzogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBkaXNhYmxlZDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICB0YWc6IHRhZ1Byb3BUeXBlLFxuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICBjc3NNb2R1bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0XG59O1xudmFyIGRlZmF1bHRQcm9wcyRxID0ge1xuICB0YWc6ICdkaXYnXG59O1xuXG5mdW5jdGlvbiBGb3JtR3JvdXAocHJvcHMpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNzc01vZHVsZSA9IHByb3BzLmNzc01vZHVsZSxcbiAgICAgIHJvdyA9IHByb3BzLnJvdyxcbiAgICAgIGRpc2FibGVkID0gcHJvcHMuZGlzYWJsZWQsXG4gICAgICBjaGVjayA9IHByb3BzLmNoZWNrLFxuICAgICAgaW5saW5lID0gcHJvcHMuaW5saW5lLFxuICAgICAgZmxvYXRpbmcgPSBwcm9wcy5mbG9hdGluZyxcbiAgICAgIFRhZyA9IHByb3BzLnRhZyxcbiAgICAgIHN3aXRjaFByb3AgPSBwcm9wc1tcInN3aXRjaFwiXSxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkJG8pO1xuXG4gIHZhciBmb3JtQ2hlY2sgPSBjaGVjayB8fCBzd2l0Y2hQcm9wO1xuICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjbGFzc05hbWUsIHJvdyA/ICdyb3cnIDogZmFsc2UsIGZvcm1DaGVjayA/ICdmb3JtLWNoZWNrJyA6ICdtYi0zJywgc3dpdGNoUHJvcCA/ICdmb3JtLXN3aXRjaCcgOiBmYWxzZSwgZm9ybUNoZWNrICYmIGlubGluZSA/ICdmb3JtLWNoZWNrLWlubGluZScgOiBmYWxzZSwgZm9ybUNoZWNrICYmIGRpc2FibGVkID8gJ2Rpc2FibGVkJyA6IGZhbHNlLCBmbG9hdGluZyAmJiAnZm9ybS1mbG9hdGluZycpLCBjc3NNb2R1bGUpO1xuXG4gIGlmIChUYWcgPT09ICdmaWVsZHNldCcpIHtcbiAgICBhdHRyaWJ1dGVzLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gIH1cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzZXNcbiAgfSkpO1xufVxuXG5Gb3JtR3JvdXAucHJvcFR5cGVzID0gcHJvcFR5cGVzJHI7XG5Gb3JtR3JvdXAuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJHE7XG5cbnZhciBfZXhjbHVkZWQkbiA9IFtcImNsYXNzTmFtZVwiLCBcImNzc01vZHVsZVwiLCBcImlubGluZVwiLCBcImNvbG9yXCIsIFwidGFnXCJdO1xudmFyIHByb3BUeXBlcyRxID0ge1xuICBjaGlsZHJlbjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ub2RlLFxuICBpbmxpbmU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcbiAgdGFnOiB0YWdQcm9wVHlwZSxcbiAgY29sb3I6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICBjc3NNb2R1bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0XG59O1xudmFyIGRlZmF1bHRQcm9wcyRwID0ge1xuICB0YWc6ICdzbWFsbCcsXG4gIGNvbG9yOiAnbXV0ZWQnXG59O1xuXG5mdW5jdGlvbiBGb3JtVGV4dChwcm9wcykge1xuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY3NzTW9kdWxlID0gcHJvcHMuY3NzTW9kdWxlLFxuICAgICAgaW5saW5lID0gcHJvcHMuaW5saW5lLFxuICAgICAgY29sb3IgPSBwcm9wcy5jb2xvcixcbiAgICAgIFRhZyA9IHByb3BzLnRhZyxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkJG4pO1xuXG4gIHZhciBjbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGNsYXNzTmFtZSwgIWlubGluZSA/ICdmb3JtLXRleHQnIDogZmFsc2UsIGNvbG9yID8gXCJ0ZXh0LVwiICsgY29sb3IgOiBmYWxzZSksIGNzc01vZHVsZSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoVGFnLCBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3Nlc1xuICB9KSk7XG59XG5cbkZvcm1UZXh0LnByb3BUeXBlcyA9IHByb3BUeXBlcyRxO1xuRm9ybVRleHQuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJHA7XG5cbnZhciBfZXhjbHVkZWQkbSA9IFtcImNsYXNzTmFtZVwiLCBcImNzc01vZHVsZVwiLCBcInR5cGVcIiwgXCJic1NpemVcIiwgXCJ2YWxpZFwiLCBcImludmFsaWRcIiwgXCJ0YWdcIiwgXCJhZGRvblwiLCBcInBsYWludGV4dFwiLCBcImlubmVyUmVmXCJdO1xudmFyIHByb3BUeXBlcyRwID0ge1xuICBjaGlsZHJlbjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ub2RlLFxuICB0eXBlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgc2l6ZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vbmVPZlR5cGUoW1Byb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ubnVtYmVyLCBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZ10pLFxuICBic1NpemU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICB2YWxpZDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBpbnZhbGlkOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG4gIHRhZzogdGFnUHJvcFR5cGUsXG4gIGlubmVyUmVmOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9uZU9mVHlwZShbUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuYywgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmddKSxcbiAgcGxhaW50ZXh0OiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG4gIGFkZG9uOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3Rcbn07XG52YXIgZGVmYXVsdFByb3BzJG8gPSB7XG4gIHR5cGU6ICd0ZXh0J1xufTtcblxudmFyIElucHV0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKElucHV0LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBJbnB1dChwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgIF90aGlzLmdldFJlZiA9IF90aGlzLmdldFJlZi5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5mb2N1cyA9IF90aGlzLmZvY3VzLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBJbnB1dC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldFJlZiA9IGZ1bmN0aW9uIGdldFJlZihyZWYpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5pbm5lclJlZikge1xuICAgICAgdGhpcy5wcm9wcy5pbm5lclJlZihyZWYpO1xuICAgIH1cblxuICAgIHRoaXMucmVmID0gcmVmO1xuICB9O1xuXG4gIF9wcm90by5mb2N1cyA9IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgIGlmICh0aGlzLnJlZikge1xuICAgICAgdGhpcy5yZWYuZm9jdXMoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wcy5jbGFzc05hbWUsXG4gICAgICAgIGNzc01vZHVsZSA9IF90aGlzJHByb3BzLmNzc01vZHVsZSxcbiAgICAgICAgdHlwZSA9IF90aGlzJHByb3BzLnR5cGUsXG4gICAgICAgIGJzU2l6ZSA9IF90aGlzJHByb3BzLmJzU2l6ZSxcbiAgICAgICAgdmFsaWQgPSBfdGhpcyRwcm9wcy52YWxpZCxcbiAgICAgICAgaW52YWxpZCA9IF90aGlzJHByb3BzLmludmFsaWQsXG4gICAgICAgIHRhZyA9IF90aGlzJHByb3BzLnRhZyxcbiAgICAgICAgYWRkb24gPSBfdGhpcyRwcm9wcy5hZGRvbixcbiAgICAgICAgcGxhaW50ZXh0ID0gX3RoaXMkcHJvcHMucGxhaW50ZXh0LFxuICAgICAgICBpbm5lclJlZiA9IF90aGlzJHByb3BzLmlubmVyUmVmLFxuICAgICAgICBhdHRyaWJ1dGVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMsIF9leGNsdWRlZCRtKTtcblxuICAgIHZhciBjaGVja0lucHV0ID0gWydzd2l0Y2gnLCAncmFkaW8nLCAnY2hlY2tib3gnXS5pbmRleE9mKHR5cGUpID4gLTE7XG4gICAgdmFyIGlzTm90YU51bWJlciA9IC9cXEQvZztcbiAgICB2YXIgdGV4dGFyZWFJbnB1dCA9IHR5cGUgPT09ICd0ZXh0YXJlYSc7XG4gICAgdmFyIHNlbGVjdElucHV0ID0gdHlwZSA9PT0gJ3NlbGVjdCc7XG4gICAgdmFyIHJhbmdlSW5wdXQgPSB0eXBlID09PSAncmFuZ2UnO1xuICAgIHZhciBUYWcgPSB0YWcgfHwgKHNlbGVjdElucHV0IHx8IHRleHRhcmVhSW5wdXQgPyB0eXBlIDogJ2lucHV0Jyk7XG4gICAgdmFyIGZvcm1Db250cm9sQ2xhc3MgPSAnZm9ybS1jb250cm9sJztcblxuICAgIGlmIChwbGFpbnRleHQpIHtcbiAgICAgIGZvcm1Db250cm9sQ2xhc3MgPSBmb3JtQ29udHJvbENsYXNzICsgXCItcGxhaW50ZXh0XCI7XG4gICAgICBUYWcgPSB0YWcgfHwgJ2lucHV0JztcbiAgICB9IGVsc2UgaWYgKHJhbmdlSW5wdXQpIHtcbiAgICAgIGZvcm1Db250cm9sQ2xhc3MgPSAnZm9ybS1yYW5nZSc7XG4gICAgfSBlbHNlIGlmIChzZWxlY3RJbnB1dCkge1xuICAgICAgZm9ybUNvbnRyb2xDbGFzcyA9ICdmb3JtLXNlbGVjdCc7XG4gICAgfSBlbHNlIGlmIChjaGVja0lucHV0KSB7XG4gICAgICBpZiAoYWRkb24pIHtcbiAgICAgICAgZm9ybUNvbnRyb2xDbGFzcyA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JtQ29udHJvbENsYXNzID0gJ2Zvcm0tY2hlY2staW5wdXQnO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGVzLnNpemUgJiYgaXNOb3RhTnVtYmVyLnRlc3QoYXR0cmlidXRlcy5zaXplKSkge1xuICAgICAgd2Fybk9uY2UoJ1BsZWFzZSB1c2UgdGhlIHByb3AgXCJic1NpemVcIiBpbnN0ZWFkIG9mIHRoZSBcInNpemVcIiB0byBib290c3RyYXBcXCdzIGlucHV0IHNpemluZy4nKTtcbiAgICAgIGJzU2l6ZSA9IGF0dHJpYnV0ZXMuc2l6ZTtcbiAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLnNpemU7XG4gICAgfVxuXG4gICAgdmFyIGNsYXNzZXMgPSBtYXBUb0Nzc01vZHVsZXMoY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oY2xhc3NOYW1lLCBpbnZhbGlkICYmICdpcy1pbnZhbGlkJywgdmFsaWQgJiYgJ2lzLXZhbGlkJywgYnNTaXplID8gc2VsZWN0SW5wdXQgPyBcImZvcm0tc2VsZWN0LVwiICsgYnNTaXplIDogXCJmb3JtLWNvbnRyb2wtXCIgKyBic1NpemUgOiBmYWxzZSwgZm9ybUNvbnRyb2xDbGFzcyksIGNzc01vZHVsZSk7XG5cbiAgICBpZiAoVGFnID09PSAnaW5wdXQnIHx8IHRhZyAmJiB0eXBlb2YgdGFnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhdHRyaWJ1dGVzLnR5cGUgPSB0eXBlID09PSAnc3dpdGNoJyA/ICdjaGVja2JveCcgOiB0eXBlO1xuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGVzLmNoaWxkcmVuICYmICEocGxhaW50ZXh0IHx8IHR5cGUgPT09ICdzZWxlY3QnIHx8IHR5cGVvZiBUYWcgIT09ICdzdHJpbmcnIHx8IFRhZyA9PT0gJ3NlbGVjdCcpKSB7XG4gICAgICB3YXJuT25jZShcIklucHV0IHdpdGggYSB0eXBlIG9mIFxcXCJcIiArIHR5cGUgKyBcIlxcXCIgY2Fubm90IGhhdmUgY2hpbGRyZW4uIFBsZWFzZSB1c2UgXFxcInZhbHVlXFxcIi9cXFwiZGVmYXVsdFZhbHVlXFxcIiBpbnN0ZWFkLlwiKTtcbiAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLmNoaWxkcmVuO1xuICAgIH1cblxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoVGFnLCBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywge1xuICAgICAgcmVmOiBpbm5lclJlZixcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NlcyxcbiAgICAgIFwiYXJpYS1pbnZhbGlkXCI6IGludmFsaWRcbiAgICB9KSk7XG4gIH07XG5cbiAgcmV0dXJuIElucHV0O1xufShSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uQ29tcG9uZW50KTtcblxuSW5wdXQucHJvcFR5cGVzID0gcHJvcFR5cGVzJHA7XG5JbnB1dC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHMkbztcbnZhciBJbnB1dCQxID0gSW5wdXQ7XG5cbnZhciBfZXhjbHVkZWQkbCA9IFtcImNsYXNzTmFtZVwiLCBcImNzc01vZHVsZVwiLCBcInRhZ1wiLCBcInR5cGVcIiwgXCJzaXplXCJdO1xudmFyIHByb3BUeXBlcyRvID0ge1xuICAvKiogQWRkIGN1c3RvbSBjbGFzcyAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuXG4gIC8qKiBDaGFuZ2UgdW5kZXJseWluZyBjb21wb25lbnQncyBDU1MgYmFzZSBjbGFzcyBuYW1lICovXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG5cbiAgLyoqIFNldHMgc2l6ZSBvZiBJbnB1dEdyb3VwICovXG4gIHNpemU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuXG4gIC8qKiBTZXQgYSBjdXN0b20gZWxlbWVudCBmb3IgdGhpcyBjb21wb25lbnQgKi9cbiAgdGFnOiB0YWdQcm9wVHlwZSxcbiAgdHlwZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmdcbn07XG52YXIgZGVmYXVsdFByb3BzJG4gPSB7XG4gIHRhZzogJ2Rpdidcbn07XG5cbmZ1bmN0aW9uIElucHV0R3JvdXAocHJvcHMpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNzc01vZHVsZSA9IHByb3BzLmNzc01vZHVsZSxcbiAgICAgIFRhZyA9IHByb3BzLnRhZyxcbiAgICAgIHNpemUgPSBwcm9wcy5zaXplLFxuICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQkbCk7XG5cbiAgdmFyIGNsYXNzZXMgPSBtYXBUb0Nzc01vZHVsZXMoY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oY2xhc3NOYW1lLCAnaW5wdXQtZ3JvdXAnLCBzaXplID8gXCJpbnB1dC1ncm91cC1cIiArIHNpemUgOiBudWxsKSwgY3NzTW9kdWxlKTtcblxuICBpZiAocHJvcHMudHlwZSA9PT0gJ2Ryb3Bkb3duJykge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoRHJvcGRvd24kMSwgX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIHtcbiAgICAgIGNsYXNzTmFtZTogY2xhc3Nlc1xuICAgIH0pKTtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoSW5wdXRHcm91cENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZToge1xuICAgICAgaW5zaWRlSW5wdXRHcm91cDogdHJ1ZVxuICAgIH1cbiAgfSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzZXNcbiAgfSkpKTtcbn1cblxuSW5wdXRHcm91cC5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkbztcbklucHV0R3JvdXAuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJG47XG5cbnZhciBfZXhjbHVkZWQkayA9IFtcImNsYXNzTmFtZVwiLCBcImNzc01vZHVsZVwiLCBcInRhZ1wiXTtcbnZhciBwcm9wVHlwZXMkbiA9IHtcbiAgLyoqIEFkZCBjdXN0b20gY2xhc3MgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcblxuICAvKiogQ2hhbmdlIHVuZGVybHlpbmcgY29tcG9uZW50J3MgQ1NTIGJhc2UgY2xhc3MgbmFtZSAqL1xuICBjc3NNb2R1bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LFxuXG4gIC8qKiBTZXQgYSBjdXN0b20gZWxlbWVudCBmb3IgdGhpcyBjb21wb25lbnQgKi9cbiAgdGFnOiB0YWdQcm9wVHlwZVxufTtcbnZhciBkZWZhdWx0UHJvcHMkbSA9IHtcbiAgdGFnOiAnc3Bhbidcbn07XG5cbmZ1bmN0aW9uIElucHV0R3JvdXBUZXh0KHByb3BzKSB7XG4gIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjc3NNb2R1bGUgPSBwcm9wcy5jc3NNb2R1bGUsXG4gICAgICBUYWcgPSBwcm9wcy50YWcsXG4gICAgICBhdHRyaWJ1dGVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZCRrKTtcblxuICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjbGFzc05hbWUsICdpbnB1dC1ncm91cC10ZXh0JyksIGNzc01vZHVsZSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoVGFnLCBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3Nlc1xuICB9KSk7XG59XG5cbklucHV0R3JvdXBUZXh0LnByb3BUeXBlcyA9IHByb3BUeXBlcyRuO1xuSW5wdXRHcm91cFRleHQuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJG07XG5cbnZhciBfZXhjbHVkZWQkaiA9IFtcImNsYXNzTmFtZVwiLCBcImNzc01vZHVsZVwiLCBcImhpZGRlblwiLCBcIndpZHRoc1wiLCBcInRhZ1wiLCBcImNoZWNrXCIsIFwic2l6ZVwiLCBcImZvclwiXTtcbnZhciBjb2xXaWR0aHMgPSBbJ3hzJywgJ3NtJywgJ21kJywgJ2xnJywgJ3hsJywgJ3h4bCddO1xudmFyIHN0cmluZ09yTnVtYmVyUHJvcCA9IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm51bWJlciwgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmddKTtcbnZhciBjb2x1bW5Qcm9wcyA9IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLCBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm51bWJlciwgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zaGFwZSh7XG4gIHNpemU6IHN0cmluZ09yTnVtYmVyUHJvcCxcbiAgb3JkZXI6IHN0cmluZ09yTnVtYmVyUHJvcCxcbiAgb2Zmc2V0OiBzdHJpbmdPck51bWJlclByb3Bcbn0pXSk7XG52YXIgcHJvcFR5cGVzJG0gPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm5vZGUsXG4gIGhpZGRlbjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBjaGVjazogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBzaXplOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgXCJmb3JcIjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIHRhZzogdGFnUHJvcFR5cGUsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG4gIHhzOiBjb2x1bW5Qcm9wcyxcbiAgc206IGNvbHVtblByb3BzLFxuICBtZDogY29sdW1uUHJvcHMsXG4gIGxnOiBjb2x1bW5Qcm9wcyxcbiAgeGw6IGNvbHVtblByb3BzLFxuICB4eGw6IGNvbHVtblByb3BzLFxuICB3aWR0aHM6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYXJyYXlcbn07XG52YXIgZGVmYXVsdFByb3BzJGwgPSB7XG4gIHRhZzogJ2xhYmVsJyxcbiAgd2lkdGhzOiBjb2xXaWR0aHNcbn07XG5cbnZhciBnZXRDb2x1bW5TaXplQ2xhc3MgPSBmdW5jdGlvbiBnZXRDb2x1bW5TaXplQ2xhc3MoaXNYcywgY29sV2lkdGgsIGNvbFNpemUpIHtcbiAgaWYgKGNvbFNpemUgPT09IHRydWUgfHwgY29sU2l6ZSA9PT0gJycpIHtcbiAgICByZXR1cm4gaXNYcyA/ICdjb2wnIDogXCJjb2wtXCIgKyBjb2xXaWR0aDtcbiAgfVxuXG4gIGlmIChjb2xTaXplID09PSAnYXV0bycpIHtcbiAgICByZXR1cm4gaXNYcyA/ICdjb2wtYXV0bycgOiBcImNvbC1cIiArIGNvbFdpZHRoICsgXCItYXV0b1wiO1xuICB9XG5cbiAgcmV0dXJuIGlzWHMgPyBcImNvbC1cIiArIGNvbFNpemUgOiBcImNvbC1cIiArIGNvbFdpZHRoICsgXCItXCIgKyBjb2xTaXplO1xufTtcblxuZnVuY3Rpb24gTGFiZWwocHJvcHMpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNzc01vZHVsZSA9IHByb3BzLmNzc01vZHVsZSxcbiAgICAgIGhpZGRlbiA9IHByb3BzLmhpZGRlbixcbiAgICAgIHdpZHRocyA9IHByb3BzLndpZHRocyxcbiAgICAgIFRhZyA9IHByb3BzLnRhZyxcbiAgICAgIGNoZWNrID0gcHJvcHMuY2hlY2ssXG4gICAgICBzaXplID0gcHJvcHMuc2l6ZSxcbiAgICAgIGh0bWxGb3IgPSBwcm9wc1tcImZvclwiXSxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkJGopO1xuXG4gIHZhciBjb2xDbGFzc2VzID0gW107XG4gIHdpZHRocy5mb3JFYWNoKGZ1bmN0aW9uIChjb2xXaWR0aCwgaSkge1xuICAgIHZhciBjb2x1bW5Qcm9wID0gcHJvcHNbY29sV2lkdGhdO1xuICAgIGRlbGV0ZSBhdHRyaWJ1dGVzW2NvbFdpZHRoXTtcblxuICAgIGlmICghY29sdW1uUHJvcCAmJiBjb2x1bW5Qcm9wICE9PSAnJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpc1hzID0gIWk7XG4gICAgdmFyIGNvbENsYXNzO1xuXG4gICAgaWYgKGlzT2JqZWN0KGNvbHVtblByb3ApKSB7XG4gICAgICB2YXIgX2NsYXNzTmFtZXM7XG5cbiAgICAgIHZhciBjb2xTaXplSW50ZXJmaXggPSBpc1hzID8gJy0nIDogXCItXCIgKyBjb2xXaWR0aCArIFwiLVwiO1xuICAgICAgY29sQ2xhc3MgPSBnZXRDb2x1bW5TaXplQ2xhc3MoaXNYcywgY29sV2lkdGgsIGNvbHVtblByb3Auc2l6ZSk7XG4gICAgICBjb2xDbGFzc2VzLnB1c2gobWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKChfY2xhc3NOYW1lcyA9IHt9LCBfY2xhc3NOYW1lc1tjb2xDbGFzc10gPSBjb2x1bW5Qcm9wLnNpemUgfHwgY29sdW1uUHJvcC5zaXplID09PSAnJywgX2NsYXNzTmFtZXNbXCJvcmRlclwiICsgY29sU2l6ZUludGVyZml4ICsgY29sdW1uUHJvcC5vcmRlcl0gPSBjb2x1bW5Qcm9wLm9yZGVyIHx8IGNvbHVtblByb3Aub3JkZXIgPT09IDAsIF9jbGFzc05hbWVzW1wib2Zmc2V0XCIgKyBjb2xTaXplSW50ZXJmaXggKyBjb2x1bW5Qcm9wLm9mZnNldF0gPSBjb2x1bW5Qcm9wLm9mZnNldCB8fCBjb2x1bW5Qcm9wLm9mZnNldCA9PT0gMCwgX2NsYXNzTmFtZXMpKSksIGNzc01vZHVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbENsYXNzID0gZ2V0Q29sdW1uU2l6ZUNsYXNzKGlzWHMsIGNvbFdpZHRoLCBjb2x1bW5Qcm9wKTtcbiAgICAgIGNvbENsYXNzZXMucHVzaChjb2xDbGFzcyk7XG4gICAgfVxuICB9KTtcbiAgdmFyIGNvbEZvcm1MYWJlbCA9IHNpemUgfHwgY29sQ2xhc3Nlcy5sZW5ndGg7XG4gIHZhciBmb3JtTGFiZWwgPSAhKGNoZWNrIHx8IGNvbEZvcm1MYWJlbCk7XG4gIHZhciBjbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGNsYXNzTmFtZSwgaGlkZGVuID8gJ3Zpc3VhbGx5LWhpZGRlbicgOiBmYWxzZSwgY2hlY2sgPyAnZm9ybS1jaGVjay1sYWJlbCcgOiBmYWxzZSwgc2l6ZSA/IFwiY29sLWZvcm0tbGFiZWwtXCIgKyBzaXplIDogZmFsc2UsIGNvbENsYXNzZXMsIGNvbEZvcm1MYWJlbCA/ICdjb2wtZm9ybS1sYWJlbCcgOiBmYWxzZSwgZm9ybUxhYmVsID8gJ2Zvcm0tbGFiZWwnIDogZmFsc2UpLCBjc3NNb2R1bGUpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe1xuICAgIGh0bWxGb3I6IGh0bWxGb3JcbiAgfSwgYXR0cmlidXRlcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3Nlc1xuICB9KSk7XG59XG5cbkxhYmVsLnByb3BUeXBlcyA9IHByb3BUeXBlcyRtO1xuTGFiZWwuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJGw7XG5cbnZhciBfZXhjbHVkZWQkaSA9IFtcImJvZHlcIiwgXCJib3R0b21cIiwgXCJjbGFzc05hbWVcIiwgXCJjc3NNb2R1bGVcIiwgXCJoZWFkaW5nXCIsIFwibGVmdFwiLCBcImxpc3RcIiwgXCJtaWRkbGVcIiwgXCJvYmplY3RcIiwgXCJyaWdodFwiLCBcInRhZ1wiLCBcInRvcFwiXTtcbnZhciBwcm9wVHlwZXMkbCA9IHtcbiAgYm9keTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBib3R0b206IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcbiAgY2hpbGRyZW46IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ubm9kZSxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgY3NzTW9kdWxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCxcbiAgaGVhZGluZzogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBsZWZ0OiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG4gIGxpc3Q6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcbiAgbWlkZGxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG4gIG9iamVjdDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICByaWdodDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICB0YWc6IHRhZ1Byb3BUeXBlLFxuICB0b3A6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbFxufTtcblxuZnVuY3Rpb24gTWVkaWEocHJvcHMpIHtcbiAgdmFyIGJvZHkgPSBwcm9wcy5ib2R5LFxuICAgICAgYm90dG9tID0gcHJvcHMuYm90dG9tLFxuICAgICAgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY3NzTW9kdWxlID0gcHJvcHMuY3NzTW9kdWxlLFxuICAgICAgaGVhZGluZyA9IHByb3BzLmhlYWRpbmcsXG4gICAgICBsZWZ0ID0gcHJvcHMubGVmdCxcbiAgICAgIGxpc3QgPSBwcm9wcy5saXN0LFxuICAgICAgbWlkZGxlID0gcHJvcHMubWlkZGxlLFxuICAgICAgb2JqZWN0ID0gcHJvcHMub2JqZWN0LFxuICAgICAgcmlnaHQgPSBwcm9wcy5yaWdodCxcbiAgICAgIHRhZyA9IHByb3BzLnRhZyxcbiAgICAgIHRvcCA9IHByb3BzLnRvcCxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkJGkpO1xuXG4gIHZhciBkZWZhdWx0VGFnO1xuXG4gIGlmIChoZWFkaW5nKSB7XG4gICAgZGVmYXVsdFRhZyA9ICdoNCc7XG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlcy5ocmVmKSB7XG4gICAgZGVmYXVsdFRhZyA9ICdhJztcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVzLnNyYyB8fCBvYmplY3QpIHtcbiAgICBkZWZhdWx0VGFnID0gJ2ltZyc7XG4gIH0gZWxzZSBpZiAobGlzdCkge1xuICAgIGRlZmF1bHRUYWcgPSAndWwnO1xuICB9IGVsc2Uge1xuICAgIGRlZmF1bHRUYWcgPSAnZGl2JztcbiAgfVxuXG4gIHZhciBUYWcgPSB0YWcgfHwgZGVmYXVsdFRhZztcbiAgdmFyIGNsYXNzZXMgPSBtYXBUb0Nzc01vZHVsZXMoY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oY2xhc3NOYW1lLCB7XG4gICAgJ21lZGlhLWJvZHknOiBib2R5LFxuICAgICdtZWRpYS1oZWFkaW5nJzogaGVhZGluZyxcbiAgICAnbWVkaWEtbGVmdCc6IGxlZnQsXG4gICAgJ21lZGlhLXJpZ2h0JzogcmlnaHQsXG4gICAgJ21lZGlhLXRvcCc6IHRvcCxcbiAgICAnbWVkaWEtYm90dG9tJzogYm90dG9tLFxuICAgICdtZWRpYS1taWRkbGUnOiBtaWRkbGUsXG4gICAgJ21lZGlhLW9iamVjdCc6IG9iamVjdCxcbiAgICAnbWVkaWEtbGlzdCc6IGxpc3QsXG4gICAgbWVkaWE6ICFib2R5ICYmICFoZWFkaW5nICYmICFsZWZ0ICYmICFyaWdodCAmJiAhdG9wICYmICFib3R0b20gJiYgIW1pZGRsZSAmJiAhb2JqZWN0ICYmICFsaXN0XG4gIH0pLCBjc3NNb2R1bGUpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzZXNcbiAgfSkpO1xufVxuXG5NZWRpYS5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkbDtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBGYWRlUHJvcFR5cGVzID0gUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zaGFwZShGYWRlLnByb3BUeXBlcyk7XG52YXIgcHJvcFR5cGVzJGsgPSB7XG4gIGF1dG9Gb2N1czogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBiYWNrZHJvcDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBiYWNrZHJvcENsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIGJhY2tkcm9wVHJhbnNpdGlvbjogRmFkZVByb3BUeXBlcyxcbiAgY2hpbGRyZW46IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ubm9kZSxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgY29udGFpbmVyOiB0YXJnZXRQcm9wVHlwZSxcbiAgY3NzTW9kdWxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCxcbiAgZGlyZWN0aW9uOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9uZU9mKFsnc3RhcnQnLCAnZW5kJywgJ2JvdHRvbScsICd0b3AnXSksXG4gIGZhZGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcbiAgaW5uZXJSZWY6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCwgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuY10pLFxuICBpc09wZW46IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcbiAga2V5Ym9hcmQ6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcbiAgbGFiZWxsZWRCeTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIG9mZmNhbnZhc1RyYW5zaXRpb246IEZhZGVQcm9wVHlwZXMsXG4gIG9uQ2xvc2VkOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZ1bmMsXG4gIG9uRW50ZXI6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuYyxcbiAgb25FeGl0OiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZ1bmMsXG4gIHN0eWxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCxcbiAgb25PcGVuZWQ6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuYyxcbiAgcmV0dXJuRm9jdXNBZnRlckNsb3NlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG4gIHJvbGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICBzY3JvbGxhYmxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG4gIHRvZ2dsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5mdW5jLFxuICB0cmFwRm9jdXM6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcbiAgdW5tb3VudE9uQ2xvc2U6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcbiAgekluZGV4OiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9uZU9mVHlwZShbUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5udW1iZXIsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nXSlcbn07XG52YXIgcHJvcHNUb09taXQgPSBPYmplY3Qua2V5cyhwcm9wVHlwZXMkayk7XG52YXIgZGVmYXVsdFByb3BzJGsgPSB7XG4gIGlzT3BlbjogZmFsc2UsXG4gIGF1dG9Gb2N1czogdHJ1ZSxcbiAgZGlyZWN0aW9uOiAnc3RhcnQnLFxuICBzY3JvbGxhYmxlOiBmYWxzZSxcbiAgcm9sZTogJ2RpYWxvZycsXG4gIGJhY2tkcm9wOiB0cnVlLFxuICBrZXlib2FyZDogdHJ1ZSxcbiAgekluZGV4OiAxMDUwLFxuICBmYWRlOiB0cnVlLFxuICBvbk9wZW5lZDogbm9vcCxcbiAgb25DbG9zZWQ6IG5vb3AsXG4gIG9mZmNhbnZhc1RyYW5zaXRpb246IHtcbiAgICB0aW1lb3V0OiBUcmFuc2l0aW9uVGltZW91dHMuT2ZmY2FudmFzXG4gIH0sXG4gIGJhY2tkcm9wVHJhbnNpdGlvbjoge1xuICAgIG1vdW50T25FbnRlcjogdHJ1ZSxcbiAgICB0aW1lb3V0OiBUcmFuc2l0aW9uVGltZW91dHMuRmFkZSAvLyB1c2VzIHN0YW5kYXJkIGZhZGUgdHJhbnNpdGlvblxuXG4gIH0sXG4gIHVubW91bnRPbkNsb3NlOiB0cnVlLFxuICByZXR1cm5Gb2N1c0FmdGVyQ2xvc2U6IHRydWUsXG4gIGNvbnRhaW5lcjogJ2JvZHknLFxuICB0cmFwRm9jdXM6IGZhbHNlXG59O1xuXG52YXIgT2ZmY2FudmFzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKE9mZmNhbnZhcywgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gT2ZmY2FudmFzKHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgIF90aGlzLl9vcmlnaW5hbEJvZHlQYWRkaW5nID0gbnVsbDtcbiAgICBfdGhpcy5nZXRGb2N1c2FibGVDaGlsZHJlbiA9IF90aGlzLmdldEZvY3VzYWJsZUNoaWxkcmVuLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmhhbmRsZUJhY2tkcm9wQ2xpY2sgPSBfdGhpcy5oYW5kbGVCYWNrZHJvcENsaWNrLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmhhbmRsZUJhY2tkcm9wTW91c2VEb3duID0gX3RoaXMuaGFuZGxlQmFja2Ryb3BNb3VzZURvd24uYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMuaGFuZGxlRXNjYXBlID0gX3RoaXMuaGFuZGxlRXNjYXBlLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmhhbmRsZVRhYiA9IF90aGlzLmhhbmRsZVRhYi5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5vbk9wZW5lZCA9IF90aGlzLm9uT3BlbmVkLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLm9uQ2xvc2VkID0gX3RoaXMub25DbG9zZWQuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMubWFuYWdlRm9jdXNBZnRlckNsb3NlID0gX3RoaXMubWFuYWdlRm9jdXNBZnRlckNsb3NlLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmNsZWFyQmFja2Ryb3BBbmltYXRpb25UaW1lb3V0ID0gX3RoaXMuY2xlYXJCYWNrZHJvcEFuaW1hdGlvblRpbWVvdXQuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMudHJhcEZvY3VzID0gX3RoaXMudHJhcEZvY3VzLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgaXNPcGVuOiBmYWxzZVxuICAgIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE9mZmNhbnZhcy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgaXNPcGVuID0gX3RoaXMkcHJvcHMuaXNPcGVuLFxuICAgICAgICBhdXRvRm9jdXMgPSBfdGhpcyRwcm9wcy5hdXRvRm9jdXMsXG4gICAgICAgIG9uRW50ZXIgPSBfdGhpcyRwcm9wcy5vbkVudGVyO1xuXG4gICAgaWYgKGlzT3Blbikge1xuICAgICAgdGhpcy5pbml0KCk7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaXNPcGVuOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgaWYgKGF1dG9Gb2N1cykge1xuICAgICAgICB0aGlzLnNldEZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9uRW50ZXIpIHtcbiAgICAgIG9uRW50ZXIoKTtcbiAgICB9IC8vIHRyYXBzIGZvY3VzIGluc2lkZSB0aGUgT2ZmY2FudmFzLCBldmVuIGlmIHRoZSBicm93c2VyIGFkZHJlc3MgYmFyIGlzIGZvY3VzZWRcblxuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLnRyYXBGb2N1cywgdHJ1ZSk7XG4gICAgdGhpcy5faXNNb3VudGVkID0gdHJ1ZTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgaWYgKHRoaXMucHJvcHMuaXNPcGVuICYmICFwcmV2UHJvcHMuaXNPcGVuKSB7XG4gICAgICB0aGlzLmluaXQoKTtcbiAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpc09wZW46IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gbm93IE9mZmNhbnZhcyBEaWFsb2cgaXMgcmVuZGVyZWQgYW5kIHdlIGNhbiByZWZlciB0aGlzLl9lbGVtZW50IGFuZCB0aGlzLl9kaWFsb2dcblxuXG4gICAgaWYgKHRoaXMucHJvcHMuYXV0b0ZvY3VzICYmIHRoaXMuc3RhdGUuaXNPcGVuICYmICFwcmV2U3RhdGUuaXNPcGVuKSB7XG4gICAgICB0aGlzLnNldEZvY3VzKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2VsZW1lbnQgJiYgcHJldlByb3BzLnpJbmRleCAhPT0gdGhpcy5wcm9wcy56SW5kZXgpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuekluZGV4ID0gdGhpcy5wcm9wcy56SW5kZXg7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuY2xlYXJCYWNrZHJvcEFuaW1hdGlvblRpbWVvdXQoKTtcblxuICAgIGlmICh0aGlzLnByb3BzLm9uRXhpdCkge1xuICAgICAgdGhpcy5wcm9wcy5vbkV4aXQoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZWxlbWVudCkge1xuICAgICAgdGhpcy5kZXN0cm95KCk7XG5cbiAgICAgIGlmICh0aGlzLnByb3BzLmlzT3BlbiB8fCB0aGlzLnN0YXRlLmlzT3Blbikge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLnRyYXBGb2N1cywgdHJ1ZSk7XG4gICAgdGhpcy5faXNNb3VudGVkID0gZmFsc2U7XG4gIH0gLy8gbm90IG1vdXNlVXAgYmVjYXVzZSBzY3JvbGxiYXIgZmlyZXMgaXQsIHNob3VsZG4ndCBjbG9zZSB3aGVuIHVzZXIgc2Nyb2xsc1xuICA7XG5cbiAgX3Byb3RvLmhhbmRsZUJhY2tkcm9wQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVCYWNrZHJvcENsaWNrKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IHRoaXMuX21vdXNlRG93bkVsZW1lbnQpIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB2YXIgYmFja2Ryb3AgPSB0aGlzLl9iYWNrZHJvcDtcbiAgICAgIGlmICghdGhpcy5wcm9wcy5pc09wZW4gfHwgdGhpcy5wcm9wcy5iYWNrZHJvcCAhPT0gdHJ1ZSkgcmV0dXJuO1xuXG4gICAgICBpZiAoYmFja2Ryb3AgJiYgZS50YXJnZXQgPT09IGJhY2tkcm9wICYmIHRoaXMucHJvcHMudG9nZ2xlKSB7XG4gICAgICAgIHRoaXMucHJvcHMudG9nZ2xlKGUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uaGFuZGxlVGFiID0gZnVuY3Rpb24gaGFuZGxlVGFiKGUpIHtcbiAgICBpZiAoZS53aGljaCAhPT0gOSkgcmV0dXJuO1xuICAgIGlmICh0aGlzLm9mZmNhbnZhc0luZGV4IDwgT2ZmY2FudmFzLm9wZW5Db3VudCAtIDEpIHJldHVybjsgLy8gbGFzdCBvcGVuZWQgb2ZmY2FudmFzXG5cbiAgICB2YXIgZm9jdXNhYmxlQ2hpbGRyZW4gPSB0aGlzLmdldEZvY3VzYWJsZUNoaWxkcmVuKCk7XG4gICAgdmFyIHRvdGFsRm9jdXNhYmxlID0gZm9jdXNhYmxlQ2hpbGRyZW4ubGVuZ3RoO1xuICAgIGlmICh0b3RhbEZvY3VzYWJsZSA9PT0gMCkgcmV0dXJuO1xuICAgIHZhciBjdXJyZW50Rm9jdXMgPSB0aGlzLmdldEZvY3VzZWRDaGlsZCgpO1xuICAgIHZhciBmb2N1c2VkSW5kZXggPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbEZvY3VzYWJsZTsgaSArPSAxKSB7XG4gICAgICBpZiAoZm9jdXNhYmxlQ2hpbGRyZW5baV0gPT09IGN1cnJlbnRGb2N1cykge1xuICAgICAgICBmb2N1c2VkSW5kZXggPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZS5zaGlmdEtleSAmJiBmb2N1c2VkSW5kZXggPT09IDApIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGZvY3VzYWJsZUNoaWxkcmVuW3RvdGFsRm9jdXNhYmxlIC0gMV0uZm9jdXMoKTtcbiAgICB9IGVsc2UgaWYgKCFlLnNoaWZ0S2V5ICYmIGZvY3VzZWRJbmRleCA9PT0gdG90YWxGb2N1c2FibGUgLSAxKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBmb2N1c2FibGVDaGlsZHJlblswXS5mb2N1cygpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uaGFuZGxlQmFja2Ryb3BNb3VzZURvd24gPSBmdW5jdGlvbiBoYW5kbGVCYWNrZHJvcE1vdXNlRG93bihlKSB7XG4gICAgdGhpcy5fbW91c2VEb3duRWxlbWVudCA9IGUudGFyZ2V0O1xuICB9O1xuXG4gIF9wcm90by5oYW5kbGVFc2NhcGUgPSBmdW5jdGlvbiBoYW5kbGVFc2NhcGUoZSkge1xuICAgIGlmICh0aGlzLnByb3BzLmlzT3BlbiAmJiBlLmtleUNvZGUgPT09IGtleUNvZGVzLmVzYyAmJiB0aGlzLnByb3BzLnRvZ2dsZSkge1xuICAgICAgaWYgKHRoaXMucHJvcHMua2V5Ym9hcmQpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB0aGlzLnByb3BzLnRvZ2dsZShlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uT3BlbmVkID0gZnVuY3Rpb24gb25PcGVuZWQobm9kZSwgaXNBcHBlYXJpbmcpIHtcbiAgICB0aGlzLnByb3BzLm9uT3BlbmVkKCk7XG4gICAgKHRoaXMucHJvcHMub2ZmY2FudmFzVHJhbnNpdGlvbi5vbkVudGVyZWQgfHwgbm9vcCkobm9kZSwgaXNBcHBlYXJpbmcpO1xuICB9O1xuXG4gIF9wcm90by5vbkNsb3NlZCA9IGZ1bmN0aW9uIG9uQ2xvc2VkKG5vZGUpIHtcbiAgICB2YXIgdW5tb3VudE9uQ2xvc2UgPSB0aGlzLnByb3BzLnVubW91bnRPbkNsb3NlOyAvLyBzbyBhbGwgbWV0aG9kcyBnZXQgY2FsbGVkIGJlZm9yZSBpdCBpcyB1bm1vdW50ZWRcblxuICAgIHRoaXMucHJvcHMub25DbG9zZWQoKTtcbiAgICAodGhpcy5wcm9wcy5vZmZjYW52YXNUcmFuc2l0aW9uLm9uRXhpdGVkIHx8IG5vb3ApKG5vZGUpO1xuXG4gICAgaWYgKHVubW91bnRPbkNsb3NlKSB7XG4gICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICB0aGlzLmNsb3NlKCk7XG5cbiAgICBpZiAodGhpcy5faXNNb3VudGVkKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaXNPcGVuOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5zZXRGb2N1cyA9IGZ1bmN0aW9uIHNldEZvY3VzKCkge1xuICAgIGlmICh0aGlzLl9kaWFsb2cgJiYgdHlwZW9mIHRoaXMuX2RpYWxvZy5mb2N1cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fZGlhbG9nLmZvY3VzKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5nZXRGb2N1c2FibGVDaGlsZHJlbiA9IGZ1bmN0aW9uIGdldEZvY3VzYWJsZUNoaWxkcmVuKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZm9jdXNhYmxlRWxlbWVudHMuam9pbignLCAnKSk7XG4gIH07XG5cbiAgX3Byb3RvLmdldEZvY3VzZWRDaGlsZCA9IGZ1bmN0aW9uIGdldEZvY3VzZWRDaGlsZCgpIHtcbiAgICB2YXIgY3VycmVudEZvY3VzO1xuICAgIHZhciBmb2N1c2FibGVDaGlsZHJlbiA9IHRoaXMuZ2V0Rm9jdXNhYmxlQ2hpbGRyZW4oKTtcblxuICAgIHRyeSB7XG4gICAgICBjdXJyZW50Rm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY3VycmVudEZvY3VzID0gZm9jdXNhYmxlQ2hpbGRyZW5bMF07XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnRGb2N1cztcbiAgfTtcblxuICBfcHJvdG8udHJhcEZvY3VzID0gZnVuY3Rpb24gdHJhcEZvY3VzKGV2KSB7XG4gICAgaWYgKCF0aGlzLnByb3BzLnRyYXBGb2N1cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZWxlbWVudCkge1xuICAgICAgLy8gZWxlbWVudCBpcyBub3QgYXR0YWNoZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGlhbG9nID09PSBldi50YXJnZXQpIHtcbiAgICAgIC8vIGluaXRpYWwgZm9jdXMgd2hlbiB0aGUgT2ZmY2FudmFzIGlzIG9wZW5lZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9mZmNhbnZhc0luZGV4IDwgT2ZmY2FudmFzLm9wZW5Db3VudCAtIDEpIHtcbiAgICAgIC8vIGxhc3Qgb3BlbmVkIG9mZmNhbnZhc1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZ2V0Rm9jdXNhYmxlQ2hpbGRyZW4oKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIC8vIGZvY3VzIGlzIGFscmVhZHkgaW5zaWRlIHRoZSBPZmZjYW52YXNcbiAgICAgIGlmIChjaGlsZHJlbltpXSA9PT0gZXYudGFyZ2V0KSByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIG90aGVyd2lzZSBmb2N1cyB0aGUgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQgaW4gdGhlIE9mZmNhbnZhc1xuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgY2hpbGRyZW5bMF0uZm9jdXMoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmluaXQgPSBmdW5jdGlvbiBpbml0KCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl90cmlnZ2VyaW5nRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLl90cmlnZ2VyaW5nRWxlbWVudCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9lbGVtZW50KSB7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuekluZGV4ID0gdGhpcy5wcm9wcy56SW5kZXg7XG4gICAgICB0aGlzLl9tb3VudENvbnRhaW5lciA9IGdldFRhcmdldCh0aGlzLnByb3BzLmNvbnRhaW5lcik7XG5cbiAgICAgIHRoaXMuX21vdW50Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnQpO1xuICAgIH1cblxuICAgIHRoaXMuX29yaWdpbmFsQm9keVBhZGRpbmcgPSBnZXRPcmlnaW5hbEJvZHlQYWRkaW5nKCk7XG4gICAgY29uZGl0aW9uYWxseVVwZGF0ZVNjcm9sbGJhcigpO1xuXG4gICAgaWYgKE9mZmNhbnZhcy5vcGVuQ291bnQgPT09IDAgJiYgdGhpcy5wcm9wcy5iYWNrZHJvcCAmJiAhdGhpcy5wcm9wcy5zY3JvbGxhYmxlKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgfVxuXG4gICAgdGhpcy5vZmZjYW52YXNJbmRleCA9IE9mZmNhbnZhcy5vcGVuQ291bnQ7XG4gICAgT2ZmY2FudmFzLm9wZW5Db3VudCArPSAxO1xuICB9O1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5fZWxlbWVudCkge1xuICAgICAgdGhpcy5fbW91bnRDb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5fZWxlbWVudCk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMubWFuYWdlRm9jdXNBZnRlckNsb3NlKCk7XG4gIH07XG5cbiAgX3Byb3RvLm1hbmFnZUZvY3VzQWZ0ZXJDbG9zZSA9IGZ1bmN0aW9uIG1hbmFnZUZvY3VzQWZ0ZXJDbG9zZSgpIHtcbiAgICBpZiAodGhpcy5fdHJpZ2dlcmluZ0VsZW1lbnQpIHtcbiAgICAgIHZhciByZXR1cm5Gb2N1c0FmdGVyQ2xvc2UgPSB0aGlzLnByb3BzLnJldHVybkZvY3VzQWZ0ZXJDbG9zZTtcbiAgICAgIGlmICh0aGlzLl90cmlnZ2VyaW5nRWxlbWVudC5mb2N1cyAmJiByZXR1cm5Gb2N1c0FmdGVyQ2xvc2UpIHRoaXMuX3RyaWdnZXJpbmdFbGVtZW50LmZvY3VzKCk7XG4gICAgICB0aGlzLl90cmlnZ2VyaW5nRWxlbWVudCA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5jbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIHRoaXMubWFuYWdlRm9jdXNBZnRlckNsb3NlKCk7XG4gICAgT2ZmY2FudmFzLm9wZW5Db3VudCA9IE1hdGgubWF4KDAsIE9mZmNhbnZhcy5vcGVuQ291bnQgLSAxKTtcbiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gbnVsbDtcbiAgICBzZXRTY3JvbGxiYXJXaWR0aCh0aGlzLl9vcmlnaW5hbEJvZHlQYWRkaW5nKTtcbiAgfTtcblxuICBfcHJvdG8uY2xlYXJCYWNrZHJvcEFuaW1hdGlvblRpbWVvdXQgPSBmdW5jdGlvbiBjbGVhckJhY2tkcm9wQW5pbWF0aW9uVGltZW91dCgpIHtcbiAgICBpZiAodGhpcy5fYmFja2Ryb3BBbmltYXRpb25UaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fYmFja2Ryb3BBbmltYXRpb25UaW1lb3V0KTtcbiAgICAgIHRoaXMuX2JhY2tkcm9wQW5pbWF0aW9uVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICBkaXJlY3Rpb24gPSBfdGhpcyRwcm9wczIuZGlyZWN0aW9uLFxuICAgICAgICB1bm1vdW50T25DbG9zZSA9IF90aGlzJHByb3BzMi51bm1vdW50T25DbG9zZTtcblxuICAgIGlmICghIXRoaXMuX2VsZW1lbnQgJiYgKHRoaXMuc3RhdGUuaXNPcGVuIHx8ICF1bm1vdW50T25DbG9zZSkpIHtcbiAgICAgIHZhciBpc09mZmNhbnZhc0hpZGRlbiA9ICEhdGhpcy5fZWxlbWVudCAmJiAhdGhpcy5zdGF0ZS5pc09wZW4gJiYgIXVubW91bnRPbkNsb3NlO1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gaXNPZmZjYW52YXNIaWRkZW4gPyAnbm9uZScgOiAnYmxvY2snO1xuICAgICAgdmFyIF90aGlzJHByb3BzMyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHMzLmNsYXNzTmFtZSxcbiAgICAgICAgICBiYWNrZHJvcENsYXNzTmFtZSA9IF90aGlzJHByb3BzMy5iYWNrZHJvcENsYXNzTmFtZSxcbiAgICAgICAgICBjc3NNb2R1bGUgPSBfdGhpcyRwcm9wczMuY3NzTW9kdWxlLFxuICAgICAgICAgIGlzT3BlbiA9IF90aGlzJHByb3BzMy5pc09wZW4sXG4gICAgICAgICAgYmFja2Ryb3AgPSBfdGhpcyRwcm9wczMuYmFja2Ryb3AsXG4gICAgICAgICAgcm9sZSA9IF90aGlzJHByb3BzMy5yb2xlLFxuICAgICAgICAgIGxhYmVsbGVkQnkgPSBfdGhpcyRwcm9wczMubGFiZWxsZWRCeSxcbiAgICAgICAgICBzdHlsZSA9IF90aGlzJHByb3BzMy5zdHlsZTtcbiAgICAgIHZhciBvZmZjYW52YXNBdHRyaWJ1dGVzID0ge1xuICAgICAgICBvbktleVVwOiB0aGlzLmhhbmRsZUVzY2FwZSxcbiAgICAgICAgb25LZXlEb3duOiB0aGlzLmhhbmRsZVRhYixcbiAgICAgICAgJ2FyaWEtbGFiZWxsZWRieSc6IGxhYmVsbGVkQnksXG4gICAgICAgIHJvbGU6IHJvbGUsXG4gICAgICAgIHRhYkluZGV4OiAnLTEnXG4gICAgICB9O1xuICAgICAgdmFyIGhhc1RyYW5zaXRpb24gPSB0aGlzLnByb3BzLmZhZGU7XG5cbiAgICAgIHZhciBvZmZjYW52YXNUcmFuc2l0aW9uID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIEZhZGUuZGVmYXVsdFByb3BzKSwgdGhpcy5wcm9wcy5vZmZjYW52YXNUcmFuc2l0aW9uKSwge30sIHtcbiAgICAgICAgYmFzZUNsYXNzOiBoYXNUcmFuc2l0aW9uID8gdGhpcy5wcm9wcy5vZmZjYW52YXNUcmFuc2l0aW9uLmJhc2VDbGFzcyA6ICcnLFxuICAgICAgICB0aW1lb3V0OiBoYXNUcmFuc2l0aW9uID8gdGhpcy5wcm9wcy5vZmZjYW52YXNUcmFuc2l0aW9uLnRpbWVvdXQgOiAwXG4gICAgICB9KTtcblxuICAgICAgdmFyIGJhY2tkcm9wVHJhbnNpdGlvbiA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBGYWRlLmRlZmF1bHRQcm9wcyksIHRoaXMucHJvcHMuYmFja2Ryb3BUcmFuc2l0aW9uKSwge30sIHtcbiAgICAgICAgYmFzZUNsYXNzOiBoYXNUcmFuc2l0aW9uID8gdGhpcy5wcm9wcy5iYWNrZHJvcFRyYW5zaXRpb24uYmFzZUNsYXNzIDogJycsXG4gICAgICAgIHRpbWVvdXQ6IGhhc1RyYW5zaXRpb24gPyB0aGlzLnByb3BzLmJhY2tkcm9wVHJhbnNpdGlvbi50aW1lb3V0IDogMFxuICAgICAgfSk7XG5cbiAgICAgIHZhciBCYWNrZHJvcCA9IGJhY2tkcm9wICYmIChoYXNUcmFuc2l0aW9uID8gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KEZhZGUsIF9leHRlbmRzKHt9LCBiYWNrZHJvcFRyYW5zaXRpb24sIHtcbiAgICAgICAgXCJpblwiOiBpc09wZW4gJiYgISFiYWNrZHJvcCxcbiAgICAgICAgaW5uZXJSZWY6IGZ1bmN0aW9uIGlubmVyUmVmKGMpIHtcbiAgICAgICAgICBfdGhpczIuX2JhY2tkcm9wID0gYztcbiAgICAgICAgfSxcbiAgICAgICAgY3NzTW9kdWxlOiBjc3NNb2R1bGUsXG4gICAgICAgIGNsYXNzTmFtZTogbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKCdvZmZjYW52YXMtYmFja2Ryb3AnLCBiYWNrZHJvcENsYXNzTmFtZSksIGNzc01vZHVsZSksXG4gICAgICAgIG9uQ2xpY2s6IHRoaXMuaGFuZGxlQmFja2Ryb3BDbGljayxcbiAgICAgICAgb25Nb3VzZURvd246IHRoaXMuaGFuZGxlQmFja2Ryb3BNb3VzZURvd25cbiAgICAgIH0pKSA6IC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKCdvZmZjYW52YXMtYmFja2Ryb3AnLCAnc2hvdycsIGJhY2tkcm9wQ2xhc3NOYW1lKSwgY3NzTW9kdWxlKSxcbiAgICAgICAgb25DbGljazogdGhpcy5oYW5kbGVCYWNrZHJvcENsaWNrLFxuICAgICAgICBvbk1vdXNlRG93bjogdGhpcy5oYW5kbGVCYWNrZHJvcE1vdXNlRG93blxuICAgICAgfSkpO1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBvbWl0KHRoaXMucHJvcHMsIHByb3BzVG9PbWl0KTtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoUG9ydGFsJDEsIHtcbiAgICAgICAgbm9kZTogdGhpcy5fZWxlbWVudFxuICAgICAgfSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KEZhZGUsIF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCBvZmZjYW52YXNBdHRyaWJ1dGVzLCBvZmZjYW52YXNUcmFuc2l0aW9uLCB7XG4gICAgICAgIFwiaW5cIjogaXNPcGVuLFxuICAgICAgICBvbkVudGVyZWQ6IHRoaXMub25PcGVuZWQsXG4gICAgICAgIG9uRXhpdGVkOiB0aGlzLm9uQ2xvc2VkLFxuICAgICAgICBjc3NNb2R1bGU6IGNzc01vZHVsZSxcbiAgICAgICAgY2xhc3NOYW1lOiBtYXBUb0Nzc01vZHVsZXMoY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oJ29mZmNhbnZhcycsIGNsYXNzTmFtZSwgXCJvZmZjYW52YXMtXCIgKyBkaXJlY3Rpb24pLCBjc3NNb2R1bGUpLFxuICAgICAgICBpbm5lclJlZjogZnVuY3Rpb24gaW5uZXJSZWYoYykge1xuICAgICAgICAgIF90aGlzMi5fZGlhbG9nID0gYztcbiAgICAgICAgfSxcbiAgICAgICAgc3R5bGU6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBzdHlsZSksIHt9LCB7XG4gICAgICAgICAgdmlzaWJpbGl0eTogaXNPcGVuID8gJ3Zpc2libGUnIDogJ2hpZGRlbidcbiAgICAgICAgfSlcbiAgICAgIH0pLCB0aGlzLnByb3BzLmNoaWxkcmVuKSwgQmFja2Ryb3ApO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBPZmZjYW52YXM7XG59KFJlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5Db21wb25lbnQpO1xuXG5PZmZjYW52YXMucHJvcFR5cGVzID0gcHJvcFR5cGVzJGs7XG5PZmZjYW52YXMuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJGs7XG5PZmZjYW52YXMub3BlbkNvdW50ID0gMDtcbnZhciBPZmZjYW52YXMkMSA9IE9mZmNhbnZhcztcblxudmFyIF9leGNsdWRlZCRoID0gW1wiY2xhc3NOYW1lXCIsIFwiY3NzTW9kdWxlXCIsIFwidGFnXCJdO1xudmFyIHByb3BUeXBlcyRqID0ge1xuICB0YWc6IHRhZ1Byb3BUeXBlLFxuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICBjc3NNb2R1bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0XG59O1xudmFyIGRlZmF1bHRQcm9wcyRqID0ge1xuICB0YWc6ICdkaXYnXG59O1xuXG5mdW5jdGlvbiBPZmZjYW52YXNCb2R5KHByb3BzKSB7XG4gIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjc3NNb2R1bGUgPSBwcm9wcy5jc3NNb2R1bGUsXG4gICAgICBUYWcgPSBwcm9wcy50YWcsXG4gICAgICBhdHRyaWJ1dGVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZCRoKTtcblxuICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjbGFzc05hbWUsICdvZmZjYW52YXMtYm9keScpLCBjc3NNb2R1bGUpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzZXNcbiAgfSkpO1xufVxuXG5PZmZjYW52YXNCb2R5LnByb3BUeXBlcyA9IHByb3BUeXBlcyRqO1xuT2ZmY2FudmFzQm9keS5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHMkajtcblxudmFyIF9leGNsdWRlZCRnID0gW1wiY2hpbGRyZW5cIiwgXCJjbGFzc05hbWVcIiwgXCJjbG9zZVwiLCBcImNsb3NlQXJpYUxhYmVsXCIsIFwiY3NzTW9kdWxlXCIsIFwidGFnXCIsIFwidG9nZ2xlXCIsIFwid3JhcFRhZ1wiXTtcbnZhciBwcm9wVHlwZXMkaSA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ubm9kZSxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgY2xvc2U6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LFxuICBjbG9zZUFyaWFMYWJlbDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG4gIHRhZzogdGFnUHJvcFR5cGUsXG4gIHRvZ2dsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5mdW5jLFxuICB3cmFwVGFnOiB0YWdQcm9wVHlwZVxufTtcbnZhciBkZWZhdWx0UHJvcHMkaSA9IHtcbiAgY2xvc2VBcmlhTGFiZWw6ICdDbG9zZScsXG4gIHRhZzogJ2g1JyxcbiAgd3JhcFRhZzogJ2Rpdidcbn07XG5cbmZ1bmN0aW9uIE9mZmNhbnZhc0hlYWRlcihwcm9wcykge1xuICB2YXIgY2xvc2VCdXR0b247XG5cbiAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjbG9zZSA9IHByb3BzLmNsb3NlLFxuICAgICAgY2xvc2VBcmlhTGFiZWwgPSBwcm9wcy5jbG9zZUFyaWFMYWJlbCxcbiAgICAgIGNzc01vZHVsZSA9IHByb3BzLmNzc01vZHVsZSxcbiAgICAgIFRhZyA9IHByb3BzLnRhZyxcbiAgICAgIHRvZ2dsZSA9IHByb3BzLnRvZ2dsZSxcbiAgICAgIFdyYXBUYWcgPSBwcm9wcy53cmFwVGFnLFxuICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQkZyk7XG5cbiAgdmFyIGNsYXNzZXMgPSBtYXBUb0Nzc01vZHVsZXMoY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oY2xhc3NOYW1lLCAnb2ZmY2FudmFzLWhlYWRlcicpLCBjc3NNb2R1bGUpO1xuXG4gIGlmICghY2xvc2UgJiYgdG9nZ2xlKSB7XG4gICAgY2xvc2VCdXR0b24gPSAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgIG9uQ2xpY2s6IHRvZ2dsZSxcbiAgICAgIGNsYXNzTmFtZTogbWFwVG9Dc3NNb2R1bGVzKCdidG4tY2xvc2UnLCBjc3NNb2R1bGUpLFxuICAgICAgXCJhcmlhLWxhYmVsXCI6IGNsb3NlQXJpYUxhYmVsXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFdyYXBUYWcsIF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoVGFnLCB7XG4gICAgY2xhc3NOYW1lOiBtYXBUb0Nzc01vZHVsZXMoJ29mZmNhbnZhcy10aXRsZScsIGNzc01vZHVsZSlcbiAgfSwgY2hpbGRyZW4pLCBjbG9zZSB8fCBjbG9zZUJ1dHRvbik7XG59XG5cbk9mZmNhbnZhc0hlYWRlci5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkaTtcbk9mZmNhbnZhc0hlYWRlci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHMkaTtcblxudmFyIF9leGNsdWRlZCRmID0gW1wiY2xhc3NOYW1lXCIsIFwibGlzdENsYXNzTmFtZVwiLCBcImNzc01vZHVsZVwiLCBcInNpemVcIiwgXCJ0YWdcIiwgXCJsaXN0VGFnXCIsIFwiYXJpYS1sYWJlbFwiXTtcbnZhciBwcm9wVHlwZXMkaCA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ubm9kZSxcblxuICAvKiogQWRkIGN1c3RvbSBjbGFzcyAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuXG4gIC8qKiBBZGQgY3VzdG9tIGNsYXNzIGZvciBsaXN0ICovXG4gIGxpc3RDbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuXG4gIC8qKiBDaGFuZ2UgdW5kZXJseWluZyBjb21wb25lbnQncyBDU1MgYmFzZSBjbGFzcyBuYW1lICovXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG5cbiAgLyoqIE1ha2UgdGhlIFBhZ2luYXRpb24gYmlnZ2VyIG9yIHNtYWxsZXIgICovXG4gIHNpemU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuXG4gIC8qKiBTZXQgYSBjdXN0b20gZWxlbWVudCBmb3IgdGhpcyBjb21wb25lbnQgKi9cbiAgdGFnOiB0YWdQcm9wVHlwZSxcblxuICAvKiogU2V0IGEgY3VzdG9tIGVsZW1lbnQgZm9yIGxpc3QgY29tcG9uZW50ICovXG4gIGxpc3RUYWc6IHRhZ1Byb3BUeXBlLFxuICAnYXJpYS1sYWJlbCc6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nXG59O1xudmFyIGRlZmF1bHRQcm9wcyRoID0ge1xuICB0YWc6ICduYXYnLFxuICBsaXN0VGFnOiAndWwnLFxuICAnYXJpYS1sYWJlbCc6ICdwYWdpbmF0aW9uJ1xufTtcblxuZnVuY3Rpb24gUGFnaW5hdGlvbihwcm9wcykge1xuICB2YXIgX2NsYXNzTmFtZXM7XG5cbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGxpc3RDbGFzc05hbWUgPSBwcm9wcy5saXN0Q2xhc3NOYW1lLFxuICAgICAgY3NzTW9kdWxlID0gcHJvcHMuY3NzTW9kdWxlLFxuICAgICAgc2l6ZSA9IHByb3BzLnNpemUsXG4gICAgICBUYWcgPSBwcm9wcy50YWcsXG4gICAgICBMaXN0VGFnID0gcHJvcHMubGlzdFRhZyxcbiAgICAgIGxhYmVsID0gcHJvcHNbJ2FyaWEtbGFiZWwnXSxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkJGYpO1xuXG4gIHZhciBjbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGNsYXNzTmFtZSksIGNzc01vZHVsZSk7XG4gIHZhciBsaXN0Q2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShsaXN0Q2xhc3NOYW1lLCAncGFnaW5hdGlvbicsIChfY2xhc3NOYW1lcyA9IHt9LCBfY2xhc3NOYW1lc1tcInBhZ2luYXRpb24tXCIgKyBzaXplXSA9ICEhc2l6ZSwgX2NsYXNzTmFtZXMpKSwgY3NzTW9kdWxlKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChUYWcsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzZXMsXG4gICAgXCJhcmlhLWxhYmVsXCI6IGxhYmVsXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChMaXN0VGFnLCBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywge1xuICAgIGNsYXNzTmFtZTogbGlzdENsYXNzZXNcbiAgfSkpKTtcbn1cblxuUGFnaW5hdGlvbi5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkaDtcblBhZ2luYXRpb24uZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJGg7XG5cbnZhciBfZXhjbHVkZWQkZSA9IFtcImFjdGl2ZVwiLCBcImNsYXNzTmFtZVwiLCBcImNzc01vZHVsZVwiLCBcImRpc2FibGVkXCIsIFwidGFnXCJdO1xudmFyIHByb3BUeXBlcyRnID0ge1xuICAvKiogU2V0IGl0ZW0gYXMgYWN0aXZlICovXG4gIGFjdGl2ZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBjaGlsZHJlbjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ub2RlLFxuXG4gIC8qKiBBZGQgY3VzdG9tIGNsYXNzICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG5cbiAgLyoqIENoYW5nZSB1bmRlcmx5aW5nIGNvbXBvbmVudCdzIENTUyBiYXNlIGNsYXNzIG5hbWUgKi9cbiAgY3NzTW9kdWxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCxcblxuICAvKiogU2V0IGl0ZW0gYXMgZGlzYWJsZWQgKi9cbiAgZGlzYWJsZWQ6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcblxuICAvKiogU2V0IGEgY3VzdG9tIGVsZW1lbnQgZm9yIHRoaXMgY29tcG9uZW50ICovXG4gIHRhZzogdGFnUHJvcFR5cGVcbn07XG52YXIgZGVmYXVsdFByb3BzJGcgPSB7XG4gIHRhZzogJ2xpJ1xufTtcblxuZnVuY3Rpb24gUGFnaW5hdGlvbkl0ZW0ocHJvcHMpIHtcbiAgdmFyIGFjdGl2ZSA9IHByb3BzLmFjdGl2ZSxcbiAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNzc01vZHVsZSA9IHByb3BzLmNzc01vZHVsZSxcbiAgICAgIGRpc2FibGVkID0gcHJvcHMuZGlzYWJsZWQsXG4gICAgICBUYWcgPSBwcm9wcy50YWcsXG4gICAgICBhdHRyaWJ1dGVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZCRlKTtcblxuICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjbGFzc05hbWUsICdwYWdlLWl0ZW0nLCB7XG4gICAgYWN0aXZlOiBhY3RpdmUsXG4gICAgZGlzYWJsZWQ6IGRpc2FibGVkXG4gIH0pLCBjc3NNb2R1bGUpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzZXNcbiAgfSkpO1xufVxuXG5QYWdpbmF0aW9uSXRlbS5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkZztcblBhZ2luYXRpb25JdGVtLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyRnO1xuXG52YXIgX2V4Y2x1ZGVkJGQgPSBbXCJjbGFzc05hbWVcIiwgXCJjc3NNb2R1bGVcIiwgXCJuZXh0XCIsIFwicHJldmlvdXNcIiwgXCJmaXJzdFwiLCBcImxhc3RcIiwgXCJ0YWdcIl07XG52YXIgcHJvcFR5cGVzJGYgPSB7XG4gICdhcmlhLWxhYmVsJzogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm5vZGUsXG5cbiAgLyoqIEFkZCBjdXN0b20gY2xhc3MgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcblxuICAvKiogQ2hhbmdlIHVuZGVybHlpbmcgY29tcG9uZW50J3MgQ1NTIGJhc2UgY2xhc3MgbmFtZSAqL1xuICBjc3NNb2R1bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LFxuXG4gIC8qKiBBZGQgdG8gbmV4dCBidXR0b24gdG8gYWRkIGRlZmF1bHQgYXJpYSBsYWJlbCBhbmQgaWNvbiAqL1xuICBuZXh0OiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG5cbiAgLyoqIEFkZCB0byBwcmV2aW91cyBidXR0b24gdG8gYWRkIGRlZmF1bHQgYXJpYSBsYWJlbCBhbmQgaWNvbiAqL1xuICBwcmV2aW91czogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuXG4gIC8qKiBBZGQgdG8gZmlyc3QgYnV0dG9uIHRvIGFkZCBkZWZhdWx0IGFyaWEgbGFiZWwgYW5kIGljb24gKi9cbiAgZmlyc3Q6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcblxuICAvKiogQWRkIHRvIGxhc3QgYnV0dG9uIHRvIGFkZCBkZWZhdWx0IGFyaWEgbGFiZWwgYW5kIGljb24gKi9cbiAgbGFzdDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuXG4gIC8qKiBTZXQgYSBjdXN0b20gZWxlbWVudCBmb3IgdGhpcyBjb21wb25lbnQgKi9cbiAgdGFnOiB0YWdQcm9wVHlwZVxufTtcbnZhciBkZWZhdWx0UHJvcHMkZiA9IHtcbiAgdGFnOiAnYSdcbn07XG5cbmZ1bmN0aW9uIFBhZ2luYXRpb25MaW5rKHByb3BzKSB7XG4gIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjc3NNb2R1bGUgPSBwcm9wcy5jc3NNb2R1bGUsXG4gICAgICBuZXh0ID0gcHJvcHMubmV4dCxcbiAgICAgIHByZXZpb3VzID0gcHJvcHMucHJldmlvdXMsXG4gICAgICBmaXJzdCA9IHByb3BzLmZpcnN0LFxuICAgICAgbGFzdCA9IHByb3BzLmxhc3QsXG4gICAgICBUYWcgPSBwcm9wcy50YWcsXG4gICAgICBhdHRyaWJ1dGVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZCRkKTtcblxuICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjbGFzc05hbWUsICdwYWdlLWxpbmsnKSwgY3NzTW9kdWxlKTtcbiAgdmFyIGRlZmF1bHRBcmlhTGFiZWw7XG5cbiAgaWYgKHByZXZpb3VzKSB7XG4gICAgZGVmYXVsdEFyaWFMYWJlbCA9ICdQcmV2aW91cyc7XG4gIH0gZWxzZSBpZiAobmV4dCkge1xuICAgIGRlZmF1bHRBcmlhTGFiZWwgPSAnTmV4dCc7XG4gIH0gZWxzZSBpZiAoZmlyc3QpIHtcbiAgICBkZWZhdWx0QXJpYUxhYmVsID0gJ0ZpcnN0JztcbiAgfSBlbHNlIGlmIChsYXN0KSB7XG4gICAgZGVmYXVsdEFyaWFMYWJlbCA9ICdMYXN0JztcbiAgfVxuXG4gIHZhciBhcmlhTGFiZWwgPSBwcm9wc1snYXJpYS1sYWJlbCddIHx8IGRlZmF1bHRBcmlhTGFiZWw7XG4gIHZhciBkZWZhdWx0Q2FyZXQ7XG5cbiAgaWYgKHByZXZpb3VzKSB7XG4gICAgZGVmYXVsdENhcmV0ID0gXCJcXHUyMDM5XCI7XG4gIH0gZWxzZSBpZiAobmV4dCkge1xuICAgIGRlZmF1bHRDYXJldCA9IFwiXFx1MjAzQVwiO1xuICB9IGVsc2UgaWYgKGZpcnN0KSB7XG4gICAgZGVmYXVsdENhcmV0ID0gXCJcXHhBQlwiO1xuICB9IGVsc2UgaWYgKGxhc3QpIHtcbiAgICBkZWZhdWx0Q2FyZXQgPSBcIlxceEJCXCI7XG4gIH1cblxuICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICBpZiAoY2hpbGRyZW4gJiYgQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgaWYgKCFhdHRyaWJ1dGVzLmhyZWYgJiYgVGFnID09PSAnYScpIHtcbiAgICBUYWcgPSAnYnV0dG9uJztcbiAgfVxuXG4gIGlmIChwcmV2aW91cyB8fCBuZXh0IHx8IGZpcnN0IHx8IGxhc3QpIHtcbiAgICBjaGlsZHJlbiA9IFsvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgIFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIsXG4gICAgICBrZXk6IFwiY2FyZXRcIlxuICAgIH0sIGNoaWxkcmVuIHx8IGRlZmF1bHRDYXJldCksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgY2xhc3NOYW1lOiBcInZpc3VhbGx5LWhpZGRlblwiLFxuICAgICAga2V5OiBcImFyaWFMYWJlbFwiXG4gICAgfSwgYXJpYUxhYmVsKV07XG4gIH1cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzZXMsXG4gICAgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbFxuICB9KSwgY2hpbGRyZW4pO1xufVxuXG5QYWdpbmF0aW9uTGluay5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkZjtcblBhZ2luYXRpb25MaW5rLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyRmO1xuXG4vKipcbiAqIFRhYkNvbnRleHRcbiAqIHtcbiAqICBhY3RpdmVUYWJJZDogUHJvcFR5cGVzLmFueVxuICogfVxuICovXG5cbnZhciBUYWJDb250ZXh0ID0gUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUNvbnRleHQoe30pO1xuXG52YXIgcHJvcFR5cGVzJGUgPSB7XG4gIHRhZzogdGFnUHJvcFR5cGUsXG4gIGFjdGl2ZVRhYjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5hbnksXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3Rcbn07XG52YXIgZGVmYXVsdFByb3BzJGUgPSB7XG4gIHRhZzogJ2Rpdidcbn07XG5cbnZhciBUYWJDb250ZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFRhYkNvbnRlbnQsIF9Db21wb25lbnQpO1xuXG4gIFRhYkNvbnRlbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKSB7XG4gICAgaWYgKHByZXZTdGF0ZS5hY3RpdmVUYWIgIT09IG5leHRQcm9wcy5hY3RpdmVUYWIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFjdGl2ZVRhYjogbmV4dFByb3BzLmFjdGl2ZVRhYlxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBmdW5jdGlvbiBUYWJDb250ZW50KHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBhY3RpdmVUYWI6IF90aGlzLnByb3BzLmFjdGl2ZVRhYlxuICAgIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFRhYkNvbnRlbnQucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2xhc3NOYW1lID0gX3RoaXMkcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgICBjc3NNb2R1bGUgPSBfdGhpcyRwcm9wcy5jc3NNb2R1bGUsXG4gICAgICAgIFRhZyA9IF90aGlzJHByb3BzLnRhZztcbiAgICB2YXIgYXR0cmlidXRlcyA9IG9taXQodGhpcy5wcm9wcywgT2JqZWN0LmtleXMocHJvcFR5cGVzJGUpKTtcbiAgICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXSgndGFiLWNvbnRlbnQnLCBjbGFzc05hbWUpLCBjc3NNb2R1bGUpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoVGFiQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IHtcbiAgICAgICAgYWN0aXZlVGFiSWQ6IHRoaXMuc3RhdGUuYWN0aXZlVGFiXG4gICAgICB9XG4gICAgfSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIHtcbiAgICAgIGNsYXNzTmFtZTogY2xhc3Nlc1xuICAgIH0pKSk7XG4gIH07XG5cbiAgcmV0dXJuIFRhYkNvbnRlbnQ7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbnZhciBUYWJDb250ZW50JDEgPSBUYWJDb250ZW50O1xuVGFiQ29udGVudC5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkZTtcblRhYkNvbnRlbnQuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJGU7XG5cbnZhciBfZXhjbHVkZWQkYyA9IFtcImNsYXNzTmFtZVwiLCBcImNzc01vZHVsZVwiLCBcInRhYklkXCIsIFwidGFnXCJdO1xudmFyIHByb3BUeXBlcyRkID0ge1xuICB0YWc6IHRhZ1Byb3BUeXBlLFxuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICBjc3NNb2R1bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LFxuICB0YWJJZDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5hbnlcbn07XG52YXIgZGVmYXVsdFByb3BzJGQgPSB7XG4gIHRhZzogJ2Rpdidcbn07XG5mdW5jdGlvbiBUYWJQYW5lKHByb3BzKSB7XG4gIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjc3NNb2R1bGUgPSBwcm9wcy5jc3NNb2R1bGUsXG4gICAgICB0YWJJZCA9IHByb3BzLnRhYklkLFxuICAgICAgVGFnID0gcHJvcHMudGFnLFxuICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQkYyk7XG5cbiAgdmFyIGdldENsYXNzZXMgPSBmdW5jdGlvbiBnZXRDbGFzc2VzKGFjdGl2ZVRhYklkKSB7XG4gICAgcmV0dXJuIG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXSgndGFiLXBhbmUnLCBjbGFzc05hbWUsIHtcbiAgICAgIGFjdGl2ZTogdGFiSWQgPT09IGFjdGl2ZVRhYklkXG4gICAgfSksIGNzc01vZHVsZSk7XG4gIH07XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChUYWJDb250ZXh0LkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBhY3RpdmVUYWJJZCA9IF9yZWYuYWN0aXZlVGFiSWQ7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChUYWcsIF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgICBjbGFzc05hbWU6IGdldENsYXNzZXMoYWN0aXZlVGFiSWQpXG4gICAgfSkpO1xuICB9KTtcbn1cblRhYlBhbmUucHJvcFR5cGVzID0gcHJvcFR5cGVzJGQ7XG5UYWJQYW5lLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyRkO1xuXG52YXIgX2V4Y2x1ZGVkJGIgPSBbXCJjbGFzc05hbWVcIiwgXCJjbG9zZUNsYXNzTmFtZVwiLCBcImNsb3NlQXJpYUxhYmVsXCIsIFwiY3NzTW9kdWxlXCIsIFwidGFnXCIsIFwiY29sb3JcIiwgXCJpc09wZW5cIiwgXCJ0b2dnbGVcIiwgXCJjaGlsZHJlblwiLCBcInRyYW5zaXRpb25cIiwgXCJmYWRlXCIsIFwiaW5uZXJSZWZcIl07XG52YXIgcHJvcFR5cGVzJGMgPSB7XG4gIC8qKiBQYXNzIGNoaWxkcmVuIHNvIHRoaXMgY29tcG9uZW50IGNhbiB3cmFwIHRoZSBjaGlsZCBlbGVtZW50cyAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ub2RlLFxuXG4gIC8qKiBBZGQgY3VzdG9tIGNsYXNzICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG5cbiAgLyoqIEFkZCBjdXN0b20gY2xhc3MgZm9yIGNsb3NlIGJ1dHRvbiAqL1xuICBjbG9zZUNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG5cbiAgLyoqIEFyaWEgbGFiZWwgZm9yIGNsb3NlIGJ1dHRvbiAqL1xuICBjbG9zZUFyaWFMYWJlbDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG5cbiAgLyoqIENoYW5nZSBjb2xvciBvZiBhbGVydCAqL1xuICBjb2xvcjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG5cbiAgLyoqIENoYW5nZSBleGlzdGluZyBjbGFzc05hbWUgd2l0aCBhIG5ldyBjbGFzc05hbWUgKi9cbiAgY3NzTW9kdWxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCxcblxuICAvKiogVG9nZ2xlIGZhZGUgYW5pbWF0aW9uICovXG4gIGZhZGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcbiAgaW5uZXJSZWY6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCwgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuY10pLFxuXG4gIC8qKiBDb250cm9sIHZpc2liaWxpdHkgc3RhdGUgb2YgQWxlcnQgKi9cbiAgaXNPcGVuOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG5cbiAgLyoqIFNldCBhIGN1c3RvbSBlbGVtZW50IGZvciB0aGlzIGNvbXBvbmVudCAqL1xuICB0YWc6IHRhZ1Byb3BUeXBlLFxuXG4gIC8qKiBGdW5jdGlvbiB0byB0b2dnbGUgdmlzaWJpbGl0eSAqL1xuICB0b2dnbGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uZnVuYyxcblxuICAvKiogUHJvcHMgdG8gYmUgcGFzc2VkIHRvIGBGYWRlYCB0byBtb2RpZnkgdHJhbnNpdGlvbiAqL1xuICB0cmFuc2l0aW9uOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnNoYXBlKEZhZGUucHJvcFR5cGVzKVxufTtcbnZhciBkZWZhdWx0UHJvcHMkYyA9IHtcbiAgY29sb3I6ICdzdWNjZXNzJyxcbiAgaXNPcGVuOiB0cnVlLFxuICB0YWc6ICdkaXYnLFxuICBjbG9zZUFyaWFMYWJlbDogJ0Nsb3NlJyxcbiAgZmFkZTogdHJ1ZSxcbiAgdHJhbnNpdGlvbjogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIEZhZGUuZGVmYXVsdFByb3BzKSwge30sIHtcbiAgICB1bm1vdW50T25FeGl0OiB0cnVlXG4gIH0pXG59O1xuXG5mdW5jdGlvbiBBbGVydChwcm9wcykge1xuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY2xvc2VDbGFzc05hbWUgPSBwcm9wcy5jbG9zZUNsYXNzTmFtZSxcbiAgICAgIGNsb3NlQXJpYUxhYmVsID0gcHJvcHMuY2xvc2VBcmlhTGFiZWwsXG4gICAgICBjc3NNb2R1bGUgPSBwcm9wcy5jc3NNb2R1bGUsXG4gICAgICBUYWcgPSBwcm9wcy50YWcsXG4gICAgICBjb2xvciA9IHByb3BzLmNvbG9yLFxuICAgICAgaXNPcGVuID0gcHJvcHMuaXNPcGVuLFxuICAgICAgdG9nZ2xlID0gcHJvcHMudG9nZ2xlLFxuICAgICAgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbixcbiAgICAgIHRyYW5zaXRpb24gPSBwcm9wcy50cmFuc2l0aW9uLFxuICAgICAgZmFkZSA9IHByb3BzLmZhZGUsXG4gICAgICBpbm5lclJlZiA9IHByb3BzLmlubmVyUmVmLFxuICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQkYik7XG5cbiAgdmFyIGNsYXNzZXMgPSBtYXBUb0Nzc01vZHVsZXMoY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oY2xhc3NOYW1lLCAnYWxlcnQnLCBcImFsZXJ0LVwiICsgY29sb3IsIHtcbiAgICAnYWxlcnQtZGlzbWlzc2libGUnOiB0b2dnbGVcbiAgfSksIGNzc01vZHVsZSk7XG4gIHZhciBjbG9zZUNsYXNzZXMgPSBtYXBUb0Nzc01vZHVsZXMoY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oJ2J0bi1jbG9zZScsIGNsb3NlQ2xhc3NOYW1lKSwgY3NzTW9kdWxlKTtcblxuICB2YXIgYWxlcnRUcmFuc2l0aW9uID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIEZhZGUuZGVmYXVsdFByb3BzKSwgdHJhbnNpdGlvbiksIHt9LCB7XG4gICAgYmFzZUNsYXNzOiBmYWRlID8gdHJhbnNpdGlvbi5iYXNlQ2xhc3MgOiAnJyxcbiAgICB0aW1lb3V0OiBmYWRlID8gdHJhbnNpdGlvbi50aW1lb3V0IDogMFxuICB9KTtcblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KEZhZGUsIF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCBhbGVydFRyYW5zaXRpb24sIHtcbiAgICB0YWc6IFRhZyxcbiAgICBjbGFzc05hbWU6IGNsYXNzZXMsXG4gICAgXCJpblwiOiBpc09wZW4sXG4gICAgcm9sZTogXCJhbGVydFwiLFxuICAgIGlubmVyUmVmOiBpbm5lclJlZlxuICB9KSwgdG9nZ2xlID8gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHtcbiAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgIGNsYXNzTmFtZTogY2xvc2VDbGFzc2VzLFxuICAgIFwiYXJpYS1sYWJlbFwiOiBjbG9zZUFyaWFMYWJlbCxcbiAgICBvbkNsaWNrOiB0b2dnbGVcbiAgfSkgOiBudWxsLCBjaGlsZHJlbik7XG59XG5cbkFsZXJ0LnByb3BUeXBlcyA9IHByb3BUeXBlcyRjO1xuQWxlcnQuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJGM7XG5cbnZhciBfZXhjbHVkZWQkYSA9IFtcImNsYXNzTmFtZVwiLCBcImNzc01vZHVsZVwiLCBcInRhZ1wiLCBcImlzT3BlblwiLCBcImNoaWxkcmVuXCIsIFwidHJhbnNpdGlvblwiLCBcImZhZGVcIiwgXCJpbm5lclJlZlwiXTtcbnZhciBwcm9wVHlwZXMkYiA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ubm9kZSxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgY3NzTW9kdWxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCxcbiAgZmFkZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBpc09wZW46IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcbiAgdGFnOiB0YWdQcm9wVHlwZSxcbiAgdHJhbnNpdGlvbjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zaGFwZShGYWRlLnByb3BUeXBlcyksXG4gIGlubmVyUmVmOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9uZU9mVHlwZShbUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLCBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZ1bmNdKVxufTtcbnZhciBkZWZhdWx0UHJvcHMkYiA9IHtcbiAgaXNPcGVuOiB0cnVlLFxuICB0YWc6ICdkaXYnLFxuICBmYWRlOiB0cnVlLFxuICB0cmFuc2l0aW9uOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgRmFkZS5kZWZhdWx0UHJvcHMpLCB7fSwge1xuICAgIHVubW91bnRPbkV4aXQ6IHRydWVcbiAgfSlcbn07XG5cbmZ1bmN0aW9uIFRvYXN0KHByb3BzKSB7XG4gIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjc3NNb2R1bGUgPSBwcm9wcy5jc3NNb2R1bGUsXG4gICAgICBUYWcgPSBwcm9wcy50YWcsXG4gICAgICBpc09wZW4gPSBwcm9wcy5pc09wZW4sXG4gICAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgdHJhbnNpdGlvbiA9IHByb3BzLnRyYW5zaXRpb24sXG4gICAgICBmYWRlID0gcHJvcHMuZmFkZSxcbiAgICAgIGlubmVyUmVmID0gcHJvcHMuaW5uZXJSZWYsXG4gICAgICBhdHRyaWJ1dGVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZCRhKTtcblxuICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjbGFzc05hbWUsICd0b2FzdCcpLCBjc3NNb2R1bGUpO1xuXG4gIHZhciB0b2FzdFRyYW5zaXRpb24gPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgRmFkZS5kZWZhdWx0UHJvcHMpLCB0cmFuc2l0aW9uKSwge30sIHtcbiAgICBiYXNlQ2xhc3M6IGZhZGUgPyB0cmFuc2l0aW9uLmJhc2VDbGFzcyA6ICcnLFxuICAgIHRpbWVvdXQ6IGZhZGUgPyB0cmFuc2l0aW9uLnRpbWVvdXQgOiAwXG4gIH0pO1xuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoRmFkZSwgX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIHRvYXN0VHJhbnNpdGlvbiwge1xuICAgIHRhZzogVGFnLFxuICAgIGNsYXNzTmFtZTogY2xhc3NlcyxcbiAgICBcImluXCI6IGlzT3BlbixcbiAgICByb2xlOiBcImFsZXJ0XCIsXG4gICAgaW5uZXJSZWY6IGlubmVyUmVmXG4gIH0pLCBjaGlsZHJlbik7XG59XG5cblRvYXN0LnByb3BUeXBlcyA9IHByb3BUeXBlcyRiO1xuVG9hc3QuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJGI7XG5cbnZhciBfZXhjbHVkZWQkOSA9IFtcImNsYXNzTmFtZVwiLCBcImNzc01vZHVsZVwiLCBcImlubmVyUmVmXCIsIFwidGFnXCJdO1xudmFyIHByb3BUeXBlcyRhID0ge1xuICB0YWc6IHRhZ1Byb3BUeXBlLFxuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICBjc3NNb2R1bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LFxuICBpbm5lclJlZjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vbmVPZlR5cGUoW1Byb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LCBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZywgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5mdW5jXSlcbn07XG52YXIgZGVmYXVsdFByb3BzJGEgPSB7XG4gIHRhZzogJ2Rpdidcbn07XG5cbmZ1bmN0aW9uIFRvYXN0Qm9keShwcm9wcykge1xuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY3NzTW9kdWxlID0gcHJvcHMuY3NzTW9kdWxlLFxuICAgICAgaW5uZXJSZWYgPSBwcm9wcy5pbm5lclJlZixcbiAgICAgIFRhZyA9IHByb3BzLnRhZyxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkJDkpO1xuXG4gIHZhciBjbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGNsYXNzTmFtZSwgJ3RvYXN0LWJvZHknKSwgY3NzTW9kdWxlKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChUYWcsIF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzLFxuICAgIHJlZjogaW5uZXJSZWZcbiAgfSkpO1xufVxuXG5Ub2FzdEJvZHkucHJvcFR5cGVzID0gcHJvcFR5cGVzJGE7XG5Ub2FzdEJvZHkuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJGE7XG5cbnZhciBfZXhjbHVkZWQkOCA9IFtcImNsYXNzTmFtZVwiLCBcImNzc01vZHVsZVwiLCBcImNoaWxkcmVuXCIsIFwidG9nZ2xlXCIsIFwidGFnXCIsIFwid3JhcFRhZ1wiLCBcImNsb3NlQXJpYUxhYmVsXCIsIFwiY2xvc2VcIiwgXCJ0YWdDbGFzc05hbWVcIiwgXCJpY29uXCJdO1xudmFyIHByb3BUeXBlcyQ5ID0ge1xuICB0YWc6IHRhZ1Byb3BUeXBlLFxuICBpY29uOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9uZU9mVHlwZShbUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ubm9kZV0pLFxuICB3cmFwVGFnOiB0YWdQcm9wVHlwZSxcbiAgdG9nZ2xlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZ1bmMsXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm5vZGUsXG4gIGNsb3NlQXJpYUxhYmVsOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgY2hhckNvZGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2ZUeXBlKFtQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZywgUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5udW1iZXJdKSxcbiAgY2xvc2U6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LFxuICB0YWdDbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nXG59O1xudmFyIGRlZmF1bHRQcm9wcyQ5ID0ge1xuICB0YWc6ICdzdHJvbmcnLFxuICB3cmFwVGFnOiAnZGl2JyxcbiAgdGFnQ2xhc3NOYW1lOiAnbWUtYXV0bycsXG4gIGNsb3NlQXJpYUxhYmVsOiAnQ2xvc2UnXG59O1xuXG5mdW5jdGlvbiBUb2FzdEhlYWRlcihwcm9wcykge1xuICB2YXIgY2xvc2VCdXR0b247XG4gIHZhciBpY29uO1xuXG4gIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjc3NNb2R1bGUgPSBwcm9wcy5jc3NNb2R1bGUsXG4gICAgICBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuLFxuICAgICAgdG9nZ2xlID0gcHJvcHMudG9nZ2xlLFxuICAgICAgVGFnID0gcHJvcHMudGFnLFxuICAgICAgV3JhcFRhZyA9IHByb3BzLndyYXBUYWcsXG4gICAgICBjbG9zZUFyaWFMYWJlbCA9IHByb3BzLmNsb3NlQXJpYUxhYmVsLFxuICAgICAgY2xvc2UgPSBwcm9wcy5jbG9zZSxcbiAgICAgIHRhZ0NsYXNzTmFtZSA9IHByb3BzLnRhZ0NsYXNzTmFtZSxcbiAgICAgIGljb25Qcm9wID0gcHJvcHMuaWNvbixcbiAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkJDgpO1xuXG4gIHZhciBjbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGNsYXNzTmFtZSwgJ3RvYXN0LWhlYWRlcicpLCBjc3NNb2R1bGUpO1xuXG4gIGlmICghY2xvc2UgJiYgdG9nZ2xlKSB7XG4gICAgY2xvc2VCdXR0b24gPSAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwge1xuICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgIG9uQ2xpY2s6IHRvZ2dsZSxcbiAgICAgIGNsYXNzTmFtZTogbWFwVG9Dc3NNb2R1bGVzKCdidG4tY2xvc2UnLCBjc3NNb2R1bGUpLFxuICAgICAgXCJhcmlhLWxhYmVsXCI6IGNsb3NlQXJpYUxhYmVsXG4gICAgfSk7XG4gIH1cblxuICBpZiAodHlwZW9mIGljb25Qcm9wID09PSAnc3RyaW5nJykge1xuICAgIGljb24gPSAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwge1xuICAgICAgY2xhc3NOYW1lOiBtYXBUb0Nzc01vZHVsZXMoXCJyb3VuZGVkIHRleHQtXCIgKyBpY29uUHJvcCksXG4gICAgICB3aWR0aDogXCIyMFwiLFxuICAgICAgaGVpZ2h0OiBcIjIwXCIsXG4gICAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbzogXCJ4TWlkWU1pZCBzbGljZVwiLFxuICAgICAgZm9jdXNhYmxlOiBcImZhbHNlXCIsXG4gICAgICByb2xlOiBcImltZ1wiXG4gICAgfSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7XG4gICAgICBmaWxsOiBcImN1cnJlbnRDb2xvclwiLFxuICAgICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgICAgaGVpZ2h0OiBcIjEwMCVcIlxuICAgIH0pKTtcbiAgfSBlbHNlIGlmIChpY29uUHJvcCkge1xuICAgIGljb24gPSBpY29uUHJvcDtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoV3JhcFRhZywgX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzZXNcbiAgfSksIGljb24sIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChUYWcsIHtcbiAgICBjbGFzc05hbWU6IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXSh0YWdDbGFzc05hbWUsIHtcbiAgICAgICdtcy0yJzogaWNvbiAhPSBudWxsXG4gICAgfSksIGNzc01vZHVsZSlcbiAgfSwgY2hpbGRyZW4pLCBjbG9zZSB8fCBjbG9zZUJ1dHRvbik7XG59XG5cblRvYXN0SGVhZGVyLnByb3BUeXBlcyA9IHByb3BUeXBlcyQ5O1xuVG9hc3RIZWFkZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJDk7XG5cbnZhciBfZXhjbHVkZWQkNyA9IFtcImNsYXNzTmFtZVwiLCBcImNzc01vZHVsZVwiLCBcInRhZ1wiLCBcImFjdGl2ZVwiLCBcImRpc2FibGVkXCIsIFwiYWN0aW9uXCIsIFwiY29sb3JcIl07XG52YXIgcHJvcFR5cGVzJDggPSB7XG4gIC8qKiBBZGQgYWN0aW9uIHByb3AgdG8gZ2l2ZSBlZmZlY3RzIHdoaWxlIGhvdmVyaW5nIG92ZXIgZWxlbWVudCAqL1xuICBhY3Rpb246IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcblxuICAvKiogQWRkIGFjdGl2ZSBwcm9wIHRvIG1ha2UgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGFjdGl2ZSAqL1xuICBhY3RpdmU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcblxuICAvKiogQWRkIGN1c3RvbSBjbGFzcyAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuXG4gIC8qKiBDaGFuZ2UgdW5kZXJseWluZyBjb21wb25lbnQncyBDU1MgYmFzZSBjbGFzcyBuYW1lICovXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG5cbiAgLyoqIEFkZCBiYWNrZ3JvdW5kIGNvbG91ciB0byB0aGUgbGlzdCBpdGVtICovXG4gIGNvbG9yOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcblxuICAvKiogTWFrZSB0aGUgbGlzdCBpdGVtIGFwcGVhciBkaXNhYmxlZCAqL1xuICBkaXNhYmxlZDogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuXG4gIC8qKiBTZXQgYSBjdXN0b20gZWxlbWVudCBmb3IgdGhpcyBjb21wb25lbnQgKi9cbiAgdGFnOiB0YWdQcm9wVHlwZVxufTtcbnZhciBkZWZhdWx0UHJvcHMkOCA9IHtcbiAgdGFnOiAnbGknXG59O1xuXG52YXIgaGFuZGxlRGlzYWJsZWRPbkNsaWNrID0gZnVuY3Rpb24gaGFuZGxlRGlzYWJsZWRPbkNsaWNrKGUpIHtcbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xufTtcblxuZnVuY3Rpb24gTGlzdEdyb3VwSXRlbShwcm9wcykge1xuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY3NzTW9kdWxlID0gcHJvcHMuY3NzTW9kdWxlLFxuICAgICAgVGFnID0gcHJvcHMudGFnLFxuICAgICAgYWN0aXZlID0gcHJvcHMuYWN0aXZlLFxuICAgICAgZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZCxcbiAgICAgIGFjdGlvbiA9IHByb3BzLmFjdGlvbixcbiAgICAgIGNvbG9yID0gcHJvcHMuY29sb3IsXG4gICAgICBhdHRyaWJ1dGVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZCQ3KTtcblxuICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjbGFzc05hbWUsIGFjdGl2ZSA/ICdhY3RpdmUnIDogZmFsc2UsIGRpc2FibGVkID8gJ2Rpc2FibGVkJyA6IGZhbHNlLCBhY3Rpb24gPyAnbGlzdC1ncm91cC1pdGVtLWFjdGlvbicgOiBmYWxzZSwgY29sb3IgPyBcImxpc3QtZ3JvdXAtaXRlbS1cIiArIGNvbG9yIDogZmFsc2UsICdsaXN0LWdyb3VwLWl0ZW0nKSwgY3NzTW9kdWxlKTsgLy8gUHJldmVudCBjbGljayBldmVudCB3aGVuIGRpc2FibGVkLlxuXG4gIGlmIChkaXNhYmxlZCkge1xuICAgIGF0dHJpYnV0ZXMub25DbGljayA9IGhhbmRsZURpc2FibGVkT25DbGljaztcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoVGFnLCBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3Nlc1xuICB9KSk7XG59XG5cbkxpc3RHcm91cEl0ZW0ucHJvcFR5cGVzID0gcHJvcFR5cGVzJDg7XG5MaXN0R3JvdXBJdGVtLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyQ4O1xuXG52YXIgX2V4Y2x1ZGVkJDYgPSBbXCJjbGFzc05hbWVcIiwgXCJjc3NNb2R1bGVcIiwgXCJ0YWdcIl07XG52YXIgcHJvcFR5cGVzJDcgPSB7XG4gIC8qKiBBZGQgY3VzdG9tIGNsYXNzICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG5cbiAgLyoqIENoYW5nZSB1bmRlcmx5aW5nIGNvbXBvbmVudCdzIENTUyBiYXNlIGNsYXNzIG5hbWUgKi9cbiAgY3NzTW9kdWxlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9iamVjdCxcblxuICAvKiogU2V0IGEgY3VzdG9tIGVsZW1lbnQgZm9yIHRoaXMgY29tcG9uZW50ICovXG4gIHRhZzogdGFnUHJvcFR5cGVcbn07XG52YXIgZGVmYXVsdFByb3BzJDcgPSB7XG4gIHRhZzogJ2g1J1xufTtcblxuZnVuY3Rpb24gTGlzdEdyb3VwSXRlbUhlYWRpbmcocHJvcHMpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSxcbiAgICAgIGNzc01vZHVsZSA9IHByb3BzLmNzc01vZHVsZSxcbiAgICAgIFRhZyA9IHByb3BzLnRhZyxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkJDYpO1xuXG4gIHZhciBjbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGNsYXNzTmFtZSwgJ2xpc3QtZ3JvdXAtaXRlbS1oZWFkaW5nJyksIGNzc01vZHVsZSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoVGFnLCBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3Nlc1xuICB9KSk7XG59XG5cbkxpc3RHcm91cEl0ZW1IZWFkaW5nLnByb3BUeXBlcyA9IHByb3BUeXBlcyQ3O1xuTGlzdEdyb3VwSXRlbUhlYWRpbmcuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJDc7XG5cbnZhciBfZXhjbHVkZWQkNSA9IFtcImNsYXNzTmFtZVwiLCBcImNzc01vZHVsZVwiLCBcInRhZ1wiXTtcbnZhciBwcm9wVHlwZXMkNiA9IHtcbiAgLyoqIEFkZCBjdXN0b20gY2xhc3MgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcblxuICAvKiogQ2hhbmdlIHVuZGVybHlpbmcgY29tcG9uZW50J3MgQ1NTIGJhc2UgY2xhc3MgbmFtZSAqL1xuICBjc3NNb2R1bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LFxuXG4gIC8qKiBTZXQgYSBjdXN0b20gZWxlbWVudCBmb3IgdGhpcyBjb21wb25lbnQgKi9cbiAgdGFnOiB0YWdQcm9wVHlwZVxufTtcbnZhciBkZWZhdWx0UHJvcHMkNiA9IHtcbiAgdGFnOiAncCdcbn07XG5cbmZ1bmN0aW9uIExpc3RHcm91cEl0ZW1UZXh0KHByb3BzKSB7XG4gIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjc3NNb2R1bGUgPSBwcm9wcy5jc3NNb2R1bGUsXG4gICAgICBUYWcgPSBwcm9wcy50YWcsXG4gICAgICBhdHRyaWJ1dGVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZCQ1KTtcblxuICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjbGFzc05hbWUsICdsaXN0LWdyb3VwLWl0ZW0tdGV4dCcpLCBjc3NNb2R1bGUpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzZXNcbiAgfSkpO1xufVxuXG5MaXN0R3JvdXBJdGVtVGV4dC5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkNjtcbkxpc3RHcm91cEl0ZW1UZXh0LmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyQ2O1xuXG52YXIgX2V4Y2x1ZGVkJDQgPSBbXCJjbGFzc05hbWVcIiwgXCJjc3NNb2R1bGVcIiwgXCJ0YWdcIiwgXCJ0eXBlXCJdO1xudmFyIHByb3BUeXBlcyQ1ID0ge1xuICAvKiogQWRkIGN1c3RvbSBjbGFzcyAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuXG4gIC8qKiBDaGFuZ2UgdW5kZXJseWluZyBjb21wb25lbnQncyBDU1MgYmFzZSBjbGFzcyBuYW1lICovXG4gIGNzc01vZHVsZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vYmplY3QsXG5cbiAgLyoqIFNldCBhIGN1c3RvbSBlbGVtZW50IGZvciB0aGlzIGNvbXBvbmVudCAqL1xuICB0YWc6IHRhZ1Byb3BUeXBlLFxuXG4gIC8qKiBUeXBlIG9mIGxpc3QgYHVuc3R5bGVkYCBvciBgaW5saW5lYCAqL1xuICB0eXBlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZ1xufTtcbnZhciBkZWZhdWx0UHJvcHMkNSA9IHtcbiAgdGFnOiAndWwnXG59O1xudmFyIExpc3QgPSBSZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIChwcm9wcywgcmVmKSB7XG4gIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjc3NNb2R1bGUgPSBwcm9wcy5jc3NNb2R1bGUsXG4gICAgICBUYWcgPSBwcm9wcy50YWcsXG4gICAgICB0eXBlID0gcHJvcHMudHlwZSxcbiAgICAgIGF0dHJpYnV0ZXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShwcm9wcywgX2V4Y2x1ZGVkJDQpO1xuXG4gIHZhciBjbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKGNsYXNzTmFtZSwgdHlwZSA/IFwibGlzdC1cIiArIHR5cGUgOiBmYWxzZSksIGNzc01vZHVsZSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoVGFnLCBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywge1xuICAgIGNsYXNzTmFtZTogY2xhc3NlcyxcbiAgICByZWY6IHJlZlxuICB9KSk7XG59KTtcbkxpc3QubmFtZSA9ICdMaXN0Jztcbkxpc3QucHJvcFR5cGVzID0gcHJvcFR5cGVzJDU7XG5MaXN0LmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyQ1O1xudmFyIExpc3QkMSA9IExpc3Q7XG5cbnZhciBfZXhjbHVkZWQkMyA9IFtcImNsYXNzTmFtZVwiLCBcImNzc01vZHVsZVwiLCBcInRhZ1wiXTtcbnZhciBwcm9wVHlwZXMkNCA9IHtcbiAgLyoqIEFkZCBjdXN0b20gY2xhc3MgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcblxuICAvKiogQ2hhbmdlIHVuZGVybHlpbmcgY29tcG9uZW50J3MgQ1NTIGJhc2UgY2xhc3MgbmFtZSAqL1xuICBjc3NNb2R1bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LFxuXG4gIC8qKiBTZXQgYSBjdXN0b20gZWxlbWVudCBmb3IgdGhpcyBjb21wb25lbnQgKi9cbiAgdGFnOiB0YWdQcm9wVHlwZVxufTtcbnZhciBkZWZhdWx0UHJvcHMkNCA9IHtcbiAgdGFnOiAnbGknXG59O1xudmFyIExpc3RJbmxpbmVJdGVtID0gUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIHJlZikge1xuICB2YXIgY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY3NzTW9kdWxlID0gcHJvcHMuY3NzTW9kdWxlLFxuICAgICAgVGFnID0gcHJvcHMudGFnLFxuICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQkMyk7XG5cbiAgdmFyIGNsYXNzZXMgPSBtYXBUb0Nzc01vZHVsZXMoY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oY2xhc3NOYW1lLCAnbGlzdC1pbmxpbmUtaXRlbScpLCBjc3NNb2R1bGUpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFRhZywgX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIHtcbiAgICBjbGFzc05hbWU6IGNsYXNzZXMsXG4gICAgcmVmOiByZWZcbiAgfSkpO1xufSk7XG5MaXN0SW5saW5lSXRlbS5uYW1lID0gJ0xpc3RJbmxpbmVJdGVtJztcbkxpc3RJbmxpbmVJdGVtLnByb3BUeXBlcyA9IHByb3BUeXBlcyQ0O1xuTGlzdElubGluZUl0ZW0uZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzJDQ7XG52YXIgTGlzdElubGluZUl0ZW0kMSA9IExpc3RJbmxpbmVJdGVtO1xuXG52YXIgVW5jb250cm9sbGVkQWxlcnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoVW5jb250cm9sbGVkQWxlcnQsIF9Db21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFVuY29udHJvbGxlZEFsZXJ0KHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBpc09wZW46IHRydWVcbiAgICB9O1xuICAgIF90aGlzLnRvZ2dsZSA9IF90aGlzLnRvZ2dsZS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVW5jb250cm9sbGVkQWxlcnQucHJvdG90eXBlO1xuXG4gIF9wcm90by50b2dnbGUgPSBmdW5jdGlvbiB0b2dnbGUoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAocHJldlN0YXRlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc09wZW46ICFwcmV2U3RhdGUuaXNPcGVuXG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChBbGVydCwgX2V4dGVuZHMoe1xuICAgICAgaXNPcGVuOiB0aGlzLnN0YXRlLmlzT3BlbixcbiAgICAgIHRvZ2dsZTogdGhpcy50b2dnbGVcbiAgICB9LCB0aGlzLnByb3BzKSk7XG4gIH07XG5cbiAgcmV0dXJuIFVuY29udHJvbGxlZEFsZXJ0O1xufShSZWFjdC5Db21wb25lbnQpO1xuXG52YXIgVW5jb250cm9sbGVkQWxlcnQkMSA9IFVuY29udHJvbGxlZEFsZXJ0O1xuXG52YXIgb21pdEtleXMkMyA9IFsnZGVmYXVsdE9wZW4nXTtcblxudmFyIFVuY29udHJvbGxlZEJ1dHRvbkRyb3Bkb3duID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFVuY29udHJvbGxlZEJ1dHRvbkRyb3Bkb3duLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBVbmNvbnRyb2xsZWRCdXR0b25Ecm9wZG93bihwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0NvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgaXNPcGVuOiBwcm9wcy5kZWZhdWx0T3BlbiB8fCBmYWxzZVxuICAgIH07XG4gICAgX3RoaXMudG9nZ2xlID0gX3RoaXMudG9nZ2xlLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBVbmNvbnRyb2xsZWRCdXR0b25Ecm9wZG93bi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnRvZ2dsZSA9IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChwcmV2U3RhdGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzT3BlbjogIXByZXZTdGF0ZS5pc09wZW5cbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KEJ1dHRvbkRyb3Bkb3duLCBfZXh0ZW5kcyh7XG4gICAgICBpc09wZW46IHRoaXMuc3RhdGUuaXNPcGVuLFxuICAgICAgdG9nZ2xlOiB0aGlzLnRvZ2dsZVxuICAgIH0sIG9taXQodGhpcy5wcm9wcywgb21pdEtleXMkMykpKTtcbiAgfTtcblxuICByZXR1cm4gVW5jb250cm9sbGVkQnV0dG9uRHJvcGRvd247XG59KFJlYWN0LkNvbXBvbmVudCk7XG5VbmNvbnRyb2xsZWRCdXR0b25Ecm9wZG93bi5wcm9wVHlwZXMgPSBfb2JqZWN0U3ByZWFkMih7XG4gIGRlZmF1bHRPcGVuOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2xcbn0sIEJ1dHRvbkRyb3Bkb3duLnByb3BUeXBlcyk7XG5cbnZhciBvbWl0S2V5cyQyID0gWyd0b2dnbGVFdmVudHMnLCAnZGVmYXVsdE9wZW4nXTtcbnZhciBwcm9wVHlwZXMkMyA9IHtcbiAgLyoqIHNldCBpZiBDb2xsYXBzZSBpcyBvcGVuIGJ5IGRlZmF1bHQgKi9cbiAgZGVmYXVsdE9wZW46IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbCxcblxuICAvKiogaWQgb2YgdGhlIGVsZW1lbnQgdGhhdCBzaG91bGQgdHJpZ2dlciB0b2dnbGUgKi9cbiAgdG9nZ2xlcjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcuaXNSZXF1aXJlZCxcblxuICAvKiogRXZlbnRzIHRoYXQgc2hvdWxkIHRyaWdnZXIgdGhlIHRvZ2dsZSAqL1xuICB0b2dnbGVFdmVudHM6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYXJyYXlPZihQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZylcbn07XG52YXIgZGVmYXVsdFByb3BzJDMgPSB7XG4gIHRvZ2dsZUV2ZW50czogZGVmYXVsdFRvZ2dsZUV2ZW50c1xufTtcblxudmFyIFVuY29udHJvbGxlZENvbGxhcHNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFVuY29udHJvbGxlZENvbGxhcHNlLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBVbmNvbnRyb2xsZWRDb2xsYXBzZShwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0NvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgIF90aGlzLnRvZ2dsZXJzID0gbnVsbDtcbiAgICBfdGhpcy5yZW1vdmVFdmVudExpc3RlbmVycyA9IG51bGw7XG4gICAgX3RoaXMudG9nZ2xlID0gX3RoaXMudG9nZ2xlLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgaXNPcGVuOiBwcm9wcy5kZWZhdWx0T3BlbiB8fCBmYWxzZVxuICAgIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFVuY29udHJvbGxlZENvbGxhcHNlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnRvZ2dsZXJzID0gZmluZERPTUVsZW1lbnRzKHRoaXMucHJvcHMudG9nZ2xlcik7XG5cbiAgICBpZiAodGhpcy50b2dnbGVycy5sZW5ndGgpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcnMgPSBhZGRNdWx0aXBsZUV2ZW50TGlzdGVuZXJzKHRoaXMudG9nZ2xlcnMsIHRoaXMudG9nZ2xlLCB0aGlzLnByb3BzLnRvZ2dsZUV2ZW50cyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLnRvZ2dsZXJzLmxlbmd0aCAmJiB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by50b2dnbGUgPSBmdW5jdGlvbiB0b2dnbGUoZSkge1xuICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBpc09wZW4gPSBfcmVmLmlzT3BlbjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzT3BlbjogIWlzT3BlblxuICAgICAgfTtcbiAgICB9KTtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KENvbGxhcHNlJDEsIF9leHRlbmRzKHtcbiAgICAgIGlzT3BlbjogdGhpcy5zdGF0ZS5pc09wZW5cbiAgICB9LCBvbWl0KHRoaXMucHJvcHMsIG9taXRLZXlzJDIpKSk7XG4gIH07XG5cbiAgcmV0dXJuIFVuY29udHJvbGxlZENvbGxhcHNlO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5VbmNvbnRyb2xsZWRDb2xsYXBzZS5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkMztcblVuY29udHJvbGxlZENvbGxhcHNlLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyQzO1xudmFyIFVuY29udHJvbGxlZENvbGxhcHNlJDEgPSBVbmNvbnRyb2xsZWRDb2xsYXBzZTtcblxudmFyIG9taXRLZXlzJDEgPSBbJ2RlZmF1bHRPcGVuJ107XG5cbnZhciBVbmNvbnRyb2xsZWREcm9wZG93biA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShVbmNvbnRyb2xsZWREcm9wZG93biwgX0NvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVW5jb250cm9sbGVkRHJvcGRvd24ocHJvcHMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9Db21wb25lbnQuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGlzT3BlbjogcHJvcHMuZGVmYXVsdE9wZW4gfHwgZmFsc2VcbiAgICB9O1xuICAgIF90aGlzLnRvZ2dsZSA9IF90aGlzLnRvZ2dsZS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVW5jb250cm9sbGVkRHJvcGRvd24ucHJvdG90eXBlO1xuXG4gIF9wcm90by50b2dnbGUgPSBmdW5jdGlvbiB0b2dnbGUoZSkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAocHJldlN0YXRlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc09wZW46ICFwcmV2U3RhdGUuaXNPcGVuXG4gICAgICB9O1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChfdGhpczIucHJvcHMub25Ub2dnbGUpIHtcbiAgICAgICAgX3RoaXMyLnByb3BzLm9uVG9nZ2xlKGUsIF90aGlzMi5zdGF0ZS5pc09wZW4pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChEcm9wZG93biQxLCBfZXh0ZW5kcyh7XG4gICAgICBpc09wZW46IHRoaXMuc3RhdGUuaXNPcGVuLFxuICAgICAgdG9nZ2xlOiB0aGlzLnRvZ2dsZVxuICAgIH0sIG9taXQodGhpcy5wcm9wcywgb21pdEtleXMkMSkpKTtcbiAgfTtcblxuICByZXR1cm4gVW5jb250cm9sbGVkRHJvcGRvd247XG59KFJlYWN0LkNvbXBvbmVudCk7XG5VbmNvbnRyb2xsZWREcm9wZG93bi5wcm9wVHlwZXMgPSBfb2JqZWN0U3ByZWFkMih7XG4gIGRlZmF1bHRPcGVuOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmJvb2wsXG4gIG9uVG9nZ2xlOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZ1bmNcbn0sIERyb3Bkb3duJDEucHJvcFR5cGVzKTtcblxudmFyIG9taXRLZXlzID0gWydkZWZhdWx0T3BlbiddO1xuXG52YXIgVW5jb250cm9sbGVkVG9vbHRpcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShVbmNvbnRyb2xsZWRUb29sdGlwLCBfQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBVbmNvbnRyb2xsZWRUb29sdGlwKHByb3BzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfQ29tcG9uZW50LmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBpc09wZW46IHByb3BzLmRlZmF1bHRPcGVuIHx8IGZhbHNlXG4gICAgfTtcbiAgICBfdGhpcy50b2dnbGUgPSBfdGhpcy50b2dnbGUuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFVuY29udHJvbGxlZFRvb2x0aXAucHJvdG90eXBlO1xuXG4gIF9wcm90by50b2dnbGUgPSBmdW5jdGlvbiB0b2dnbGUoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAocHJldlN0YXRlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc09wZW46ICFwcmV2U3RhdGUuaXNPcGVuXG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChUb29sdGlwLCBfZXh0ZW5kcyh7XG4gICAgICBpc09wZW46IHRoaXMuc3RhdGUuaXNPcGVuLFxuICAgICAgdG9nZ2xlOiB0aGlzLnRvZ2dsZVxuICAgIH0sIG9taXQodGhpcy5wcm9wcywgb21pdEtleXMpKSk7XG4gIH07XG5cbiAgcmV0dXJuIFVuY29udHJvbGxlZFRvb2x0aXA7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5VbmNvbnRyb2xsZWRUb29sdGlwLnByb3BUeXBlcyA9IF9vYmplY3RTcHJlYWQyKHtcbiAgZGVmYXVsdE9wZW46IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uYm9vbFxufSwgVG9vbHRpcC5wcm9wVHlwZXMpO1xuXG52YXIgX2V4Y2x1ZGVkJDIgPSBbXCJjbGFzc05hbWVcIiwgXCJjc3NNb2R1bGVcIiwgXCJ0eXBlXCIsIFwic2l6ZVwiLCBcImNvbG9yXCIsIFwiY2hpbGRyZW5cIiwgXCJ0YWdcIl07XG52YXIgcHJvcFR5cGVzJDIgPSB7XG4gIC8qKiBTZXQgYSBjdXN0b20gZWxlbWVudCBmb3IgdGhpcyBjb21wb25lbnQgKi9cbiAgdGFnOiB0YWdQcm9wVHlwZSxcblxuICAvKiogQ2hhbmdlIGFuaW1hdGlvbiBvZiBzcGlubmVyICovXG4gIHR5cGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2YoWydib3JkZXInLCAnZ3JvdyddKSxcblxuICAvKiogQ2hhbmdlIHNpemUgb2Ygc3Bpbm5lciAqL1xuICBzaXplOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9uZU9mKFsnc20nXSksXG5cbiAgLyoqIENoYW5nZSBjb2xvciBvZiBzcGlubmVyICovXG4gIGNvbG9yOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9uZU9mKFsncHJpbWFyeScsICdzZWNvbmRhcnknLCAnc3VjY2VzcycsICdkYW5nZXInLCAnd2FybmluZycsICdpbmZvJywgJ2xpZ2h0JywgJ2RhcmsnXSksXG5cbiAgLyoqIEFkZCBjdXN0b20gY2xhc3MgKi9cbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcblxuICAvKiogQ2hhbmdlIGV4aXN0aW5nIGNsYXNzTmFtZSB3aXRoIGEgbmV3IGNsYXNzTmFtZSAqL1xuICBjc3NNb2R1bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LFxuXG4gIC8qKiBQYXNzIGNoaWxkcmVuIHNvIHRoaXMgY29tcG9uZW50IGNhbiB3cmFwIHRoZSBjaGlsZCBlbGVtZW50cyAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmdcbn07XG52YXIgZGVmYXVsdFByb3BzJDIgPSB7XG4gIHRhZzogJ2RpdicsXG4gIHR5cGU6ICdib3JkZXInLFxuICBjaGlsZHJlbjogJ0xvYWRpbmcuLi4nXG59O1xuXG5mdW5jdGlvbiBTcGlubmVyKHByb3BzKSB7XG4gIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjc3NNb2R1bGUgPSBwcm9wcy5jc3NNb2R1bGUsXG4gICAgICB0eXBlID0gcHJvcHMudHlwZSxcbiAgICAgIHNpemUgPSBwcm9wcy5zaXplLFxuICAgICAgY29sb3IgPSBwcm9wcy5jb2xvcixcbiAgICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBUYWcgPSBwcm9wcy50YWcsXG4gICAgICBhdHRyaWJ1dGVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZCQyKTtcblxuICB2YXIgY2xhc3NlcyA9IG1hcFRvQ3NzTW9kdWxlcyhjbGFzc05hbWVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXShjbGFzc05hbWUsIHNpemUgPyBcInNwaW5uZXItXCIgKyB0eXBlICsgXCItXCIgKyBzaXplIDogZmFsc2UsIFwic3Bpbm5lci1cIiArIHR5cGUsIGNvbG9yID8gXCJ0ZXh0LVwiICsgY29sb3IgOiBmYWxzZSksIGNzc01vZHVsZSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoVGFnLCBfZXh0ZW5kcyh7XG4gICAgcm9sZTogXCJzdGF0dXNcIlxuICB9LCBhdHRyaWJ1dGVzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzXG4gIH0pLCBjaGlsZHJlbiAmJiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBjbGFzc05hbWU6IG1hcFRvQ3NzTW9kdWxlcygndmlzdWFsbHktaGlkZGVuJywgY3NzTW9kdWxlKVxuICB9LCBjaGlsZHJlbikpO1xufVxuXG5TcGlubmVyLnByb3BUeXBlcyA9IHByb3BUeXBlcyQyO1xuU3Bpbm5lci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHMkMjtcblxudmFyIF9leGNsdWRlZCQxID0gW1wiY2xhc3NOYW1lXCIsIFwiY3NzTW9kdWxlXCIsIFwiY29sb3JcIiwgXCJpbm5lclJlZlwiLCBcInRhZ1wiLCBcImFuaW1hdGlvblwiLCBcInNpemVcIiwgXCJ3aWR0aHNcIl07XG5cbnZhciBwcm9wVHlwZXMkMSA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBDb2wucHJvcFR5cGVzKSwge30sIHtcbiAgLyoqIEFkZCBjdXN0b20gY29sb3IgdG8gdGhlIHBsYWNlaG9sZGVyICovXG4gIGNvbG9yOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcblxuICAvKiogQWRkIGN1c3RvbSB0YWcuICovXG4gIHRhZzogdGFnUHJvcFR5cGUsXG5cbiAgLyoqIEFwcGx5IGVpdGhlciBgZ2xvd2Agb3IgYHdhdmVgIGFuaW1hdGlvbi4gKi9cbiAgYW5pbWF0aW9uOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLm9uZU9mKFsnZ2xvdycsICd3YXZlJ10pLFxuICBpbm5lclJlZjogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5vbmVPZlR5cGUoW1Byb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0LCBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmZ1bmMsIFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nXSksXG5cbiAgLyoqIE1ha2UgdGhlIHNpemUgbGFyZ2VyICovXG4gIHNpemU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub25lT2YoWydsZycsICdzbScsICd4cyddKVxufSk7XG5cbnZhciBkZWZhdWx0UHJvcHMkMSA9IHtcbiAgdGFnOiAnc3Bhbidcbn07XG5cbmZ1bmN0aW9uIFBsYWNlaG9sZGVyKHByb3BzKSB7XG4gIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjc3NNb2R1bGUgPSBwcm9wcy5jc3NNb2R1bGUsXG4gICAgICBjb2xvciA9IHByb3BzLmNvbG9yLFxuICAgICAgaW5uZXJSZWYgPSBwcm9wcy5pbm5lclJlZixcbiAgICAgIFRhZyA9IHByb3BzLnRhZyxcbiAgICAgIGFuaW1hdGlvbiA9IHByb3BzLmFuaW1hdGlvbixcbiAgICAgIHNpemUgPSBwcm9wcy5zaXplLFxuICAgICAgd2lkdGhzID0gcHJvcHMud2lkdGhzLFxuICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQkMSk7XG5cbiAgdmFyIF9nZXRDb2x1bW5DbGFzc2VzID0gZ2V0Q29sdW1uQ2xhc3NlcyhhdHRyaWJ1dGVzLCBjc3NNb2R1bGUsIHdpZHRocyksXG4gICAgICBtb2RpZmllZEF0dHJpYnV0ZXMgPSBfZ2V0Q29sdW1uQ2xhc3Nlcy5hdHRyaWJ1dGVzLFxuICAgICAgY29sQ2xhc3NlcyA9IF9nZXRDb2x1bW5DbGFzc2VzLmNvbENsYXNzZXM7XG5cbiAgdmFyIGNsYXNzZXMgPSBtYXBUb0Nzc01vZHVsZXMoY2xhc3NOYW1lc19fZGVmYXVsdFtcImRlZmF1bHRcIl0oY2xhc3NOYW1lLCBjb2xDbGFzc2VzLCAncGxhY2Vob2xkZXInICsgKGFuaW1hdGlvbiA/ICctJyArIGFuaW1hdGlvbiA6ICcnKSwgc2l6ZSA/ICdwbGFjZWhvbGRlci0nICsgc2l6ZSA6IGZhbHNlLCBjb2xvciA/ICdiZy0nICsgY29sb3IgOiBmYWxzZSksIGNzc01vZHVsZSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoVGFnLCBfZXh0ZW5kcyh7fSwgbW9kaWZpZWRBdHRyaWJ1dGVzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzLFxuICAgIHJlZjogaW5uZXJSZWZcbiAgfSkpO1xufVxuXG5QbGFjZWhvbGRlci5wcm9wVHlwZXMgPSBwcm9wVHlwZXMkMTtcblBsYWNlaG9sZGVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcyQxO1xuXG52YXIgX2V4Y2x1ZGVkID0gW1wiY3NzTW9kdWxlXCIsIFwiY2xhc3NOYW1lXCIsIFwidGFnXCJdO1xudmFyIHByb3BUeXBlcyA9IHtcbiAgc2l6ZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5zdHJpbmcsXG4gIGNvbG9yOiBQcm9wVHlwZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnN0cmluZyxcbiAgb3V0bGluZTogUHJvcFR5cGVzX19kZWZhdWx0W1wiZGVmYXVsdFwiXS5ib29sLFxuICBjbGFzc05hbWU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0uc3RyaW5nLFxuICB0YWc6IHRhZ1Byb3BUeXBlLFxuICBjc3NNb2R1bGU6IFByb3BUeXBlc19fZGVmYXVsdFtcImRlZmF1bHRcIl0ub2JqZWN0XG59O1xudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgY29sb3I6ICdwcmltYXJ5JyxcbiAgdGFnOiBCdXR0b25cbn07XG5cbmZ1bmN0aW9uIFBsYWNlaG9sZGVyQnV0dG9uKHByb3BzKSB7XG4gIHZhciBjc3NNb2R1bGUgPSBwcm9wcy5jc3NNb2R1bGUsXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBhdHRyaWJ1dGVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocHJvcHMsIF9leGNsdWRlZCk7XG5cbiAgdmFyIF9nZXRDb2x1bW5DbGFzc2VzID0gZ2V0Q29sdW1uQ2xhc3NlcyhhdHRyaWJ1dGVzLCBjc3NNb2R1bGUpLFxuICAgICAgbW9kaWZpZWRBdHRyaWJ1dGVzID0gX2dldENvbHVtbkNsYXNzZXMuYXR0cmlidXRlcyxcbiAgICAgIGNvbENsYXNzZXMgPSBfZ2V0Q29sdW1uQ2xhc3Nlcy5jb2xDbGFzc2VzO1xuXG4gIHZhciBjbGFzc2VzID0gbWFwVG9Dc3NNb2R1bGVzKGNsYXNzTmFtZXNfX2RlZmF1bHRbXCJkZWZhdWx0XCJdKCdwbGFjZWhvbGRlcicsIGNsYXNzTmFtZSwgY29sQ2xhc3NlcyksIGNzc01vZHVsZSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoQnV0dG9uLCBfZXh0ZW5kcyh7fSwgbW9kaWZpZWRBdHRyaWJ1dGVzLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc2VzLFxuICAgIGRpc2FibGVkOiB0cnVlXG4gIH0pKTtcbn1cblxuUGxhY2Vob2xkZXJCdXR0b24ucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuUGxhY2Vob2xkZXJCdXR0b24uZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuXG4oZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuXG4gIHZhciBDdXN0b21FdmVudCA9IGZ1bmN0aW9uIEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMpIHtcbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge1xuICAgICAgYnViYmxlczogZmFsc2UsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgIGRldGFpbDogbnVsbFxuICAgIH07XG4gICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSwgcGFyYW1zLmRldGFpbCk7XG4gICAgcmV0dXJuIGV2dDtcbiAgfTtcblxuICB3aW5kb3cuQ3VzdG9tRXZlbnQgPSBDdXN0b21FdmVudDtcbn0pKCk7XG5cbihmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgT2JqZWN0LnZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuXG4gIHZhciB2YWx1ZXMgPSBmdW5jdGlvbiB2YWx1ZXMoTykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhPKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIE9ba2V5XTtcbiAgICB9KTtcbiAgfTtcblxuICBPYmplY3QudmFsdWVzID0gdmFsdWVzO1xufSkoKTtcblxudmFyIHBvbHlmaWxsID0ge1xuICBfX3Byb3RvX186IG51bGxcbn07XG5cbmV4cG9ydHMuQWNjb3JkaW9uID0gQWNjb3JkaW9uO1xuZXhwb3J0cy5BY2NvcmRpb25Cb2R5ID0gQWNjb3JkaW9uQm9keTtcbmV4cG9ydHMuQWNjb3JkaW9uQ29udGV4dCA9IEFjY29yZGlvbkNvbnRleHQ7XG5leHBvcnRzLkFjY29yZGlvbkhlYWRlciA9IEFjY29yZGlvbkhlYWRlcjtcbmV4cG9ydHMuQWNjb3JkaW9uSXRlbSA9IEFjY29yZGlvbkl0ZW07XG5leHBvcnRzLkFsZXJ0ID0gQWxlcnQ7XG5leHBvcnRzLkJhZGdlID0gQmFkZ2U7XG5leHBvcnRzLkJyZWFkY3J1bWIgPSBCcmVhZGNydW1iO1xuZXhwb3J0cy5CcmVhZGNydW1iSXRlbSA9IEJyZWFkY3J1bWJJdGVtO1xuZXhwb3J0cy5CdXR0b24gPSBCdXR0b247XG5leHBvcnRzLkJ1dHRvbkRyb3Bkb3duID0gQnV0dG9uRHJvcGRvd247XG5leHBvcnRzLkJ1dHRvbkdyb3VwID0gQnV0dG9uR3JvdXA7XG5leHBvcnRzLkJ1dHRvblRvZ2dsZSA9IEJ1dHRvblRvZ2dsZTtcbmV4cG9ydHMuQnV0dG9uVG9vbGJhciA9IEJ1dHRvblRvb2xiYXI7XG5leHBvcnRzLkNhcmQgPSBDYXJkO1xuZXhwb3J0cy5DYXJkQm9keSA9IENhcmRCb2R5O1xuZXhwb3J0cy5DYXJkQ29sdW1ucyA9IENhcmRDb2x1bW5zO1xuZXhwb3J0cy5DYXJkRGVjayA9IENhcmREZWNrO1xuZXhwb3J0cy5DYXJkRm9vdGVyID0gQ2FyZEZvb3RlcjtcbmV4cG9ydHMuQ2FyZEdyb3VwID0gQ2FyZEdyb3VwO1xuZXhwb3J0cy5DYXJkSGVhZGVyID0gQ2FyZEhlYWRlcjtcbmV4cG9ydHMuQ2FyZEltZyA9IENhcmRJbWc7XG5leHBvcnRzLkNhcmRJbWdPdmVybGF5ID0gQ2FyZEltZ092ZXJsYXk7XG5leHBvcnRzLkNhcmRMaW5rID0gQ2FyZExpbms7XG5leHBvcnRzLkNhcmRTdWJ0aXRsZSA9IENhcmRTdWJ0aXRsZTtcbmV4cG9ydHMuQ2FyZFRleHQgPSBDYXJkVGV4dDtcbmV4cG9ydHMuQ2FyZFRpdGxlID0gQ2FyZFRpdGxlO1xuZXhwb3J0cy5DYXJvdXNlbCA9IENhcm91c2VsJDE7XG5leHBvcnRzLkNhcm91c2VsQ2FwdGlvbiA9IENhcm91c2VsQ2FwdGlvbjtcbmV4cG9ydHMuQ2Fyb3VzZWxDb250cm9sID0gQ2Fyb3VzZWxDb250cm9sO1xuZXhwb3J0cy5DYXJvdXNlbEluZGljYXRvcnMgPSBDYXJvdXNlbEluZGljYXRvcnM7XG5leHBvcnRzLkNhcm91c2VsSXRlbSA9IENhcm91c2VsSXRlbSQxO1xuZXhwb3J0cy5DbG9zZUJ1dHRvbiA9IENsb3NlQnV0dG9uO1xuZXhwb3J0cy5Db2wgPSBDb2w7XG5leHBvcnRzLkNvbGxhcHNlID0gQ29sbGFwc2UkMTtcbmV4cG9ydHMuQ29udGFpbmVyID0gQ29udGFpbmVyO1xuZXhwb3J0cy5Ecm9wZG93biA9IERyb3Bkb3duJDE7XG5leHBvcnRzLkRyb3Bkb3duQ29udGV4dCA9IERyb3Bkb3duQ29udGV4dDtcbmV4cG9ydHMuRHJvcGRvd25JdGVtID0gRHJvcGRvd25JdGVtJDE7XG5leHBvcnRzLkRyb3Bkb3duTWVudSA9IERyb3Bkb3duTWVudSQxO1xuZXhwb3J0cy5Ecm9wZG93blRvZ2dsZSA9IERyb3Bkb3duVG9nZ2xlJDE7XG5leHBvcnRzLkZhZGUgPSBGYWRlO1xuZXhwb3J0cy5Gb3JtID0gRm9ybSQxO1xuZXhwb3J0cy5Gb3JtRmVlZGJhY2sgPSBGb3JtRmVlZGJhY2s7XG5leHBvcnRzLkZvcm1Hcm91cCA9IEZvcm1Hcm91cDtcbmV4cG9ydHMuRm9ybVRleHQgPSBGb3JtVGV4dDtcbmV4cG9ydHMuSW5wdXQgPSBJbnB1dCQxO1xuZXhwb3J0cy5JbnB1dEdyb3VwID0gSW5wdXRHcm91cDtcbmV4cG9ydHMuSW5wdXRHcm91cFRleHQgPSBJbnB1dEdyb3VwVGV4dDtcbmV4cG9ydHMuTGFiZWwgPSBMYWJlbDtcbmV4cG9ydHMuTGlzdCA9IExpc3QkMTtcbmV4cG9ydHMuTGlzdEdyb3VwID0gTGlzdEdyb3VwO1xuZXhwb3J0cy5MaXN0R3JvdXBJdGVtID0gTGlzdEdyb3VwSXRlbTtcbmV4cG9ydHMuTGlzdEdyb3VwSXRlbUhlYWRpbmcgPSBMaXN0R3JvdXBJdGVtSGVhZGluZztcbmV4cG9ydHMuTGlzdEdyb3VwSXRlbVRleHQgPSBMaXN0R3JvdXBJdGVtVGV4dDtcbmV4cG9ydHMuTGlzdElubGluZUl0ZW0gPSBMaXN0SW5saW5lSXRlbSQxO1xuZXhwb3J0cy5NZWRpYSA9IE1lZGlhO1xuZXhwb3J0cy5Nb2RhbCA9IE1vZGFsJDE7XG5leHBvcnRzLk1vZGFsQm9keSA9IE1vZGFsQm9keTtcbmV4cG9ydHMuTW9kYWxGb290ZXIgPSBNb2RhbEZvb3RlcjtcbmV4cG9ydHMuTW9kYWxIZWFkZXIgPSBNb2RhbEhlYWRlcjtcbmV4cG9ydHMuTmF2ID0gTmF2O1xuZXhwb3J0cy5OYXZJdGVtID0gTmF2SXRlbTtcbmV4cG9ydHMuTmF2TGluayA9IE5hdkxpbmskMTtcbmV4cG9ydHMuTmF2YmFyID0gTmF2YmFyO1xuZXhwb3J0cy5OYXZiYXJCcmFuZCA9IE5hdmJhckJyYW5kO1xuZXhwb3J0cy5OYXZiYXJUZXh0ID0gTmF2YmFyVGV4dDtcbmV4cG9ydHMuTmF2YmFyVG9nZ2xlciA9IE5hdmJhclRvZ2dsZXI7XG5leHBvcnRzLk9mZmNhbnZhcyA9IE9mZmNhbnZhcyQxO1xuZXhwb3J0cy5PZmZjYW52YXNCb2R5ID0gT2ZmY2FudmFzQm9keTtcbmV4cG9ydHMuT2ZmY2FudmFzSGVhZGVyID0gT2ZmY2FudmFzSGVhZGVyO1xuZXhwb3J0cy5QYWdpbmF0aW9uID0gUGFnaW5hdGlvbjtcbmV4cG9ydHMuUGFnaW5hdGlvbkl0ZW0gPSBQYWdpbmF0aW9uSXRlbTtcbmV4cG9ydHMuUGFnaW5hdGlvbkxpbmsgPSBQYWdpbmF0aW9uTGluaztcbmV4cG9ydHMuUGxhY2Vob2xkZXIgPSBQbGFjZWhvbGRlcjtcbmV4cG9ydHMuUGxhY2Vob2xkZXJCdXR0b24gPSBQbGFjZWhvbGRlckJ1dHRvbjtcbmV4cG9ydHMuUG9seWZpbGwgPSBwb2x5ZmlsbDtcbmV4cG9ydHMuUG9wb3ZlciA9IFBvcG92ZXI7XG5leHBvcnRzLlBvcG92ZXJCb2R5ID0gUG9wb3ZlckJvZHk7XG5leHBvcnRzLlBvcG92ZXJIZWFkZXIgPSBQb3BvdmVySGVhZGVyO1xuZXhwb3J0cy5Qb3BwZXJDb250ZW50ID0gUG9wcGVyQ29udGVudCQxO1xuZXhwb3J0cy5Qb3BwZXJUYXJnZXRIZWxwZXIgPSBQb3BwZXJUYXJnZXRIZWxwZXI7XG5leHBvcnRzLlByb2dyZXNzID0gUHJvZ3Jlc3M7XG5leHBvcnRzLlJvdyA9IFJvdztcbmV4cG9ydHMuU3Bpbm5lciA9IFNwaW5uZXI7XG5leHBvcnRzLlRhYkNvbnRlbnQgPSBUYWJDb250ZW50JDE7XG5leHBvcnRzLlRhYlBhbmUgPSBUYWJQYW5lO1xuZXhwb3J0cy5UYWJsZSA9IFRhYmxlO1xuZXhwb3J0cy5Ub2FzdCA9IFRvYXN0O1xuZXhwb3J0cy5Ub2FzdEJvZHkgPSBUb2FzdEJvZHk7XG5leHBvcnRzLlRvYXN0SGVhZGVyID0gVG9hc3RIZWFkZXI7XG5leHBvcnRzLlRvb2x0aXAgPSBUb29sdGlwO1xuZXhwb3J0cy5VbmNvbnRyb2xsZWRBY2NvcmRpb24gPSBVbmNvbnRyb2xsZWRBY2NvcmRpb247XG5leHBvcnRzLlVuY29udHJvbGxlZEFsZXJ0ID0gVW5jb250cm9sbGVkQWxlcnQkMTtcbmV4cG9ydHMuVW5jb250cm9sbGVkQnV0dG9uRHJvcGRvd24gPSBVbmNvbnRyb2xsZWRCdXR0b25Ecm9wZG93bjtcbmV4cG9ydHMuVW5jb250cm9sbGVkQ2Fyb3VzZWwgPSBVbmNvbnRyb2xsZWRDYXJvdXNlbCQxO1xuZXhwb3J0cy5VbmNvbnRyb2xsZWRDb2xsYXBzZSA9IFVuY29udHJvbGxlZENvbGxhcHNlJDE7XG5leHBvcnRzLlVuY29udHJvbGxlZERyb3Bkb3duID0gVW5jb250cm9sbGVkRHJvcGRvd247XG5leHBvcnRzLlVuY29udHJvbGxlZFBvcG92ZXIgPSBVbmNvbnRyb2xsZWRQb3BvdmVyO1xuZXhwb3J0cy5VbmNvbnRyb2xsZWRUb29sdGlwID0gVW5jb250cm9sbGVkVG9vbHRpcDtcbmV4cG9ydHMuVXRpbCA9IHV0aWxzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3RzdHJhcC5janMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/reactstrap/dist/reactstrap.cjs\n");

/***/ }),

/***/ "./node_modules/ts-invariant/lib/invariant.cjs":
/*!*****************************************************!*\
  !*** ./node_modules/ts-invariant/lib/invariant.cjs ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar tslib = __webpack_require__(/*! tslib */ \"tslib\");\n\nvar genericMessage = \"Invariant Violation\";\nvar _a = Object.setPrototypeOf, setPrototypeOf = _a === void 0 ? function (obj, proto) {\n    obj.__proto__ = proto;\n    return obj;\n} : _a;\nvar InvariantError = /** @class */ (function (_super) {\n    tslib.__extends(InvariantError, _super);\n    function InvariantError(message) {\n        if (message === void 0) { message = genericMessage; }\n        var _this = _super.call(this, typeof message === \"number\"\n            ? genericMessage + \": \" + message + \" (see https://github.com/apollographql/invariant-packages)\"\n            : message) || this;\n        _this.framesToPop = 1;\n        _this.name = genericMessage;\n        setPrototypeOf(_this, InvariantError.prototype);\n        return _this;\n    }\n    return InvariantError;\n}(Error));\nfunction invariant(condition, message) {\n    if (!condition) {\n        throw new InvariantError(message);\n    }\n}\nvar verbosityLevels = [\"debug\", \"log\", \"warn\", \"error\", \"silent\"];\nvar verbosityLevel = verbosityLevels.indexOf(\"log\");\nfunction wrapConsoleMethod(name) {\n    return function () {\n        if (verbosityLevels.indexOf(name) >= verbosityLevel) {\n            // Default to console.log if this host environment happens not to provide\n            // all the console.* methods we need.\n            var method = console[name] || console.log;\n            return method.apply(console, arguments);\n        }\n    };\n}\n(function (invariant) {\n    invariant.debug = wrapConsoleMethod(\"debug\");\n    invariant.log = wrapConsoleMethod(\"log\");\n    invariant.warn = wrapConsoleMethod(\"warn\");\n    invariant.error = wrapConsoleMethod(\"error\");\n})(invariant || (invariant = {}));\nfunction setVerbosity(level) {\n    var old = verbosityLevels[verbosityLevel];\n    verbosityLevel = Math.max(0, verbosityLevels.indexOf(level));\n    return old;\n}\nvar invariant$1 = invariant;\n\nexports.InvariantError = InvariantError;\nexports[\"default\"] = invariant$1;\nexports.invariant = invariant;\nexports.setVerbosity = setVerbosity;\n//# sourceMappingURL=invariant.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHMtaW52YXJpYW50L2xpYi9pbnZhcmlhbnQuY2pzP2JjODMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQThDLGNBQWM7O0FBRTVELFlBQVksbUJBQU8sQ0FBQyxvQkFBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDBCQUEwQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy90cy1pbnZhcmlhbnQvbGliL2ludmFyaWFudC5janMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciB0c2xpYiA9IHJlcXVpcmUoJ3RzbGliJyk7XG5cbnZhciBnZW5lcmljTWVzc2FnZSA9IFwiSW52YXJpYW50IFZpb2xhdGlvblwiO1xudmFyIF9hID0gT2JqZWN0LnNldFByb3RvdHlwZU9mLCBzZXRQcm90b3R5cGVPZiA9IF9hID09PSB2b2lkIDAgPyBmdW5jdGlvbiAob2JqLCBwcm90bykge1xuICAgIG9iai5fX3Byb3RvX18gPSBwcm90bztcbiAgICByZXR1cm4gb2JqO1xufSA6IF9hO1xudmFyIEludmFyaWFudEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhJbnZhcmlhbnRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbnZhcmlhbnRFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlID09PSB2b2lkIDApIHsgbWVzc2FnZSA9IGdlbmVyaWNNZXNzYWdlOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGVvZiBtZXNzYWdlID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICA/IGdlbmVyaWNNZXNzYWdlICsgXCI6IFwiICsgbWVzc2FnZSArIFwiIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Fwb2xsb2dyYXBocWwvaW52YXJpYW50LXBhY2thZ2VzKVwiXG4gICAgICAgICAgICA6IG1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmZyYW1lc1RvUG9wID0gMTtcbiAgICAgICAgX3RoaXMubmFtZSA9IGdlbmVyaWNNZXNzYWdlO1xuICAgICAgICBzZXRQcm90b3R5cGVPZihfdGhpcywgSW52YXJpYW50RXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSW52YXJpYW50RXJyb3I7XG59KEVycm9yKSk7XG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFyaWFudEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbn1cbnZhciB2ZXJib3NpdHlMZXZlbHMgPSBbXCJkZWJ1Z1wiLCBcImxvZ1wiLCBcIndhcm5cIiwgXCJlcnJvclwiLCBcInNpbGVudFwiXTtcbnZhciB2ZXJib3NpdHlMZXZlbCA9IHZlcmJvc2l0eUxldmVscy5pbmRleE9mKFwibG9nXCIpO1xuZnVuY3Rpb24gd3JhcENvbnNvbGVNZXRob2QobmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh2ZXJib3NpdHlMZXZlbHMuaW5kZXhPZihuYW1lKSA+PSB2ZXJib3NpdHlMZXZlbCkge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBjb25zb2xlLmxvZyBpZiB0aGlzIGhvc3QgZW52aXJvbm1lbnQgaGFwcGVucyBub3QgdG8gcHJvdmlkZVxuICAgICAgICAgICAgLy8gYWxsIHRoZSBjb25zb2xlLiogbWV0aG9kcyB3ZSBuZWVkLlxuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IGNvbnNvbGVbbmFtZV0gfHwgY29uc29sZS5sb2c7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuKGZ1bmN0aW9uIChpbnZhcmlhbnQpIHtcbiAgICBpbnZhcmlhbnQuZGVidWcgPSB3cmFwQ29uc29sZU1ldGhvZChcImRlYnVnXCIpO1xuICAgIGludmFyaWFudC5sb2cgPSB3cmFwQ29uc29sZU1ldGhvZChcImxvZ1wiKTtcbiAgICBpbnZhcmlhbnQud2FybiA9IHdyYXBDb25zb2xlTWV0aG9kKFwid2FyblwiKTtcbiAgICBpbnZhcmlhbnQuZXJyb3IgPSB3cmFwQ29uc29sZU1ldGhvZChcImVycm9yXCIpO1xufSkoaW52YXJpYW50IHx8IChpbnZhcmlhbnQgPSB7fSkpO1xuZnVuY3Rpb24gc2V0VmVyYm9zaXR5KGxldmVsKSB7XG4gICAgdmFyIG9sZCA9IHZlcmJvc2l0eUxldmVsc1t2ZXJib3NpdHlMZXZlbF07XG4gICAgdmVyYm9zaXR5TGV2ZWwgPSBNYXRoLm1heCgwLCB2ZXJib3NpdHlMZXZlbHMuaW5kZXhPZihsZXZlbCkpO1xuICAgIHJldHVybiBvbGQ7XG59XG52YXIgaW52YXJpYW50JDEgPSBpbnZhcmlhbnQ7XG5cbmV4cG9ydHMuSW52YXJpYW50RXJyb3IgPSBJbnZhcmlhbnRFcnJvcjtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gaW52YXJpYW50JDE7XG5leHBvcnRzLmludmFyaWFudCA9IGludmFyaWFudDtcbmV4cG9ydHMuc2V0VmVyYm9zaXR5ID0gc2V0VmVyYm9zaXR5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW52YXJpYW50LmNqcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ts-invariant/lib/invariant.cjs\n");

/***/ }),

/***/ "./node_modules/ts-invariant/process/main.cjs":
/*!****************************************************!*\
  !*** ./node_modules/ts-invariant/process/main.cjs ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction maybe(thunk) {\n  try { return thunk() } catch (_) {}\n}\n\nvar safeGlobal = (\n  maybe(function() { return globalThis }) ||\n  maybe(function() { return window }) ||\n  maybe(function() { return self }) ||\n  maybe(function() { return global }) ||\n  // We don't expect the Function constructor ever to be invoked at runtime, as\n  // long as at least one of globalThis, window, self, or global is defined, so\n  // we are under no obligation to make it easy for static analysis tools to\n  // detect syntactic usage of the Function constructor. If you think you can\n  // improve your static analysis to detect this obfuscation, think again. This\n  // is an arms race you cannot win, at least not in JavaScript.\n  maybe(function() { return maybe.constructor(\"return this\")() })\n);\n\nvar needToRemove = false;\n\nfunction install() {\n  if (safeGlobal &&\n      !maybe(function() { return \"development\" }) &&\n      !maybe(function() { return process })) {\n    Object.defineProperty(safeGlobal, \"process\", {\n      value: {\n        env: {\n          // This default needs to be \"production\" instead of \"development\", to\n          // avoid the problem https://github.com/graphql/graphql-js/pull/2894\n          // will eventually solve, once merged and released.\n          NODE_ENV: \"production\",\n        },\n      },\n      // Let anyone else change global.process as they see fit, but hide it from\n      // Object.keys(global) enumeration.\n      configurable: true,\n      enumerable: false,\n      writable: true,\n    });\n    needToRemove = true;\n  }\n}\n\n// Call install() at least once, when this module is imported.\ninstall();\n\nfunction remove() {\n  if (needToRemove) {\n    delete safeGlobal.process;\n    needToRemove = false;\n  }\n}\n\nexports.install = install;\nexports.remove = remove;\n//# sourceMappingURL=main.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHMtaW52YXJpYW50L3Byb2Nlc3MvbWFpbi5janM/ZjJiNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBOEMsY0FBYzs7QUFFNUQ7QUFDQSxPQUFPLGlCQUFpQjtBQUN4Qjs7QUFFQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEMsb0JBQW9CLGdCQUFnQjtBQUNwQyxvQkFBb0IsY0FBYztBQUNsQyxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0Q0FBNEM7QUFDaEU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixRQUFRLGFBQW9CLEVBQUU7QUFDdkQseUJBQXlCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3RzLWludmFyaWFudC9wcm9jZXNzL21haW4uY2pzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBtYXliZSh0aHVuaykge1xuICB0cnkgeyByZXR1cm4gdGh1bmsoKSB9IGNhdGNoIChfKSB7fVxufVxuXG52YXIgc2FmZUdsb2JhbCA9IChcbiAgbWF5YmUoZnVuY3Rpb24oKSB7IHJldHVybiBnbG9iYWxUaGlzIH0pIHx8XG4gIG1heWJlKGZ1bmN0aW9uKCkgeyByZXR1cm4gd2luZG93IH0pIHx8XG4gIG1heWJlKGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZiB9KSB8fFxuICBtYXliZShmdW5jdGlvbigpIHsgcmV0dXJuIGdsb2JhbCB9KSB8fFxuICAvLyBXZSBkb24ndCBleHBlY3QgdGhlIEZ1bmN0aW9uIGNvbnN0cnVjdG9yIGV2ZXIgdG8gYmUgaW52b2tlZCBhdCBydW50aW1lLCBhc1xuICAvLyBsb25nIGFzIGF0IGxlYXN0IG9uZSBvZiBnbG9iYWxUaGlzLCB3aW5kb3csIHNlbGYsIG9yIGdsb2JhbCBpcyBkZWZpbmVkLCBzb1xuICAvLyB3ZSBhcmUgdW5kZXIgbm8gb2JsaWdhdGlvbiB0byBtYWtlIGl0IGVhc3kgZm9yIHN0YXRpYyBhbmFseXNpcyB0b29scyB0b1xuICAvLyBkZXRlY3Qgc3ludGFjdGljIHVzYWdlIG9mIHRoZSBGdW5jdGlvbiBjb25zdHJ1Y3Rvci4gSWYgeW91IHRoaW5rIHlvdSBjYW5cbiAgLy8gaW1wcm92ZSB5b3VyIHN0YXRpYyBhbmFseXNpcyB0byBkZXRlY3QgdGhpcyBvYmZ1c2NhdGlvbiwgdGhpbmsgYWdhaW4uIFRoaXNcbiAgLy8gaXMgYW4gYXJtcyByYWNlIHlvdSBjYW5ub3Qgd2luLCBhdCBsZWFzdCBub3QgaW4gSmF2YVNjcmlwdC5cbiAgbWF5YmUoZnVuY3Rpb24oKSB7IHJldHVybiBtYXliZS5jb25zdHJ1Y3RvcihcInJldHVybiB0aGlzXCIpKCkgfSlcbik7XG5cbnZhciBuZWVkVG9SZW1vdmUgPSBmYWxzZTtcblxuZnVuY3Rpb24gaW5zdGFsbCgpIHtcbiAgaWYgKHNhZmVHbG9iYWwgJiZcbiAgICAgICFtYXliZShmdW5jdGlvbigpIHsgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WIH0pICYmXG4gICAgICAhbWF5YmUoZnVuY3Rpb24oKSB7IHJldHVybiBwcm9jZXNzIH0pKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNhZmVHbG9iYWwsIFwicHJvY2Vzc1wiLCB7XG4gICAgICB2YWx1ZToge1xuICAgICAgICBlbnY6IHtcbiAgICAgICAgICAvLyBUaGlzIGRlZmF1bHQgbmVlZHMgdG8gYmUgXCJwcm9kdWN0aW9uXCIgaW5zdGVhZCBvZiBcImRldmVsb3BtZW50XCIsIHRvXG4gICAgICAgICAgLy8gYXZvaWQgdGhlIHByb2JsZW0gaHR0cHM6Ly9naXRodWIuY29tL2dyYXBocWwvZ3JhcGhxbC1qcy9wdWxsLzI4OTRcbiAgICAgICAgICAvLyB3aWxsIGV2ZW50dWFsbHkgc29sdmUsIG9uY2UgbWVyZ2VkIGFuZCByZWxlYXNlZC5cbiAgICAgICAgICBOT0RFX0VOVjogXCJwcm9kdWN0aW9uXCIsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgLy8gTGV0IGFueW9uZSBlbHNlIGNoYW5nZSBnbG9iYWwucHJvY2VzcyBhcyB0aGV5IHNlZSBmaXQsIGJ1dCBoaWRlIGl0IGZyb21cbiAgICAgIC8vIE9iamVjdC5rZXlzKGdsb2JhbCkgZW51bWVyYXRpb24uXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIH0pO1xuICAgIG5lZWRUb1JlbW92ZSA9IHRydWU7XG4gIH1cbn1cblxuLy8gQ2FsbCBpbnN0YWxsKCkgYXQgbGVhc3Qgb25jZSwgd2hlbiB0aGlzIG1vZHVsZSBpcyBpbXBvcnRlZC5cbmluc3RhbGwoKTtcblxuZnVuY3Rpb24gcmVtb3ZlKCkge1xuICBpZiAobmVlZFRvUmVtb3ZlKSB7XG4gICAgZGVsZXRlIHNhZmVHbG9iYWwucHJvY2VzcztcbiAgICBuZWVkVG9SZW1vdmUgPSBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnRzLmluc3RhbGwgPSBpbnN0YWxsO1xuZXhwb3J0cy5yZW1vdmUgPSByZW1vdmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWluLmNqcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ts-invariant/process/main.cjs\n");

/***/ }),

/***/ "./node_modules/zen-observable-ts/index.cjs":
/*!**************************************************!*\
  !*** ./node_modules/zen-observable-ts/index.cjs ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports.Observable = __webpack_require__(/*! zen-observable/index.js */ \"zen-observable/index.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvemVuLW9ic2VydmFibGUtdHMvaW5kZXguY2pzPzkwMGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEscUJBQXFCLG1CQUFPLENBQUMsd0RBQXlCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3plbi1vYnNlcnZhYmxlLXRzL2luZGV4LmNqcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMuT2JzZXJ2YWJsZSA9IHJlcXVpcmUoXCJ6ZW4tb2JzZXJ2YWJsZS9pbmRleC5qc1wiKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zen-observable-ts/index.cjs\n");

/***/ }),

/***/ "./pages/client.js":
/*!*************************!*\
  !*** ./pages/client.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @apollo/client */ \"./node_modules/@apollo/client/main.cjs\");\n/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_apollo_client__WEBPACK_IMPORTED_MODULE_0__);\n\nconst API_URL = \"http://localhost:1337\" || false;\nconst link = new _apollo_client__WEBPACK_IMPORTED_MODULE_0__[\"HttpLink\"]({\n  uri: `${API_URL}/graphql`\n});\nconst cache = new _apollo_client__WEBPACK_IMPORTED_MODULE_0__[\"InMemoryCache\"]();\nconst client = new _apollo_client__WEBPACK_IMPORTED_MODULE_0__[\"ApolloClient\"]({\n  link,\n  cache\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (client);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWdlcy9jbGllbnQuanM/YWZkZSJdLCJuYW1lcyI6WyJBUElfVVJMIiwicHJvY2VzcyIsImxpbmsiLCJIdHRwTGluayIsInVyaSIsImNhY2hlIiwiSW5NZW1vcnlDYWNoZSIsImNsaWVudCIsIkFwb2xsb0NsaWVudCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBS3dCO0FBRXhCLE1BQU1BLE9BQU8sR0FBR0MsdUJBQStCLElBQUksS0FBdUI7QUFDMUUsTUFBTUMsSUFBSSxHQUFHLElBQUlDLHVEQUFRLENBQUM7RUFBRUMsR0FBRyxFQUFHLEdBQUVKLE9BQVE7QUFBVSxDQUFDLENBQUM7QUFDeEQsTUFBTUssS0FBSyxHQUFHLElBQUlDLDREQUFhLEVBQUU7QUFDakMsTUFBTUMsTUFBTSxHQUFHLElBQUlDLDJEQUFZLENBQUM7RUFBRU4sSUFBSTtFQUFFRztBQUFNLENBQUMsQ0FBQztBQUNqQ0UscUVBQU0iLCJmaWxlIjoiLi9wYWdlcy9jbGllbnQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBcG9sbG9Qcm92aWRlcixcbiAgQXBvbGxvQ2xpZW50LFxuICBIdHRwTGluayxcbiAgSW5NZW1vcnlDYWNoZSxcbn0gZnJvbSBcIkBhcG9sbG8vY2xpZW50XCI7XG5cbmNvbnN0IEFQSV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8IFwiaHR0cDovL2xvY2FsaG9zdDoxMzM3XCI7XG5jb25zdCBsaW5rID0gbmV3IEh0dHBMaW5rKHsgdXJpOiBgJHtBUElfVVJMfS9ncmFwaHFsYCB9KTtcbmNvbnN0IGNhY2hlID0gbmV3IEluTWVtb3J5Q2FjaGUoKTtcbmNvbnN0IGNsaWVudCA9IG5ldyBBcG9sbG9DbGllbnQoeyBsaW5rLCBjYWNoZSB9KTtcbmV4cG9ydCBkZWZhdWx0IGNsaWVudDtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/client.js\n");

/***/ }),

/***/ "./pages/index.js":
/*!************************!*\
  !*** ./pages/index.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_cart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/cart */ \"./components/cart.js\");\n/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @apollo/client */ \"./node_modules/@apollo/client/main.cjs\");\n/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_apollo_client__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _restaurants_restaurantList__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./restaurants/restaurantList */ \"./pages/restaurants/restaurantList.js\");\n/* harmony import */ var reactstrap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! reactstrap */ \"./node_modules/reactstrap/dist/reactstrap.cjs\");\n/* harmony import */ var reactstrap__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(reactstrap__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _components_context__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/context */ \"./components/context.js\");\n/* harmony import */ var _client__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./client */ \"./pages/client.js\");\nvar _jsxFileName = \"/Users/carloszapata/Desktop/CAPSTONE/main/root/frontend/pages/index.js\";\nvar __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;\n\n\n\n\n\n\n\nfunction Home() {\n  const addItem = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(_components_context__WEBPACK_IMPORTED_MODULE_5__[\"default\"]);\n  const {\n    0: query,\n    1: setQuery\n  } = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(\"\");\n  return __jsx(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__[\"Container\"], {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 20,\n      columnNumber: 7\n    }\n  }, __jsx(\"div\", {\n    className: \"search\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 21,\n      columnNumber: 9\n    }\n  }, __jsx(\"h2\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 22,\n      columnNumber: 11\n    }\n  }, \" Local Restaurants\"), __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__[\"InputGroup\"], {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 23,\n      columnNumber: 11\n    }\n  }, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__[\"InputGroup\"], {\n    type: \"append\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 24,\n      columnNumber: 13\n    }\n  }, \" Search \"), __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__[\"Input\"], {\n    onChange: e => setQuery(e.target.value.toLocaleLowerCase()),\n    value: query,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 25,\n      columnNumber: 13\n    }\n  })), __jsx(\"br\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 30,\n      columnNumber: 11\n    }\n  }))), __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__[\"Row\"], {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 33,\n      columnNumber: 7\n    }\n  }, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__[\"Col\"], {\n    className: \"bg-dark border\",\n    md: \"8\",\n    lg: \"8\",\n    xl: \"8\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 34,\n      columnNumber: 9\n    }\n  }, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__[\"Container\"], {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 39,\n      columnNumber: 11\n    }\n  }, __jsx(_restaurants_restaurantList__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n    search: query,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 40,\n      columnNumber: 13\n    }\n  }))), __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__[\"Col\"], {\n    className: \"bg-light border\",\n    md: \"4\",\n    lg: \"4\",\n    xl: \"4\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 43,\n      columnNumber: 9\n    }\n  }, addItem.cart.items.length !== 0 && __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_4__[\"Row\"], {\n    xs: \"8\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 49,\n      columnNumber: 13\n    }\n  }, __jsx(_components_cart__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 50,\n      columnNumber: 15\n    }\n  })))));\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (Home);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWdlcy9pbmRleC5qcz80NGQ4Il0sIm5hbWVzIjpbIkhvbWUiLCJhZGRJdGVtIiwidXNlQ29udGV4dCIsIkFwcENvbnRleHQiLCJxdWVyeSIsInNldFF1ZXJ5IiwidXNlU3RhdGUiLCJlIiwidGFyZ2V0IiwidmFsdWUiLCJ0b0xvY2FsZUxvd2VyQ2FzZSIsImNhcnQiLCJpdGVtcyIsImxlbmd0aCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFvRDtBQUNkO0FBTWQ7QUFDa0M7QUFDVTtBQUNyQjtBQUNqQjtBQUU5QixTQUFTQSxJQUFJLEdBQUc7RUFDZCxNQUFNQyxPQUFPLEdBQUdDLHdEQUFVLENBQUNDLDJEQUFVLENBQUM7RUFDdEMsTUFBTTtJQUFBLEdBQUNDLEtBQUs7SUFBQSxHQUFFQztFQUFRLElBQUlDLHNEQUFRLENBQUMsRUFBRSxDQUFDO0VBRXRDLE9BQ0UsbUVBQ0UsTUFBQyxvREFBUztJQUFBO0lBQUE7TUFBQTtNQUFBO01BQUE7SUFBQTtFQUFBLEdBQ1I7SUFBSyxTQUFTLEVBQUMsUUFBUTtJQUFBO0lBQUE7TUFBQTtNQUFBO01BQUE7SUFBQTtFQUFBLEdBQ3JCO0lBQUE7SUFBQTtNQUFBO01BQUE7TUFBQTtJQUFBO0VBQUEsd0JBQTJCLEVBQzNCLE1BQUMscURBQVU7SUFBQTtJQUFBO01BQUE7TUFBQTtNQUFBO0lBQUE7RUFBQSxHQUNULE1BQUMscURBQVU7SUFBQyxJQUFJLEVBQUMsUUFBUTtJQUFBO0lBQUE7TUFBQTtNQUFBO01BQUE7SUFBQTtFQUFBLGNBQXNCLEVBQy9DLE1BQUMsZ0RBQUs7SUFDSixRQUFRLEVBQUdDLENBQUMsSUFBS0YsUUFBUSxDQUFDRSxDQUFDLENBQUNDLE1BQU0sQ0FBQ0MsS0FBSyxDQUFDQyxpQkFBaUIsRUFBRSxDQUFFO0lBQzlELEtBQUssRUFBRU4sS0FBTTtJQUFBO0lBQUE7TUFBQTtNQUFBO01BQUE7SUFBQTtFQUFBLEVBQ2IsQ0FDUyxFQUNiO0lBQUE7SUFBQTtNQUFBO01BQUE7TUFBQTtJQUFBO0VBQUEsRUFBUyxDQUNMLENBQ0ksRUFDWixNQUFDLDhDQUFHO0lBQUE7SUFBQTtNQUFBO01BQUE7TUFBQTtJQUFBO0VBQUEsR0FDRixNQUFDLDhDQUFHO0lBQ0YsU0FBUyxFQUFDLGdCQUFnQjtJQUMxQixFQUFFLEVBQUMsR0FBRztJQUNOLEVBQUUsRUFBQyxHQUFHO0lBQ04sRUFBRSxFQUFDLEdBQUc7SUFBQTtJQUFBO01BQUE7TUFBQTtNQUFBO0lBQUE7RUFBQSxHQUNOLE1BQUMsb0RBQVM7SUFBQTtJQUFBO01BQUE7TUFBQTtNQUFBO0lBQUE7RUFBQSxHQUNSLE1BQUMsbUVBQWM7SUFBQyxNQUFNLEVBQUVBLEtBQU07SUFBQTtJQUFBO01BQUE7TUFBQTtNQUFBO0lBQUE7RUFBQSxFQUFHLENBQ3ZCLENBQ1IsRUFDTixNQUFDLDhDQUFHO0lBQ0YsU0FBUyxFQUFDLGlCQUFpQjtJQUMzQixFQUFFLEVBQUMsR0FBRztJQUNOLEVBQUUsRUFBQyxHQUFHO0lBQ04sRUFBRSxFQUFDLEdBQUc7SUFBQTtJQUFBO01BQUE7TUFBQTtNQUFBO0lBQUE7RUFBQSxHQUNMSCxPQUFPLENBQUNVLElBQUksQ0FBQ0MsS0FBSyxDQUFDQyxNQUFNLEtBQUssQ0FBQyxJQUM5QixNQUFDLDhDQUFHO0lBQUMsRUFBRSxFQUFDLEdBQUc7SUFBQTtJQUFBO01BQUE7TUFBQTtNQUFBO0lBQUE7RUFBQSxHQUNULE1BQUMsd0RBQUk7SUFBQTtJQUFBO01BQUE7TUFBQTtNQUFBO0lBQUE7RUFBQSxFQUFHLENBRVgsQ0FDRyxDQUNGLENBQ0w7QUFFUDtBQUNlYixtRUFBSSIsImZpbGUiOiIuL3BhZ2VzL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUNvbnRleHQsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgQ2FydCBmcm9tIFwiLi4vY29tcG9uZW50cy9jYXJ0XCI7XG5pbXBvcnQge1xuICBBcG9sbG9Qcm92aWRlcixcbiAgQXBvbGxvQ2xpZW50LFxuICBIdHRwTGluayxcbiAgSW5NZW1vcnlDYWNoZSxcbn0gZnJvbSBcIkBhcG9sbG8vY2xpZW50XCI7XG5pbXBvcnQgUmVzdGF1cmFudExpc3QgZnJvbSBcIi4vcmVzdGF1cmFudHMvcmVzdGF1cmFudExpc3RcIjtcbmltcG9ydCB7IElucHV0R3JvdXAsIElucHV0LCBSb3csIENvbCwgQ29udGFpbmVyIH0gZnJvbSBcInJlYWN0c3RyYXBcIjtcbmltcG9ydCBBcHBDb250ZXh0IGZyb20gXCIuLi9jb21wb25lbnRzL2NvbnRleHRcIjtcbmltcG9ydCBjbGllbnQgZnJvbSBcIi4vY2xpZW50XCI7XG5cbmZ1bmN0aW9uIEhvbWUoKSB7XG4gIGNvbnN0IGFkZEl0ZW0gPSB1c2VDb250ZXh0KEFwcENvbnRleHQpO1xuICBjb25zdCBbcXVlcnksIHNldFF1ZXJ5XSA9IHVzZVN0YXRlKFwiXCIpO1xuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxDb250YWluZXI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPSdzZWFyY2gnPlxuICAgICAgICAgIDxoMj4gTG9jYWwgUmVzdGF1cmFudHM8L2gyPlxuICAgICAgICAgIDxJbnB1dEdyb3VwPlxuICAgICAgICAgICAgPElucHV0R3JvdXAgdHlwZT0nYXBwZW5kJz4gU2VhcmNoIDwvSW5wdXRHcm91cD5cbiAgICAgICAgICAgIDxJbnB1dFxuICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldFF1ZXJ5KGUudGFyZ2V0LnZhbHVlLnRvTG9jYWxlTG93ZXJDYXNlKCkpfVxuICAgICAgICAgICAgICB2YWx1ZT17cXVlcnl9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvSW5wdXRHcm91cD5cbiAgICAgICAgICA8YnI+PC9icj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L0NvbnRhaW5lcj5cbiAgICAgIDxSb3c+XG4gICAgICAgIDxDb2xcbiAgICAgICAgICBjbGFzc05hbWU9J2JnLWRhcmsgYm9yZGVyJ1xuICAgICAgICAgIG1kPSc4J1xuICAgICAgICAgIGxnPSc4J1xuICAgICAgICAgIHhsPSc4Jz5cbiAgICAgICAgICA8Q29udGFpbmVyPlxuICAgICAgICAgICAgPFJlc3RhdXJhbnRMaXN0IHNlYXJjaD17cXVlcnl9IC8+XG4gICAgICAgICAgPC9Db250YWluZXI+XG4gICAgICAgIDwvQ29sPlxuICAgICAgICA8Q29sXG4gICAgICAgICAgY2xhc3NOYW1lPSdiZy1saWdodCBib3JkZXInXG4gICAgICAgICAgbWQ9JzQnXG4gICAgICAgICAgbGc9JzQnXG4gICAgICAgICAgeGw9JzQnPlxuICAgICAgICAgIHthZGRJdGVtLmNhcnQuaXRlbXMubGVuZ3RoICE9PSAwICYmIChcbiAgICAgICAgICAgIDxSb3cgeHM9JzgnPlxuICAgICAgICAgICAgICA8Q2FydCAvPlxuICAgICAgICAgICAgPC9Sb3c+XG4gICAgICAgICAgKX1cbiAgICAgICAgPC9Db2w+XG4gICAgICA8L1Jvdz5cbiAgICA8Lz5cbiAgKTtcbn1cbmV4cG9ydCBkZWZhdWx0IEhvbWU7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pages/index.js\n");

/***/ }),

/***/ "./pages/restaurants/restaurantList.js":
/*!*********************************************!*\
  !*** ./pages/restaurants/restaurantList.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @apollo/client */ \"./node_modules/@apollo/client/main.cjs\");\n/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_apollo_client__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ \"./node_modules/next/link.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _components_dishes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../components/dishes */ \"./components/dishes.js\");\n/* harmony import */ var _components_context__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../components/context */ \"./components/context.js\");\n/* harmony import */ var reactstrap__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! reactstrap */ \"./node_modules/reactstrap/dist/reactstrap.cjs\");\n/* harmony import */ var reactstrap__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(reactstrap__WEBPACK_IMPORTED_MODULE_5__);\nvar _jsxFileName = \"/Users/carloszapata/Desktop/CAPSTONE/main/root/frontend/pages/restaurants/restaurantList.js\";\n\nvar __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;\n\n\n\n\n\n\nfunction RestaurantList(props) {\n  const {\n    0: restaurantID,\n    1: setRestaurantID\n  } = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(0);\n  const {\n    cart\n  } = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(_components_context__WEBPACK_IMPORTED_MODULE_4__[\"default\"]);\n  const {\n    0: state,\n    1: setState\n  } = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(cart);\n  const GET_RESTAURANTS = _apollo_client__WEBPACK_IMPORTED_MODULE_1__[\"gql\"]`\n    query {\n      restaurants {\n        id\n        name\n        description\n        image {\n          url\n        }\n      }\n    }\n  `;\n  const {\n    loading,\n    error,\n    data\n  } = Object(_apollo_client__WEBPACK_IMPORTED_MODULE_1__[\"useQuery\"])(GET_RESTAURANTS);\n  if (loading) return __jsx(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 37,\n      columnNumber: 23\n    }\n  }, \"Loading...\");\n  if (error) return __jsx(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 38,\n      columnNumber: 21\n    }\n  }, \"ERROR\");\n  if (!data) return __jsx(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 39,\n      columnNumber: 21\n    }\n  }, \"Not found\");\n  console.log(`Query Data: ${data.restaurants}`);\n\n  //search query value is defined in index --\n  //loop and\n  let searchQuery = data.restaurants.filter(res => {\n    return res.name.toLowerCase().includes(props.search);\n  }) || [];\n  let restId = searchQuery[0] ? searchQuery[0].id : null;\n\n  // define renderer for Dishes\n  const renderDishes = restaurantID => {\n    return __jsx(_components_dishes__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n      restId: restaurantID,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 53,\n        columnNumber: 12\n      }\n    }, \" \");\n  };\n  //get each restaurants and store in list and render with properties below\n  if (searchQuery.length > 0) {\n    const restList = searchQuery.map(res => __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_5__[\"Col\"], {\n      xs: \"12\",\n      md: \"4\",\n      xl: \"4\",\n      className: \"p-0\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 58,\n        columnNumber: 7\n      }\n    }, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_5__[\"Card\"], {\n      key: res.id,\n      className: \"h-100\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 63,\n        columnNumber: 9\n      }\n    }, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_5__[\"CardImg\"], {\n      top: true,\n      className: \"fluid\",\n      style: {\n        height: 180,\n        minWidth: 80\n      },\n      src: `http://localhost:1337` + res.image.url,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 66,\n        columnNumber: 11\n      }\n    }), __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_5__[\"CardBody\"], {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 72,\n        columnNumber: 11\n      }\n    }, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_5__[\"CardText\"], {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 73,\n        columnNumber: 13\n      }\n    }, res.description)), __jsx(\"div\", {\n      className: \"card-footer\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 75,\n        columnNumber: 11\n      }\n    }, __jsx(next_link__WEBPACK_IMPORTED_MODULE_2___default.a, {\n      as: \"/restaurants/\" + res.id,\n      href: \"restaurants/[...id]\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 76,\n        columnNumber: 13\n      }\n    }, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_5__[\"Button\"], {\n      onClick: () => setRestaurantID(res.id),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 79,\n        columnNumber: 15\n      }\n    }, res.name))))));\n    return (\n      //3 col in the row\n      //Just pass the element and all styling done in index.js\n      __jsx(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, __jsx(reactstrap__WEBPACK_IMPORTED_MODULE_5__[\"Row\"], {\n        className: \"d-flex align-items-stretch\",\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 92,\n          columnNumber: 9\n        }\n      }, restList))\n    );\n  } else {\n    return __jsx(\"h1\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 98,\n        columnNumber: 12\n      }\n    }, \" No Restaurants Found\");\n  }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (RestaurantList);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWdlcy9yZXN0YXVyYW50cy9yZXN0YXVyYW50TGlzdC5qcz9kODkwIl0sIm5hbWVzIjpbIlJlc3RhdXJhbnRMaXN0IiwicHJvcHMiLCJyZXN0YXVyYW50SUQiLCJzZXRSZXN0YXVyYW50SUQiLCJ1c2VTdGF0ZSIsImNhcnQiLCJ1c2VDb250ZXh0IiwiQXBwQ29udGV4dCIsInN0YXRlIiwic2V0U3RhdGUiLCJHRVRfUkVTVEFVUkFOVFMiLCJncWwiLCJsb2FkaW5nIiwiZXJyb3IiLCJkYXRhIiwidXNlUXVlcnkiLCJjb25zb2xlIiwibG9nIiwicmVzdGF1cmFudHMiLCJzZWFyY2hRdWVyeSIsImZpbHRlciIsInJlcyIsIm5hbWUiLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwic2VhcmNoIiwicmVzdElkIiwiaWQiLCJyZW5kZXJEaXNoZXMiLCJsZW5ndGgiLCJyZXN0TGlzdCIsIm1hcCIsImhlaWdodCIsIm1pbldpZHRoIiwiaW1hZ2UiLCJ1cmwiLCJkZXNjcmlwdGlvbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBK0M7QUFDbEI7QUFDZ0I7QUFDQTtBQUVLO0FBWTlCO0FBRXBCLFNBQVNBLGNBQWMsQ0FBQ0MsS0FBSyxFQUFFO0VBQzdCLE1BQU07SUFBQSxHQUFDQyxZQUFZO0lBQUEsR0FBRUM7RUFBZSxJQUFJQyxzREFBUSxDQUFDLENBQUMsQ0FBQztFQUNuRCxNQUFNO0lBQUVDO0VBQUssQ0FBQyxHQUFHQyx3REFBVSxDQUFDQywyREFBVSxDQUFDO0VBQ3ZDLE1BQU07SUFBQSxHQUFDQyxLQUFLO0lBQUEsR0FBRUM7RUFBUSxJQUFJTCxzREFBUSxDQUFDQyxJQUFJLENBQUM7RUFDeEMsTUFBTUssZUFBZSxHQUFHQyxrREFBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7RUFDRCxNQUFNO0lBQUVDLE9BQU87SUFBRUMsS0FBSztJQUFFQztFQUFLLENB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O1VBQUE7VUFBQTtVQUFBO1FBQUE7TUFBQSxHQUFFUSxRQUFRLENBQU87SUFHM0Q7RUFFUCxDQUFDLE1BQU07SUFDTCxPQUFPO01BQUE7TUFBQTtRQUFBO1FBQUE7UUFBQTtNQUFBO0lBQUEsMkJBQThCO0VBQ3ZDO0FBQ0Y7QUFDZTlCLDZFQUFjIiwiZmlsZSI6Ii4vcGFnZXMvcmVzdGF1cmFudHMvcmVzdGF1cmFudExpc3QuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBncWwsIHVzZVF1ZXJ5IH0gZnJvbSBcIkBhcG9sbG8vY2xpZW50XCI7XG5pbXBvcnQgTGluayBmcm9tIFwibmV4dC9saW5rXCI7XG5pbXBvcnQgRGlzaGVzIGZyb20gXCIuLi8uLi9jb21wb25lbnRzL2Rpc2hlc1wiO1xuaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IEFwcENvbnRleHQgZnJvbSBcIi4uLy4uL2NvbXBvbmVudHMvY29udGV4dFwiO1xuaW1wb3J0IHtcbiAgQnV0dG9uLFxuICBDYXJkLFxuICBDYXJkQm9keSxcbiAgQ2FyZEltZyxcbiAgQ2FyZFRleHQsXG4gIENhcmRUaXRsZSxcbiAgQ2FyZEdyb3VwLFxuICBDb250YWluZXIsXG4gIFJvdyxcbiAgQ29sLFxufSBmcm9tIFwicmVhY3RzdHJhcFwiO1xuXG5mdW5jdGlvbiBSZXN0YXVyYW50TGlzdChwcm9wcykge1xuICBjb25zdCBbcmVzdGF1cmFudElELCBzZXRSZXN0YXVyYW50SURdID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IHsgY2FydCB9ID0gdXNlQ29udGV4dChBcHBDb250ZXh0KTtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZShjYXJ0KTtcbiAgY29uc3QgR0VUX1JFU1RBVVJBTlRTID0gZ3FsYFxuICAgIHF1ZXJ5IHtcbiAgICAgIHJlc3RhdXJhbnRzIHtcbiAgICAgICAgaWRcbiAgICAgICAgbmFtZVxuICAgICAgICBkZXNjcmlwdGlvblxuICAgICAgICBpbWFnZSB7XG4gICAgICAgICAgdXJsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGA7XG4gIGNvbnN0IHsgbG9hZGluZywgZXJyb3IsIGRhdGEgfSA9IHVzZVF1ZXJ5KEdFVF9SRVNUQVVSQU5UUyk7XG4gIGlmIChsb2FkaW5nKSByZXR1cm4gPHA+TG9hZGluZy4uLjwvcD47XG4gIGlmIChlcnJvcikgcmV0dXJuIDxwPkVSUk9SPC9wPjtcbiAgaWYgKCFkYXRhKSByZXR1cm4gPHA+Tm90IGZvdW5kPC9wPjtcbiAgY29uc29sZS5sb2coYFF1ZXJ5IERhdGE6ICR7ZGF0YS5yZXN0YXVyYW50c31gKTtcblxuICAvL3NlYXJjaCBxdWVyeSB2YWx1ZSBpcyBkZWZpbmVkIGluIGluZGV4IC0tXG4gIC8vbG9vcCBhbmRcbiAgbGV0IHNlYXJjaFF1ZXJ5ID1cbiAgICBkYXRhLnJlc3RhdXJhbnRzLmZpbHRlcigocmVzKSA9PiB7XG4gICAgICByZXR1cm4gcmVzLm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhwcm9wcy5zZWFyY2gpO1xuICAgIH0pIHx8IFtdO1xuXG4gIGxldCByZXN0SWQgPSBzZWFyY2hRdWVyeVswXSA/IHNlYXJjaFF1ZXJ5WzBdLmlkIDogbnVsbDtcblxuICAvLyBkZWZpbmUgcmVuZGVyZXIgZm9yIERpc2hlc1xuICBjb25zdCByZW5kZXJEaXNoZXMgPSAocmVzdGF1cmFudElEKSA9PiB7XG4gICAgcmV0dXJuIDxEaXNoZXMgcmVzdElkPXtyZXN0YXVyYW50SUR9PiA8L0Rpc2hlcz47XG4gIH07XG4gIC8vZ2V0IGVhY2ggcmVzdGF1cmFudHMgYW5kIHN0b3JlIGluIGxpc3QgYW5kIHJlbmRlciB3aXRoIHByb3BlcnRpZXMgYmVsb3dcbiAgaWYgKHNlYXJjaFF1ZXJ5Lmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCByZXN0TGlzdCA9IHNlYXJjaFF1ZXJ5Lm1hcCgocmVzKSA9PiAoXG4gICAgICA8Q29sXG4gICAgICAgIHhzPScxMidcbiAgICAgICAgbWQ9JzQnXG4gICAgICAgIHhsPSc0J1xuICAgICAgICBjbGFzc05hbWU9J3AtMCc+XG4gICAgICAgIDxDYXJkXG4gICAgICAgICAga2V5PXtyZXMuaWR9XG4gICAgICAgICAgY2xhc3NOYW1lPSdoLTEwMCc+XG4gICAgICAgICAgPENhcmRJbWdcbiAgICAgICAgICAgIHRvcD17dHJ1ZX1cbiAgICAgICAgICAgIGNsYXNzTmFtZT0nZmx1aWQnXG4gICAgICAgICAgICBzdHlsZT17eyBoZWlnaHQ6IDE4MCwgbWluV2lkdGg6IDgwIH19XG4gICAgICAgICAgICBzcmM9e2BodHRwOi8vbG9jYWxob3N0OjEzMzdgICsgcmVzLmltYWdlLnVybH1cbiAgICAgICAgICAvPlxuICAgICAgICAgIDxDYXJkQm9keT5cbiAgICAgICAgICAgIDxDYXJkVGV4dD57cmVzLmRlc2NyaXB0aW9ufTwvQ2FyZFRleHQ+XG4gICAgICAgICAgPC9DYXJkQm9keT5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nY2FyZC1mb290ZXInPlxuICAgICAgICAgICAgPExpbmtcbiAgICAgICAgICAgICAgYXM9e1wiL3Jlc3RhdXJhbnRzL1wiICsgcmVzLmlkfVxuICAgICAgICAgICAgICBocmVmPSdyZXN0YXVyYW50cy9bLi4uaWRdJz5cbiAgICAgICAgICAgICAgPEJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzZXRSZXN0YXVyYW50SUQocmVzLmlkKX0+XG4gICAgICAgICAgICAgICAge3Jlcy5uYW1lfVxuICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgIDwvTGluaz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9DYXJkPlxuICAgICAgPC9Db2w+XG4gICAgKSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgLy8zIGNvbCBpbiB0aGUgcm93XG4gICAgICAvL0p1c3QgcGFzcyB0aGUgZWxlbWVudCBhbmQgYWxsIHN0eWxpbmcgZG9uZSBpbiBpbmRleC5qc1xuICAgICAgPD5cbiAgICAgICAgPFJvdyBjbGFzc05hbWU9J2QtZmxleCBhbGlnbi1pdGVtcy1zdHJldGNoJz57cmVzdExpc3R9PC9Sb3c+XG5cbiAgICAgICAgey8qIDxSb3cgeHM9JzMnPntyZW5kZXJEaXNoZXMocmVzdGF1cmFudElEKX08L1Jvdz4gKi99XG4gICAgICA8Lz5cbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiA8aDE+IE5vIFJlc3RhdXJhbnRzIEZvdW5kPC9oMT47XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IFJlc3RhdXJhbnRMaXN0O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./pages/restaurants/restaurantList.js\n");

/***/ }),

/***/ "@wry/context":
/*!*******************************!*\
  !*** external "@wry/context" ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"@wry/context\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAd3J5L2NvbnRleHRcIj8xOWEwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IkB3cnkvY29udGV4dC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIkB3cnkvY29udGV4dFwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///@wry/context\n");

/***/ }),

/***/ "@wry/equality":
/*!********************************!*\
  !*** external "@wry/equality" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"@wry/equality\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAd3J5L2VxdWFsaXR5XCI/ODNkMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiJAd3J5L2VxdWFsaXR5LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiQHdyeS9lcXVhbGl0eVwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///@wry/equality\n");

/***/ }),

/***/ "@wry/trie":
/*!****************************!*\
  !*** external "@wry/trie" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"@wry/trie\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJAd3J5L3RyaWVcIj80ZThkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IkB3cnkvdHJpZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIkB3cnkvdHJpZVwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///@wry/trie\n");

/***/ }),

/***/ "classnames":
/*!*****************************!*\
  !*** external "classnames" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"classnames\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJjbGFzc25hbWVzXCI/YWFhYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiJjbGFzc25hbWVzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY2xhc3NuYW1lc1wiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///classnames\n");

/***/ }),

/***/ "graphql":
/*!**************************!*\
  !*** external "graphql" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"graphql\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJncmFwaHFsXCI/MzExNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiJncmFwaHFsLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZ3JhcGhxbFwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///graphql\n");

/***/ }),

/***/ "graphql-tag":
/*!******************************!*\
  !*** external "graphql-tag" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"graphql-tag\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJncmFwaHFsLXRhZ1wiP2Y4YjciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiZ3JhcGhxbC10YWcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJncmFwaHFsLXRhZ1wiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///graphql-tag\n");

/***/ }),

/***/ "next/router":
/*!******************************!*\
  !*** external "next/router" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"next/router\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJuZXh0L3JvdXRlclwiP2Q4M2UiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoibmV4dC9yb3V0ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJuZXh0L3JvdXRlclwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///next/router\n");

/***/ }),

/***/ "optimism":
/*!***************************!*\
  !*** external "optimism" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"optimism\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJvcHRpbWlzbVwiP2FjYjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoib3B0aW1pc20uanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJvcHRpbWlzbVwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///optimism\n");

/***/ }),

/***/ "prop-types":
/*!*****************************!*\
  !*** external "prop-types" ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"prop-types\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJwcm9wLXR5cGVzXCI/MzgzMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiJwcm9wLXR5cGVzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicHJvcC10eXBlc1wiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///prop-types\n");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"react\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJyZWFjdFwiPzU4OGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoicmVhY3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWFjdFwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///react\n");

/***/ }),

/***/ "react-dom":
/*!****************************!*\
  !*** external "react-dom" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"react-dom\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJyZWFjdC1kb21cIj81ZTlhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6InJlYWN0LWRvbS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlYWN0LWRvbVwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///react-dom\n");

/***/ }),

/***/ "react-is":
/*!***************************!*\
  !*** external "react-is" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"react-is\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJyZWFjdC1pc1wiPzBkMzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoicmVhY3QtaXMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWFjdC1pc1wiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///react-is\n");

/***/ }),

/***/ "react-popper":
/*!*******************************!*\
  !*** external "react-popper" ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"react-popper\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJyZWFjdC1wb3BwZXJcIj9hOGY0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6InJlYWN0LXBvcHBlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlYWN0LXBvcHBlclwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///react-popper\n");

/***/ }),

/***/ "react-transition-group":
/*!*****************************************!*\
  !*** external "react-transition-group" ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"react-transition-group\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJyZWFjdC10cmFuc2l0aW9uLWdyb3VwXCI/ZGRlMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiJyZWFjdC10cmFuc2l0aW9uLWdyb3VwLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVhY3QtdHJhbnNpdGlvbi1ncm91cFwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///react-transition-group\n");

/***/ }),

/***/ "styled-jsx/style":
/*!***********************************!*\
  !*** external "styled-jsx/style" ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"styled-jsx/style\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJzdHlsZWQtanN4L3N0eWxlXCI/MmJiYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiJzdHlsZWQtanN4L3N0eWxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic3R5bGVkLWpzeC9zdHlsZVwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///styled-jsx/style\n");

/***/ }),

/***/ "symbol-observable":
/*!************************************!*\
  !*** external "symbol-observable" ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"symbol-observable\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJzeW1ib2wtb2JzZXJ2YWJsZVwiPzY4MDgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoic3ltYm9sLW9ic2VydmFibGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJzeW1ib2wtb2JzZXJ2YWJsZVwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///symbol-observable\n");

/***/ }),

/***/ "tslib":
/*!************************!*\
  !*** external "tslib" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"tslib\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ0c2xpYlwiPzM5OTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoidHNsaWIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ0c2xpYlwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///tslib\n");

/***/ }),

/***/ "zen-observable/index.js":
/*!******************************************!*\
  !*** external "zen-observable/index.js" ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"zen-observable/index.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ6ZW4tb2JzZXJ2YWJsZS9pbmRleC5qc1wiPzY4OTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiemVuLW9ic2VydmFibGUvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ6ZW4tb2JzZXJ2YWJsZS9pbmRleC5qc1wiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///zen-observable/index.js\n");

/***/ })

/******/ });